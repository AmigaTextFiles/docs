@DATABASE CXX-Tutor.guide
@SMARTWRAP
@TAB 4

@node Main "Keywords, hvad kan c++"

  @{b}@{U}Indbyggede C++ komandoer@{ub}@{UU}


@{" auto      " link Main 22}

@{" break     " link Main 25}

@{" case      " link Main 28}
@{" char      " link Main 30}
@{" class     " link Main 32}
@{" const     " link Main 35}
@{" continue  " link Main 38}

@{" default   " link Main 40}
@{" delete    " link Main 42}
@{" do        " link Main 50}
@{" double    " link Main 59}

@{" else      " link Main 59}
@{" extern    " link Main 61}

@{" float     " link Main 63}
@{" for       " link Main 65}
@{" friend    " link Main 75}

@{" goto      " link Main 104}

@{" if        " link Main 106}
@{" inline    " link Main 109}
@{" int       " link Main 129}

@{" long      " link Main 131}

@{" new       " link Main 133}

@{" operator  " link Main 144}

@{" private   " link Main 169}
@{" protected " link Main 172}
@{" public    " link Main 175}

@{" register  " link Main 177}
@{" return    " link Main 179}

@{" short     " link Main 181}
@{" signed    " link Main 183}
@{" sizeof    " link Main 186}
@{" static    " link Main 188}
@{" struct    " link Main 209}
@{" switch    " link Main 220}

@{" this      " link Main 258}
@{" typedef   " link Main 274}

@{" union     " link Main 287}
@{" unsigned  " link Main 289}

@{" virtual   " link Main 291}
@{" void      " link Main 293}

@{" while     " link Main 295}


	@{b}Auto : @{ub}
Storage-class specifier.
En 'normal' variabel .
Alle variabler er automatiske medmindre andet er specificeret (som static, extern, register, typedef).
At den er automatisk betyder at computeren allokerer plads til variablen, når den erklæres.
Det betyder også at den ligger et forskelligt sted, fra gang til gang.
Det er overflødigt at skrive dette keyword, da man opnår det samme ved at skrive ingenting.


	@{b}Break : @{ub}
Afslutter en sektion ( defineres med { og } ) og fortsætter til programdelen efter sektionen.
Bruges i @{I}for , while @{UI}og @{I}switch @{UI}.
Se også continue.


	@{b}Case : @{ub}
Bruges i switch.


	@{b}Char : @{ub}
@{" Variabel type " link VariabelTyper/Main}. Svarer til en ASCII værdi.


	@{b}Class : @{ub}
Bruges til at erklære objekter.
Er i princippet en struct, men indeholder i modsætning til denne, også funktioner.
Indholdet i en class er, medmindre andet er specificeret ( eksempelvis med @{I}public @{UI} og @{I}protected @{UI} ), privat (private keyword), mens indholdet i en struct er offentligt (public keyword).


	@{b}Const : @{ub}
Konstanter er ikke variable, men svarer til en konstant værdi der er uændret igennem hele programmet.
Eksempler : 0 , 'a' , 'b' , 'c' , 0x1000 , 1.1 , "Hej der" .


	@{b}Continue : @{ub}
Går øjeblikkeligt til slutningen af en sektion ( { og } ).
Se også break.


	@{b}Default : @{ub}
En case.
Hvis der ikke var en match i de specificerede case sætninger, hopper programmet til denne label.
Default skrives som den sidste case.
En break er egentlig overflødig i en default case, men bør inkluderes for god ordens skyld.
Se også switch.


	@{B}Delete : @{UB}
Sletter objekter skabt med @{" New " link Main 80}

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
char*	string;
string = new char[80];
delete string;
@{BODY}

	@{b}Do : @{ub}
Bruges med while.
Betyder at computeren udfører en løkke, og efter hvert gennemløb checkes betingelsen.
While fungerer omvendt : betingelsen checkes først, og løkken udføres derefter.

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
int a=100;
do
{
    cout << a << endl;
    a--;
}while (a);
@{BODY}

	@{b}Double : @{ub}
@{"Variabel type " link VariabelTyper/Main}.
Flydende-komma tal som float, men med større precision.
Så vidt muligt bør double bruges i stedet for float, da double kan (via SCOptions) ændres til FPU operationer (68881 / 68882 / 68040 / 68060).
Ønsker man derfor at kunne udnytte evt. FPU, bør man bruge double i stedet for float.


	@{b}Else : @{ub}
Udføres hvis ikke et @{I}if @{UI} statement blev opfyldt.
Syntaksen er den samme som i en @{I}if @{UI}.


	@{b}Extern : @{ub}
Storage-class specifier.
Betyder at variablen eksisterer men findes udenfor den pågældende funktion.


	@{b}Float : @{ub}
@{"Variabel type " link VariabelTyper/Main} .
Flydende-komma tal.
Man kan derfor arbejde med komma-tal.
Se også @{I}double @{UI}.


	@{b}For : @{ub}
Løkke et antal gange.
Minder om while, men er mere kompakt i visse tilfælde.
Syntaksen er : for( erklæring ; betingelse ; operator) .


@{U}@{I}Eksempel : @{UU}@{UI}

for(a=0 ; a<10 ; a++) { cout <<"Hello" <<endl; }


Vil udskrive 'Hello' ti gange.
Erklæringen og operator delen kan egentligt indeholde flere udtryk, opdelt af komma.


@{U}@{I}Eksempel : @{UU}@{UI}

for(a=0,b=10 ; a<10 ; a++,b--) {cout<<"A="<<a<<" B="<<b<<endl;}


	@{b}Friend : @{ub}
Bruges i klasser og strukturer.
Fortæller at en funktion eller klasse er ven af den pågældende klasse, og derfor kan læse og skrive i værdier som normalt er private (private).
Sagt med andre ord, gælder data-hiding ikke for friend funktioner/klasser.

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
class A
{
    private:
    int		a_value;

    public:
    A			(int value) {a_value = value;}
    ~A		() {}

    friend	class B;
};
class B
{
    private:
    int		b_value;

    public:
    B			(A& a_object) {b_value = a_object.a_value;}
    ~B		() {}
};
A obj_a(10);
B obj_b(obj_a);
@{BODY}

obj_b vil her blive sat til værdien af obj_a.
Fjerner man 'friend class B' sætningen i class A, kan programmet ikke kompileres, da class B ikke længere er ven af class A.


	@{b}Goto : @{ub}
Hopper til en label.
En label består af noget tekst, efterfulgt af et kolon.
Eksempelvis 'LOOP1:'.
Undgå brug af goto, da den stort set er overflødig.


	@{b}If : @{ub}
if (a<b) cout<<"a<b"<<endl; else cout<<"a>=b"<<endl;

	Betyder at hvis a er mindre end b, så skriv 'a<b' ellers skriv 'a>=b'.


	@{b}Inline : @{ub}
Betyder at en funktion indsættes i koden de steder hvor funktionen kaldes, istedet for at funktionen kaldes som en underrutine.
Dette vil gøre funktionen hurtigere, men vil somregel fylde mere end ikke inline funktioner.
Består en funktion kun af en enkelt eller to linier, bør den være inline, da kode-delen der kalder funktionen sandsynligvis vil fylde mere end selve funktionen.

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
inline void	SkrivEnBare()
{
    cout<<"--------------------"<<endl;
}
void 			main()
{
	SkrivEnBare();
}

@{U}@{I}Svarer til : @{UU}@{UI}
void	main()
{
	cout<<"--------------------"<<endl;
}
@{BODY}

	@{b}Int : @{ub}
@{"Variabel type " link VariabelTyper/Main}.
Heltalts værdi.


	@{b}Long : @{ub}
@{"Variabel type " link VariabelTyper/Main}.
Er en ekstra lang int.
Bruges også foran double, hvilket giver en endnu mere præcis double.


	@{b}New : @{ub}
Bruges til at reservere RAM, som man siden skal frigive med delete.

	Dette eksempel venter på input fra brugeren, og udskriver det.
Bemærk at computeren selv holder øje med hvor meget hukommelse der blev reserveret i 'delete streng;', ellers skulle vi gøre opmærksom på det ved istedet at skrive 'delete streng[80];' :

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
char*    streng;
streng = new char[80];
cin >> streng;
cout << endl << "Du skrev : " << streng << endl;
delete streng;
@{BODY}

	@{b}Operator : @{ub}
Specificerer at der er tale om en operator funktion.
Dette gør det muligt at bruge = + - * / << og >> på ens egne objekter.
Normalt kan man kun bruge aritmetik på standard typer som int og double.
Men i C++ er der mulighed for at indrette ens klasser således, at man kan udføre aritmetiske operationer på dem.
Dette gør det muligt at regne med imaginære tal, arealer m.m., som var det normale tal.

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
Coordinate	co1(10,5);
Coordinate	co2(5,0);
Coordinate	co3;

co3 = co1 + co2;
cout << co3 << endl;
@{BODY}

	I C ville det f.eks. se således ud:

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
struct Co2d    coord1,coord2,coord3;
coord1.x = 10;
coord1.y = 5;
coord2.x = 5;
coord2.y = 0;

AddCo2d(coord3,coord1,coord2);

printf("Coord3 x,y= %d %d\n",coord3.x,coord3.y);
@{BODY}

	@{b}Private : @{ub}
Bruges til @{" data-hiding " link data_hiding}.
Med 'private:' indikerer man at der er tale om private data, som derfor er usynlige for brugeren.
Se også protected og public keywords.


	@{b}Protected : @{ub}
Bruges til @{" data-hiding " link DataHiding/Main}.
Med 'protected:' indikerer man at der er tale om private data, men at klasser der arver fra klassen/ strukturen har adgang dvs 'public:'.


	@{b}Public : @{ub}
Bruges til @{" data-hiding " link data_hiding}.
Med 'public:' indikerer man at der er fri adgang til data.
Både indenfor og udenfor klassen.


	@{b}Register : @{ub}
@{"Variabel type " link VariabelTyper/Main}.
Svarer til et CPU register.


	@{b}Return : @{ub}
Indikerer at funktionen forlades, og der eventuelt returneres en værdi.
'return a;' betyder at værdien a returneres.
Det er vigtigt at retur typen er den samme som specificeres i prototypen.


	@{b}Short : @{ub}
@{"Variabel type " link VariabelTyper/Main}.


	@{b}Signed : @{ub}
Variabel type komponent.
Bruges på heltalsværdier.
En signed int kan være negativ eller positiv, hvorimod en unsigned int kun er positiv.
Til gengæld kan en unsigned int indeholde et større tal end signed, da den bit der bruges til fortegn, istedet bliver brugt til værdien.


	@{b}Sizeof : @{ub}
Returnerer størelsen på et objekt.
'cout<<sizeof(int)<<endl;' udskriver derfor størelsen på en int.


	@{b}Static : @{ub}
Storage-class specifier.
En statisk variabel forbliver uændret fra gang til gang en funktion kaldes.
Statiske variabler findes kun i et eksemplar, dvs. hvis en funktion kalder sig selv, så vil de statiske variabler i funktionen blive ændret til når der returneres fra funktionen.
I modsætning til automatiske variabler, som der laves et extra eksemplar af, hver gang funktionen kaldes.
Derudover er en statisk variabel automatisk nul når programmet startes.
Eksempel:

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
// Program der udskriver tallene fra 0 til 9.

void Increase()
{
    static int counter;
    cout<<"Counter er :"<<counter++<<endl;
}

void main()
{
    int x;
    for(x=0; x<10; x++) Increase();
}
@{BODY}

	Funktioner kan også være statiske.


	@{b}Struct : @{ub}
Data struktur. Eksempelvis:

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
struct Koordinat
{
    int x;
    int y;
};

Koordinat k1={0,0};
@{BODY}

	@{b}Switch : @{ub}
Som alternativ til lange if sætninger, er den mere kompakte udgave switch. Eksempel:

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
char c;

cout<<
"Vælg et menupunkt og tryk return"<<endl<<
"(L)oad"<<endl<<
"(S)ave"<<endl<<
"(Q)uit"<<endl;
cin >> c;

switch(c)
{
    case 'l':
    case 'L':
    cout << "Du valgte at loade" << endl;
    break;

    case 's':
    case 'S':
    cout << "Du valgte at save" << endl;
    break;

    case 'q':
    case 'Q':
    cout << "Du valgte at quitte" << endl;
    break;

    default:
    cout << "Du trykkede forkert" << endl;
    break;
}
@{BODY}

	Bemærk at der er to cases for hvert valg, lige efter hinanden.
Det fungerer ved at programmet søger efter en match til værdien (i dette tilfælde c), og når den er fundet, afvikles programmet derfra, indtil en break mødes, hvorefter switch sektionen forlades.
Man kan have lige så mange efterfølgende cases som man har lyst til.


	@{b}This : @{ub}
This er en pointer til selve det objekt som en funktion er en del af.
Eksemplet her udskriver addresserne på tre objekter ::

@{CODE}
@{U}@{I}Eksemepel : @{UU}@{UI}
class Dummy
{
    public:
    Dummy(){}
    ~Dummy(){}
    Skriv(){cout <<  this  << endl;}
};

Dummy a,b,c;
a.Skriv();
b.Skriv();
c.Skriv();
@{BODY}

	@{b}Typedef : @{ub}
Bruges til at skabe et alias for en variabel type.

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
typedef int    integer;
integer a;
@{BODY}

	Vil skabe en variabel type ved navn integer, som er identisk med int.
Hvis vi så har et størrere program som bruger integer typen og finder ud af at int ikke er nok, kan vi ændre int til long i typedef sætningen uden at skulle erstatte alle tilfælde af int i programmet med long.
Typedef sætningen vil så se således ud:


@{U}@{I}Eksempel : @{UU}@{UI}

typedef long   integer;


	@{b}Union : @{ub}
Bruges normalt ikke (dvs. forfatteren bruger den ikke).


	@{b}Unsigned : @{ub}
Se afsnittet om @{" Variabel typer " link VariabelTyper/Main}.


	@{b}Virtual : @{ub}
Indikerer at der er tale om en virtuel funktion.
Se afsnittet om {" virtuelle funktioner "} link Virtual/Main}.


	@{b}Void : @{ub}
Tomrum, svarer til ingenting.
Sætningen 'void main()' indikerer at funktionen main returnerer void, dvs. ingenting.
Egentligt står der ' void main(void) ' , da tomme paranteser i funktioner svarer til void.


	@{b}While : @{ub}
While bruges til loops og syntaksen er : while(logisk_udtryk) {loop_rutine}  . Eksempelvis :

@{CODE}
@{U}@{I}Eksempel : @{UU}@{UI}
int a=100;
while (a--)
{
    cout << a << endl;
}
@{BODY}

@endnode
