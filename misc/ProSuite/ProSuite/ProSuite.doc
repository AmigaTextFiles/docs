
Introduction to the Amiga Programmer's Suite Book 1.01, by RJ Mical
Copyright (C) 1986, 1987, Robert J. Mical
20 October 1987



Welcome to the Amiga Programmer's Suite, Book 1.  Presented here 
are several tools for Amiga developers.  I hope you find them useful.  


The Amiga Programmer's Suite is an evolving entity.  It's being 
designed with several goals in mind.  

First and foremost, the intent is to make programmers' lives easier by 
creating mechanisms that every programmer wants sooner or later; an 
example of this is the FileIO Requester, which is a mechanism that 
creates a requester and allows the user to browse through the Amiga 
filesystem using an Intuition interface.  Such a tool is very 
complicated to design, for it requires a good amount of Exec, 
AmigaDOS and Intuition knowledge, combined with a familiarity of 
user-interface techniques and touch of graphic design.  The prospect 
of doing the work involved in creating a fully-capable requester 
such as this has boggled the minds of many designers and made them soft.  
Now, by using the Programmer's Suite, designers can include this 
requester in their programs, making the programs easier and more 
enjoyable to use while costing the developer very little effort.

The second intent of the Programmer's Suite is to give new Amiga 
tools to the developer.  The XText mechanism is an example of this.  
XText gives programmers a new, powerful way to create text on the Amiga.  
Another example is DoRequest(), which manages requesters automatically.  
These are tools that are part of the Amiga system and may one day 
appear in the Amiga ROM Kernel.

The third intent of the Programmer's Suite is to provide a tutorial 
on how to program the Amiga.  The source code and examples may be 
used as a learning aide for the novitiate and the old-salt alike.  For 
instance, in the FileIO Requester source many complicated system 
problems are solved, to the edification of all (hopefully).  I myself 
have learned quite a bit about the Amiga while creating these routines.  
I hope you get something good from them too.


So enjoy!  And, as always, go for the gold.  You know can do it.


   - RJ Mical



P.S.  I'm currently compiling notes for Books 2 and 3.  If you have any 
suggestions for these books, and if you have comments and criticisms about 
Book 1, please send them to me at:

        RJ Mical
        Suite 123
        999C Edgewater Blvd.
        Foster City, CA    94404




=============================================================================
=== Copyright, Distribution, and Registration Notices =======================
=============================================================================

The Amiga Programmer's Suite Book 1 is copyrighted but freely distributable.
All copyright notices and all file headers must be retained intact.
The Amiga Programmer's Suite Book 1 may be compiled and assembled, and the 
resultant object code may be included in any software product.  However, no 
portion of the source listings or documentation of the Amiga Programmer's 
Suite Book 1 may be distributed or sold for profit or in a for-profit 
product without the written authorization of the author, RJ Mical.

You should register your copy with me.  Those who register will get:  
updates which should include both bug fixes and enhancements; announcement 
of and price break on future Suite books; pleasant sense of having done 
a good thing. 

To register your copy, send $15 to RJ Mical at the below address
(price subject to change without notice).  I will return a receipt 
along with your registration number:

	APS Registration
        RJ Mical
        Suite 123
        999C Edgewater Blvd.
        Foster City, CA    94404


The Amiga Programmer's Suite was created to help you do it to the 
Amiga computer.  Bang on it well.  The author, RJ Mical, wishes that 
if you use this code in your program, you give him some discreet mention
somewhere.




=============================================================================
=== Amiga Programmer's Suite Book 1 Contents ================================
=============================================================================

ColorWindow
    This is a procedure call that creates a window, called the ColorWindow,
    which has gadgets that allow the user to change the colors of any 
    screen.  After opening the ColorWindow, this routine interacts with 
    the user until the user is satisfied with the current colors.


DoRequest
    This is a procedure call that creates a requester according to 
    your specifications and manages the interaction with the 
    requester for you.  When finished this routine returns control
    to you with an identifier describing which gadget the user selected
    to terminate the requester.


FileIO Requester
    This routine creates and manages the FileIO Requester.  The FileIO 
    Requester is a powerful mechanism that gives the user an easy,
    intuitive way to cruise the Amiga filesystem and select file names.


SetWaitPointer
    A short collection of data and procedure calls that allow 
    the programmer to display one of several WaitPointers 
    such as Workbench Z-cloud.


XText
    The XText routines have one purpose:  extra-fast text.  These routines 
    give the programmer a way to do high-performance text.  Flash!




=============================================================================
=== Programmer's Suite Technical Information ================================
=============================================================================

All of the .c files in the Programmer's Suite will compile under either 
Lattice or Aztec, and all of the .asm files will compile under either 
Metacomco or Aztec.

There's a .doc file in each directory.  Contained in that file are 
the programmer's notes and the autodoc headers for the functions.

Note that the C code is meant to be a tutorial and therefore isn't
always optimized for performance.  Manx programmers who want maximum
performance should dig in and switch the SHORTS to 16-bit, though with 
the latest release of Manx C the difference between 16-bit int and 32-bit 
int modes is less than before.

Be sure to see the section "Exercises for the Reader" below.

In most directories you can find these files:  makefile.lattice and 
makefile.aztec.  If you are a make user you can rename one of these to 
"makefile" and you'll be ready to go, though you will probably have to edit 
the pathnames slightly to fit your own environment.  If you don't use 
make, all the information you need to build your own make-like script 
file is contained in the makefiles.  The Lattice .wth file is included 
for your convenience.

I tried to keep the idiosyncracies of the languages out of the source 
files, and succeeded almost completely.  Unfortunately, there's 
one place where it matters whether you're using the Aztec assembler 
or a standard assembler.  When compiling the XText routines, if you 
use Aztec you must define the constant AZTEC in the xtext.i files.  
If you don't use Aztec, you must make sure that AZTEC is not defined.
If you use the most recent Manx release (3.40), you could rewrite
this section of code to avoid making the declaration.

In general, it's a good idea to define the constants MANX and AZTEC
when you are working with Aztec languages.  I believe that
the Lattice folks guarantee that the constant LATTICE is defined
for you.  For instance:

    #ifndef MANX
    #define MANX
    #endif

    #ifndef AZTEC
    #define AZTEC
    #endif

    main()
    {
    #ifdef MANX
        printf("MANX found.\n");
    #endif
    #ifdef AZTEC
        printf("AZTEC found.\n");
    #endif
    #ifdef LATTICE
        printf("Error:  LATTICE found when MANX was wanted.\n");
    #endif
    }


My makefiles refer to an executable AmigaDOS script file called "del",
which tests for the existence of a file and deletes it if it exists.
del looks like this:
	.key file
	if exists <file>
	delete file
	endif
I use del to delete a previously-existing object file before attempting to
compile a source file.  The advantage of this:  if the compilation fails,
the link will fail too, and I am alerted that something went wrong.
Often this isn't necessary, as I'm watching my window and see that 
there's errors in a file.  However, when make compiles many files, 
error messages may scroll out of the window and I may not be aware that
something went wrong.  This way, I know which files failed and I can 
invoke make again and observe the error messages directly.




=============================================================================
=== Programmer's Suite Exercises for the Reader =============================
=============================================================================

The following items have been left as exercises for the reader.  The 
"features" listed below will probably be incorporated in a future revision
of Book 1.

There are several ways that Book 1 could could be rewritten to support 
the high-performance features of Manx.  Most notably, 16-bit ints aren't 
supported; you'll have to do it yourself.  It was too much work for me 
to support both a 32-bit Lattice version and a 16-bit Manx version of 
this stuff, so I went with the default 32-bit.

If you use XText extensively, you might rewrite GetXTextSupport() to reuse 
as much as possible from existing structures.  This might involve something 
like passing the address of an existing XTextSupport structure (or NULL) to 
the routine.

At 11K, the FileIO requester is overweight:  it has a *lot* of functionality, 
and each feature costs; as a tutorial it sometimes does things in a 
long-winded way for the sake of clarity; in fact the code has evolved over a 
long period of time and so is no longer the most concise piece of code I've 
ever written.  A good programmer could get in there and tighten 1 or 2K out 
of the code easily.  This combined with switching to 16-bit integers could 
result in easy big savings.  

Some of the routines have data that must be in chip memory.  The data that 
must go into chip memory is collected in a "chipdata.c" file.  When using 
the Lattice environment, the contents of this file can be located in chip 
memory by using the ATOM tool on the chipdata.o file created by compiling 
the chipdata.c file.  Under Manx, the only easy way to put some 
pre-initialized data into chip memory is by putting *all* pre-initialized 
data into chip memory.  This can be wasteful.  If you are a Manx user, you 
might want to consider writing some chipdata transfer routine based on a 
global Remember key.  

Most of the routines have string functions in a strings.c file.
These string functions are usually redundant (both Lattice and Aztec have
built-in string functions) and are included just for clarity; for example,
the novice programmer will understand a function named CopyString() much 
more readily than a function named strcpy().  You can strip out many of 
the strings.c routines and save a few bytes.  To avoid editing all the 
fileswhere string functions are called, you can create definitions such as:  
    #define StringLength(s) strlen(s)
    #define CopyString(s) strcpy(s)

The FileIO routines could use textual pattern matching when building the 
name list, so that the program could specify, for instance, that only 
those names ending in ".asm" would be displayed.  Probably the smartest 
thing would be to duplicate AmigaDOS pattern matching, though you may 
choose to do Unix-like pattern matching.  

