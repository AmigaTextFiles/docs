@database "AmigaDOS.guide"
@index ÍndicePrincipal

@NODE main "¡Bienvenido al AmigaDOS 3.0!"
*****************************************************************************

		      GUÍA DEL USUARIO DEL AmigaDOS 3.0

*****************************************************************************



¡BIENVENIDO!


La línea de ordenadores personales Commodore® Amiga® ofrece una combinación
única de versatilidad, potencia y facilidad de uso. El rápido sistema
operativo del Amiga, con capacidad multitarea, permite a los usuarios con
cualquier nivel de experiencia aprovechar las ventajas de los recursos de
su sistema.

El AmigaDOS(tm) es el sistema operativo basado en disco (DOS) del Amiga.
Un sistema operativo de disco es un conjunto de programas que gobiernan
el manejo de información y que controlan el ordenador:

- ofreciendo un sistema de ficheros que organice la información que los
  programas usan y producen

- manejando el almacenamiento y la recuperación de información de discos
  flexibles, discos duros y otros medios de almacenamiento

- actuando de interfaz con los periféricos, como impresoras y modems

El AmigaDOS ofrece un interfaz de línea de comandos (CLI), lo que significa
que usted trabaja con él mediante comandos escritos. Algunos de estos
comandos tienen su equivalente en el Workbench(tm), como Copy, Rename y
Format Disk. También existen comandos avanzados que le permiten crear
scripts para realizar tareas repetitivas, para monitorear el uso de la
memoria y para realizar otras tareas que no están disponibles a través del
Workbench. Los comandos se introducen en una ventana especial, conocida
como ventana Shell. Las ventanas Shell se abren sobre la pantalla del
Workbench y son similares a las demás ventanas del mismo, exceptuando el
hecho de que las ventanas Shell sólo muestran texto.

En conjunto, el AmigaDOS y el Shell le ofrecen un entorno operativo
flexible con las siguientes características.

CARACTERÍSTICAS DEL SISTEMA OPERATIVO

- Completo control sobre todos los aspectos del funcionamiento del Amiga

- Sistema de ficheros jerárquico

- Nombres de fichero de hasta 30 caracteres, manteniendo las letras
  minúsculas y mayúsculas aún siendo indiferente el uso de unas u otras

- Senda de búsqueda de comandos configurable

- Uso de comodines

- Proceso de comandos en segundo plano

- Muchos comandos son internos, mientras que otros pueden hacerse residentes
  en la memoria

- Librerías compartidas

- Se soportan múltiples sistemas de ficheros, incluyendo CrossDOS (sistema
  de ficheros MS-DOS)

CARACTERÍSTICAS DE SHELL

- Múltiples ventanas Shell, totalmente independientes

- Las ventanas Shell pueden cambiar de tamaño, pueden arrastrarse y pueden
  colocarse delante o detrás de otras ventanas

- Prompt, fuente y color y estilo de texto configurables

- Rápida presentación de caracteres

- Uso de alias

- Variables de entorno locales y globales

- Uso de scripts

- Redirección de la entrada y la salida de los comandos

- Múltiples asignaciones a directorios

- Copia y pegado de texto entre diferentes ventanas de tipo consola

- Soporte ARexx

USANDO ESTE MANUAL

Este manual, que debería utilizarse junto con la "Guía de Usuario del
Workbench", describe el software AmigaDOS, sus diferentes partes, y cómo
hacer uso de él. Este manual asume que el usuario está familiarizado con
el Workbench, pero que nunca ha trabajado con el AmigaDOS. Si éste es su
caso, le recomendamos que lea el manual por completo para aprender los
conceptos asociados con el sistema operativo del Amiga antes de comenzar
a usarlo. Después de familiarizarse con el AmigaDOS, use este manual como
instrumento de referencia al usar comandos o escribir programas o scripts.

Lo que sigue es una breve descripción de cada capítulo y apéndice:

- Capítulo 1: "SELECCIONANDO UN INTERFAZ". Este capítulo le da información
  para ayudarle a saber cuándo debería usar el AmigaDOS en lugar del
  Workbench.

- Capítulo 2: "ENTENDIENDO EL SHELL DEL AmigaDOS". Este capítulo describe
  el Shell del AmigaDOS con detalle.

- Capítulo 3: "TRABAJANDO CON AmigaDOS". Este capítulo describe el sistema
  de manejo de ficheros, tipos de comandos y partes de los comandos
  AmigaDOS.

- Capítulo 4: "USO DE LOS EDITORES". Este capítulo ofrece una completa
  explicación del uso del editor de texto ED, así como un listado de los
  comandos de los editores de texto MEmacs y EDIT.

- Capítulo 5: "USO DE SCRIPTS". Este capítulo describe los scripts del
  AmigaDOS y cómo crearlos.

- Capítulo 6: "REFERENCIA DE COMANDOS DEL AmigaDOS". Este capítulo describe
  cada comando del AmigaDOS con detalle.

- Capítulo 7: "REFERENCIA DE COMANDOS RELACIONADOS CON EL WORKBENCH". Este
  capítulo describe los comandos relacionados con el Workbench que pueden
  usarse desde el AmigaDOS.

- Capítulo 8: "EJEMPLOS SOBRE EL USO DE LOS COMANDOS". Este capítulo ofrece
  ejemplos de cómo realizar algunas tareas habituales con comandos del
  AmigaDOS.

- Apéndice A: "MENSAJES DE ERROR". Este capítulo contiene una lista de
  posibles problemas que pueden surgir con los programas, así como las
  soluciones sugeridas.

- Apéndice B: "DIRECTORIOS ADICIONALES DEL AMIGA". Este capítulo describe
  los directorios S:, DEVS:, L:, FONTS:, y muchos otros.

- Apéndice C: "TRABAJANDO CON SISTEMAS BASADOS EN DISCO FLEXIBLE". Este
  capítulo le dice cómo sacar el máximo provecho de su sistema si sólo
  dispone de una unidad de disco flexible y de ningún disco duro.

- Apéndice D: "FUNCIONES AVANZADAS DEL AmigaDOS". Este capítulo ofrece
  información acerca de cómo personalizar el AmigaDOS para usuarios
  avanzados del Amiga.

A continuación del apéndice D se ofrece un glosario de la terminología
utilizada en este manual.

DOCUMENTACIÓN RELACIONADA

- AmigaDOS Quick Reference ("Referencia rápida para el AmigaDOS")

- Workbench User's Guide ("Guía de usuario del Workbench"), incluido con
  su Amiga.

- ARexx User's Guide ("Guía de usuario de ARexx"), disponible en su
  distribuidor de Amiga.

Además, los manuales "Amiga ROM Kernel" publicados por Addison-Wesley
ofrecen documentación técnica sobre el AmigaDOS para programadores y
fabricantes.




                               @{" ÍNDICE " link ÍndicePrincipal}

@endnode main
@node ÍndicePrincipal "AmigaDOS 3.0 - Contenido"

TABLA DE CONTENIDOS
===================


@{"ATENCIÓN -- COPYRIGHT" link Copyright}


Capítulo 1

@{"SELECCIONANDO UN INTERFAZ" link select}

@{" Elección del interfaz " link ElecInterfaz}

@{" Tareas del AmigaDOS   " link TareasAmigaDOS}


Capítulo 2

@{"ENTENDIENDO EL SHELL DEL AmigaDOS" link capichi}

@{" Sobre el Shell          " link SobreShell}

@{" Abriendo ventanas Shell " link AbreShell}

@{" Cerrando ventanas Shell " link CierraShell}

@{" Usando el Shell         " link UsandoShell}
   @{" Edición y control de la línea de comando " link TeclasShell}
   @{" Usando el historial de comandos          " link UsandoElHistorial}
   @{" Copiar y pegar                           " link CopiarYPegar}
   @{" Trabajando con el Shell                  " link TrabajoShell}


Capítulo 3

@{"TRABAJANDO CON AmigaDOS" link working}

@{" Manejo de ficheros, directorios y discos " link ManejaFicDirDis}
   @{" Términos del sistema de ficheros " link TérminosFileSystem}
   @{" Manejo de ficheros               " link ManejaFicheros}
      @{" Dispositivos   " link Dispositivos}
      @{" Directorios    " link Directorios}
      @{" Ficheros       " link Ficheros}
      @{" Ficheros .info " link FicherosInfo}
   @{" Convenciones al nombrar ficheros " link ConvencionesAlNombrar}
   @{" Palabras clave                   " link PalabrasClave}

@{" Bases de la línea de comandos " link BasesDeShell}
   @{" Ficheros, programas, comandos y scripts " link FicProComScr}
      @{" Ficheros  " link BaseFicheros}
      @{" Programas " link BaseProgramas}
      @{" Comandos  " link BaseComandos}
      @{" Scripts   " link BaseScripts}
   @{" Senda de búsqueda                       " link BaseSenda}
   @{" Directorio actual                       " link BaseDirecActual}

@{" Tipos de comandos " link TiposDeComandos}

@{" Estructura de comandos del AmigaDOS " link EstructuraDeComandos}

@{" Caracteres especiales del AmigaDOS  " link CaracteresEspeciales}
   @{" Caracteres de la línea de comando " link CaracteresCLI}
   @{" Uso de comodines                  " link UsoDeComodines}
      @{" Caracteres comodín  " link CaracteresComodín}
   @{" Redirección                       " link Redirección}
      @{" Corchetes angulares " link CorchetesAngulares}

@{" Ejecutando programas " link EjecutandoProgramas}
   @{" Ejecutando programas en segundo plano (background) " link RunBack}

@{" Modificación del entorno AmigaDOS " link ModificaEntornoCLI}


Capítulo 4

@{"USO DE LOS EDITORES" link editors}
   @{" ED " link MiraED}
      @{" Ejecutando ED " link EjecutandoED}
      @{" Usando ED     " link UsandoED}
         @{" Comandos inmediatos                                 " link ComandosInmediatos}
         @{" Movimiento del cursor en modo inmediato             " link MueveCursorInm}
         @{" Inserción de texto en modo inmediato                " link InsertaTextoIn}
         @{" Borrado de texto en modo inmediato                  " link BorraTextoIn}
         @{" Cambiando a mayúsculas/minúsculas en modo inmediato " link CaseIn}
         @{" Comando extendidos                                  " link ComandosExtendidos}
         @{" Usando delimitadores de cadena                      " UsandoDelimit}
         @{" Usando un requester de ficheros                     " link UsandoRequesterFic}
      @{" Menús de ED   " link EDMenus}
         @{" Habilitando menús expandidos    " link MenúsExpandidos}
         @{" Menú Project                    " link MenúProject}
         @{" Menú Edit                       " link MenúEdit}
         @{" Menú Movement                   " link MenúMovement}
         @{" Menú Search                     " link MenúSearch}
         @{" Menú Settings                   " link MenúSettings}
         @{" Ajuste de las teclas de función " link SetFNKey}
         @{" Teclas especiales               " link SetFNKey 32}
         @{" Menú Command                    " link MenúCommand}
         @{" Otros comandos de ED            " link OtrosComandosED}
      @{" Repetición de comandos en modo extendido " link RepiteComExtendido}
      @{" Personalización de ED " link PersonalizaED}
         @{" Opción Set Menu                   " link OpciónSetDeED}
      @{" Impresión desde ED    " link ImpresiónDesdeED}
      @{" Salir de ED           " link SalidaDeED}
      @{" Soporte ARexx         " link EDbajoARexx}
         @{" Programa ARexx de ejemplo para ED " link EjemploARexxED}

@{" MEmacs " link MEmacs}
   @{" Ejecutando MEmacs  " link EjecutaMEmacs}
   @{" Comandos de MEmacs " link ComandosMEmacs}
   @{" Comandos de menú   " link ComandosDeMenúMEmacs}
      @{" Menú Project " link MenúProjectMEmacs}
      @{" Menú Edit    " link MenúEditMEmacs}
      @{" Menú Window  " link MenúWindowMEmacs}
      @{" Menú Move    " link MenúMoveMEmacs}
      @{" Menú Line    " link MenúLineMEmacs}
      @{" Menú Word    " link MenúWordMEmacs}
      @{" Menú Search  " link MenúSearchMEmacs}
      @{" Menú Extras  " link MenúExtrasMEmacs}
   @{" Comandos no incluidos en los menús " link ComandosSecretos}
   @{" Personalizando MEmacs              " link PersonalizaMEmacs}
   @{" Saliendo de MEmacs                 " link AdiósMEmacs}

@{" EDIT " link MiraEDIT}
   @{" Ejecutando EDIT  " link EjecutaEDIT}
   @{" Comandos de EDIT " link ComandosEDIT}
      @{" Selección de la línea actual  " link LíneaActualEDIT}
      @{" Edición de la línea actual    " link EditaLíneaActualEDIT}
      @{" Inserción y borrado de líneas " link InsDelLíneasEDIT}
      @{" Ventanas de edición de líneas " link VentanasEdicEDIT}
      @{" Dividiendo y uniendo líneas   " link PlisPlasLíneasEDIT}
      @{" Renumeración de líneas        " link RenumLíneasEDIT}
      @{" Verificación de líneas        " link VerificaLíneasEDIT}
      @{" Inspección del fichero fuente " link InspecFuenteEDIT}
      @{" Haciendo cambios globales     " link CambiosGlobalesEDIT}
      @{" Cambiando ficheros de comandos, de entrada y de salida " link CEDIT}
   @{" Saliendo de EDIT " link AdiósEDIT}


Capítulo 5

@{"USO DE SCRIPTS" link guiones}

@{" Comprendiendo los scripts " link ComprendeScripts}
   @{" Tipos de scripts " link TiposDeScripts}
      @{" Cuándo usar ARexx   " link CuándoUsarARexx}
      @{" Scripts sencillos   " link ScriptsSencillos}
      @{" Scripts automáticos " link ScriptsAutomáticos}

@{" Caracteres especiales en los scripts " link CaracEspecScripts}

@{" Comandos de los scripts " link ComandosScripts}
   @{" Comandos específicos de los scripts " link ComandosSóloScripts}
   @{" Comandos de tipo .comando           " link ComandosPunto}
      @{" Permitiendo argumentos " link PermiteArgumentosScripts}
      @{" Sustitución            " link SustituciónEnScripts}
      @{" Valores por defecto    " link DefaultValuesScripts}
   @{" Comentarios                  " link ComentariosScripts}
   @{" Comandos anidados            " link NestedComScripts}
   @{" Ficheros script interactivos " link ScriptsInterac}
   @{" Repetición de comandos       " link RepComandosScripts}
   @{" Finalización de un script    " link FinalizaScripts}

@{" Banderas condicionales        " link BanderasCondicionales}

@{" Depuración de ficheros script " link DepuraScripts}

@{" Uso de variables de entorno   " link UsaEnvVarScripts}
   @{" Creando variables de entorno " link CreaEnvVarScripts}
      @{" SET    " link SETScripts}
      @{" SETENV " link SETENVScripts}


Capítulo 6

@{"REFERENCIA DE COMANDOS DEL AmigaDOS" link veamos}

@{" Documentación de los comandos     " link ReferenciaComandosDOS}
   @{" Formato  " link FormatoComandos}
   @{" Sintaxis " link SintaxisComandos}

   @{"ADDBUFFERS   " link Addbuffers} @{"ENDIF        " link endif} @{"LOCK         " link lock} @{"SET          " link set}
   @{"ALIAS        " link Alias} @{"ENDSHELL     " link endshell} @{"MAGTAPE      " link magtape} @{"SETCLOCK     " link setclock}
   @{"ASK          " link Ask} @{"ENDSKIP      " link endskip} @{"MAKEDIR      " link makedir} @{"SETDATE      " link setdate}
   @{"ASSIGN       " link Assign} @{"EVAL         " link eval} @{"MAKELINK     " link makelink} @{"SETENV       " link setenv}
   @{"AVAIL        " link Avail} @{"EXECUTE      " link execute} @{"MOUNT        " link mount} @{"SETFONT      " link setfont}
   @{"BREAK        " link Break} @{"FAILAT       " link failat} @{"NEWCLI       " link newcli} @{"SETKEYBOARD  " link setkeyboard}
   @{"CD           " link cd} @{"FAULT        " link fault} @{"NEWSHELL     " link newshell} @{"SKIP         " link skip}
   @{"CHANGETASKPRI" link changetaskpri} @{"FILENOTE     " link filenote} @{"PATH         " link path} @{"SORT         " link sort}
   @{"COPY         " link copy} @{"GET          " link get} @{"PROMPT       " link prompt} @{"STACK        " link stack}
   @{"CPU          " link cpu} @{"GETENV       " link getenv} @{"PROTECT      " link protect} @{"STATUS       " link status}
   @{"DATE         " link date} @{"ICONX        " link iconx} @{"QUIT         " link quit} @{"TYPE         " link type}
   @{"DELETE       " link delete} @{"IF           " link if} @{"RELABEL      " link relabel} @{"UNALIAS      " link unalias}
   @{"DIR          " link dir} @{"INFO         " link info} @{"REMRAD       " link remrad} @{"UNSET        " link unset}
   @{"DISKCHANGE   " link diskchange} @{"INSTALL      " link install} @{"RENAME       " link rename} @{"UNSETENV     " link unsetenv}
   @{"ECHO         " link echo} @{"JOIN         " link join} @{"REQUESTCHOICE" link requestchoice} @{"VERSION      " link version}
   @{"ED           " link ed} @{"LAB          " link lab} @{"REQUESTFILE  " link requestfile} @{"WAIT         " link wait}
   @{"EDIT         " link edit} @{"LIST         " link list} @{"RESIDENT     " link resident} @{"WHICH        " link which}
   @{"ELSE         " link else} @{"LOADRESOURCE " link loadresource} @{"RUN          " link run} @{"WHY          " link why}
   @{"ENDCLI       " link endcli} @{"LOADWB       " link loadwb} @{"SEARCH       " link search}
        
@{" Comandos del sistema " link ComandosDelSistema}
   @{" ADDDATATYPES " link adddatatypes}
   @{" BINDDRIVERS  " link binddrivers}
   @{" CONCLIP      " link conclip}
   @{" IPREFS       " link iprefs}
   @{" SETPATCH     " link setpatch}


Capítulo 7

@{"REFERENCIA DE COMANDOS RELACIONADOS CON EL WORKBENCH" link veamos2}

@{" Editores de Preferencias " link EditoresPrefs}
   @{" Font       " link EditorFont}
   @{" IControl   " link EditorIControl}
   @{" Input      " link EditorInput}
   @{" Locale     " link EditorLocale}
   @{" Overscan   " link EditorOverscan}
   @{" Palette    " link EditorPalette}
   @{" Pointer    " link EditorPointer}
   @{" Printer    " link EditorPrinter}
   @{" PrinterGfx " link EditorPrinterGfx}
   @{" PrinterPS  " link EditorPrinterPS}
   @{" ScreenMode " link EditorScreenMode}
   @{" Serial     " link EditorSerial}
   @{" Sound      " link EditorSound}
   @{" Time       " link EditorTime}
   @{" WBPattern  " link EditorWBPattern}

@{" Programas de Comodidades " link ProgramasCommodities}
   @{" AutoPoint    " link CoAutoPoint}
   @{" Blanker      " link CoBlanker}
   @{" ClickToFront " link CoClickToFront}
   @{" CrossDOS     " link CoCrossDOS}
   @{" Exchange     " link CoExchange}
   @{" FKey         " link CoFkey}
   @{" MouseBlanker " link CoMouseBlanker}
   @{" NoCapsLock   " link CoNoCapsLock}

@{" Otras herramientas y programas relacionados con el Workbench " link UtilEtc}
   @{" Calculadora " link UtiCalculadora}
   @{" Reloj       " link UtiReloj}
   @{" CMD         " link UtiCMD}
   @{" DiskCopy    " link UtiDiskCopy}
   @{" FixFonts    " link UtiFixFonts}
   @{" Format      " link UtiFormat}
   @{" GraphicDump " link UtiGraphicDump}
   @{" IconEdit    " link UtiIconEdit}
   @{" InitPrinter " link UtiInitPrinter}
   @{" Intellifont " link UtiIntellifont}
   @{" KeyShow     " link UtiKeyShow}
   @{" MEmacs      " link UtiMEmacs}
   @{" More        " link UtiMore}
   @{" MultiView   " link UtiMultiview}
   @{" NoFastMem   " link UtiNoFastMem}
   @{" PrepCard    " link UtiPrepCard}


Capítulo 8

@{"EJEMPLOS SOBRE EL USO DE LOS COMANDOS" link examples}

@{" Tareas básicas " link TareasBásicasConAmigaDOS}
   @{" Abrir una ventana Shell               " link OpenShell}
   @{" Ejecución de programas desde el Shell " link RunProgShell}
   @{" Detener un programa                   " link StopProgShell}
   @{" Cambio del directorio actual          " link ChangeCDShell}
   @{" Cambio de la senda de búsqueda        " link ChangePathShell}
   @{" Mostrar el contenido de un directorio " link MuestraDirShell}
   @{" Copia de ficheros y directorios       " link CopiaConShell}
   @{" Creación de un fichero User-startup   " link CrearUserStartup}
   @{" Creación de una asignación            " link CreaAssign}
   @{" Acceso a los menús expandidos de ED   " link MenúsExpandDeED}
   @{" Trabajo con una ventana Shell         " link TrabajaConShellCaray}
   @{" Uso de iconos                         " link UsaIconos}
   @{" Creando scripts cómodamente           " link CreaScriptsDurmiendo}

@{" Tareas ocasionales " link TareasOcasionales}
   @{" Creación de alias para ahorrar trabajo        " link CreaciónDeAlias}
   @{" Personalización de NEWSHELL                   " link PersonalizaNewshell}
   @{" Modificación del prompt                       " link CambiaElPrompt}
   @{" Creación de un icono de disco RAM diferente   " link DiscoRamLoco}
   @{" Borrado de ficheros con icono                 " link BorraFicherosConInfo}
   @{" Probando comandos                             " link ProbandoComandos}
   @{" Creación de un script para trasladar ficheros " link ScriptCopiador}
   @{" Borrar con un DIR interactivo                 " link DirInteractivo}
   @{" Generando scripts con LIST LFORMAT            " link GeneraScriptsLFORMAT}
   @{" Personalizando la salida de LIST              " link PersonalizaList}
   @{" Uso de ICONX para ejecutar scripts            " link IconXRun}
   @{" Eliminación de salida visible de los scripts  " link ChitónScript}
   @{" Introducción y prueba de macros ARexx         " link PruebaElARexx}
   @{" Ordenación y unión de ficheros                " link SortJoinFicheros}

@{" Tareas avanzadas " link HuyHuyHuy}
   @{" Probando versiones de software              " link PruebaVersiones}
   @{" Eliminación de fuentes y librerías inútiles " link AdiósBasura}
   @{" Bucles AmigaDOS usando EVAL                 " link BuclesAmigaDOS}
   @{" Usando PIPE:                                " link VamosConPIPE}
   @{" Scripts recursivos con comandos AmigaDOS    " link ScriptsRecursivos}


Apéndice A

@{"MENSAJES DE ERROR" link ApéndiceA}


Apéndice B

@{"DIRECTORIOS ADICIONALES DEL AMIGA" MoreDirs}

@{" DEVS: " link DirDevs}
   @{" Ficheros de tipo '.device' " link FicherosPuntoDevice}
   @{" Otros ficheros             " link MásficherosDevs}
      @{" Uso de ficheros de montaje o Mountlist                     " link UsoDeMountlist}
      @{" Creación de un fichero de montaje o entrada para Mountlist " link MásMountlist}

@{" S: " link DirS}
   @{" SPat y Dpat " link Patos}
   @{" PCD         " link ScriptPCD}

@{" L: " link DirL}
   @{" Aux-handler           " link auxhandler}
   @{" Queue-handler (PIPE:) " link queue}
   @{" Port-handler          " link porthandler}
   @{" CrossDOSFileSystem    " link SistemaCrossDOS}
   @{" FileSystem_Trans      " link Transystem}
   @{" CDFileSystem          " link AlricoCD}

@{" FONTS: " link DirFonts}
   @{" Fuentes Bitmap     " link FuentesBitmap}
   @{" Fuentes Escalables " link FuentesEscalables}

@{" LIBS:    " link DirLibs}

@{" REXX:    " link DirRexx}

@{" LOCALE:  " link DirLocale}

@{" ENVARC:  " link DirEnvarc}
 
@{" ENV:     " link DirEnv}

@{" CLIPS:   " link DirClips}

@{" T:       " link DirT}

@{" Classes: " link DirClasses}

@{" C:       " link DirC}


Apéndice C

@{"TRABAJANDO CON SISTEMAS BASADOS EN DISCO FLEXIBLE" link muñecarota}

@{" Haciendo comandos residentes " link HaciendoComandosResidentes}

@{" Pre-carga de recursos        " link PrecargaRecursos}

@{" Usando la opción PATH del comando ASSIGN " link AssignPath}

@{" Eliminando ficheros del disco Workbench " link EspacioEnWorkbench}
   @{" Ficheros que puede borrar     " link PuedesBorrar}
   @{" Ficheros que no deben borrarse " link NoTocar}

@{" Uso del disco RAM " link UsoDelDiscoRam}
   @{" Copia de un disco a otro " link CopiaDisco1a2}
   @{" Disco RAM recuperable    " link RamRecuperable}
      @{" RAD: de arranque " link RADdeArranque}


Apéndice D

@{"FUNCIONES AVANZADAS DEL AmigaDOS" link atiza}

@{" Personalizando la ventana   " link PersonalizaVentana}
   @{" Pantallas públicas - opción PUBSCREEN " link PantallasPúblicas}

@{" Personalizando el Shell     " link CambioDePersonalidad}
   @{" Usando alias        " link OtraVezAlias}
   @{" Cambiando el prompt " link OtraVezElPrompt}

@{" Uso de secuencias de Escape " link Escape}

@{" Personalización de los ficheros de arranque " link OtroArranque}
   @{" Edición de los ficheros de arranque             " link OtrosFicherosArranque}
   @{" Añadidos más comunes a los ficheros de arranque " link AñadidoNormal}

@{" Uso de PIPE: " link MásDePIPE}


@{"GLOSARIO" link Glosario}


@endnode

@NODE Copyright "COPYRIGHT"

*****************************************************************************

		      GUÍA DEL USUARIO DEL AMIGADOS 3.0

*****************************************************************************


			      C O P Y R I G H T
			      =================


Copyright © 1993 de Commodore Electronics Limited. Todos los derechos
reservados. Esta documentación no puede, ni en su totalidad ni en parte,
ser fotocopiada, reproducida, traducida ni reducida por ningún medio
electrónico ni en forma legible por máquina alguna sin el consentimiento
previo por escrito de Commodore Electronics Limited.

Si este producto se adquiere en los Estados Unidos de América, por medio de
sus agencias y/o instrumentalidades, se ofrece con DERECHOS RESTRINGIDOS, y
todo uso y duplicación con respecto al software y a la documentación están
sujetos a las restricciones fijadas en el apartado b/3/II de la cláusula
252.227-7013 de DOD FAR sobre "The Rights in Technical Data and Computer
Software". A menos que se indique lo contrario, el fabricante/montador es
Commodore Business Machines, Inc., 1200 Wilson Drive, West Chester, PA 19380.

El material contenido en la Guía de Usuario del AmigaDOS es una adaptación
de The AmigaDOS Manual, segunda edición, Copyright © 1987 de Commodore-Amiga,
Inc., y se usa con permiso de Bantam Books. Todos los derechos reservados.
La fuentes Times Roman, Helvetica Medium y Courier incluidas en el directorio
Fonts del disco Fonts son Copyright © 1985, 1987 de Adobe Systems, Inc. Las
fuentes CG Times, Univers Medium y LetterGothic incluidas en el disco Fonts
son Copyright © 1990 de Agfa Corporation, y se ofrecen bajo licencia de Agfa
Corporation.


				   A V I S O
				   =========


Con este documento Commodore no ofrece garantías o representaciones, ni
expresas ni implícitas, con respecto a los productos aquí descritos. La
información aquí presentada se suministra "TAL COMO ES", y está sujeta a
cambios sin previo aviso. El riesgo de usar esta información es asumido
por el usuario. EN NINGÚN CASO COMMODORE SERÁ RESPONSABLE DE NINGÚN DAÑO
PRODUCIDO DIRECTA O ACCIDENTALMENTE, O COMO CONSECUENCIA DE CUALQUIER
DEFECTO DE LA INFORMACIÓN PRESENTADA AQUÍ, AÚN EN EL CASO DE QUE COMMODORE
TUVIESE CONOCIMIENTO DE LA POSIBILIDAD DE QUE OCURRIESEN TALES DAÑOS.
ALGUNOS PAÍSES NO CONTEMPLAN LA LIMITACIÓN DE GARANTÍAS IMPLÍCITAS O DE
DAÑOS, LO QUE SIGNIFICA QUE LAS LIMITACIONES DESCRITAS PODRÍAN NO TENER
EFECTO.


			       MARCAS REGISTRADAS
			       ==================


Commodore, el logotipo de Commodore, CBM y AUTOCONFIG con marcas registradas
de Commodore Electronics Limited en los Estados Unidos y en otros países.
Amiga, AmigaDOS, Kickstart, Workbench y Bridgeboard son marcas registradas
de Commodore-Amiga, Inc. en los Estados Unidos y en otros países.

MS-DOS es una marca registrada de Microsoft Corporation. CrossDOS es una
marca registrada de Consultron. Compugraphic, CG e Intellifont son marcas
registradas de Agfa Corp. CG Triumvirate es una marca registrada de Agfa
Corp. CG Times está basada en Times New Roman bajo licencia de The Monotype
Corporation Plc. Times New Roman es una marca registrada de Monotype
Corporation. Univers es una marca registrada de Linotype AG. Universe está
bajo licencia de Haas Typefoundry Ltd. Diablo es una marca registrada de
Xerox Corporation; Epson es una marca registrada de Epson America, Inc.;
IBM y Proprinter XL son marcas registradas de International Business
Machines Corp.; Apple, Macintosh e Imagewriter son marcas registradas de
Apple Computer, Inc.; LaserJet y LaserJet PLUS son marcas registradas de
Hewlett-Packard Company; NEC y Pinwriter son marcas registradas de Nec
Information Systems; Okidata es una marca registrada de Okidata, una
división de Oki America, Inc.; Okimate 20 es una marca registrada de
Okidata, una división de Oki America, Inc. Este documento también puede
contener referencias a otras marcas registradas, que se supone que
pertenecen a las fuentes asociadas a su nombre.

Impreso en las islas Filipinas.

Este libro fue producido usando una variedad de sistemas informáticos de
Commodore por Kitsel Outlaw, Ross Hippely, Barbara Siwirski y Carina Ahren.

@endnode

@NODE select "Seleccionando un interfaz"

				   Capítulo 1
				   ==========


			  SELECCIÓN DEL INTERFAZ IDÓNEO
			  =============================


A pesar de que el Amiga viene con el interfaz gráfico de usuario (GUI)
Workbench y de que la mayor parte de las operaciones del AmigaDOS pueden
realizarse con el Workbench sin abrir ninguna ventana Shell, existen varias
razones para aprender a usar el interfaz de línea de comandos AmigaDOS.
Entre las ventajas de trabajar directamente con el AmigaDOS están:

- Preferencia personal

  Algunos usuarios prefieren trabajar con texto y teclado en lugar de con
  un ratón y unos iconos. Esto puede ser una cuestión de gusto personal o
  por estar ya familiarizado con otros sistemas informáticos basados en el
  uso de texto.

- Limitaciones del Workbench

  A pesar de que la mayor parte de las operaciones básicas pueden llevarse
  a cabo con la misma facilidad tanto en Shell como en el Workbench, hay
  cosas que sólo se pueden hacer utilizando comandos del AmigaDOS. Entre
  estas funciones están ciertas tareas básicas de configuración, así como
  la ejecución de scripts y utilidades que carecen de iconos. Fíjese en que
  todas las funciones del AmigaDOS están disponibles en el Workbench usando
  la opción "Ejecutar Comando..." del menú Workbench.

- Velocidad

  Los usuarios que teclean con una cierta velocidad y que están
  familiarizados con los comandos del AmigaDOS a menudo se encuentran con
  que tardan menos tiempo en teclear un comando que en realizar la operación
  equivalente con el ratón. Esto es particularmente cierto cuando hay que
  ejecutar más de un comando. Las funciones propias del Shell, como el uso
  de comodines y la redirección, hacen que algunas tareas resulten
  particularmente sencillas cuando se comparan con el uso del Workbench.
  Además, la salida de texto de los comandos del AmigaDOS normalmente se
  muestra más rápidamente que los requesters y las ventanas llenas de
  iconos.

- Control y flexibilidad

  La ejecución de programas desde Shell hace más fácil controlar la
  multitarea del Amiga. Además, al usar aplicaciones como por ejemplo
  compiladores, que ofrecen numerosas opciones de uso directo, es más
  rápido indicar estas opciones cambiantes en una línea de comando que
  editar los tipos de herramienta ("ToolTypes") de un icono.

- Uso de scripts

  Realizar tareas complejas, repetitivas y/o que funcionen sin que el
  usuario esté presente resulta difícil, si no imposible, usando un interfaz
  gráfico. Llevar a cabo estas tareas es la finalidad ideal de los scripts,
  que son ficheros de texto que contienen comandos del AmigaDOS.

- Ahorro de recursos para sus aplicaciones

  El interfaz de texto requiere menos memoria, menos espacio en disco y
  menos recursos del sistema que la maquinaria visual de un interfaz
  gráfico.

@endnode

@NODE ElecInterfaz "Elija su interfaz preferido"

ELIJA SU INTERFAZ PREFERIDO
---------------------------

A pesar de que algunos usuarios prefieren usar el Shell o el Workbench de
forma exclusiva, la mayor parte pueden hacer uso de ambos una vez que
aprenden las bases del AmigaDOS. Como las ventanas Shell se abren en la
misma pantalla del Workbench, resulta fácil pasar de uno a otro método de
trabajo. El que usted haga algo con el Workbench o con el Shell depende
del método que le resulte más fácil de usar para una tarea determinada.

USUARIOS DEL WORKBENCH

A pesar de que puede trabajar principalmente con el Workbench, le
recomendamos que se familiarice con el AmigaDOS, ya que es posible que
necesite usar comandos del AmigaDOS o examinar un script para controlar
su funcionamiento. Las numerosas funciones del Shell del Amiga hacen que
el proceso de aprendizaje y uso del AmigaDOS resulte considerable más
fácil que la mayor parte de los sistemas basados en línea de comando. Si
prefiere no usar el AmigaDOS directamente, siempre podrá asociar scripts
y comandos del Shell a iconos.

USUARIOS DE SHELL

Para los usuarios que elijan no abrir el Workbench, el soporte del interfaz
gráfico incorporado en el Amiga es todavía un as en la manga. Las ventanas
Shell, al igual que las ventanas del Workbench, pueden ser rápidamente
movidas, cambiadas de tamaño, colocadas delante y detrás de otras ventanas,
abiertas o cerradas, y todo ello usando el ratón. Las ventanas Shell pueden
abrirse en pantallas públicas además de en la propia del Workbench. FKey,
MouseBlanker y otras utilidades de Comodidades le permiten personalizar
aún más su entorno de trabajo basado en línea de comando.

@endnode

@NODE TareasAmigaDOS "Tareas del AmigaDOS"

TAREAS DEL AmigaDOS

Para determinar la forma más eficiente de interactuar con su Amiga, use la
tabla siguiente para saber dónde se comentan las tareas específicamente.
Luego compare el método AmigaDOS con el equivalente a través del Workbench.
Seleccione el método que le resulte más fácil y cómodo para conseguir su
objetivo.

-----------------------------------------------------------------------------
Configuración de las preferencias		Dónde encontrar el apartado
-----------------------------------------------------------------------------

Selección de un idioma				Capítulo 7

Selección de un tipo de teclado y opciones
de ratón					Capítulo 7

Selección del modo de visualización por
defecto						Capítulo 7

Edición de los colores del Workbench		Capítulo 7

Ajuste de la fecha y hora del sistema		Capítulo 7

Selección de las fuentes del sistema		Capítulo 7

Selección de las opciones de impresora		Capítulo 7

Edición del puntero del ratón			Capítulo 7

Selección de los fondos del Workbench		Capítulo 7

Selección del tipo de sonido a reproducir
cuando ocurra un error				Capítulo 7


-----------------------------------------------------------------------------
Configuración de los discos y el entorno	Dónde encontrar el apartado
de trabajo					
-----------------------------------------------------------------------------

Formateo y copia de discos			Capítulo 7

Añadido de directorios a la senda de búsqueda	Capítulos 6 y 8

Creación de alias				Capítulos 6 y 8
						Apéndice C

Asignación de directorios y dispositivos	Capítulos 6 y 8
						Apéndice C

Uso de la opción PATH del comando ASSIGN	Capítulo 6
 						Apéndice C

Haciendo comandos residentes			Capítulo 6
						Apéndice C

Personalización de los ficheros de arranque	Apéndice D

Creción de nuevos directorios			Capítulo 6

Ajuste de las opciones de CrossDOS		Capítulo 7

Ajuste de las teclas de función			Capítulo 7

Preparación de tarjetas de memoria PCMCIA
para su uso					Capítulos 6 y 7

Pre-carga de recursos en memoria		Capítulo 6
						Apéndice C

Haciendo espacio en su disco de Workbench	Apéndice C

Uso de ficheros de montaje y listas de montaje
(MountList)					Capítulo 6
						Apéndice B


-----------------------------------------------------------------------------
Aprendizaje del AmigaDOS y el Shell		Dónde encontrar el apartado
-----------------------------------------------------------------------------

Decidiendo cuándo usar el AmigaDOS		Capítulo 1

Apertura y cierre de ventanas Shell		Capítulos 2, 6 y 8

Activación de una ventana Shell			Capítulo 2

Entendiendo las bases de un comando		Capítulo 6

Entendiendo el formato de la línea de comando	Capítulo 6

Entendiendo la sintaxis del comando		Capítulo 6

Entendiendo los caracteres especiales del
AmigaDOS					Capítulo 3

Uso de patrones y caracteres comodín		Capítulo 3

Uso de la edición de la línea de comando	Capítulo 2

Uso del historial de comandos			Capítulo 2

Revelando la salida de comandos anteriores	Capítulos 2 y 8

Usando la copia y pegado			Capítulo 2

Especificando sendas				Capítulos 3 y 8

Trabajando con un sólo Shell			Capítulo 8

Entendiendo los comandos basados en disco y
los internos					Capítulo 3

Personalización de la ventana Shell		Capítulos 6 y 8
						Apéndice D

Conociendo la estructura de directorios
estándar					Apéndice B

Nombrado y renombrado de discos, ficheros y
directorios					Capítulos 3 y 6


-----------------------------------------------------------------------------
Mostrado de información				Dónde encontrar el apartado
-----------------------------------------------------------------------------

Determinar el directorio actual			Capítulos 3 y 8

Listar el contenido de un directorio (ejemplo)	Capítulos 6 y 8

Mostrar la sintaxis de un comando		Capítulo 3

Listar información sobre ficheros y
directorios					Capítulos 6 y 8

Uso de LIST LFORMAT (ejemplo)			Capítulo 6

Mostrar o ajustar la fecha y la hora		Capítulo 7

Mostrar ficheros de gráficos, texto y
animación					Capítulos 6 y 7

Usando una calculadora en la pantalla		Capítulo 7

Uso de un reloj en la pantalla			Capítulo 7

Mostrar el keymap (mapa del teclado)		Capítulo 7

Mostrar los números de versión del software	Capítulo 6

Cambio de la fuente de la ventana Shell		Capítulo 6

Obtener información sobre sistemas de ficheros	Capítulo 6

Uso de secuencias de Escape			Apéndice D

Listar información acerca de procesos Shell	Capítulo 6


-----------------------------------------------------------------------------
Ejecución de programas				Dónde encontrar el apartado
-----------------------------------------------------------------------------

Ejecución de programas desde Shell		Capítulos 3 y 8

Uso de la senda correcta			Capítulos 3 y 8

Cambio del directorio actual			Capítulo 8

Redireccionar o redirigir la entrada y salida
de los comandos					Capítulo 3

Detener un programa (ejemplo)			Capítulo 8

Ejecución de programas como procesos en
segundo plano					Capítulos 6 y 8

Uso de ICONX (ejemplo)				Capítulo 8


-----------------------------------------------------------------------------
Uso de scripts					Dónde encontrar el apartado
-----------------------------------------------------------------------------

Ejecución de scripts				Capítulos 5 y 6

Salir de un script				Capítulo 6

Edición de texto o scripts			Capítulo 4

Creación y modificación de un fichero
User-startup					Capítulo 8
						Apéndice D

Uso de caracteres script			Capítulo 5

Ajuste del bit de protección "s"		Capítulos 5 y 8

Creación automática de scripts			Capítulos 5, 6 y 8

Uso de PCD					Capítulo 8
						Apéndice B

Evitando la salida hacia la pantalla con >NIL:	Capítulo 8

Uso de comandos script				Capítulo 5

Depuración de scripts				Capítulo 5

Uso de variables de entorno			Capítulo 5

Crear bucles usando EVAL (ejemplo)		Capítulo 8

Crear un comando Move ("Mover")			Capítulo 8


-----------------------------------------------------------------------------
Editores de texto				Dónde encontrar el apartado
-----------------------------------------------------------------------------

Uso del editor ED				Capítulo 4

Acceso a los menús expandidos de ED		Capítulo 8

Uso del editor MEmacs				Capítulo 4

Uso del editor EDIT				Capítulo 4


-----------------------------------------------------------------------------
Manipulación de ficheros			Dónde encontrar el apartado
-----------------------------------------------------------------------------

Copia de ficheros o directorios			Capítulos 6 y 8

Copia de discos					Capítulo 7

Borrado de ficheros o directorios		Capítulos 6 y 8

Borrado de ficheros con iconos			Capítulo 8

Borrado con un DIR interactivo			Capítulo 8

Ordenación y unión de ficheros			Capítulo 8

Prueba de comandos				Capítulo 8

Uso del disco RAM				Apéndice C

Eliminando de la memoria fuentes y librerías
no utilizadas					Capítulo 8

Usando pipes (ejemplo)				Capítulo 8
						Apéndice B

Evaluando expresiones simples			Capítulo 6

Localizando cadenas de texto específicas	Capítulo 6

Ordenación alfabética de las líneas de un
fichero						Capítulo 6

Redirección de la salida a la impresora		Capítulo 7

Actualización de los ficheros .font		Capítulo 7


-----------------------------------------------------------------------------
Tareas específicas del Workbench		Dónde encontrar el apartado
-----------------------------------------------------------------------------

Parámetros específicos del Workbench		Capítulo 7

Edición de iconos				Capítulo 7

Asignando iconos a ficheros			Capítulo 8

Creando un icono de disco RAM diferente		Capítulo 8

Uso de ICONX					Capítulo 8

Uso de una calculadora en pantalla		Capítulo 7

Uso de un reloj en pantalla			Capítulo 7

Imprimiendo una pantalla			Capítulo 7

Creación de fondos para el Workbench		Capítulo 7

Desactivar la pantalla del monitor		Capítulo 7

Desactivar el puntero del ratón			Capítulo 7

Cambiar los colores del Workbench		Capítulo 7

Cambiar el puntero del ratón			Capítulo 7

Ajuste de las opciones de entrada (Input)	Capítulo 7

Especificando fuentes				Capítulo 7

Selección de modos de visualización		Capítulo 7

Carga del Workbench desde Shell			Capítulo 6

@endnode

@NODE capichi "ENTENDIENDO EL SHELL DEL AmigaDOS"

				  Capítulo 2
				  ==========


		      ENTENDIENDO EL SHELL DEL AmigaDOS
		      =================================


Un Shell de AmigaDOS es una ventana especial que aparece sobre la pantalla
del Workbench y que acepta la entrada de texto, permitiéndole comunicarse
con el AmigaDOS. El Shell es un tipo de interfaz de línea de comando o CLI.
Este capítulo describe lo siguiente:

                               @{" Sobre el Shell  " link SobreShell}
                    @{" Apertura " link AbreShell} y @{" cierre " link CierraShell} de ventanas Shell
                               @{" Usando el Shell " link UsandoShell}

@endnode

@NODE SobreShell "Sobre el Shell"

SOBRE EL SHELL

Puede comunicarse directamente con el AmigaDOS a través de una ventana de
consola Shell, un interfaz de sólo texto que acepta la entrada desde el
teclado. La ventana Shell tiene el mismo aspecto y actúa como una ventana
Workbench, con las siguientes diferencias:

- No pueden arrastrarse iconos hacia la ventana Shell.

- El ratón sólo puede utilizarse para las operaciones de copiar y pegar,
  excepto en los editores de texto ED y MEmacs.

- No aparecen gadgets deslizantes.

- La ventana Shell de AmigaDOS utiliza solamente fuentes no proporcionales,
  normalmente la fuente de texto utilizada por defecto por el sistema (Topaz
  o Courier), especificada en el editor de preferencias Font.

- Ningún dibujo de fondo indicado en el editor WBPattern aparecerá en las
  ventanas Shell.

Como ocurre con el Workbench, pueden abrirse varias ventanas Shell
independientes al mismo tiempo. Mientras que los comandos introducidos
en un Shell están siendo ejecutados, puede introducir y ejecutar otros
comandos en otra ventana Shell.

@endnode

@NODE AbreShell "Abriendo ventanas Shell"

ABRIENDO VENTANAS SHELL

Las ventanas Shell pueden abrirse de dos formas:

- Pulsando en el icono Shell del cajón System del disco Workbench.

- Usando el comando @{"NEWSHELL" link newshell} descrito en el capítulo 6.

Cuando se abre una ventana Shell:

- la ventana queda destacada, indicando que es la ventana actual

- aparece un prompt, como "1.SYS> "

- a la derecha del prompt hay un cursor, un pequeño rectángulo de color.

Como en el Workbench, sólo la ventana seleccionada puede aceptar la entrada
de información. Para introducir información en una ventana diferente, pulse
sobre ella para convertirla en la ventana actual. Mientras una ventana Shell
es la ventana actual, no pueden usarse los menús de la barra de título del
Workbench.

@endnode

@NODE CierraShell "Cerrando ventanas Shell"

CERRANDO VENTANAS SHELL

Use una de las siguientes operaciones para cerrar una ventana Shell:

- Seleccione el gadget de cierre

- Introduzca el comando @{"ENDSHELL" link endshell} (o @{"ENDCLI" link endcli})

- Pulse Ctrl+\

Le recomendamos que cierre las ventanas Shell cuando ya no las necesite; las
ventanas abiertas consumen memoria.

Todos los programas que no sean totalmente independientes del Shell que
los ejecutó deberán abandonar el sistema para poder cerrar ese Shell.
Puede comprobar si un programa está activo pulsando Return: si no aparece
el prompt del Shell en la ventana, el programa está activo. Aunque puede
teclear comandos en esa ventana, el AmigaDOS no responderá a los mismos
hasta que el programa que está siendo ejecutado abandone el sistema.
@endnode

@NODE UsandoShell "Usando el Shell"

USANDO EL SHELL

Introduzca comandos AmigaDOS en el prompt de texto del Shell. Incluya con
el comando la información que sea necesaria, como nombres de ficheros u
opciones del comando. Pulse Return al final de cada línea de comando para
ejecutarlo. El prompt del Shell aparecerá cuando el comando haya terminado
de ejecutarse.

Para ver la salida impresa del comando una vez que ésta ha desaparecido
por la parte superior de la ventana, agrande la ventana usando el gadget
de zoom del Shell o el gadget de tamaño. De esta forma se revelará toda la
información posible que quepa en la ventana.

@endnode

@NODE TeclasShell "Edición y control de la línea de comando"

EDICIÓN Y CONTROL DE LA LÍNEA DE COMANDO

Para simplificar la introducción y la edición del texto de la línea de
comando, el Shell del AmigaDOS ofrece las siguientes teclas y combinaciones
de teclas:

flecha izquierda		Mueve el cursor un carácter a la izquierda

flecha derecha			Mueve el cursor un carácter a la derecha

Mayúsculas + flecha izquierda	Lleva el cursor al principio de la línea

Mayúsculas + flecha derecha	Lleva el cursor al final de la línea

Borrar (Retroceso)		Borra el carácter a la izquierda del cursor

Del				Borra el carácter destacado por el cursor

Ctrl + H			Borra el último carácter (como Retroceso)

Ctrl + M			Ejecuta la línea de comando (como Return)

Ctrl + J			Añade un salto de línea

Ctrl + W			Borra la palabra que está a la izquierda
				del cursor

Ctrl + X			Borra la línea completa

Ctrl + K			Borra todo desde el cursor hasta el final
				de la línea

Ctrl + Y			Recupera los caracteres borrados con Ctrl+K

Ctrl + U			Borra todo desde el cursor hasta el
                                principio de la línea

Además, el Shell soporta las siguientes teclas y combinaciones de teclas:

barra espaciadora (o cualquier
carácter imprimible)		Suspende la salida de texto (detiene el
				movimiento del texto hacia arriba)

borrar (Retroceso)		Reanuda la salida de texto (reanuda el
				movimiento del texto hacia arriba)

Ctrl + C			Envía un comando BREAK al proceso actual
				(interrumpe el proceso)

Ctrl + D			Envía un comando BREAK al script actual
				(interrumpe el script)

Ctrl + F			Activa y trae las ventanas de programas
				Workbench a la parte frontal de la
				visualización

Ctrl + S			Suspende la salida

Ctrl + Q			Continúa la salida si ésta fue detenida con
				Ctrl + S

Ctrl + \			Cierra la ventana Shell. Cuando la entrada/
				salida está redirigida a otros dispositivos,
				con * se recupera la entrada/salida normal

El Shell le permite introducir un comando u otra información mientras se está
emitiendo un listado. Sin embargo, esto detiene la salida hasta que pulse
la tecla Return. El nuevo comando se ejecuta tras haber finalizado la salida
del listado.

Si introduce un nuevo comando o texto y luego lo borra, la salida de texto
original continúa su curso en cuanto se borra el último carácter.

@endnode

@NODE UsandoElHistorial "Usando el historial de comandos"

USANDO EL HISTORIAL DE COMANDOS

Shell usa un buffer de línea de comando de 2 Kb para retener líneas de
comando, lo que ofrece un historial de comandos. Usando este historial
puede acudir a líneas de comando introducidas con anterioridad, editarlas
y ejecutarlas de nuevo. Esto le permite repetir fácilmente un comando o
introducir varios comandos similares.

El número exacto de líneas retenidas en el buffer de líneas de comando varía
dependiendo de la longitud de las líneas almacenadas. Cuando el buffer está
lleno, las líneas más viejas se eliminan. Puede acceder a las líneas del
buffer con las teclas flecha arriba y flecha abajo:

flecha arriba			Se mueve hacia arriba por el historial de
				comandos (las líneas más antiguas)

flecha abajo			Se mueve hacia abajo por el historial de
				comandos (las líneas más recientes)

Por ejemplo, puede copiar varios ficheros .info de un directorio a otro
introduciendo la línea de comando con la senda completa sólo una vez, y
luego llamando a esta línea las veces que sean necesarias, cambiando
solamente el nombre del fichero.

También puede buscar la ocasión más reciente en la que se ha utilizado un
comando en particular introduciendo la línea de comando, o el principio de
la misma, y pulsando Mayúsculas + flecha arriba (o Ctrl + R). Por ejemplo,
si introduce DIR y pulsa Mayúsculas + flecha arriba, aparecerá la última
línea en la que se ha hecho uso del comando DIR. Pulsando Mayúsculas +
flecha abajo irá a la parte inferior del historial de comandos, dejando
el cursor en una línea en blanco.

@endnode

@NODE CopiarYPegar "Copiar y Pegar"

COPIAR Y PEGAR

Puede copiar y pegar información desde una ventana de tipo consola, como una
ventana Shell o ED, a la misma ventana o a otra diferente, siempre que sea
también de tipo consola. Ésta es la única operación de tipo Workbench que se
puede hacer en las ventanas Shell, exceptuando las ventanas de los editores
de texto ED y MEmacs.

Use el ratón para destacar el trozo de texto que quiera copiar y pegar.
Destaque el texto a copiar llevando el puntero al principio del trozo de
texto, manteniendo pulsado el botón de selección y arrastrando el puntero
del ratón hasta el final del trozo de texto que le interese. Entonces
suelte el botón de selección y pulse Amiga derecha + C. El trozo de texto
destacado tiene ahora una copia en el Portapapeles. El texto que ha copiado
puede ser pegado repetidas veces a cualquier ventana de aplicación que
soporte la lectura de texto proveniente del Portapapeles, como Shell, ED y
MEmacs.

Para colocar el cursor donde quiera pegar el texto, lleve el puntero del
ratón al lugar en cuestión y pulse. Luego pulse Amiga derecha + V para pegar
el texto.

NOTA: Si se pega un bloque de texto en una ventana Shell, el Shell intentará
      ejecutar cada línea del texto como si se tratase de un comando. Esto
      puede tener resultados impredecibles si el bloque de texto tiene
      señales de retorno de carro por medio y no se trata de un script
      AmigaDOS.

@endnode

@NODE TrabajoShell "Trabajando con el Shell"

TRABAJANDO CON EL SHELL

A continuación se apuntan algunos consejos para acelerar su trabajo con el
Shell.

- Use el historial de comandos y la edición de la línea de comandos

  A veces se necesitan varios intentos hasta conseguir que un comando cumpla
  con la tarea deseada, especialmente si está todavía aprendiendo a usar el
  AmigaDOS. Use las teclas del cursor para acudir a comandos previamente
  introducidos y cambie solamente la parte de la línea que cause el problema
  para eliminar la necesidad de volver a escribir la línea entera.

- Use @{"alias" link alias}

  Definir alias cortos para los comandos que use a menudo es otra forma de
  ahorrar tiempo. También elimina la necesidad de recordar una serie de
  opciones que puede resultar larga o compleja.

- No teclee palabras clave innecesarias

  Para mayor claridad, los nombres de los comandos del AmigaDOS y las
  palabras clave a menudo se muestran en este manual, aunque puedan ser
  opcionales. Cuando aprenda el formato de uso de un comando, sin embargo,
  tal vez desee o necesite incluir palabras clave opcionales.

- No use letras mayúsculas

  Los nombres de comandos, palabras clave y directorios asignados se
  muestran en mayúsculas en este manual, a pesar de que para el AmigaDOS
  no supone diferencia alguna frente a las minúsculas. Nosotros lo hacemos
  para distinguirlos fácilmente de nombres de fichero y otra información en
  las líneas de comando expuestas como ejemplo; no hay necesidad de usar
  mayúsculas, excepto cuando use un comando para crear un fichero o
  directorio cuyo nombre quiera que aparezca en mayúsculas.

- Use el @{"CD" link cd} implícito

  Esto le permite prescindir del comando CD, ahorrándole tres pulsaciones en
  el teclado. Introduzca solamente el nombre del directorio, senda, signo de
  dos puntos o de barra en el prompt para cambiar de directorio.

@endnode

@NODE working "TRABAJANDO CON AmigaDOS"

				   Capítulo 3
				   ==========


			    TRABAJANDO CON AmigaDOS
			    =======================


El AmigaDOS almacena información con la misma estructura jerárquica que el
Workbench. Los comandos AmigaDOS tienen reglas específicas que usted debe
seguir al crear scripts y programas que serán ejecutados en el Amiga. Deberá
familiarizarse con los términos relacionados con el sistema de ficheros y
con los conceptos sobre los comandos del AmigaDOS para poder usar el
AmigaDOS con éxito. Este capítulo describe lo siguiente:

                  @{" Manejo de ficheros, directorios y discos " link ManejaFicDirDis}

                        @{" Bases de la línea de comando " link BasesDeShell}

                              @{" Tipos de comandos " link TiposDeComandos}

                           @{" Estructura de comandos " link EstructuraDeComandos}

                            @{" Caracteres especiales " link CaracteresEspeciales}

                            @{" Ejecutando programas " link EjecutandoProgramas}

                      @{" Modificación del entorno AmigaDOS " link ModificaEntornoCLI}

@endnode

@NODE ManejaFicDirDis "Manejo de ficheros, directorios y discos"

MANEJO DE FICHEROS, DIRECTORIOS Y DISCOS
----------------------------------------

Para usar el AmigaDOS para acceder a la información, deberá saber dónde
se encuentra esa información. En el Amiga, toda la información se almacena
siguiendo un sistema de directorios y ficheros. Es el mismo sistema
utilizado por el Workbench; la diferencia estriba en el método de trabajo.
La mayor diferencia es que no utilizará iconos para manipular los ficheros
y los directorios. Mire la "Guía del usuario del Workbench" para una
información más detallada sobre el sistema de ficheros del Amiga y el uso
de los comandos. Use esta sección para revisar los siguientes conceptos
básicos del AmigaDOS:

                       @{" Términos del sistema de ficheros " link TérminosFileSystem}

                              @{" Manejo de ficheros " link ManejaFicheros}

                       @{" Convenciones al nombrar ficheros " link ConvencionesAlNombrar}

                                @{" Palabras Clave " link PalabrasClave}
@endnode

@NODE TérminosFileSystem "Términos del sistema de ficheros"

TÉRMINOS DEL SISTEMA DE FICHEROS

A continuación se describen los elementos principales del sistema de
ficheros AmigaDOS:

  Dispositivo			Un dispositivo físico, como una unidad de
				disco o una impresora, o un dispositivo de
				software (dispositivo lógico), como RAM: o
				el dispositivo de impresora, PRT:

  Partición			Un disco duro o parte del mismo que el
				AmigaDOS trata como un dispositivo aparte.

  Volumen			Un disco en particular o una subdivisión de
				un disco duro que el AmigaDOS trata como un
				dispositivo separado. Los discos flexibles
				y las particiones de disco duro son
				volúmenes.

  Directorio			Equivale a un cajón en el Workbench.

  Directorio raíz		Es la parte más alta del sistema de ficheros
				en un volumen determinado; es el directorio
				del que parten todos los demás directorios.

  Subdirectorio			Un directorio que se encuentra dentro de
				otro directorio.

  Fichero			Un conjunto organizado de información que
				tiene un nombre.

  Senda				Una serie de nombres de dispositivo,
				directorio y subdirectorio que especifican
				únicamente dónde se encuentra un fichero en
				particular.

@endnode

@NODE ManejaFicheros "Manejo de ficheros"

MANEJO DE FICHEROS

El AmigaDOS almacena información en un dispositivo usando un sistema de
ficheros, que es una forma de organizar directorios, subdirectorios y
ficheros. Los directorios y los ficheros se organizan siguiendo un sistema
jerárquico, que a menudo recibe el nombre de árbol. Las ramas son los
directorios, que pueden contener subdirectorios. Al final de las ramas
están los ficheros, a menos que el directorio esté vacío. La siguiente
figura muestra un árbol de directorios:

				     DISCO
		     ________________||||____________________
		     |                ||                    |
		Directorio	Fichero	Fichero		Directorio
	    _____|  |  |___				___|  |___
	    |       |     |                             |        |
	Fichero Fichero Fichero			   Directorio  Fichero

@endnode

@NODE Dispositivos

Dispositivos

Los dispositivos incluyen dispositivos lógicos y el hardware asociado con
su Amiga, como las unidades de disco flexible, discos duros, el disco RAM,
RAD: y los periféricos. A la información almacenada en estos dispositivos
puede accederse usando varios nombres.

Para acceder a los ficheros de un volumen concreto, puede aludir a ese
volumen por su nombre de volumen, como "Workbench:", o por su nombre de
dispositivo, como "DF0:". Use el nombre que prefiera, pero recuerde añadir
siempre el signo de dos puntos (:) inmediatamente después del nombre. Cuando
alude a un disco por su nombre de volumen, el sistema busca ese volumen por
todos los dispositivos disponibles. Si no puede encontrar un volumen con ese
nombre, aparecerá un requester pidiéndole que inserte ese volumen. Cuando
alude a un disco con un nombre de dispositivo en particular, el sistema usa
el volumen que esté insertado en ese dispositivo.

El AmigaDOS tiene nombres asignados de forma estándar a los periféricos
asignados a los diferentes puertos, así como a los diferentes dispositivos
lógicos (por software). Generalmente, estos dispositivos se usan como
salida, como por ejemplo para copiar un fichero a la impresora. Los nombres
estándar de los dispositivos son:

  SYS:				Representa el volumen en el cual el Amiga
				busca sus recursos básicos de disco, como
				C: y LIBS:.

  PAR:				Representa cualquier dispositivo
				(normalmente una impresora) que se conecta
				al puerto paralelo.

  SER:				Representa cualquier dispositivo conectado
				al puerto serie, como una impresora o un
				módem. La salida enviada aquí no se ve
				modificada por ningún driver de software.

  PRT:				Representa la impresora. La salida enviada
				a PRT: pasa por el control del driver de
				impresora seleccionado y su destino es el
				puerto serie o paralelo, según se indique
				en el editor Printer del cajón Prefs.

  CON:				Representa una consola, que usa una ventana
				para aceptar la entrada desde teclado y para
				mostrar la salida de texto. La ventana Shell
				es un ejemplo de ventana de tipo consola.

  CONSOLE:			Representa la ventana de consola actual.
				Puede usarse un asterisco (*) en lugar de
				CONSOLE:

  NIL:				Representa un dispositivo especial que
				normalmente se usa para evitar la aparición
				de información en la pantalla. Toda la
				salida enviada a NIL: se pierde.

  RAM:				Representa el disco RAM, que es una porción
				de la memoria interna del Amiga que puede
				utilizarse como medio de almacenamiento.
				Toda la información contenida en RAM: se
                                pierde si el Amiga se resetea o se apaga.

  RAD:				Representa un tipo especial de disco RAM
				que se pierde únicamente cuando el sistema
				se desconecta de la red eléctrica, pero NO
				cuando se resetea. Mire el apéndice C para
				@{" más información " link RamRecuperable} .

  DF0: 				Representa la unidad de disco flexible
				principal del Amiga, desde la cual el Amiga
				intentará arrancar si no encuentra ningún
				otro dispositivo de arranque.

@endnode

@NODE Directorios

Directorios

Los directorios son el equivalente en el AmigaDOS de los cajones en el
Workbench. Los directorios le permiten agrupar y clasificar ficheros que
guardan alguna relación. Cada fichero de un disco está contenido en un
directorio. Un disco vacío recién formateado contiene sólo un directorio:
el directorio raíz. Si crea un fichero en un disco vacío, el fichero se
situará en el directorio raíz. Si el fichero tiene un icono, éste aparecerá
en la ventana del disco.

Los directorios pueden contener otros directorios, llamados subdirectorios.
El Amiga soporta cualquier número de directorios anidados (directorios
contenidos en otros directorios).

@endnode

@NODE Ficheros

Ficheros

Un fichero, la unidad básica de almacenamiento en un ordenador, es un
conjunto organizado de información. Todos los programas y la información
permanente que producen y usan no son más que ficheros. Los iconos de
proyecto representan ficheros de datos. Los ficheros de datos contienen la
información creada o utilizada por un programa; puede ser un fichero de
texto, de gráficos o una hoja de cálculo.

@endnode

@NODE FicherosInfo "Ficheros .info"

Ficheros de tipo .info

Otro tipo de ficheros que usa el Amiga son los ficheros .info. Estos
ficheros contienen los iconos que aparecen en la pantalla del Workbench.
Cada fichero o directorio que tiene un icono también tiene el
correspondiente fichero .info. Además de almacenar la información sobre
el gráfico y la posición del icono, los ficheros .info contienen la
información de tipos de herramienta ("ToolTypes") y herramienta por
defecto introducida en la ventana de información del icono.

Al trabajar con Shell, el AmigaDOS no asocia automáticamente ficheros .info
con los correspondientes ficheros y directorios. Por ejemplo, si usa el
comando COPY para copiar el fichero Clock del directorio Tools al directorio
System, el fichero Clock.info no se copia como ocurriría si arrastrase el
icono Clock de un cajón a otro en el Workbench. En el AmigaDOS, para
asegurarse de que el icono del reloj aparece en el cajón System, deberá
copiar también el fichero Clock.info.

Cuando cambie las imágenes de los iconos copiando los ficheros .info,
necesitará copiar un icono del mismo tipo que el objeto que representen:
herramienta, proyecto, cajón, disco o papelera. Si el tipo de icono no
coincide con el tipo de fichero que representa, no podrá abrirse desde el
Workbench. El tipo de icono se indica en la ventana de información del
icono, y puede cambiarse con el programa @{"IconEdit" link UtiIconEdit}.

@endnode

@NODE ConvencionesAlNombrar "Convenciones al nombrar ficheros"

CONVENCIONES AL NOMBRAR FICHEROS

Se aplican las siguientes normas con los nombres de ficheros y directorios:

- Los nombres pueden ser de hasta 30 caracteres de largo y pueden contener
  letras mayúsculas y cualquier signo de puntuación que no esté reservado.
  Los nombres de ficheros y directorios pueden tener solamente 25 caracteres
  de largo para poder acomodar una posible extensión .info.

- El signo de dos puntos (:) y la barra inclinada (/) están reservados y no
  pueden utilizarse en los nombres de ficheros y directorios. Los signos de
  punto y coma (;), asterisco (*), paréntesis ( () ), interrogación (?),
  apóstrofe (`), canal (#), corchetes ([]), corchetes angulados (<>), tilde
  especial (~), barra vertical (|), dólar ($), comillas (") y tanto por
  ciento (%) no están reservados; sin embargo, le recomendamos que no use
  estos caracteres en los nombres de ficheros y directorios, ya que tienen
  un significado especial para el AmigaDOS.

- Las letras mayúsculas en los nombres de ficheros se mantienen, a pesar de
  que para el AmigaDOS no representan diferencia alguna. El nombre es
  reconocido por sus caracteres: por ejemplo, PicUno es lo mismo que picuno.

- Los espacios en los nombres están permitidos, pero no se recomiendan
  cuando se trabaja con AmigaDOS. Si usa nombres con espacios, la senda
  entera que contenga el nombre deberá ir entre comillas. Le recomendamos
  que use el signo de subrayado (_) como separador en lugar de espacios.

NOTA: Si usa espacios en los nombres de fichero, no los coloque al principio
      ni al final del nombre. Estos espacios resultarían invisibles al ser
      mostrado el nombre, y fácilmente pasarían desapercibidos como parte
      del nombre. El AmigaDOS no reconocerá el nombre si no se indican estos
      espacios.

@endnode

@NODE PalabrasClave "Palabras clave"

PALABRAS CLAVE

Una palabra clave ("keyword") es una palabra especial que es reconocida por
un comando del AmigaDOS. Los comandos del AmigaDOS usan palabras clave para
identificar argumentos o para especificar opciones. Si existe un conflicto
entre un nombre y una palabra clave, indicando el nombre entre comillas se
asegurará de que sea interpretado como tal. Por ejemplo, si tiene un
directorio llamado Files y quiere ver información sobre todos sus ficheros
y subdirectorios, podría usar el comando LIST FILES. Sin embargo, esto no
funcionaría correctamente, ya que LIST usa la palabra clave FILES. Para
evitar esto, introduzca:

  1.SYS> LIST "Files"

@endnode

@NODE BasesDeShell "Bases de la línea de comando"

BASES DE LA LÍNEA DE COMANDO
----------------------------

Para usar eficazmente un interfaz de línea de comandos como el Shell del
Amiga, es necesario que comprenda algunos conceptos relacionados únicamente
con este método de trabajo. Éstos incluyen:

           @{" Diferencias entre ficheros, programas, comandos y scripts " link FicProComScr}

                              @{" La senda de búsqueda " link BaseSenda}

                              @{" El directorio actual " link BaseDirecActual}

@endnode

@NODE FicProComScr "Ficheros, programas, comandos y scripts"

FICHEROS, PROGRAMAS, COMANDOS Y SCRIPTS

Los ficheros, comandos y scripts también reciben el nombre de conjunto de
información que puede ser almacenada en la memoria del ordenador o en un
disco. Estos conceptos pueden resultar confusos debido a que a menudo los
significados de estos términos son similares.

                                 @{" Ficheros  " link BaseFicheros}

                                 @{" Programas " link BaseProgramas}

                                 @{" Comandos  " link BaseComandos}

                                 @{" Scripts   " link BaseScripts}
@endnode

@NODE BaseFicheros "Ficheros"

Ficheros

Los programas, los comandos y los scripts son todos ficheros. Los ficheros
pueden guardarse en disco o en la memoria del Amiga, aunque ciertos tipos de
ficheros acostumbran a ser guardados en lugares específicos.
@endnode

@NODE BaseProgramas "Programas"

Programas

Un programa es un fichero que el ordenador ejecuta para realizar una tarea.
El software que compra para el Amiga es en su mayoría un conjunto de
programas. Los programas del Workbench reciben el nombre de herramientas,
utilidades o editores. Normalmente, un fichero que no es un programa es un
fichero de datos, que contiene información que un programa puede utilizar,
como texto o gráficos. Los programas pueden guardarse en cualquier parte.
@endnode

@NODE BaseComandos "Comandos"

Comandos

Un comando es un tipo de programa. El término 'comando' se utiliza
normalmente para hacer referencia a los programas que se ejecutan mediante
la línea de comandos, que vienen con el ordenador como parte del sistema
operativo y que realizan algunas funciones básicas. Los programas detallados
en el capítulo 6 de este manual son los comandos del AmigaDOS. Los comandos
del AmigaDOS que no son internos (integrados en Shell) se encuentran en el
directorio C:.

El término 'comando' también puede utilizarse para hacer referencia a la
invocación de un programa, incluyendo sus argumentos, si los hay. En este
manual, el término 'línea de comando' se usa para indicar una invocación al
nombre de un programa. Por ejemplo, 'La línea de comando TYPE S:User-Startup
es un ejemplo del comando TYPE'. El comando debe ser siempre lo primero que
aparece en la línea de comando.
@endnode

@NODE BaseScripts "Scripts"

Scripts

Un script es otro tipo de programa que consiste en un fichero de texto que
contiene una serie de comandos que componen el programa. Puede ver y editar
un script con un editor de texto. Normalmente, un script realiza cualquier
tarea sencilla que puede ser modificada editando el script.

En este manual, el término 'script' se usa para aludir a los scripts que
consisten en una serie de comandos del AmigaDOS. Los scripts AmigaDOS están
guardados en el directorio S:. Los programas ARexx también reciben el nombre
de scripts, a pesar de que son más conocidos como macros o programas; estos
scripts están también guardados en el directorio S: usando la asignación
REXX:. Algunos sistemas informáticos aluden a los scripts como 'ficheros
batch'.
@endnode

@NODE BaseSenda "Senda de búsqueda"

SENDA DE BÚSQUEDA

Al usar Shell, el Amiga debe saber dónde puede encontrar los comandos que
quiera usar. El Shell tiene una senda de búsqueda, que le permite
introducir comandos sin teclear la senda completa. La senda de búsqueda
es una serie de directorios en los que el AmigaDOS busca los comandos que
son introducidos sin senda.

La senda de búsqueda utilizada por defecto incluye el directorio actual, C:
y otros directorios indicados en el Startup-sequence estándar. Puede añadir
otros directorios en los que guarde programas de uso frecuente usando el
comando PATH o utilizando múltiples asignaciones con el comando ASSIGN. Por
supuesto, existen diferencias significativas entre estos dos métodos. Los
directorios añadidos a la senda de búsqueda con el comando PATH son locales
para el Shell en el que los añadió y para los Shell que abra desde esa
ventana Shell. Los directorios añadidos mediante asignaciones con el comando
ASSIGN son globales para todo el sistema.

Cuando introduce algo en el Shell, el AmigaDOS busca por los directorios
de la senda de búsqueda el comando que ha tecleado. Busca en los directorios
en el mismo orden en el que éstos aparecen en la senda de búsqueda hasta
encontrarlos o llegar al final de la lista de la senda. Cuando un comando
no ha sido encontrado en ningún directorio de la senda de búsqueda, Shell
muestra un mensaje "Comando desconocido".

NOTA: El AmigaDOS usa la senda de búsqueda sólo para encontrar los comandos.
      Deberá incluir la senda completa para los ficheros indicados como
      argumentos del comando.

@endnode

@NODE BaseDirecActual "Directorio actual"

DIRECTORIO ACTUAL

El directorio actual es el lugar actual de la jerarquía del sistema de
ficheros de Shell, de forma similar a la ventana actual del Workbench.
El nombre del directorio actual se muestra en el prompt del Shell para que
siempre pueda saber dónde está. El directorio actual tiene las siguientes
propiedades:

- Cada Shell tiene su propio e independiente directorio actual.

- Un Shell tiene sólo un directorio actual.

- El directorio actual es siempre el primer directorio de la senda de
  búsqueda.

- El directorio actual está asumido como parte de la senda de búsqueda y por
  ello no necesita indicarse nunca para usar un comando que se encuentre en
  el mismo.

- El directorio actual es el directorio por defecto, el directorio en el que
  cada comando hace su trabajo, de no especificarse un directorio diferente.

El cambio del directorio actual, al igual que añadir directorios a la senda
de búsqueda, es una forma de reducir el trabajo necesario para especificar
un comando. A menudo necesitará realizar varias operaciones en cierto
directorio, como copiar, pegar y borrar ficheros. Puede ahorrarse el trabajo
de teclear la senda completa para cada fichero cambiando el directorio
actual por el directorio en el que se encuentren esos ficheros o la mayoría
de ellos.

@endnode

@NODE TiposDeComandos "Tipos de comandos"

TIPOS DE COMANDOS
-----------------

El AmigaDOS tiene comandos internos y otros basados en disco.

Los comandos basados en disco deben ser cargados desde disco para poder
ejecutarlos. En sistemas con disco duro, los comandos basados en disco son
siempre accesibles para el sistema, ya que se cargan automáticamente cuando
son invocados. En sistemas basados en disco flexible, estos comandos se leen
de un disco flexible, que deberá ser insertado cada vez que sean invocados.

Los comandos internos residen en Shell, que está en ROM (Read Only Memory,
memoria de sólo lectura). El sistema accede a los comandos internos de forma
inmediata.

Algunos comandos del AmigaDOS equivalen a opciones de menú y programas del
Workbench. Estos comandos y su equivalente en el Workbench se muestran en
la siguiente tabla:

-----------------------------------------------------------------------------
Comando		Función				Equivalente en el Workbench
-----------------------------------------------------------------------------

@{"CD" link CD}		Cambiar el directorio actual	Seleccionar otra ventana o
						icono

@{"COPY" link Copy}		Copiar un fichero, directorio	Opción de menú 'Copiar'
		o disco

@{"DATE" link Date}		Ajustar la fecha y hora		Editor Prefs/Time
		actuales

@{"DELETE" link Delete}		Borrar un fichero o directorio	Opción de menú 'Borrar'

@{"DIR" link Dir}		Mostrar los ficheros de un	Opción de menú 'Mostrar/
		directorio			Todos los ficheros'

@{"DISKCOPY" link UtiDiskCopy}	Copiar un disco			Opción de menú 'Copiar'

@{"ENDSHELL" link EndShell}	Cerrar una ventana Shell	Seleccionar el gadget de
						cierre de la ventana Shell

@{"FORMAT" link UtiFormat}		Formatear un disco		Opción de menú 'Formatear
						disco'

@{"INFO" link Info}		Mostrar información de todos	Observar la barra de título
		los discos			de cada ventana de disco

@{"LIST" link List}		Mostrar todos los ficheros,	Opción de menú 'Ver por/
		con su tamaño, etc.		Nombre'

@{"MAKEDIR" link Makedir}	Hacer un nuevo directorio	Opción de menú 'Cajón nuevo'

@{"NEWSHELL" link NewShell}	Abrir una nueva ventana Shell	Abrir el icono Shell

@{"RELABEL" link Relabel}	Cambiar el nombre de volumen	Opción de menú 'Renombrar'
		de un disco

@{"RENAME" link Rename}		Cambiar de nombre un fichero	Opción de menú 'Renombrar'
		o directorio

@{"SETCLOCK" link SetClock}	Grabar la fecha y la hora	Editor Prefs/Time

@{"TYPE" link Type}		Mostrar el contenido de un	Usar el programa Multiview
		fichero de texto

@endnode

@NODE EstructuraDeComandos "Estructura de comandos del AmigaDOS"

ESTRUCTURA DE COMANDOS DEL AmigaDOS
-----------------------------------

Cada comando del AmigaDOS tiene un formato y una sintaxis específicos,
que deben ser utilizados por el usuario para que el AmigaDOS acepte y
utilice el comando. Las reglas generales de trabajo con los comandos
AmigaDOS son pocas, pero deben obedecerse:

- Un comando legal o un nombre de programa debe aparecer inmediatamente
  al principio de la línea de comando. La senda completa del comando no
  es necesaria si el comando está en un directorio de la senda de búsqueda.

- Los argumentos deben ir separados del comando y de otros argumentos por
  espacios; un sólo espacio basta, aunque se permiten más espacios. No
  deberá utilizarse más que la puntuación necesaria específicamente por
  el comando.

- El AmigaDOS no ve diferencia entre letras mayúsculas y minúsculas. Puede
  utilizarse cualquier mezcla de ambos tipos en la línea de comando, pero
  recuerde que se ignoran las diferencias. Eso sí, las diferencias en los
  nombres de ficheros y directorios se preservan.

- A no ser que se indique lo contrario, cuando una senda o argumento de
  cadena contenga algún espacio, la senda completa o argumento deberá ir
  entre comillas (""). Por ejemplo:

    1.SYS> ECHO comentario TO disco1:Texto/Comentario

    1.SYS> ECHO "Un comentario" TO "Disco 2:Texto/Comentario"

- La longitud máxima permitida de una línea de comando estándar en Shell es
  de 512 caracteres.

Un ejemplo de la estructura de una línea de comando del AmigaDOS se muestra
a continuación. Consiste en un comando COPY seguido por dos argumentos.


    comando  ______      __ palabras clave opcionales__            opción
		   |    |	  __ nombres __	       |	      |
		   |    |        |	       |       |	      |

  1.Extras:Prefs> COPY FROM ScreenMode ScreenMode.info TO SYS:Prefs CLONE

Un argumento es una parte opcional de información que usa el comando,
como un nombre de fichero o una opción. Los argumentos de los comandos
son similares a los tipos de herramienta ("ToolTypes") del Workbench.
Dependiendo del comando, los argumentos pueden ser opcionales u
obligatorios. El ejemplo mostrado arriba ilustra los siguientes puntos
sobre los argumentos.

- Las palabras clave de los comandos AmigaDOS son generalmente palabras
  enteras o bien abreviaturas; en este ejemplo son FROM y TO.

- Un argumento puede consistir en más de un término; en el ejemplo, el
  argumento de nombre de fichero incluye dos nombres al mismo tiempo:
  ScreenMode y ScreenMode.info.

- Algunos argumentos tienen una palabra clave que los identifica, que
  puede ser opcional u obligatoria.

- Cuando se omiten las palabras clave opcionales en un comando que usa
  varios argumentos, los argumentos deben aparecer en el orden mostrado
  en la sintaxis del comando.

@endnode

@NODE CaracteresEspeciales "Caracteres especiales del AmigaDOS"

CARACTERES ESPECIALES DEL AmigaDOS
----------------------------------

Hay varios caracteres que tienen un significado especial cuando se usan en
el AmigaDOS. Entre las funciones de estos caracteres especiales están:

- Especificar sendas

- Uso de patrones

- Redirección de la entrada y la salida de los comandos

Al usar el AmigaDOS, es importante recordar las numerosas funciones
especiales que pueden tener estos caracteres. Fíjese en que, en diferentes
contextos, el mismo carácter puede tener diferentes efectos, e incluso
perder cualquier función especial. Si un comando que parece haberse indicado
correctamente produce un resultado inesperado, compruebe si algún carácter
de la línea de comando tiene una función especial.
@endnode

@NODE CaracteresCLI "Caracteres de la línea de comando"

CARACTERES DE LA LÍNEA DE COMANDO

Los signos de dos puntos y barra inclinada están reservados en el AmigaDOS
para indicar sendas. En los requesters de ficheros, en la línea de comando
y en los scripts, estos caracteres se usan solamente para separar partes de
la línea que indica la senda.


Dos puntos (:)

El signo de dos puntos se utiliza para designar nombres de dispositivo (por
ejemplo, DF0:), nombres de volumen (como Workbench:) y directorios asignados
(como SYS:). No deben colocarse espacios antes del signo de dos puntos a
menos que sea el primer carácter de la senda, ni tampoco entre el signo de
dos puntos y los subsiguientes nombres de fichero y directorio de la senda.
Usado en solitario, el signo de dos puntos representa el directorio raíz del
volumen actual. A continuación se ponen algunos ejemplos de usos legales del
signo de dos puntos:

  1.SYS> DIR DEVS:

  1.SYS> DF0:Dibujos

  1.Workbench:Utilities> :Prefs

  1.SYS:Tools> :


Barra inclinada (/)

La barra inclinada se usa en las sendas para separar los nombres de
directorios y fichero. Por ejemplo:

  1.Archivos:> LIST Informes/1994/Junio

Los tres niveles de directorios están separados con barras inclinadas; este
ejemplo ofrece un listado del subdirectorio Junio.

Si teclea simplemente una barra inclinada, subirá un nivel por la estructura
de directorios. Por ejemplo, si el directorio actual es Informes/1994/Junio
y teclea:

  1.Archivos:Informes/1994/Junio> CD /

el directorio actual será ahora Informes/1994. Usando dos barras inclinadas
subirá dos niveles, etcétera.


Comillas (")

Las comillas por sí mismas no tienen ningún significado especial. Sin
embargo, en alguna ocasión puede necesitar un par de comillas para indicar
correctamente un argumento para que un comando actúe correctamente. Dado
que el AmigaDOS usa espacios para separar argumentos, deberá indicar entre
comillas los argumentos que contengan espacios para hacer que Shell los
interprete correctamente. Por ejemplo, lo siguiente es incorrecto:

  1.Workbench:Tools> COPY Ram Disk:Suma TO SYS:OtroDirectorio

Esta orden produce un mensaje de error, ya que hay un espacio en la senda.
El comando indica que hay dos objetos que copiar, cuando la intención es
copiar sólo uno. Indicando la senda entre comillas, ésta será tratada como
un único argumento:

  1.Workbench:Tools> COPY "Ram Disk:Suma" TO SYS:OtroDirectorio

El uso de un par de comillas sin nada entre ellas es una forma rápida de
hacer referencia al directorio actual. Por ejemplo:

  1.SYS:Libs> COPY DF0:Librería TO ""

Esta orden copia el fichero Librería del volumen insertado en la unidad DF0:
al directorio Libs del disco de arranque.


Signo de suma (+)

El signo de suma, cuando se introduce con el comando @{"RUN" link run}, concatena varios
comandos introducidos en líneas consecutivas en la línea de comando.


Signo de interrogación (?)

Uno de los usos especiales del signo de interrogación es el muestreo de la
sintaxis de un comando. La sintaxis ("template" en el inglés original) actúa
como recordatorio de la forma de usar los argumentos del comando. Para
mostrar la sintaxis de un comando concreto, introduzca el nombre del comando
seguido por un espacio y el signo de interrogación, sin ningún otro
argumento:

  1.SYS:S> TYPE ?
  FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S:

Shell muestra la sintaxis correcta. También le invita a introducir los
argumentos del comando que ha introducido. Indique los argumentos del
comando después del signo de dos puntos. Asegúrese de introducir sólo los
argumentos y palabras clave necesarios antes de pulsar Return.

@endnode

@NODE UsoDeComodines "Uso de comodines"

USO DE COMODINES

Puede trabajar con varios ficheros o directorios utilizando un sólo comando
usando comodines. Los caracteres comodín se usan en los argumentos del
comando para hacer referencia a otros caracteres de los nombres de fichero.
Por ejemplo, use un carácter comodín en un sólo comando para copiar y
renombrar todos los ficheros cuyos nombres empiecen por una letra
determinada, que terminen con la misma extensión o que residan en el mismo
directorio.
@endnode

@NODE CaracteresComodín "Caracteres comodín"

CARACTERES COMODÍN

La siguiente lista le muestra todos los caracteres comodín y la función de
cada uno. En esta lista, <cadena> significa que el comodín hará uso de la
cadena <cadena>, que deberá tener un mínimo de un carácter de largo y que
deberá estar adyacente al comodín. Para aludir a un carácter que normalmente
actúa como comodín, debe utilizar el apóstrofe (') para desactivar su
función especial. Por ejemplo, '? alude a ?, y '' (dos apóstrofes seguidos)
aluden a '.

  ?				Alude a cualquier carácter (uno solamente)

  #<cadena>			Alude a cero o más encuentros de <cadena>

  <cadena1>|<cadena2>		Alude a cualquier ocurrencia de <cadena1> o
				<cadena2>

  ~<cadena>			Alude a todo excepto a <cadena>

  (<cadena1><cadena2>...)	Los paréntesis agrupan varias cosas juntas

  [<carácter1>-<carácter2>]	Los corchetes delimitan una gama de
				caracteres

  %				Alude a una cadena vacía (cero caracteres)

  '<comodín>			Cuando <comodín> es, efectivamente, un
				comodín, alude a ese comodín

Los siguientes ejemplos muestran las cadenas aludidas por la entrada
indicada a la izquierda:

  A?B				Alude a cualquier nombre de tres caracteres
				que comience por A y que termine por B, como
				AcB, AzB o a3b

  A#BC				Alude a cualquier nombre que comience por A,
				que termine en C y que tenga por medio
				cualquier número de Bs, como AC, ABC, ABBC
				o ABBBC

  ABC#?				Alude a cualquier nombre que comience por
				ABC, sin importar el resto, como ABCD,
				ABCDEF.info o ABCXYZ

  #?XYZ				Alude a cualquier nombre que termine en
				XYZ, sin importar lo que anteceda a estos
				tres caracteres, como ABCXYZ y ABCDEFXYZ

  A(B|C)D			Alude a ABD y a ACD

  ~(XYZ)			Alude a todo excepto a XYZ

  ~(#?XYZ)			Alude a todos los nombres que no terminen
				en XYZ

  A#(BC)			Alude a cualquier nombre que comience por
				A y que luego tenga cualquier número de
				combinaciones BC, como ABC, ABCBC o
                                ABCBCbcBCbc

  A(B|D|%)#C			Alude a ABC, ADC, AC (% representa una
				cadena nula), ABCC, ADCC, ACCC, etcétera

  [A-D]#?			Alude a cualquier nombre que comience por
				A, B, C o D

  #?XYZ'?			Alude a cualquier nombre que termine en
				XYZ?

La combinación de comodines #? alude a cualquier carácter, y es la utilizada
más a menudo. #? es equivalente al comodín * utilizado por otros sistemas
informáticos. Por ejemplo, para borrar todos los ficheros .info del
directorio Dibujos, teclee:

  1.Archivos:> DELETE Dibujos/#?.info

ATENCIÓN: Tenga cuidado de no borrar el contenido completo de un disco al
          usar #?.

@endnode

@NODE Redirección

REDIRECCIÓN

La redirección puede cambiar la entrada o la salida hacia un fichero o
dispositivo específico (como una impresora, un módem o un dispositivo
lógico). Al trabajar con Shell, el teclado es la fuente de entrada de
comandos, y la ventana Shell actual es el destino de la salida. Puede
redirigir la entrada y la salida utilizando los corchetes < > y el
asterisco (*).
@endnode

@NODE CorchetesAngulares "Corchetes angulares"

CORCHETES ANGULARES

Un argumento de redirección consiste en usar los símbolos < y > seguidos por
un nombre de fichero o de dispositivo. El corchete angular debe ir precedido
por un espacio, pero no se necesita un espacio después del mismo.

Con algunos comandos, los caracteres de redirección pueden sustituir a
las palabras clave TO y FROM, dependiendo de la sintaxis del comando en
particular.

Sólo puede redirigir la entrada o salida en la línea de comando en la que
ha introducido los caracteres de redirección. El AmigaDOS aplica de nuevo
las fuentes de entrada y salida por defecto en los comandos utilizados
después que no usen redirección.


Corchete angular a derecha (>)

El corchete angular a derecha redirige la salida de consola de un comando
hacia el destino indicado por el corchete. La salida de consola es el texto
que el comando emite como resultado en la ventana Shell al ser ejecutado.
Por ejemplo, la línea

  1.Notas:> DIR >Prueba DF0:

envía la lista del directorio de DF0: a un fichero del directorio actual
llamado Prueba. El fichero Prueba se crea si aún no existe, y contendrá el
listado del directorio en forma de texto ASCII. Este listado no se mostrará
en la pantalla.

Sólo la salida de consola de un comando es redirigida, NO la información con
la que el comando trabaja. Por ejemplo, la línea

  1.Dibujos:> COPY >Log PicDir TO ArchivoPics: ALL

copia todos los ficheros del directorio PicDir al disco ArchivoPics,
enviando una lista con los nombres de los ficheros copiados al fichero Log.


Corchete angulado a izquierda (<)

Para cambiar la fuente de entrada de información de un comando por un
fichero en lugar del teclado, use el símbolo <. Sin embargo, recuerde que
deberá usar un signo de interrogación (?) como un argumento aparte en la
línea de comando. El signo de interrogación ordena al comando que acepte
la entrada; en este contexto, no se comporta como un carácter comodín. El
siguiente ejemplo crea un fichero y luego usa su contenido como argumento
para un comando:

  1.Workbench:> ECHO Mañana TO Fecha

  1.Workbench:> DATE ? <Fecha

El comando ECHO crea un fichero llamado Fecha que contiene la palabra
"Mañana". El comando DATE acepta el contenido del fichero Fecha (la
palabra "Mañana") como si se hubiese tecleado en ese momento. Esta orden
adelantaría el reloj del sistema 24 horas.


Doble corchete angulado a derecha (>>)

Puede redirigir la salida y añadir información a un fichero ya existente
usando dos símbolos de salida (>>) sin espacios entre ambos. Por ejemplo,

  1.Disco1> Postscript >>Laser/Carta

ejecuta el programa Postscript y añade la salida al final del fichero Laser/
Carta.


Asterisco (*)

Un asterisco hace referencia a la ventana Shell actual. Sin embargo, para
evitar confusión con otros usos del asterisco, le recomendamos que use
CONSOLE:, que es un sinónimo de *. El asterisco puede utilizarse como
argumento TO o FROM o como un nombre de fichero que acepta la redirección
(actuando como fuente de entrada o como destino de la salida).

Pulsando Ctrl+\ se restauran la entrada y la salida a su estado normal. Por
ejemplo:

  1.> COPY * TO Notas

  o

  1.> COPY CONSOLE: TO Notas

copia todo el texto introducido a continuación en la ventana actual al
fichero llamado Notas hasta que pulse Ctrl+\.

La combinación Ctrl+\ también se utiliza para cerrar una ventana Shell.
Tenga cuidado de no pulsar esta combinación de teclas dos veces cuando sólo
quiera finalizar el uso de la redirección, ya que en ese caso cerraría la
ventana Shell.

@endnode

@NODE EjecutandoProgramas "Ejecutando programas"

EJECUTANDO PROGRAMAS
--------------------

La mayor parte de los programas pueden ejecutarse tanto desde el Workbench
como desde Shell. Para ejecutar un programa desde Shell, normalmente tendrá
que introducir su nombre en el prompt del Shell (si el programa no está
dentro de la senda de búsqueda, deberá especificar la senda completa para
llamar al programa). Esta orden le dice al AmigaDOS que cargue y ejecute el
programa.

La mayor parte de los programas le permiten especificar información
adicional en la línea de comando después del nombre del programa, como el
nombre de un fichero a cargar o bien opciones de arranque. Estas partes
adicionales se consideran sus argumentos. Acuda a la documentación que
acompañe al programa para saber los argumentos que admite y cómo deberán
ser introducidos.

Por ejemplo:

  1.> MEmacs

carga y ejecuta el editor MEmacs. Añadiendo un argumento:

  1.> MEmacs S:User-startup

cargará y ejecutará MEmacs, abriendo de forma automática el fichero User-
startup del directorio S: como el fichero a comenzar a editar.

  1.> CLOCK WIDTH 200 HEIGHT 100 SECONDS

carga el reloj con un tamaño de 200 por 100 pixels, y con la opción del
segundero activada.

A menudo esta característica de pase de argumentos se ofrece para la
comodidad del usuario, ya que le permite indicar directamente en la línea
de comando lo que de otra forma tal vez necesitase de varias operaciones
con los menús. Sin embargo, muchos programas, especialmente aquellos que
sólo pueden ejecutarse desde Shell, necesitan como condición indispensable
que se indiquen nombres de fichero u otros argumentos en la línea de
comando junto con el nombre del programa.

@endnode

@NODE RunBack "Ejecutar programas en segundo plano"

EJECUTANDO PROGRAMAS EN SEGUNDO PLANO (BACKGROUND)

Otra forma de introducir el nombre de un programa es mediante el comando RUN.
RUN carga y ejecuta un programa en segundo plano. El prompt del Shell vuelve
a aparecer una vez que el programa se ha abierto.

Por ejemplo, introduciendo:

  1.> MEmacs

se abrirá el editor MEmacs, pero no podrá introducir más comandos ni cerrar
la ventana Shell hasta que haya abandonado MEmacs.

Sin embargo, si introduce:

  1.> RUN MEmacs

se abrirá el editor MEmacs y el prompt del Shell volverá a aparecer para que
pueda introducir comandos adicionales.

Cuando un programa es invocado con RUN, automáticamente se asigna un nombre
de proceso al mismo, y aparece un mensaje indicando el nuevo número de
proceso, por ejemplo "[CLI 2]".

Cualquier salida que el programa genere aparecerá en la ventana Shell que
lo haya originado.

No podrá cerrar la ventana Shell mientras esté abierto cualquier programa
lanzado desde la misma. Por ejemplo, si abre MEmacs mediante Shell, no
podrá cerrar la ventana Shell hasta que salga de MEmacs. Puede evitar este
problema usando el dispositivo NIL:. Mire el capítulo 8 para ver un @{"ejemplo" link TrabajaConShellCaray 20}.
@endnode

@NODE ModificaEntornoCLI "Modificación del entorno AmigaDOS"

MODIFICACIÓN DEL ENTORNO AmigaDOS
---------------------------------

Los siguientes consejos le ayudarán a configurar el entorno AmigaDOS para
que se ajuste a sus necesidades particulares.

- Personalización del prompt del Shell

  El cambio del color, por ejemplo, de la cadena de texto que forma el
  prompt mediante secuencias de Escape hace que éste pueda distinguirse más
  fácilmente del resto de la línea de comando y de la salida que produzca
  el comando. Esto le ayudará a estar más al tanto del número de proceso y
  del directorio actual, que normalmente son parte del prompt. Para más
  información sobre cómo cambiar el prompt del Shell, mire el comando
  @{"PROMPT" link prompt} en el capítulo 6 y el @{"ejemplo" link CambiaElPrompt} del capítulo 8.

- Cree una estructura de directorios lógica y use nombres adecuados

  Dado que para encontrar algo hace falta saber dónde está, debería
  organizar sus discos y directorios de una forma lógica, con nombres que
  indiquen su contenido. Sin embargo, tampoco vaya a crear estructuras de
  directorios que estén demasiado anidadas sin tener una buena razón para
  ello.

- Evite usar espacios y otros caracteres especiales en los nombres

  Los caracteres que tienen un significado especial para el AmigaDOS, como
  son "#" y "~", están permitidos en los nombres, pero pueden producir
  problemas cuando se usan en la línea de comando. Use un punto (.), un
  signo de subrayado (_) o letras mayúsculas en lugar de espacios para
  separar las palabras de un nombre: "Fichero.Anim", "Fichero_Anim" o
  "FicheroAnim" en lugar de "Fichero Anim".

- Nombre de forma similar a los ficheros que guarden relación

  Dando a los ficheros relacionados entre sí una extensión común o un
  número secuencial, se simplifica el uso de patrones a la hora de utilizar
  estos ficheros.

- Use nombres asignados en las sendas

  Los nombres asignados le permiten teclear un nombre más corto y fácil de
  recordar que si usase una senda completa. Por ejemplo, es más rápido
  teclear ENVARC: que SYS:Prefs/Env-Archive. Use sus propios nombres
  asignados para los directorios que use a menudo y para alcanzar
  rápidamente directorios que se encuentren profundamente anidados.

- Extienda la senda de búsqueda

  Si tiene varios comandos o programas que usa a menudo, añadiendo sus
  directorios a la senda de búsqueda con PATH o ASSIGN podrá acceder a
  ellos más fácilmente.

- Experimente

  La mejor forma de aprender la forma en la que funciona el AmigaDOS es
  experimentar. Siempre que tenga cuidado con comandos potencialmente
  destructivos, como un DELETE con uso de patrones, puede experimentar
  libremente.

@endnode

@NODE editors "Uso de los editores"

				  Capítulo 4


			     USO DE LOS EDITORES
			     ===================


Un editor de texto o programa de proceso de textos es necesario para crear
o editar ficheros de texto y ficheros script. Entre los programas del
entorno Workbench del Amiga se incluyen tres editores de texto. Este
capítulo los describe en el siguiente orden:

                                   @{"   ED   " link MiraED}

                                   @{" MEmacs " link MEmacs}

                                   @{"  EDIT  " link MiraEDIT}

Cada editor del Amiga puede utilizarse por separado para editar scripts y
programas AmigaDOS; ED y MEmacs pueden usarse para editar estos ficheros. Si
le resulta cómodo usar el editor Emacs de los sistemas UNIX, posiblemente
prefiera utilizar el editor MEmacs. Si necesita editar ficheros que
contienen código binario o que son demasiado grandes para caber enteros en
la memoria, use EDIT. Si no ha usado nunca ninguno de los editores, le
recomendamos que use el editor ED.

Cada editor tiene las funciones básicas de un procesador de textos. Sin
embargo, ninguno de estos editores soporta opciones relacionadas con el
cambio de fuentes de texto, como son el uso de itálicas, numeración de
páginas, etcétera. Si necesita estas funciones, puede adquirir un programa
de proceso de textos que contenga estas funciones para su Amiga.

@endnode

@NODE MiraED "ED"

ED
--

ED es un editor de texto ASCII que dispone de menús y teclas de función para 
acceder a sus funciones. Es fácil de usar y resulta adecuado para editar
scripts, ficheros de arranque, @{"MountLists" link UsoDeMountlist} y otros ficheros de texto.
Puede usar el ratón o el teclado para realizar operaciones con ED. A pesar
de que los menús de ED están ya programados, cuando tenga un cierto nivel
de experiencia con ED podrá configurarlos como le sea necesario.

NOTA: ED no acepta ficheros que contengan código binario. Para editar este
      tipo de ficheros, use EDIT o MEmacs.

La línea inferior de la ventana ED es la línea de estado que se utiliza para
mostrar mensajes, prompts y comandos. Los mensajes de error mostrados en la
línea de estado permanecen allí hasta que introduce otro comando para ED.

El formato para llamar a ED desde Shell es el siguiente:

  ED [FROM] <NombreFichero> [SIZE <n>] [WITH <NombreFichero>] [WINDOW
    <EspecificaciónDeVentana>] [TABS <n>] [WIDTH|COLS <n>] [HEIGHT|ROWS <n>]

El argumento FROM indica el fichero fuente que se va a editar. Este
argumento es imprescindible, pero la palabra clave FROM es opcional.

El argumento SIZE cambia el tamaño del buffer de ED. ED usa por defecto
un buffer de 40000 bytes. Por ejemplo,

  1.> ED Script SIZE 55000

incrementa el tamaño del buffer hasta 55000 bytes.

El argumento WITH indica un fichero de comandos para ED que puede contener
cualquier secuencia de comandos en modo extendido de ED. Cuando se indica
WITH, ED ejecuta los comandos contenidos en el fichero de comandos. Para
hacer uso de un fichero de este tipo, deberá emplear la palabra clave WITH.

El argumento WINDOW especifica el tipo de consola, como RAW:0/0/640/256/
VentanaED o CONSOLE:. Deberá indicar la palabra clave WINDOW para usar
esta opción.

TABS ajusta el intervalo de parada del tabulador, es decir, el número de
espacios que se saltará el cursor cada vez que pulse la tecla del tabulador.
El valor por defecto de TABS es 3.

Los argumentos WIDTH y HEIGHT ajustan el tamaño de la ventana ED indicando
el número de caracteres a mostrar en horizontal y vertical, respectivamente.
Por defecto, la ventana ED es de 640 * 200 pixels, lo que equivale
aproximadamente a 88 caracteres de ancho por 21 líneas de alto.

@endnode

@NODE  EjecutandoED "Ejecutando ED"

EJECUTANDO ED

Ejecute ED desde Shell o con la opción "Ejecutar comando" del menú
Workbench. Puede abrir ED desde Shell tecleando ED y un nombre de fichero
nuevo o ya existente, como por ejemplo:

  1.> ED <fichero>

donde <fichero> es el nombre de un fichero existente o de un nuevo fichero
que quiera usar para grabar su trabajo. Si el nombre del fichero indicado
no puede encontrarse en el directorio actual, ED abrirá una línea en blanco
mostrando el mensaje "Creating new file" ("Creando un nuevo fichero").
@endnode

@NODE UsandoED "Usando ED"

USANDO ED

Todos los comandos de ED tienen combinaciones de teclas y muchos están
disponibles en los menús. Puede introducir comandos en ED de las dos
formas siguientes:

  1. Eligiendo la opción de menú que equivale al comando.

  2. Tecleando la combinación de teclas que activa el comando y pulsando
     Return.

Además, puede usar el ratón para ejecutar algunos comandos, como los que
controlan el movimiento del cursor.

Puede trabajar en los ficheros con ED con los dos modos de comando
siguientes:

  Inmediato		Los comandos son ejecutados en cuanto son tecleados.
			ED abre su ventana en modo inmediato.

  Extendido		Los comandos no se ejecutan hasta que pulsa Return
 			o Esc.

@endnode

@NODE ComandosInmediatos "Comandos Inmediatos"

Comandos inmediatos

En modo inmediato, ED ejecuta los comandos de forma instantánea. Llame al
comando inmediato pulsando una sola tecla o una combinación Ctrl+tecla, o
bien usando el ratón. Todos los comandos inmediatos tienen sus
correspondientes versiones en el modo extendido.

Los comandos inmediatos controlan lo siguiente:

                             @{" Movimiento del cursor " link MueveCursorInm}

                              Deslizamiento de texto

                             @{"  Inserción de texto   " link InsertaTextoIn}

                             @{"   Borrado de texto    " link BorraTextoIn}

                              Repetición de comandos
@endnode

@NODE MueveCursorInm "Moviendo el cursor en modo inmediato"

Movimiento del cursor en modo inmediato

El cursor puede colocarse en cualquier parte del texto llevando el puntero
al lugar deseado y pulsando el botón de selección. Para mover el cursor con
el teclado, use las flechas del cursor, la tecla del tabulador y las
combinaciones Ctrl+tecla.

NOTA: En ED, la tecla del tabulador sólo mueve el cursor; no inserta
      caracteres de tabulación ni espacios en una línea.

Puede mover el cursor un espacio hacia cualquier dirección con la tecla
apropiada del cursor. Si el cursor está en el borde derecho de la pantalla,
ED mueve el texto hacia la izquierda para mostrar el resto de la línea. ED
mueve el texto verticalmente una línea cada vez, y horizontalmente diez
caracteres cada vez. No puede llevar el cursor más allá del borde izquierdo
de la línea. Además, si intenta llevar el cursor más allá de los bordes
superior o inferior del fichero, ED mostrará el mensaje "Top of file" o
"Bottom of file", respectivamente.

Otras combinaciones de teclas que controlan el movimiento del cursor son:

  Mayúsculas + flecha arriba		Comienzo del fichero

  Mayúsculas + flecha abajo		Final del fichero

  Mayúsculas + flecha izquierda		Borde izquierdo de la ventana de ED
                                        (sin importar el margen)

  Mayúsculas + flecha derecha		Final de la línea actual

  Ctrl + ]				Borde derecho de la línea actual (si
                                        el cursor ya estaba allí, se situará
                                        en el borde izquierdo)

  Ctrl + E				Comienzo de la primera línea visible
                                        en pantalla (si el cursor ya está
                                        allí, se colocará al final de la
                                        última línea visible)

  Ctrl + T				Comienzo de la palabra siguiente

  Ctrl + R				Espacio que sigue a la palabra
                                        siguiente

  Tabulador				La posición siguiente del tabulador
                                        (múltiplo del valor ajustado del
                                        tabulador; el valor por defecto es 3)

Si el fichero tiene más líneas que las que puede albergar la ventana ED,
podrá moverse por el fichero verticalmente. Mueva una línea cada vez
pulsando la tecla de cursor arriba o abajo para deslizar el texto en esa
dirección. También puede mover el texto con saltos más grandes pulsando:

  Ctrl + D				El texto salta 12 líneas hacia
                                        adelante

  Ctrl + U				El texto salta 12 líneas hacia
                                        atrás

Estos comandos no cambian la posición del cursor en la ventana; simplemente
redibujan el texto en la ventana con la nueva línea en la posición del
cursor.

Si algo molesto aparece en la pantalla, como una alerta de otro programa
que aparece en la ventana ED o mensajes en la línea de estado, pulse:

  Ctrl + V				Refresca la visualización de la
                                        ventana

@endnode

@NODE InsertaTextoIn "Inserción de texto en modo inmediato"

Inserción de texto en modo inmediato

Los caracteres tecleados en modo inmediato se insertan en la posición actual
del cursor, mientras éste se desplaza hacia la derecha. Los caracteres que
se encuentran a la derecha del cursor también se desplazan para hacer
espacio para el nuevo texto. Si la línea es más ancha que el ancho de la
ventana, la ventana se deslizará hacia la derecha para mostrar lo que está
tecleando. Si lleva el cursor más allá del final de la línea, ED insertará
espacios entre el final de la línea y los nuevos caracteres que se inserten.

El límite de caracteres máximo de una línea es de 255. Si añade más
caracteres, ED mostrará el mensaje "Line too long".

Para dividir la línea actual por la posición del cursor, pulse Return. El
texto que se encuentre a la izquierda del cursor permanecerá en su lugar
original, mientras que el texto que se encuentre debajo y a la derecha del
cursor se moverá hacia abajo una línea. Pulsando Return al final de una
línea creará una línea en blanco.
@endnode

@NODE BorraTextoIn "Borrado de texto en modo inmediato"

Borrado de texto en modo inmediato

ED no tiene un modo de inserción que permita borrar los caracteres tecleando
otros encima. Para sustituir una palabra o una línea, deberá borrar las
palabras existentes e insertar después la nueva información con las
siguientes teclas y combinaciones de teclas:

  Borrar (Retroceso)		Borra el carácter que se encuentra a la
                                izquierda del cursor

  Del				Borra el carácter destacado por el cursor

  Ctrl + O			Si el cursor se encuentra sobre un espacio
                                en blanco, todos los espacios hasta el
                                siguiente carácter serán borrados. Si el
                                cursor está sobre un carácter, entonces se
                                borrarán todos los caracteres hasta el
                                siguiente espacio

  Ctrl + Y                      Borra todos los caracteres desde el cursor
                                hasta el final de la línea

Cuando se borra texto, los caracteres que quedan en la línea se mueven hacia
la izquierda y el texto que había más allá del borde derecho de la pantalla
se hace visible.

@endnode

@NODE CaseIn "Cambiando a mayúsculas/minúsculas en modo inmediato"

Cambiando a mayúsculas/minúsculas en modo inmediato

Puede cambiar el texto a mayúsculas o a minúsculas colocando el cursor
y pulsando Ctrl+F. Si la letra es minúscula, se vuelve mayúscula, y
viceversa. La combinación Ctrl+F no cambia los símbolos o caracteres no
alfabéticos.

Después de pulsar Ctrl+F, el cursor se mueve una posición a la derecha.
Puede mantener pulsadas estas dos teclas para usar el comando de forma
continuada hasta cambiar todas las letras de la línea.
@endnode

@NODE ComandosExtendidos "Comandos extendidos"

Comandos extendidos

En modo extendido, los comandos se muestran en la línea de comando -o línea
de estado- en la parte inferior de la ventana. ED no ejecuta estos comandos
hasta que pulse Return o Esc. Si usa Esc para ejecutar comandos extendidos,
ED sigue después estando en modo extendido. En cambio, si usa Return para
ejecutar comandos extendidos, ED vuelve luego al modo inmediato.

Los comandos extendidos manejan lo siguiente:

- Control del programa

- Movimiento del cursor

- Modificación del texto

- Control de bloque

- Búsqueda y cambio de texto

Para entrar en el modo extendido, pulse Esc. Aparecerá un asterisco como
prompt en la línea de estado. Los comandos extendidos consisten en uno ó
dos caracteres. Pueden teclearse varios comandos extendidos en una sola
línea de comando separándolos con un signo de dos puntos. Los comandos
pueden agruparse juntos para que ED los repita automáticamente. Use la
tecla Retroceso para corregir los errores.

También puede ejecutar comandos mediante los menús programables y las
teclas de función. Puede modificar la configuración de los menús y las
teclas de función asignando un comando a la tecla u opción de menú que
quiera tal como se describe en el apartado @{" PERSONALIZACIÓN DE ED " link PersonalizaED}.

@endnode

@NODE UsandoDelimit "Usando delimitadores de cadena"

Usando delimitadores de cadena

En algunos casos, los comandos necesitan argumentos, como puede ser un
número o una cadena de texto. Los argumentos de cadena para los comandos de
ED deben indicarse dentro de un par de caracteres delimitadores idénticos.
Los delimitadores válidos son ("), (/), (\), (!), (:), (+), (-) y (%). No
puede usar el mismo carácter delimitador dentro de la cadena de texto.
Los caracteres no considerados como delimitadores válidos son letras,
números, espacios, signo de punto y coma (;), signos de interrogración
(¿ y ?), corchetes y caracteres de control.
@endnode


@NODE UsandoRequesterFic "Usando un requester de ficheros"

Usando un requester de ficheros

También puede pedirle a ED que use un requester de ficheros, que le
permitirá ver el contenido de los drives y directorios de su sistema.

Para invocar un requester de ficheros para un comando de carga o grabación,
deberá colocar un signo de interrogación (?) antes del argumento de cadena
que use. Asegúrese de incluir un espacio antes del signo de interrogación
(por ejemplo, "sa ?/Texto/"). Normalmente, cuando un comando va seguido por
una cadena, ED trata la cadena como el fichero a cargar o grabar, e
intentará realizar la operación inmediatamente. Sin embargo, el signo de
interrogación indica que quiere especificar el fichero mediante un requester
de ficheros. Aún así deberá indicar una cadena de texto después del signo
de interrogación, pero en este caso la cadena será el texto que aparezca en
la barra de título del requester.
@endnode

@NODE EDMenus "Los menús de ED"

MENÚS DE ED

ED tiene dos conjuntos de asignaciones de los comandos de menú: por defecto
y expandidas. Las asignaciones de menú por defecto están configuradas por el
fichero S:Ed-startup, que se ejecuta automáticamente cada vez que ejecuta
ED. El fichero S:Ed-startup es un fichero de comandos que contiene comandos
en modo extendido de ED, sin caracteres de Escape. Puede editar este
fichero para configurar unos menús diferentes, como se describe en el
apartado @{" Personalización de ED " link PersonalizaED}, o definir otras asignaciones preprogramadas
para las teclas de función con la opción de menú "Set FN Key".
@endnode

@NODE MenúsExpandidos "Habilitando menús expandidos"

Habilitando menús expandidos

Las asignaciones expandidas de comandos de menú pueden activarse cambiando
de nombre o borrando el fichero S:Ed-startup que se utiliza por defecto. Si
ED no puede encontrar el fichero S:Ed-startup, abrirá su conjunto de menús
expandidos, ofreciendo más opciones.

En lugar de borrar su fichero S:Ed-startup, le recomendamos que lo cambie
de nombre de la forma siguiente:

1. En la ventana del Workbench, abra el menú Ventana y elija la opción
   "Mostrar/Todos los ficheros".

2. Pulse dos veces sobre el nombre del cajón S.

3. Pulse una vez sobre el icono Ed-startup.

4. Vaya al menú Iconos y elija la opción Renombrar.

5. Borre el nombre que aparece en el gadget de texto de la opción Renombrar
   e introduzca un nuevo nombre para Ed-startup.

6. Seleccione OK o pulse Return.

También puede crear su propio fichero personalizado con opciones de
arranque. Evite incluir comandos de tipo Quit en el fichero S:Ed-startup,
ya que obligarían a ED a salir inmediatamente al abrir el fichero.

Las opciones de los menús tanto por defecto como expandido tienen la misma
función, sin importar el conjunto que utilice. Todos los comandos de ED
están disponibles desde el teclado usando los comandos en modo extendido
a pesar de que éstos no aparezcan en ningún menú.

Las siguientes secciones describen las opciones de menú contenidas en los
menús expandidos y sus correspondientes comandos en modo extendido e
inmediato. Si aparecen tres puntos (...), ello quiere decir que se necesita
un argumento o que esa opción de menú abre un requester o prompt.

@endnode

@NODE MenúProject "Menú Project"

Menú Project

A continuación se listan las opciones del menú expandido Project:

  New			Esc,N,W		Crea un nuevo fichero, sustituyendo
                                        el fichero existente. Se mostrará
                                        el mensaje "Edits will be lost-type
                                        Y to confirm:". Pulse cualquier
                                        tecla (excepto Y) para anular la
                                        orden.

  Open...		Esc,O,P...	Abre un fichero. Deberá indicar el
                                        fichero introduciendo la senda
                                        completa para el fichero con una
                                        cadena de texto correctamente
                                        delimitada (si aparecen barras
                                        inclinadas en la senda, no use la
                                        barra inclinada como delimitador).
                                        Aparecerá el mensaje "Edits will be
                                        lost-type Y to confirm:" para
                                        recordarle que va a sustituir
                                        el fichero actual.

  Insert File...	Esc,I,F...      Inserta un fichero en el fichero
                                        actual. ED lee a la memoria el
                                        fichero indicado en el punto que
                                        sigue inmediatamente a la línea
                                        actual.

  Write Block...	Esc,W,B...	Escribe el bloque marcado
                                        actualmente en un fichero. ED
                                        sobreescribe cualquier otro fichero
                                        que tenga el nombre introducido y
                                        copia el bloque en ese fichero.

  Save			Esc,S,A		Salva el texto en el fichero actual,
                                        sobreescribiendo el texto existente
                                        en el fichero. Use "Save As" si
                                        quiere grabar el texto en otro
                                        fichero. SA seguido por Q equivale
                                        al comando X.

  Save As...		Esc,S,A...	Salva el texto en el fichero que se
                                        indique.

  Save & Exit		Esc,X		Abandona ED, grabando el fichero
                                        actual en el fichero indicado. ED
                                        escribe el texto al fichero que
                                        abrió al principio de la sesión y
                                        luego abandona el sistema.

  About			Esc,S,H		Muestra el estado actual del editor.
                                        La pantalla muestra información como
                                        el valor de salto del tabulador, los
                                        márgenes, las marcas de bloque y el
                                        nombre del fichero que se está
                                        editando.

  Quit			Esc,Q		Sale de ED sin grabar los cambios.
                                        Si ha realizado algún cambio en el
                                        texto, ED le preguntará si realmente
                                        quiere salir. Si pulsa Y, ED saldrá
                                        inmediatamente sin grabar los
                                        posibles cambios.

@endnode

@NODE MenúEdit "Menú Edit"

Menú Edit

Lo que sigue es una lista de los comandos utilizados en la edición:

  Undo Line		Esc,U		Anula los cambios hechos en la línea
                                        actual. Sin embargo, ED no puede
                                        recuperar una línea borrada. Además,
                                        una vez que deja la línea actual,
                                        el comando U ya no puede deshacer
                                        ningún cambio hecho a la misma.

  Start Block		Esc,B,S		Identifica el comienzo y el final
  End Block		Esc,B,E		del texto. Para indicar un bloque
                                        de texto que quiera mover, insertar
                                        o borrar, coloque el cursor en la
                                        primera línea del bloque a marcar
                                        e introduzca el comando BS. Luego
                                        lleve el cursor a la última línea
                                        del bloque a marcar e introduzca
                                        el comando BE.

                                        No puede comenzar ni terminar un
                                        bloque en medio de una línea.

  Show Block		Esc,S,B		Redibuja el texto de forma que el
                                        bloque quede en la parte superior
                                        de la pantalla.

  Insert Block		Esc,I,B		Inserta una copia del bloque después
                                        de la línea actual. El bloque
                                        permanece definido hasta que cambie
                                        el texto. Use IB para insertar
                                        varias copias del bloque por el
                                        documento.

  Delete Block		Esc,D,B		Borra un bloque.

  Delete Line		Esc,D		Borra la línea entera.
			Ctrl + B

@endnode

@NODE MenúMovement "Menú Movement"

Menú Movement

Los siguientes comandos mueven el cursor por la pantalla:

  Top			Esc,T		El principio del fichero; la primera
                                        línea del fichero aparece en la
                                        parte superior de la ventana.

  Bottom		Esc,B		El final del fichero; la última
                                        línea del fichero aparece en la
                                        parte inferior de la ventana.

  Go To Line...		Esc,M...	Lleva el cursor a la línea que se
                                        especifique. Introduzca el número de
                                        línea en la línea de estado y pulse
                                        Return. La línea indicada aparece en
                                        la parte superior de la ventana. Si
                                        no se introduce número alguno, el
                                        cursor se situará en la parte
                                        superior de la ventana.

  Next Page		Esc,P,D		Va a la página siguiente.
			Ctrl + D

  Previous Page		Esc,P,U		Va a la página anterior.
			Ctrl + U

@endnode

@NODE MenúSearch "Menú Search"

Menú Search

Los siguientes comandos le permiten buscar en el fichero una determinada
cadena de texto. Puede sustituir una determinada cadena de texto por otra
(buscar y sustituir) y hacer que ED le pida confirmación antes de realizar
esta sustitución. Si ED no encuentra la cadena indicada o si ya no la
encuentra más veces, aparecerá el mensaje "Search failed". Cuando use las
opciones de menú Find (Buscar) y Replace (Sustituir), ED pedirá las
correspondientes cadenas de texto. Introduzca este texto sin usar
delimitadores. Cuando esté en modo extendido, entonces sí tendrá que
hacer uso de los delimitadores de cadena.

  Find...		Esc,s...	Busca la siguiente aparición de la
  Find Next                             cadena de texto. La búsqueda
                                        comienza un carácter más allá de
                                        la posición actual del cursor y
                                        continúa por todo el fichero. Si ED
                                        encuentra la cadena, situará el
                                        cursor en el principio de la misma.
                                        La búsqueda diferencia las letras
                                        mayúsculas de las minúsculas, a
                                        menos que se utilice el comando
                                        Ignore Case. La opción Find Next
                                        repite el comando.

  Reverse Find...	Esc,B,F...	Busca hacia atrás por el texto la
  Reverse Find Next                     cadena de texto que se indique. Este
                                        comando busca la última aparición de
                                        la cadena de texto antes de la
                                        posición actual del cursor. La
                                        búsqueda continúa hasta el principio
                                        del fichero. La opción Reverse Find
                                        Next repite el comando.

  Replace...		Esc,E...	Cambia una aparición de la cadena
                                        de texto indicada por otra.

                                        En modo extendido, introduzca las
                                        cadenas entre delimitadores. Por
                                        ejemplo, para sustituir la palabra
                                        "Uno" por "Dos", deberá introducir
                                        "Uno"Dos". Para introducir una
                                        cadena vacía, teclee dos
                                        delimitadores sin ningún espacio
                                        entre ellos. Si la primera cadena
                                        está vacía, ED insertará la segunda
                                        cadena en la posición actual del
                                        cursor. Si la segunda cadena está
                                        vacía, ED buscará la siguiente
                                        ocasión en que aparece la primera
                                        cadena y la borrará. Fíjese en que
                                        ED ignora los ajustes de los
                                        márgenes al sustituir texto.

  Global Replace...	Esc,R,P,E...	Cambia todas las ocasiones en las
                                        que aparezca la cadena de texto
                                        indicada.

  Query-Replace...	Esc,E,Q...	Busca la cadena indicada y pide
                                        confirmación antes de cambiarla con
                                        la pregunta "Exchange?". Pulse Y
                                        para cambiarla o cualquier otra
                                        tecla para no hacerlo.

  Global Query-		Esc,R,P,E,Q...	Busca todas las ocasiones en las
  Replace...                            que aparece la cadena de texto
                                        indicada, solicitando confirmación
                                        en todos los casos. Teclee Y para
                                        realizar el cambio o cualquier otra
                                        tecla para no hacerlo.

@endnode

@NODE MenúSettings "Menú Settings"

Menú Settings

Los siguientes comandos se usan para configurar su entorno ED:

  Set FN Key...		Esc,S,F...	Define las teclas de función y otras
                                        teclas programables. Definir una
                                        tecla de función o un comando Ctrl+
                                        tecla es semejante a definir
                                        opciones de menú. Mire más adelante
                                        el apartado @{"Set FN Key" link SetFNKey} para ver
                                        algunas intrucciones sobre cómo
                                        definir teclas de función y un
                                        ejemplo del comando @{"Set FN Key" link SetFNKey}.

  Show FN Key...	Esc,D,F <tecla> Muestra el ajuste actual de la tecla
                                        de función <tecla>. Introduzca un
                                        espacio y número de slot para
                                        <tecla>.

  Reset Keys		Esc,R,K		Devuelve las definiciones de las
                                        teclas a su valor por defecto. Mire
                                        el apartado dedicado a la función
                                        @{"Set FN Key" link SetFNKey 32} para ver una tabla con
                                        el mapa de teclas especiales.

  Right Margin...	Esc,S,R...	Ajusta el margen derecho. Use el
                                        comando SR seguido por un número
                                        para indicar la posición de la
                                        columna.

  Left Margin...	Esc,S,L...	Ajusta el margen izquierdo. Use el
                                        comando SL seguido por un número
                                        para indicar la posición de la
                                        columna. El margen izquierdo no
                                        debería pasar del borde derecho de
                                        la pantalla.

  Ignore Case		Esc,U,C		Especifica una búsqueda indiferente
                                        a mayúsculas y minúsculas. UC hace
                                        que todas las búsquedas que se hagan
                                        posteriormente no hagan distinción
                                        entre el texto en minúsculas y el
                                        texto en mayúsculas. Para hacer que
                                        las búsquedas sean otra vez
                                        sensibles a esta diferencia, use
                                        el comando LC.

  Case Sensitive	Esc,L,C		Especifica una búsqueda que
                                        distingue las minúsculas de las
                                        mayúsculas.

@endnode

@NODE SetFNKey "Ajuste de las teclas de función"

Set FN Key

La opción Set FN Key se utiliza para definir las teclas de función y otras
teclas programables. Hay 57 slots de teclas de comandos inmediatos, de 1 a
57. Cualquier número de slot puede ser redefinido y cualquier número de esa
gama que no aparezca en la tabla mostrada más adelante no está definido.

A continuación presentamos la sintaxis para el comando Set FN Key:

  SF <número de slot> /texto del comando/

Puede definir combinaciones Ctrl+tecla usando el signo ^ en la definición
del número de slot.


Script de ejemplo

Este script de ejemplo asigna teclas de función a los comandos de control
del cursor. También puede introducir esto como una serie de comandos en modo
extendido. Los comados "Top of File", "Bottom of File", "End of Page", "Next
Page", "Next Line" y "Previous Line" se asignan a las teclas F1-F6,
respectivamente. Se usan las comillas como delimitador.

  SF 1 "t"
  SF 2 "b"
  SF 3 "ep"
  SF 4 "pd"
  SF 5 "n"
  SF 6 "p"


Mapa de las teclas especiales

La siguiente tabla muestra las definiciones que se usan por defecto al usar
el comando "Reset Keys":

-----------------------------------------------------------------------------
Slot	Tecla/Combinación de teclas	Función
-----------------------------------------------------------------------------

1-10	De F1 a F10			No definida

11-20	Mayúsculas+F1 - Mayúsculas+F10	No definida

21	Mayúsculas+Flecha izquierda	Ir al comienzo de la línea

22	Mayúsculas+Flecha derecha	Ir al final de la línea

23	Mayúsculas+Flecha arriba	Ir al comienzo del documento

24	Mayúsculas+Flecha abajo		Ir al final del documento

25	Del				Borrar el carácter destacado por el
                                        cursor

26	No definida			No definida

27	Ctrl + A			Insertar línea

28	Ctrl + B			Borrar línea

29	Ctrl + C			No definida

30	Ctrl + D			Ir hacia abajo 12 líneas

31	Ctrl + E			Ir hacia la parte superior o
                                        inferior de la pantalla

32	Ctrl + F			Cambio a mayúsculas o a minúsculas

33	Ctrl + G			Repite la última línea de comando
                                        extendido

34	Ctrl + H			Borrar el carácter situado a la
                                        izquierda del cursor

35	Ctrl + I			Llevar el cursor a la siguiente
                                        posición del tabulador

36	Ctrl + J			No definida

37	Ctrl + K			No definida

38	Ctrl + L			No definida

39	Ctrl + M			Return

40	Ctrl + N			No definida

41	Ctrl + O			Borrar palabra o espacios

42	Ctrl + P			No definida

43	Ctrl + Q			No definida

44	Ctrl + R			Ir al final de la palabra anterior

45	Ctrl + S			No definida

46	Ctrl + T			Ir al comienzo de la próxima palabra

47	Ctrl + U			Ir hacia arriba 12 líneas

48	Ctrl + V			Redibujar la ventana

49	Ctrl + W			No definida

50	Ctrl + X			No definida

51	Ctrl + Y			Borrar hasta el final de la línea

52	Ctrl + Z			No definida

53	Ctrl + [			Esc (entrar en el modo de comandos
                                        extendidos)

54	No definida			No definida

55	Ctrl + ]			Ir al final o al principio de la
                                        línea, dependiendo de la posición
                                        del cursor

56	No definida			No definida

57	No definida		 	No definida

@endnode

@NODE MenúCommand "Menú Command"

Menú Command

Los siguientes comandos se utilizan para manipular ficheros:

  Extended Command...	Esc,C,M...	Entra en el modo de comandos
                                        extendidos; equivale a pulsar
					Ctrl+[ ó Esc.

  Repeat Last		Esc,R,E		Intenta repetir el último comando.

  Run File...		Esc,R,F...	Carga y ejecuta un fichero de
                                        comandos o comandos en modo
                                        extendido.

  ARexx Command...	Esc,R,X...	Ejecuta el programa ARexx que se
                                        indique.

  Redisplay		Esc,V,W		Redibuja la ventana ED y borra la
                                        línea de estado; equivale a pulsar
                                        Ctrl+V.
@endnode

@NODE OtrosComandosED "Otros comandos de ED"

Otros comandos de ED

También hay otros comandos de ED que no aparecen en los menús. Estos
comandos se listan aquí en grupos según su función. Úselos en modo
extendido introduciendo las siguientes combinaciones de teclas:

Control del programa

Los comandos siguientes se encargan del control del programa:

  Extend Margins	Esc,E,X		Extiende los márgenes en la línea
                                        actual. Una vez que introduce el
                                        comando EX, ED ignora el margen
                                        derecho en la línea actual.

  Status Line Message	Esc,S,M...	Imprime una cadena determinada en
                                        la línea de estado.

  Exit with Query	Esc,X,Q		Sale de ED a menos que se haya hecho
                                        algún cambio en el texto. Si ha
                                        realizado algún cambio, se mostrará
                                        el mensaje "File has been changed -
                                        - type Y to save and exit:". Pulse
                                        cualquier tecla (excepto Y) para
                                        interrumpir la salida. XQ es
                                        equivalente a pulsar el gadget de
					cierre de la ventana ED.


Control del cursor

Los siguientes comandos se usan para controlar el cursor:

  End Page		Esc,E,P		Final de la página.

  Previous		Esc,P		Comienzo de la línea anterior.

  Character Left	Esc,C,L		Un lugar a la izquierda.

  Character Right	Esc,C,R		Un lugar a la derecha.

  Current End		Esc,C,E		Final de la línea actual.

  Current Start		Esc,C,S		Comienzo de la línea actual.

  Tab			Esc,T,B		Siguiente posición del tabulador.

  Word Next		Esc,W,N		Comienzo de la siguiente palabra.

  Word Previous		Esc,W,P		Un espacio después de la palabra
                                        anterior.


Modificación de texto

Los siguientes comandos editan texto en la pantalla:

  Insert Before		Esc,I		Inserta la cadena de texto indicada
                                        en la línea actual, antes del
                                        cursor. Indique una cadena de texto
                                        después del comando para que ésta
                                        aparezca después de la línea en la
                                        que se encuentra el cursor.

  Insert After		Esc,A		Inserta la cadena de texto indicada
                                        en la línea que está antes del
                                        cursor. Este comando trabaja de la
                                        misma forma que el anterior, excepto
                                        que en este caso la cadena se
                                        inserta una línea por debajo de la
                                        posición actual del cursor.

  Split			Esc,S		Divide la línea actual por la
                                        posición del cursor.

  Join			Esc,J		Une la siguiente línea al final de
                                        la línea actual.

  Delete		Esc,D		Borra la línea actual.

  Delete Character	Esc,D,C		Borra el carácter destacado por el
                                        cursor.

  Delete Left		Esc,D,L		Borra el carácter que se encuentra
                                        a la izquierda del cursor.

  Delete Word		Esc,D,W		Borra hasta el final de la palabra
                                        actual.

  End Line		Esc,E,L		Borra hasta el final de la línea
                                        actual.

  Flip Case		Esc,F,C		Cambia la letra actual por
                                        minúscula si es mayúscula y
                                        viceversa.

  Set Tab		Esc,S,T		Ajusta el tabulador. Para cambiar el
                                        valor actual del tabulador, use el
                                        comando ST seguido por un número.

  Next			Esc,N		Va al comienzo de la siguiente línea.

@endnode

@NODE RepiteComExtendido "Repetición de comandos en modo extendido"

REPETICIÓN DE COMANDOS EN MODO EXTENDIDO

Pulsando Ctrl+G repite una línea de comando. Puede preparar y ejecutar
tareas complejas con los comandos muchas veces.

Puede repetir un comando un número determinado de veces introduciendo el
número antes del comando. Por ejemplo, la línea:

  4 E/rename/copy/

cambia las siguientes cuatro apariciones de "rename" por "copy".

Use el comando extendido RP (Repeat, repetir) para repetir un comando
hasta que ED indique error, como puede ser el haber alcanzado el final del
fichero. Por ejemplo, la línea:

  T;RP E/rename/copy/

lleva el cursor al comienzo del fichero y cambia todas las apariciones de
"rename" por "copy". El comando T (Top of File, comienzo del fichero) cambia
todas las apariciones de la palabra "Rename" en todo el fichero. Si no se
usa este comando, sólo se modificará esta palabra partiendo de la posición
actual del cursor.

Para ejecutar grupos de comandos repetidamente, puede agrupar los comandos
juntos indicándolos entre paréntesis. También puede anidar grupos de
comandos. Por ejemplo, la línea:

  RP (F/Workbench/;3A//)

inserta tres líneas en blanco (la cadena nula //) después de cada línea que
contenga "Workbench".

Para interrumpir una secuencia de comandos extendidos, pulse cualquier tecla
durante su ejecución. Si ocurre algún error, ED abandonará la secuencia de
comandos automáticamente.

@endnode

@NODE PersonalizaED "Personalización de ED"

PERSONALIZACIÓN DE ED

Puede personalizar ED con comandos que cambien la configuración de los
menús y de las teclas de función. Estos comandos pueden introducirse
individualmente en ED. También pueden grabarse como un script, como
S:Ed-startup, o como un fichero indicado con el argumento WITH. Para
ejecutar un fichero desde ED, use el comando extendido "Run File"
(Ejecutar fichero), que puede invocar pulsando Esc,R,F. Para más
información sobre el cambio de las teclas de función, mire el apartado
que habla del menú @{"Settings" link MenúSettings}.

  Set Menu Item		Esc,S,I		Define el título y las opciones de
                                        un menú. Hay 120 slots para opciones
                                        de menú, de 0 a 119. El tipo de slot
                                        identifica su contenido, y es un
                                        número de 0 a 4. El tipo de slot 0
                                        debe ser el último slot definido.
                                        No cree un menú sin opciones; si
                                        especifica un título para un menú,
                                        incluya también opciones para el
                                        mismo. Mire más adelante la sintaxis
                                        de la opción @{"Set" link OpciónSetDeED} para ver una
                                        tabla con los tipos de slot.

  Enable Menu		Esc,E,M		Activa menús. Debe acompañar a los
                                        comandos "Set Menu Item" con EM para
                                        activar los comandos de los menús.
                                        Mire el apartado que habla de la
                                        opción @{"Set" link OpciónSetDeED} para ver un script
                                        de ejemplo que usa este comando.

@endnode

@NODE OpciónSetDeED "Opción de menú Set"

Opción Set Menu Item

Ésta es la sintaxis para el comando Set Menu Item:

  SI <número de slot> <tipo de slot> /cadena1/cadena2/

La siguiente tabla muestra los tipos de slot y las funciones que se usan con
el comando Set Menu Item:

-----------------------------------------------------------------------------
Tipo		Función			Entrada de la cadena
-----------------------------------------------------------------------------

  0		Fin de los menús	Sin argumentos

  1		Título del menú		Cadena1 = nombre del título

  2		Opción de menú		Cadena1 = nombre de la opción
                                        Cadena2 = cadena del comando

  3		Opción de submenú	Cadena1 = nombre de la cabecera
                                        Cadena2 = cadena del comando

  4		Barra separadora	Sin argumentos


Script de ejemplo

Lo que sigue es un script de ejemplo que usa los comandos "Set Menu Item" y
"Enable Menu". Las comillas se utilizan como delimitador.

  SI 0 1 "Proyecto"
  SI 1 2 "Abrir ... " "op ? /Abrir fichero:/"
  SI 2 2 "Grabar ... " "sa"
  SI 3 4
  SI 4 2 "Salir" "q"
  SI 5 1 "Mover"
  SI 6 2 "Principio" "t"
  SI 7 2 "Final" "b"
  SI 8 0
  EM

@endnode

@NODE ImpresiónDesdeED "Impresión desde ED"

IMPRESIÓN DESDE ED

Siga los pasos siguientes para imprimir un fichero que está abierto en la
ventana actual de ED:

1. Elija la opción de menú "Save As" para hacer aparecer un requester de
   ficheros.

2. Introduzca prt: en el apartado "Directorio".

3. Seleccione OK.

De esta forma imprime el fichero, pero no se graba en disco. Si desea grabar
en disco el fichero, deberá seleccionar la opción "Save", o "Save As" y un
nombre de fichero.
@endnode

@NODE SalidaDeED "Salir de ED"

SALIR DE ED

Puede salir de ED de las tres formas siguientes:

- Esc,X. Este método abandona ED y salva el fichero actual con el nombre de
  fichero utilizado al cargar ED.

- Esc,X,Q o pulsar en el gadget de cierre de la ventana ED. Este método sale
  de ED si no se han hecho cambios en el fichero. Si ha hecho algún cambio
  en el mismo, ED le permite grabar los cambios o salir sin grabar.

- Esc,Q o seleccionar la opción "Quit" del menú Project. Este método sale
  de ED sin grabar ningún cambio si responde afirmativamente con Y al
  mensaje que aparece en la línea de estado para avisarle de que perderá
  esos cambios.
@endnode

@NODE EDbajoARexx "Soporte ARexx"

SOPORTE AREXX

También puede controlar a ED desde ARexx enviando y recibiendo comandos
a través del puerto ARexx de ED. Cada copia de ED que se esté ejecutando
tendrá un nombre de puerto ARexx propio, que deberá especificarse para
manejar información en la sesión correcta. Los nombres de puerto ARexx
se asignan de la forma siguiente:

- El nombre de puerto de la primera sesión es "Ed".

- El de la segunda sesión es "Ed_1".

- El de la tercera sesión es "Ed_2", etcétera.

Muchos de los comandos extendidos de ED pueden utilizarse desde ARexx.
Usando el comando RV de ED en los programas ARexx, puede enviar información
desde ED hacia ARexx. Esto ofrece información sobre el estado de ED, como
el número de la línea actual o el nombre del fichero que se está editando.

El comando RV acepta el nombre de la variable "stem" de ARexx para la
información de su argumento. Por ejemplo, en ARexx, la línea:

  address 'Ed' 'RV /stem/'

asigna valores a las siguientes variables:

  stem.LEFT			Margen izquierdo actual

  stem.RIGHT			Margen derecho actual

  stem.TABSTOP			Ajuste actual del tabulador

  stem.LMAX			Máximo número de líneas visibles en la
                                pantalla

  stem.WIDTH			Ancho de la pantalla, en caracteres

  stem.X			Posición X del cursor en la ventana ED (1 es
                                el borde izquierdo)

  stem.Y			Posición Y del cursor en la ventana ED (1 es
                                la línea superior)

  stem.BASE			La base de la ventana (normalmente 0, pero
                                puede no ser 0 cuando la pantalla se mueve
                                hacia la derecha)

  stem.EXTEND			Valor del margen extendido (comando "Extend
                                Margins")

  stem.FORCECASE		Bandera de sensibilidad a la diferencia
                                entre mayúsculas y minúsculas (ignorar
                                diferencia = 1; sensible a la diferencia = 0)

  stem.LINE			Número actual de línea del fichero (1 sería
                                la primera línea)

  stem.FILENAME			Nombre del fichero que se está editando

  stem.CURRENT			Texto de la línea actual

  stem.LASTCMD			Último comando extendido utilizado

  stem.SEARCH			Última cadena de texto buscada

Puede usarse cualquier símbolo válido en ARexx en lugar de "stem.". Incluya
el nombre entre delimitadores válidos. Estas variables pueden tratarse como
las varibles "stem" ordinarias de ARexx.

@endnode

@NODE EjemploARexxED "Programa ARexx de ejemplo para ED"

Programa ARexx de ejemplo para ED

El programa de ejemplo, Transpose.ed, ilustra el uso de varios comandos
extendidos desde ARexx. Este programa intercambia dos caracteres cuando se
lanza desde ED. Por ejemplo, si una línea contiene la cadena "123" y el
cursor está destacando el 3, Transpose.ed cambiará la cadena por "213".

Teclee el programa y grábelo con el nombre REXX:Transpose.ed. Luego cargue
ED y edite un fichero existente, o bien cree uno nuevo. Coloque el cursor un
carácter a la derecha de los que quiera trasponer, pulse ESC e introduzca:

  RX /transpose.ed/

El programa se ejecutará y los caracteres serán transpuestos si ARexx está
corriendo en el sistema y todo se introduce correctamente. Deberá indicar
el nombre completo del fichero, incluyendo la extensión, para ejecutar el
programa.

  /* Transpose.ed : programa de ejemplo para transponer dos caracteres. */
  /* Si se da la cadena '123' y el cursor está sobre el 3, esta macro   */
  /* cambia la cadena por '213'.                                        */
  HOST = address()   /* Averigua qué sesión de ED invocó el programa    */
  address VALUE HOST /* y habla con esa sesión                          */
  'rv' '/CURR/'      /* Le pide a ED que almacene información en la     */
                     /* variable stem (CURR) y obtiene dos datos:       */
  currpos = CURR.x        /* 1. Posición del cursor en la línea         */
  currlin = CURR.CURRENT  /* 2. Contenido de la línea actual            */
  if (currpos > 2) then   /* Trabaja solamente en la línea actual       */
    currpos = currpos - 1
  else do                 /* De lo contrario, da error y abandona       */
  'sm /El cursor debe estar en la posición 2 o más a la derecha/'
  exit 10
  end
  /* Luego el código necesita transponer los caracteres CURRPOSx y      */
  /* CURRPOSx-1 y luego sustituir la línea actual por la nueva.         */
  /* Deja CURR. CURR ya no se necesita; dejándola se ahorra memoria.    */
  'd'                                  /* Le dice a ED que borre la     */
                                       /* línea actual.                 */
  currlin = swapch (currpos,currlin)   /* Intercambia los dos caracteres*/
  'i /'llcurrlin'/'                    /* Inserta la línea modificada   */
  do i = 1 to currpos                  /* Coloca el cursor donde estaba */
    'cr'                               /* Comando "Cursor Right' de ED  */
    end
  exit                                 /* El programa ha terminado      */
  /* Función para intercambiar dos caracteres                           */
  swapch: procedure
  parse arg cpos,lin
    ch1 = substr(clin,cpos,1)          /* Toma carácter                 */
    clin = delstr(clin,cpos,1)         /* Lo borra de la cadena         */
    clin = insert(ch1,clin,cpos-2,1)   /* Lo inserta para hacer la      */
                                       /* transposición                 */
  return clin                          /* Devuelve la cadena modificada */

@endnode

@NODE MEmacs

MEMACS
------

MEmacs (MicroEmacs), similar al editor Emacs basado en UNIX, es un editor
orientado a pantalla en el que puede editar múltiples ficheros al mismo
tiempo. MEmacs realiza todas las operaciones con el texto residente en
memoria; es necesario que los ficheros quepan enteros en la memoria.

La longitud de las líneas, generalmente de 80 caracteres, está limitada por
el borde derecho de la pantalla. Puede introducir caracteres más allá del
límite, pero no podrá verlos. Para ver estos caracteres, haga un corte en
la línea o borre algunos de los caracteres mostrados. Un signo de dólar ($)
en el borde derecho de la pantalla indica que hay más caracteres de los que
pueden verse.

El formato del comando para llamar a MEmacs es el siguiente:

  MEmacs [<nombre de fichero>] [GOTO <n>] [OPT W]

El argumento <nombre de fichero> es opcional.

La opción GOTO <n> indica la línea en la que aparecerá el cursor en cuanto
se cargue el fichero.

Si indica OPT W, MEmacs se abrirá en una ventana del Workbench en lugar de
hacerlo en su propia pantalla, lo que ahorra memoria.

@endnode

@NODE EjecutaMEmacs "Ejecutando MEmacs"

EJECUTANDO MEMACS

MEmacs puede ejecutarse tanto desde el Workbench como desde Shell. Desde el
Workbench, pulse dos veces sobre el icono de MEmacs que se encuentra en la
ventana Tools del disco Extras. Si tiene un disco duro, el cajón Tools está
en la partición Workbench.

Desde el Shell, introduzca:

  MEmacs <nombre de fichero>

donde <nombre de fichero> indica el fichero que quiere cargar en MEmacs. Si
no existe un fichero con ese nombre, se creará automáticamente para grabar
su trabajo.
@endnode

@NODE ComandosMEmacs "Comandos de MEmacs"

COMANDOS DE MEMACS

La línea de la parte inferior de la pantalla de MEmacs identifica el nombre
del fichero actual, o bien el nombre del buffer actual si no se ha indicado
ningún nombre de fichero.

Pueden usarse varios buffers al mismo tiempo, y pueden mostrarse uno o más
en la pantalla a la vez. Use las opciones de menú para pasar de uno a otro.
En todo momento, la pantalla muestra lo que hay actualmente en el buffer.

MEmacs tiene dos formas de funcionamiento:

  Normal		Cuando introduce y manipula texto directamente en
			el fichero, sin funciones especiales.

  Comandos		Cuando introduce un comando mediante una opción de
 			menú o mediante un atajo de teclado equivalente. En
 			este modo, el cursor aparece en la línea inferior
			de la visualización y espera a que introduzca más
			información mostrando el prompt. No puede volver al
			modo normal hasta que introduzca o cancele el
			comando pulsando Return.

En el modo normal de MEmacs, puede:

- Mover el cursor usando las teclas del cursor.

- Mover el cursor hasta el borde de la ventana manteniendo pulsada la tecla
  Mayúsculas y pulsando la tecla apropiada del cursor.

- Mover el cursor pulsando el botón izquierdo del ratón y teniendo el
  puntero del ratón en el lugar deseado de la pantalla.

- Insertar caracteres en la posición actual del cursor simplemente
  tecleándolos.

- Borrar el carácter que esté en la posición actual del cursor pulsando la
  tecla Del.

- Borrar el carácter que esté a la izquierda del cursor pulsando la tecla
  Retroceso.

- Realizar otras funciones con los menús y comandos especiales.

Para usar MEmacs, debería familiarizarse con los siguientes términos
especiales:

  Buffer		Una zona de la memoria que MEmacs controla. Siempre
			hay al menos un buffer usado por MEmacs que contiene
			cero o más caracteres de texto.

  Punto			La posición actual del cursor.

  Marca			Una posición determinada del cursor (cada buffer
  			tiene su propio punto y su propia marca). La opción
			de menú "Set-mark" marca la posición actual del
			cursor (como se explica en el apartado que habla del
 			@{"menú Edit" link MenúEditMEmacs 27}). Puede ir hacia adelante o hacia atrás
                        por el fichero, añadiendo o borrando texto. Para
                        volver al lugar marcado, selecccione la	opción de
                        menú "Swap-dot&mark", que se describe en el apartado
                        que habla del @{"menú Move" link MenúMoveMEmacs 24}.

 			También puede fijar una marca para indicar el
			comienzo de un bloque de texto que quiera duplicar,
			mover o borrar. El bloque está formado por todos los
			caracteres desde la marca hasta la posición actual
			del cursor.

  Kill			Los comandos de tipo Kill borran texto de la
			pantalla para grabarlos en un buffer Kill propio.
			Este texto puede recuperarse e insertarse en el
			documento usando el comando "Yank". Usando varias
			veces seguidas los comandos Kill (sin seleccionar
			la opción "Yank" por medio) añadirá cada bloque de
			texto al texto existente en el buffer Kill. Si
			selecciona "Yank", el siguiente bloque de texto
			eliminado sobreescribirá el bloque actual.

  Ventana		Las pantallas de MEmacs pueden dividirse en varias
			partes para editar y mostrar más de un buffer o dos
			o más porciones del mismo buffer. Cada parte se
			considera una ventana MEmacs aparte.

  Buffers modificados	Los buffers se marcan como modificados cuando sufren
			algún cambio. El estado de modificado desaparece
			cuando el buffer se graba en disco.

			Para ver los buffers modificados, use el comando
			"List-buffers" (que se describe en el apartado que
			habla del @{"menú Edit" link MenúEditMEmacs 49}); los buffers modificados se
                        identifican con un asterisco (*). Si intenta salir
                        de MEmacs sin haber grabado los cambios, un prompt
                        le dirá que tiene buffers modificados, y le pedirá
                        confirmación.

@endnode

@NODE ComandosDeMenúMEmacs "Comandos de menú"

COMANDOS DE MENÚ

MEmacs tiene los siguientes menús:

  @{"Project" link MenúProjectMEmacs}		Contiene opciones orientadas al sistema y a los
			ficheros.

  @{"Edit" link MenúEditMEmacs}			Contiene comandos de edición de buffer.

  @{"Window" link MenúWindowMEmacs}		Controla las características de las ventanas de
			MEmacs.

  @{"Move" link MenúMoveMEmacs}			Controla el lugar del cursor.

  @{"Line" link MenúLineMEmacs}			Controla las operaciones relacionadas con la línea.

  @{"Word" link MenúWordMEmacs}			Controla las operaciones relacionadas con las
			palabras.

  @{"Search" link MenúSearchMEmacs}		Controla las operaciones de búsqueda y búsqueda con
			sustitución de cadenas de texto.

  @{"Extras" link MenúExtrasMEmacs}		Controla el valor numérico de los argumentos y le
			permite ejecutar una serie de operaciones como si
			fuesen un sólo comando especial.

@endnode

@NODE MenúProjectMEmacs "Menú Project"

Menú Project

Los comandos del menú Project, exceptuando "Visit-file", afectan al buffer
asociado con la posición actual del cursor.

  Rename		Ctrl+X,F	Cambia el nombre del fichero
                                        asociado con el buffer actual.
                                        Pulsando Return sin indicar ningún
					nombre, des-asociará el buffer de
					cualquier nombre de fichero.

  Read-file		Ctrl+X,	Ctrl+R	Sustituye el contenido del buffer
			                por el contenido de un fichero.
                                        Introduzca la senda completa del
                                        fichero. Pulse Return sin indicar
                                        ningún nombre para ignorar la orden
					y volver al modo normal.

  Visit-file		Ctrl+X,	Ctrl+V	Le permite trabajar con ficheros
			        	además del que está editando ahora.
                                        Introduzca la senda completa del
                                        fichero.

  Insert-file		Ctrl+X,	Ctrl+I	Inserta el contenido de un fichero
                                        en el buffer actual, una línea por
                                        encima de la posición actual del
                                        cursor. Introduzca la senda completa
                                        del fichero.

  Save-file		Ctrl+X, Ctrl+S	Escribe el contenido del buffer
                                        actual usando el nombre de fichero
                                        asociado al mismo. Al terminar la
                                        grabación, mostrará el número de
                                        líneas salvadas, lo que además sirve
                                        para asegurar que la grabación ha
                                        tenido éxito. MEmacs no graba el
                                        fichero si éste no tiene ningún
                                        nombre asignado; en este caso
                                        mostrará el mensaje de error
					"No file name".

  Save-as-file		Ctrl+X, Ctrl+W	Le permite indicar la senda completa
                                        con la que se grabará el fichero.

  Save-mod		Ctrl+X, Ctrl+M	Graba el contenido de todos los
                                        buffers modificados. Tenga cuidado de
                                        no modificar un buffer que no quiera
                                        grabar.

  Save-exit		Ctrl+X, Ctrl+F	Graba todos los buffers modificados
                                        y sale de MEmacs.

  New-Cli		Ctrl + -	Abre una nueva ventana Shell, llamada
                                        "Spawn Window". Puede introducir
                                        comandos AmigaDOS en esta ventana
                                        sin interferir con MEmacs. Para
                                        cerrar la ventana, introduzca
                                        ENDSHELL.

  Cli-Command		Ctrl+X, !	Le permite ejecutar un comando del
                                        AmigaDOS sin salir de MEmacs.
                                        Introduzca el comando después del
                                        prompt "!" que aparece en la línea
                                        inferior de la pantalla. La salida
                                        del comando se coloca en el buffer
                                        "spawn.output".

  Quit			Ctrl+C		Sale de MEmacs. Se le dará la
                                        oportunidad de grabar los buffers
                                        que hayan sido modificados o bien
                                        salir sin realizar ninguna grabación.
                                        Los atajos de teclado alternativos
                                        son Ctrl+X, Ctrl+C y Esc, Ctrl+C.

  About...                              Da información sobre el Copyright
                                        del programa.

@endnode

@NODE MenúEditMEmacs "Menú Edit"

Menú Edit

Los comandos del menú Edit afectan a la edición de los buffers y los
ficheros asociados a los mismos.

  Kill-region		Ctrl+W		Borra bloques de texto del buffer
                                        actual y los traslada al buffer
                                        Kill. El texto puede ser recuperado
                                        con el comando "Yank". Puede hacer
                                        varias copias de un mismo bloque
                                        seleccionando inmediatamente "Yank"
                                        sin cambiar la posición del cursor
                                        después de borrar el bloque. Esto
                                        recupera el bloque a su posición
                                        original, guardando una copia en el
                                        buffer Kill.

  Yank			Ctrl+Y		Copia el contenido del buffer Kill
                                        a la posición actual del cursor.
                                        Esto es lo contrario de usar "Kill-
                                        region", pero sin cambiar el
                                        contenido del buffer Kill. Se usa
					con la opción "Kill-region" para
					mover texto o para copiar
					repetidamente un bloque de texto.

  Set-mark		Ctrl+@		Marca la posición del cursor en el
                                        buffer. Después de hacer esto, la
                                        posición del cursor pasa a recibir
                                        el nombre de punto. Puede pasar de
                                        la posición del punto a la marca
                                        usando el comando "Swap-dot&mark"
                                        del menú Move. Esta opción se usa
                                        para hacer bloques de texto. Un
                                        atajo de teclado alternativo es
                                        Esc -.

  Copy-region		Esc,W		Copia el contenido de la región
                                        marcada al buffer Kill sin borrarla,
                                        sustituyendo el contenido previo de
                                        este buffer.

  Upper-region		Ctrl+X, Ctrl+U	Cambia todo el texto de la región
                                        marcada a letras mayúsculas.

  Lower-region		Ctrl+X, Ctrl+L	Cambia todo el texto de la región
                                        marcada a letras minúsculas.

  List-buffers		Ctrl+X, Ctrl+B	Divide la ventana del buffer actual
                                        y muestra una lista de los buffers
                                        que MEmacs está utilizando. Para
                                        volver a mostrar de la forma normal
                                        el buffer en el que estaba
                                        trabajando, seleccione el comando
                                        "One-window" o pulse Ctrl+X, 1.
                                        Los campos de "List-buffers" son:

                                        C	Muestra un asterisco si el
                                        	buffer ha sido modificado
                                        	desde la última vez que se
                                        	grabó el fichero (significa
                                        	"cambiado").

                                        Size	Muestra el número de
                                        	caracteres que contiene el
                                        	buffer.

                                        Buffer	Muestra el nombre dado al
	                                        buffer. Si tiene un fichero
                                        	asociado, su nombre se
                                        	mostrará aquí, aunque sin
                                        	la senda completa.

                                        File	Muestra la senda completa
                                        	del fichero. Se trata del
                                        	fichero en el que MEmacs
                                        	escribe el buffer si usa
                                        	las opciones "Save-file" o
                                        	"Save-exit" mientras el
                                        	cursor está en el buffer.

  Select-buffer		Ctrl+X, B	Le permite seleccionar el buffer a
                                        editar en la ventana actual. Este
                                        comando sustituye el contenido de
                                        la ventana por el buffer
                                        seleccionado o uno nuevo.

  Insert-buffer		Esc, Ctrl+Y	Inserta el contenido de un buffer
                                        indicado en el buffer actual, una
                                        línea por encima de la posición
                                        actual del cursor.

  Kill-buffer		Ctrl+X, K	Borra el contenido de uno o más
                                        buffers indicados, liberando
                                        memoria. Deberá indicar el buffer a
                                        borrar; un buffer no puede borrarse
                                        si su contenido está siendo mostrado
                                        en cualquier ventana de MEmacs.

  Justify-buffer	Ctrl+X, J	Elimina todos los espacios en blanco
                                        y los tabuladores desde el borde
                                        izquierdo en todas las líneas del
                                        buffer actual. El texto se alinea
                                        con los márgenes actuales.

  Redisplay		Ctrl+L		Redibuja la pantalla.

  Quote-char		Ctrl+Q		Permite la inserción de cualquier
                                        carácter literal en el fichero de
                                        texto, excepto la tecla de
                                        tabulación. Un atajo de teclado
                                        alternativo es Ctrl+X, Q.

  Indent		Ctrl+J		Lleva el cursor a la siguiente
                                        línea, adelantándose automáticamente
                                        los mismos caracteres que en la
                                        línea en la que se encontraba.
                                        Atajos de teclado alternativos: Help
                                        o Enter en el teclado numérico.

  Transpose		Ctrl+T		Intercambia las posiciones de dos
                                        caracteres adyacentes. Coloque el
                                        cursor en el carácter de la derecha
                                        y ejecute el comando.

  Cancel		Ctrl+G		Interrumpe una opción de comando que
                                        esté en marcha, como una opción de
                                        búsqueda y sustitución que pide
                                        confirmación.

@endnode

@NODE MenúWindowMEmacs "Menú Window"

Menú Window

El menú Window controla el modo en que los buffers se muestran en la
pantalla.

  One-window		Ctrl+X, 1	Hace que el buffer actual ocupe la
                                        ventana completa de la pantalla
                                        MEmacs.

  Split-window		Ctrl+X, 2	Divide la ventana actual en dos
                                        mitades, posicionando el buffer
                                        actual igualmente en ambas ventanas.
                                        Los cambios que hace en cualquier
                                        ventana afectan al buffer entero.

  Next-window		Ctrl+X, N	Lleva el cursor a la ventana
                                        siguiente, permitiendo la edición
                                        en esa ventana.

  Prev-window		Ctrl+X, P	Lleva el cursor a la ventana
                                        anterior, permitiendo la edición
                                        en la misma.

  Expand-window		Ctrl+X, Z	Añade una línea a la altura de la
                                        ventana actual, sustrayéndola a su
                                        vez de la ventana adyacente.

  Shrink-window		Ctrl+X, Ctrl+Z	Sustrae una línea a la altura de la
                                        ventana actual, añadiéndola a la
                                        altura de la ventana adyacente.

  Next-w-page		Esc, Ctrl+V	Muestra la página siguiente de la
                                        ventana adyacente. Esto no convierte
                                        a esa ventana en disponible para la
                                        edición.

  Prev-w-page		Ctrl+X, V	Muestra la página anterior de la
                                        ventana adyacente. Si sólo se está
                                        mostrando una ventana, se mostrará
                                        la página anterior de esa ventana.

@endnode

@NODE MenúMoveMEmacs "Menú Move"

Menú Move

Estos comandos mueven el cursor rápidamente por el buffer actual.

  Top-of-buffer		Esc <		Lleva el cursor al comienzo del
                                        buffer actual.

  End-of-buffer		Esc >		Lleva el cursor al final del buffer
                                        actual.

  Top-of-window		Esc ,		Lleva el cursor a la primera línea
                                        de la ventana actual.

  End-of-window		Esc .		Lleva el cursor a la última línea
                                        de la ventana actual.

  Goto-line		Ctrl+X, Ctrl+G	Lleva el cursor al número de línea
                                        que se indique. Si indica un número
                                        de línea que sobrepasa el número de
                                        líneas del buffer, conseguirá que
                                        el cursor aparezca en la última
                                        línea del mismo.

  Swap-dot&mark		Ctrl+X, Ctrl+X	Marca la posición actual del cursor
                                        (punto) y lleva el cursor al lugar
                                        marcado previamente.

  Next-page		Ctrl+V		Mueve el cursor hacia adelante una
                                        ventana completa, menos una línea.

  Prev-page		Esc+V		Mueve el cursor hacia atrás una
                                        ventana completa, menos una línea.

  Next-word		Esc+F		Mueve el cursor hasta el siguiente
                                        carácter no alfabético, como un
                                        espacio o un signo de puntuación,
                                        después de la palabra actual.

  Previous-word		Esc+B		Mueve el cursor hacia atrás, hasta
                                        la primera letra de la palabra
                                        anterior.

  Scroll-up		Ctrl+Z		Mueve el texto hacia arriba una
                                        línea.

  Scroll-down		Esc+Z		Mueve el texto hacia abajo una
                                        línea.

@endnode

@NODE MenúLineMEmacs "Menú Line"

Menú Line

Estos comandos mueven el cursor dentro o entre líneas y realizan operaciones
a nivel de líneas enteras.

  Open-line		Ctrl+O		Divide la línea en la que se
                                        encuentra el cursor, forzando al
                                        carácter que está en la posición
					actual del cursor a ser el primer
					carácter de la siguiente línea.
					El cursor permanece en la línea
					original. Pulsando la tecla Del
					se anula el efecto de este comando.

  Kill-line		Ctrl+X, Ctrl+D	Borra la línea que contiene el
                                        cursor y coloca el texto en el
					buffer Kill.

  Kill-to-eol		Ctrl+K		Borra el texto desde la posición del
                                        cursor hasta el final de la línea,
                                        colocando este texto en el buffer
                                        Kill.

  Start-of-line		Ctrl+A		Lleva el cursor a la primera
                                        posición de la línea.

  End-of-line		Ctrl+E		Lleva el cursor a la última posición
                                        de la línea.

  Next-line		Ctrl+N		Lleva el cursor hacia abajo una
                                        línea.

  Previous-line		Ctrl+P		Mueve el cursor hacia arriba una
                                        línea.

  Line-to-top		Esc !		Lleva la línea que contiene el
                                        cursor a la parte superior de la
                                        ventana.

  Delete-blanks		Ctrl+X, Ctlr+O	Borra las líneas en blanco,
                                        partiendo de la posición actual
					del cursor y hacia adelante hasta
					que MEmacs alcance una línea que
					contenga texto.

  Show-Line#		Ctrl+X, #	Muestra información sobre la
                                        posición actual del cursor.

@endnode

@NODE MenúWordMEmacs "Menú Word"

Menú Word

El menú Word contiene operaciones relacionadas directamente con las
palabras.

  Delete-forw		Esc, D		Borra el carácter destacado por el
                                        cursor y todos los caracteres que
                                        haya a la derecha hasta encontrar
                                        un carácter no alfanumérico, como
                                        un espacio en blanco, una tabulación
                                        o un signo de puntuación.

  Delete-back		Esc, H		Borra todos los caracteres que se
                                        encuentren a la izquierda del cursor
                                        hasta que se encuentre el primer
                                        carácter de una palabra. El carácter
                                        que se encuentre en la posición del
                                        cursor no se borrará. Un atajo de
                                        teclado alternativo es Esc, Del.

  Upper-word		Esc, U		Cambia una palabra a letras
                                        mayúsculas, comenzando por la
					posición del cursor y hasta llegar
					al último carácter de la palabra.

  Lower-word		Esc, L		Cambia una palabra a letras
                                        minúsculas, partiendo de la posición
					del cursor hacia adelante hasta
					llegar al último carácter de la
					palabra.

  Cap-word		Esc, C		Cambia el carácter sobre el que se
                                        encuentra el cursor a mayúscula.
                                        También cambia los caracteres que
                                        estén a la derecha del cursor, pero
                                        en este caso a minúsculas.

  Switch-case		Esc, ^		Cambia los caracteres de una palabra
                                        a mayúsculas o a minúsculas,
                                        partiendo de la posición actual del
                                        cursor y hasta alcanzar el final de
                                        la palabra. Si una palabra tiene
                                        letras mayúsculas y minúsculas,
                                        estas letras pasan a ser mayúsculas
                                        si eran minúsculas, y viceversa.

@endnode

@NODE MenúSearchMEmacs "Menú Search"

Menú Search

Estos comandos buscan por el buffer actual la cadena de texto que se
indique. No importa si los caracteres son mayúsculas o minúsculas. Sin
embargo, si está haciendo sustituciones en el texto (búsqueda y
sustitución), el texto nuevo que se introduzca lo hará tal como se
indicó al llamar al comando.

  Search-forward	Ctrl+S		Realiza la búsqueda por todo el
                                        texto partiendo de la posición actual
                                        del cursor y hacia adelante hasta
                                        llegar al final del buffer. En el
                                        prompt, introduzca la cadena de
                                        caracteres a buscar. Un atajo de
                                        teclado alternativo es Ctrl+X, S.

  Search-backward	Ctrl+R		Realiza la búsqueda por todo el
                                        texto partiendo de la posición actual
                                        del cursor hacia atrás hasta llegar
                                        al principio del buffer. Un atajo
                                        de teclado alternativo es Ctrl+X, R.

  Search-replace	Esc, R		Busca de la misma forma que "Search-
                                        forward", permitiéndole sustituir
                                        la cadena por otra diferente. En el
                                        prompt, introduzca la cadena a buscar
                                        y la nueva cadena a colocar en su
                                        lugar.

  Query-s-r		Esc, Q		Funciona de la misma forma que
                                        Search-replace, excepto que pide
                                        confirmación antes de hacer cada
                                        sustitución. Las opciones son Y
                                        (para confirmar), N (para no hacer
                                        la sustitución), C (sustituir en
                                        todas las ocasiones) y Ctrl+G
                                        (para interrumpir el comando).

  Fence-match		Esc, Ctrl+F	Busca otro carácter como el
                                        destacado en la posición actual
					del cursor. Esto funciona también
					con paréntesis, corchetes y llaves.

@endnode

@NODE MenúExtrasMEmacs "Menú Extras"

Menú Extras

Estos comandos controlan ciertas operaciones de MEmacs, así como el uso de
macros. Pueden ser necesarios argumentos numéricos específicos para poder
hacer uso de un comando; un asterisco (*) indicará que se necesita un
argumento. Los comandos macro se ejecutan seleccionando la opción de menú
"Execute-macro".

  Set-arg		Ctrl+U		Le permite indicar un argumento
                                        numérico para un comando.

  Set			Esc, S		Le permite ajustar los siguientes
                                        parámetros de MEmacs:

                                        Screen	   Coloca a MEmacs en una
                                        	   ventana del Workbench o
                                                   de vuelta en su propia
                                        	   pantalla.

                                        Interlace  Activa o desactiva el
                                        	   modo entrelazado.

                                        Mode	   Abre un segundo prompt
                                        	   "Mode:"; puede introducir
                                        	   Cmode (para editar
                                        	   programas en C) o Wrap
                                        	   (para permitir el cortado
                                        	   automático de las
                                        	   palabras una vez que éstas
                                        	   alcancen una determinada
                                        	   posición del cursor).
                                                   Use +mode o -mode para
                                        	   añadir o sustraer un
                                        	   modo.

                                        Left	   Determina el margen
                                        	   izquierdo. Solicita un
                                        	   argumento numérico si
                                        	   éste no acompañaba a la
                                        	   entrada.

                                        Right	   Determina el margen
                                        	   derecho. Solicita un
                                        	   argumento numérico si
                                        	   éste no acompañaba a la
                                        	   entrada.

                                        Tab	   Ajusta el incremento del
                                        	   tabulador. Solicita un
                                        	   argumento numérico si
                                        	   éste no se incluía con
                                        	   la entrada.

                                        Indent	   Determina cómo se utiliza
                                         	   el margen en cada nivel
                                        	   de anidamiento (esto se
                                        	   se usa en Cmode). Solicita
                                        	   un argumento numérico si
                                        	   éste no se incluía con
                                        	   la entrada.

                                        Case	   Activa o desactiva las
                                        	   búsquedas sensibles a
                                        	   la diferencia entre
                                        	   mayúsculas y minúsculas.
                                        	   Por defecto las búsquedas
                                        	   son insensibles a esta
                                        	   diferencia.

                                        Backup	   Activa o desactiva la
                                        	   función de backup de
                                        	   MEmacs. Sus opciones son:
                                        	   ON (cambia el nombre del
                                        	   fichero actual por
                                        	   <nombre>.bak y graba el
                                        	   fichero de copia al
                                        	   directorio T:), SAFE (esta
                                        	   opción comprueba si hay
                                        	   un fichero asociado al
                                        	   buffer; si lo hay, muestra
                                        	   un mensaje de error y no
                                        	   sobreescribe el fichero
                                        	   existente; con Ctrl+X
                                        	   puede redibujar la
                                        	   ventana) y OFF (ésta es
                                        	   la opción por defecto,
                                        	   MEmacs no usa backup).

  Start-macro		Ctrl+X, (	Le dice a MEmacs que memorice
                                        las pulsaciones realizadas a
                                        continuación. Se usa con los comandos
                                        "Stop-macro" y "Execute-macro".

  Stop-macro		Ctrl+X, )	Le dice a MEmacs que deje de
                                        memorizar las pulsaciones.

  Execute-macro		Ctrl+X, E	Repite las pulsaciones introducidas
                                        entre los comandos "Start-macro" y
                                        "Stop-macro".

  Set-key		Ctrl+X, Ctrl+K	Le permite redefinir todas las
                                        teclas de función, tanto solas como
                                        junto con la tecla Mayúsculas, la
                                        tecla Help y cualquier tecla del
                                        teclado numérico como macros de
                                        teclado. No puede usar el atajo de
                                        menú Ctrl+@ para insertar el comando
                                        "Set-mark" en ninguna definición de
                                        macro de teclado.

  Reset-keys		Esc, K		Devuelve las teclas definidas con
                                        "Set-key" a su estado original por
                                        defecto.

  Execute-file		Esc, E		Le permite ejecutar un fichero de
                                        programa en MEmacs.

  Execute-line		Ctrl+[, Ctrl+[	Introduce a MEmacs en el modo de
                                        comando. En el prompt deberá
                                        introducir el comando de menú y sus
                                        parámetros. Atajo de teclado
                                        alternativo: Esc, Esc.

La siguiente tabla contiene los valores por defecto de las Set-Key y las
teclas de función cuando se usan en comandos macro.

-----------------------------------------------------------------------------
Tecla		Asignación				Combinación de teclas
-----------------------------------------------------------------------------

F1		Clonar línea				Ctrl+A, Ctrl+K,
                                        		Ctrl+Y, Ctrl+M
                                        		Ctrl+Y

F2		Borrar línea                            Ctrl+X, Ctrl+D

F3		Ejecutar macro de teclado		Ctrl+X, E

F4		Siguiente pantalla			Ctrl+V

F5		Pantalla anterior			Esc+V

F6		Dividir ventana				Ctrl+X, 2

F7		Una ventana				Ctrl+X, 1

F8		Deslizar la ventana hacia arriba	Ctrl+Z

F9		Deslizar la ventana hacia abajo		Esc+Z

F10		Salvar fichero y salir			Ctrl+X, Ctrl+F

Help		Insertar línea				Ctrl+J

Enter (teclado
numérico)	Insertar línea				Ctrl+J

@endnode

@NODE ComandosSecretos "Comandos no incuidos en los menús"

COMANDOS NO INCLUIDOS EN LOS MENÚS

Los siguientes comandos son sólo accesibles desde el teclado.

Las teclas están asignadas cuando pueden utilizarse para realizar una
función. Por ejemplo, una tecla o combinación de teclas que puede usarse
como atajo de teclado para activar una opción de menú está asignada ("bind")
a esa opción de menú.

  Describe Key		Esc, Ctrl+D	Le dice la función que está asignada
                                        a una tecla o combinación de teclas.
                                        Introduzca en el prompt la tecla o
                                        combinación de teclas que desee.

  Bind key		Esc, Ctrl+B	Le permite asignar una tecla a una
                                        función. En el prompt, introduzca la
                                        tecla o combinación de teclas.

  Unbind Key		Esc, Ctrl+U	Le permite devolver una tecla
                                        asignada a su estado normal, sin
                                        asignar. En el prompt, introduzca la
                                        tecla o combinación de teclas. Las
                                        teclas que se asignan por defecto
                                        no pueden des-asignarse con este
                                        comando.

  Echo			Esc, Ctrl+E	Muestra la cadena introducida en la
                                        línea de comando.

  Move to Edge of	Mayúsculas+	Lleva el cursor al borde superior,
  Window		Flecha		inferior, izquierdo o derecho de la
                                        pantalla.

  Delete the Next	Ctrl+D		Borra el carácter de la posición
  Character                             actual del cursor. Lo mismo que
                                        pulsar Del.

  Delete the Previous	Ctrl+H		Borra el carácter que se encuentra a
  Character				la izquierda de la posición actual
                                        del cursor. Lo mismo que pulsar
                                        Retroceso.

  Move to Next Line	Ctrl+M		Inserta una nueva línea después de
                                        la posición actual del cursor, y
                                        lleva el cursor al principio de la
                                        última línea.

  Move x number of	Ctrl+F, Ctrl+B	Le permite mover el cursor hacia
  Characters                            adelante o hacia atrás un número
                                        determinado de caracteres. Si no se
                                        indica valor alguno, el cursor sólo
                                        se moverá un carácter.

@endnode

@NODE PersonalizaMEmacs "Personalización de MEmacs"

PERSONALIZANDO MEMACS

MEmacs busca el fichero Emacs_pro cuando se carga para ver si hay comandos
o ficheros locales que debería ejecutar automáticamente. Puede personalizar
el fichero Emacs_pro añadiendo al mismo comandos que use a menudo,
secuencias de comandos, o cadenas de texto. Si no existe todavía el
fichero Emacs_pro, puede crear uno.

Para crear un fichero global de comandos, coloque el fichero Emacs_pro en el
directorio S:. Los ficheros locales pueden ponerse en cualquier directorio.
Si ese directorio es el directorio actual cuando se carga MEmacs, los
comandos de ese fichero local en particular serán ejecutados.

Cuando hay un fichero Emacs_pro tanto local como global presente, el fichero
local tiene preferencia sobre el global.

Por ejemplo:

  Set Case On
  Set-Key F11 "Queridos señores:"
  Set-Key F12 "^S Workbench"
  Set-Key F13 "^X^B"

hace las siguientes asignaciones:

  Mayúsculas+F1		Introduce la cadena de texto "Queridos señores:".

  Mayúsculas+F2		Busca hacia adelante la siguiente ocasión en la que
			aparece la cadena de texto "Workbench" (el comando
			"Set Case On" hace que la búsqueda diferencie las
			letras minúsculas de las mayúsculas).

  Mayúsculas+F3		Muestra la lista de buffers.

Debe usar Ctrl+Q para introducir una secuencia Ctrl+tecla. Por ejemplo,
para introducir el carácter ^S mostrado en el ejemplo, deberá pulsar Ctrl+Q,
Ctrl+S.

@endnode

@NODE AdiósMEmacs "Saliendo de MEmacs"

SALIENDO DE MEMACS

Puede salir de MEmacs seleccionando la opción de menú "Quit" del menú
Project o pulsando Ctrl+C. MEmacs le permite salvar los buffers que hayan
sufrido cambios o salir sin realizar ninguna grabación.
@endnode

@NODE MiraEDIT "EDIT"

EDIT
----

EDIT es un editor de líneas diseñado para la edición automatizada de
ficheros, particularmente ficheros binarios que son mayores que la memoria
disponible. No puede crear un nuevo fichero con EDIT.

EDIT procesa ficheros línea a línea. Según EDIT se va moviendo por la
entrada o fichero fuente, cada línea pasa después de cada cambio al fichero
de salida secuencial, o fichero destino.

EDIT procesa las líneas de los ficheros hacia adelante; sin embargo, puede
moverse hacia atrás un número limitado de líneas. EDIT guarda las líneas en
un buffer de salida antes de escribirlas en el fichero destino. El tamaño de
este buffer depende de la cantidad de memoria disponible. Puede incrementar
el tamaño del buffer con las opciones OPT P y OPT W.

El formato para llamar a EDIT desde la línea de comando es:

  EDIT [FROM] <nombre de fichero> [[TO] <nombre de fichero>] [WITH <nombre
  de fichero>] [VER <nombre de fichero>] [OPT P <líneas> | W <caracteres> |
  P <líneas> W <caracteres>] [WIDTH <caracteres>] [PREVIOUS <líneas>]

El argumento FROM indica el fichero fuente a editar. Debe indicar un fichero
fuente para EDIT, aunque la palabra clave FROM es opcional.

El argumento TO indica el fichero destino al que EDIT enviará la salida,
incluyendo los cambios durante la edición. Si omite el argumento TO, EDIT
usará un fichero temporal. Este fichero temporal toma el nombre del fichero
fuente y sobreescribe este fichero cuando se completa la edición.

La palabra clave WITH indica un fichero que contiene comandos de edición.

La palabra clave VER indica el fichero al que EDIT enviará mensajes de error
y verificaciones de línea. Si no se da el argumento VER, EDIT usará la
pantalla para esto.

Use OPT P <n> y OPT W <n> para indicar las opciones PREVIOUS y WIDTH. Sin
embargo, no use la palabra clave OPT junto con PREVIOUS y WIDTH.

Puede usar las opciones PREVIOUS y WIDTH para incrementar o disminuir la
cantidad de memoria disponible. La opción PREVIOUS ajusta el número de
líneas previas disponibles para EDIT según el valor entero <n>. La opción
WIDTH ajusta el número máximo de caracteres que se permiten en cada línea
según el valor <n>. EDIT multiplica el número de líneas previas por el
número máximo de caracteres (PREVIOUS * WIDTH) para determinar la memoria
disponible. Los valores por defecto son PREVIOUS 40 WIDTH 120.

@endnode

@NODE EjecutaEDIT "Ejecutando EDIT"

EJECUTANDO EDIT

Ejecute EDIT mediante el Shell usando el siguiente comando:

  1.> EDIT <nombre de fichero>

donde <nombre de fichero> es el nombre del fichero existente que quiere
editar.

@endnode

@NODE ComandosEDIT "Comandos de EDIT"

COMANDOS DE EDIT

La siguiente lista ofrece información importante sobre los comandos de EDIT:

  Línea actual		Se refiere a la línea en la que EDIT está trabajando
			en un momento dado. Cada comando introducido actúa
			sobre la línea actual, todos los cambios se hacen
			en la línea actual, y las nuevas líneas insertadas
			se colocan antes de la línea actual.

  Líneas originales	Las líneas del fichero fuente. Las líneas mantienen
			su número original hasta que las renumere con los
			comandos REWIND o =.

  Líneas no originales	Son las líneas que se insertan en el fichero fuente
			o las líneas originales que se dividen. Éstas no
			tienen un número de línea asignado.

  Verificación de línea	Cuando se utilizan comandos que cambian la
			información de una línea, EDIT muestra la línea
			revisada después de ejecutar el comando.

  Argumentos		Cadenas, cadenas clasificadas, números y valores
			usados con comandos de EDIT.

Puede introducir comandos de las tres formas siguientes:

- Introduciendo el comando y pulsando Return.

- Introduciendo el argumento final del comando y pulsando Return.

- Introduciendo un punto y coma (;) o un paréntesis de cierre ")".

Las convenciones para el texto que se usan en las descripciones de los
comandos son las siguientes:

- Los nombres de los comandos se muestran en mayúsculas, a pesar de que para
  EDIT es lo mismo que use mayúsculas que minúsculas.

- Los corchetes angulados indican que debe hacer una sustitución. Por
  ejemplo, <cadena> indica que el comando necesita un argumento de cadena.

- Una <n> representa un argumento numérico.

- Los corchetes rectos indican que el argumento es opcional. Por ejemplo,
  [<n>] indica que el comando puede llevar un argumento de forma opcional.

- Las barras inclinadas se usan como delimitador para las cadenas; use una
  barra inclinada (/) entre dos cadenas.

- Los puntos se usan como delimitadores para los nombres de fichero (las
  barras inclinadas no pueden utilizarse, ya que se usan para delimitar
  cadenas).

@endnode

@NODE LíneaActualEDIT "Selección de la línea actual"

Selección de la línea actual

Los siguientes comandos le permiten moverse por el fichero y seleccionar la
línea actual.

  Moverse a un número	M <n>		Indique una nueva línea actual
  de línea concreto			introduciendo su número de línea,
                                        un espacio, y un asterisco como
					argumento de M. Sólo puede accederse
					a las líneas originales por su número
					de línea.

  Moverse a la 		N		Se mueve hacia adelante una línea.
  siguiente línea del			Introduciendo un número y N indicará
  fichero fuente			el número de líneas a adelantar.
                                        Cuando se usa como la última línea
                                        del fichero fuente, EDIT crea una
                                        línea extra al final del fichero. Si
                                        ya está en esta línea extra, usar
                                        N hace que se muestre un mensaje de
                                        error.

  Moverse a la línea	P		Se mueve hacia atrás una línea.
  anterior del fichero			Introduciendo P repetidas veces se
  fuente                                irá moviendo línea a línea. Si
                                        introduce un número y luego P,
                                        indicará cuántas líneas quiere ir
                                        hacia atrás. Sólo puede ir hacia
					atrás a líneas que todavía no han
					sido escritas en el fichero destino.
					El valor por defecto es de 40 líneas,
                                        pero este valor puede modificarse
                                        con la opción PREVIOUS.

  Buscar		F <cadena>	Le permite seleccionar una línea
                                        actual especificando parte de su
                                        contenido.

  Buscar hacia		B,F <cadena>	Busca hacia adelante partiendo de
  adelante				la línea actual en el fichero fuente
                                        una línea que contenga la cadena
                                        indicada.

@endnode

@NODE EditaLíneaActualEDIT "Edición de la línea actual"

Edición de la línea actual

Los siguientes comandos añaden nueva información o sustituyen información
en la línea actual.

  Insertar <cadena2>	A <cadena1>	Inserta <cadena2> inmediatamente
  después de <cadena1>	<cadena2>	después de encontrar <cadena1>.

  Insertar <cadena2>	B <cadena2>	Inserta <cadena2> inmediatamente
  antes de <cadena1>	<cadena1>	antes de encontrar <cadena1>.

  Cambiar <cadena2>	E <cadena2>	Sustituye la primera aparición de
  por <cadena1>		<cadena1>	<cadena1> por <cadena2>.

@endnode

@NODE InsDelLíneasEDIT "Inserción y borrado de líneas"

Inserción y borrado de líneas

Los siguientes comandos insertan nueva información (líneas no originales)
y borran líneas en el fichero fuente. También puede insertar ficheros
enteros en el fichero fuente.

  Insertar una o más	I [<n>]		Si se indica el comando solo o con
  líneas                                un número de línea, inserta texto
                                        antes de la línea actual.

                                        Si se indica con un asterisco, el
                                        texto se inserta al final del
                                        fichero.

                                        Indique el final de la inserción
                                        pulsando Return, Z y Return.

  Borrar una o más	D [<n>]		Borra la línea actual si se introduce
  líneas                                sin argumentos. Borra una línea
                                        concreta si se introduce con un
                                        número de línea. Borra un conjunto
                                        de líneas si se indica una gama de
                                        líneas; en este caso, no utilice
                                        signos de puntuación entre los
                                        números. Este comando también borra
                                        desde la línea actual hasta el final
                                        del fichero fuente si se introduce
                                        con un espacio y un asterisco como
                                        argumentos.

  Borrar todas las	D,F <cadena>	Borra todas las líneas del fichero
  líneas hasta que			fuente hasta que aparece una línea
  aparezca la cadena			que contiene la cadena indicada. Si
  indicada				no se indica ningún argumento, borra
                                        todas las líneas hasta que encuentra
                                        la última cadena indicada.

  Borrar las líneas	R [<n>]		Le permite borrar líneas y luego
  existentes y  			insertar otras nuevas. Si introduce
  sustituirlas por			un número de línea después de la R,
  nuevo texto				indicará el número de línea concreto
                                        que quiere sustituir.

  Cambiar el 		Z <cadena>	Le dice a EDIT que ha alcanzado el
  terminador                            final del nuevo texto que se ha
                                        insertado. Introduciendo una cadena
                                        después de la Z usará este valor
                                        en lugar del que se utiliza por
                                        defecto.

  Mostrar información	S,H,D		Muestra valores sobre la información
  actual sobre EDIT			grabada, como la última cadena
                                        buscada, el último comando
                                        introducido y el terminador de
					entrada.

  Activar/Desactivar	T,R, +|-	Preserva los espacios en blanco que
  los espacios finales			haya al final de las líneas.

@endnode

@NODE VentanasEdicEDIT "Ventanas de edición de líneas"

Ventanas de edición de líneas

Puede definir sub-secciones de la línea, llamadas ventanas de línea, en las
que EDIT ejecute todos los comandos indicados después. En las descripciones
de los calificadores de EDIT, el comienzo de la línea indica siempre el
comienzo de la ventana de línea.

Siempre que EDIT verifica una línea actual, indica la posición de la ventana
de línea mostrando un carácter ">" directamente por encima de la línea. EDIT
omite el puntero si la ventana de línea comienza al principio de la línea.

Los siguientes comandos controlan la posición de puntero de caracteres:

  >			Lleva el puntero un carácter a la derecha.

  <			Lleva el puntero un carácter a la izquierda.

  PR			Resetea el puntero al comienzo de la línea.

  PA <cadena>		Lleva el puntero hasta el primer carácter antes de
                        la cadena indicada.

Los siguientes comandos cambian el carácter que se encuentra en la posición
del puntero y luego mueven el puntero:

  $			Convierte el carácter de la posición del puntero en
			minúscula, y luego mueve el puntero un carácter a la
			derecha.

  %			Convierte el carácter de la posición del puntero en
			mayúscula, y luego mueve el puntero un carácter a la
			derecha.

  _			El comando _ (subrayado) borra el carácter de la
			posición del puntero, convirtiéndolo en un espacio,
			y luego mueve el puntero un carácter a la derecha.

  #			Borra el carácter de la posición del puntero y luego
			mueve el resto de la línea un carácter a la
			izquierda. Para borrar varios caracteres, indique
			un número antes del signo #. Por ejemplo, 5# borra
			los siguientes cinco caracteres de la ventana.

Puede utilizarse una combinación de estos comandos para editar una línea
carácter a carácter.

Los siguientes comandos insertan y cambian texto en la línea actual, de
forma similar a los comandos A, B y E; sin embargo, el puntero de caracteres
se mueve de otra forma.

  Insertar <cadena2>	A,P <cadena1>	Inserta <cadena2> después de
  después de <cadena1>	<cadena2>	encontrar <cadena1>. El puntero se
                                        coloca entonces después de <cadena2>.

  Insertar <cadena2>	B,P <cadena1>	Inserta <cadena2> antes de encontrar
  antes de <cadena1>	<cadena2>	por primera vez <cadena1>. El
                                        puntero se coloca entonces después
                                        de <cadena2>.

  Cambiar <cadena1>	E,P <cadena1>	Sustituye la primera ocasión en la
  por <cadena2>		<cadena2>	que aparece <cadena1> por <cadena2>.
                                        El puntero entonces se coloca
                                        después de <cadena2>.

  Borrar todo después	D,T,A		Borra todo el texto desde el
			<cadena>	comienzo de la línea o desde el
                                        puntero de caracteres hasta el final
					de la cadena especificada.

  Borrar todo antes	D,T,B		Borra todo el texto desde el
			<cadena>	comienzo de la línea o el puntero
					de caracteres; se detiene al
					encontrar la cadena especificada.

  Borrar desde después	D,F,A		Borra todo el texto comenzando desde
			<cadena>	la cadena especificada hasta el
                                        final de la línea.

  Borrar desde antes	D,F,B		Borra todo el texto partiendo de la
			<cadena>	cadena especificada y hasta el final
                                        de la línea.

@endnode

@NODE PlisPlasLíneasEDIT "Dividiendo y uniendo líneas"

Dividiendo y uniendo líneas

Estos comandos dividen una línea en más de una y también juntan una o más
líneas sucesivas.

  Dividir línea antes	S,B <cadena>	Divide la línea actual antes de la
  de <cadena>				cadena especificada. La primera
                                        parte de la línea se envía al buffer
                                        de salida, mientras que la segunda
                                        parte se convierte en una línea
                                        actual no original. Los calificadores
                                        se usan para restringir el contexto
                                        de la cadena.

  Dividir la línea	S,A <cadena>	Divide la línea actual después de la
  después de <cadena>			cadena indicada. La primera parte de
                                        la línea se envía al buffer de
                                        salida; el resto de la línea se
                                        convierte en la nueva línea actual.
                                        Los calificadores se usan para
					restringir el contexto de la cadena.

  Unir dos líneas	C,L [<cadena>]	Une la línea actual con la siguiente
                                        línea del fichero fuente. El
                                        argumento de cadena es opcional; sin
                                        embargo, si se especifica una cadena,
                                        ésta se añade al final de la línea
                                        actual, y la línea completa se une a
					la siguiente línea del fichero
                                        fuente.

@endnode

@NODE RenumLíneasEDIT "Renumeración de líneas"

Renumeración de líneas

Estos comandos renumeran las líneas del fichero fuente para incluir líneas
no originales y para actualizar un fichero que ha sido editado.

  Renumerar líneas	= <n>		Ajusta el número de línea actual a
  fuente                                <n>. Todas las líneas siguientes,
                                        tanto originales como no originales,
                                        bajo <n>, se renumeran si acude a
                                        ellas.

  Volver al comienzo	REWIND		Se mueve hacia atrás por el fichero
  del fichero fuente			fuente para convertir la línea 1 en
                                        la línea actual. EDIT observa el
                                        resto del fichero fuente y escribe
                                        las líneas en el fichero destino.
                                        Este fichero se cierra y se vuelve
                                        a abrir como un nuevo fichero
                                        fuente. Las líneas no originales
                                        ahora se reconocen como líneas
                                        originales. Puede introducirse
					como REWI.

@endnode

@NODE VerificaLíneasEDIT "Verificación de líneas"

Verificando líneas

Estos comandos describen diferentes formas de verificar líneas.

  Activa/Desactiva la	V + | -		Activa o desactiva la verificación
  verificación				de las líneas. Si está desactivada,
                                        las líneas no se muestran en la
                                        pantalla. Para desactivarla,
					introduzca V -. Para activarla,
					introduzca V +.

  Verifica la línea	?		Verifica la línea actual mostrando
  actual				el número de línea y el contenido de
                                        la misma.

  Verifica la línea	!		Produce dos líneas de verificación.
  actual con				En la primera línea, todos los
  indicadores				caracteres no gráficos se sustituyen
  de caracteres                         con el primer carácter de su valor
                                        hexadecimal. En la segunda línea,
                                        se muestra un signo "-" bajo las
                                        posiciones de todas las letras
                                        mayúsculas y el segundo dígito
                                        hexadecimal corresponde a los
					caracteres no gráficos. Todas las
                                        demás posiciones contienen espacios.
					En ficheros binarios, los caracteres
					no gráficos se representan con signos
                                        de interrogación (?).

@endnode

@NODE InspecFuenteEDIT "Inspección del fichero fuente"

Inspección del fichero fuente

Estos comandos le permiten avanzar por el fichero fuente, enviando las
líneas por las que pase al fichero de verificación, así como a la salida
normal.

  Pasar <n> líneas	T <n>		Pasa el número de líneas indicado a
  a la pantalla                         la pantalla. La primera línea que se
                                        pase será la línea actual. Omitiendo
                                        la <n>, la operación seguirá hasta
                                        el final del fichero fuente. Puede
                                        interrumpir el comando con Ctrl+C.

  Pasar las líneas	T,P		Muestra las líneas que se encuentran
  al buffer de salida			actualmente en el buffer de salida.

  Pasar hasta que	T,N		Pasa desde la línea actual hacia
  EDIT haya				adelante, hasta que todas las líneas
  sustituido todas			del buffer de salida se hayan
  las líneas en el			sustituido. El contenido previo se
  buffer de salida                      envía al fichero destino.

  Pasar con números	T,L, <n>	Similar al comando T. Pasa un
  de línea				determinado número de líneas,
                                        mostrando los números de línea.
					EDIT muestra "++++" para indicar
					las líneas insertadas o divididas,
					ya que éstas no tienen números de
					línea.

@endnode

@NODE CambiosGlobalesEDIT "Haciendo cambios globales"

Haciendo cambios globales

Estos comandos comienzan y finalizan los cambios globales. Los cambios
globales tienen lugar automáticamente cuando EDIT escanea el fichero fuente
hacia adelante. Estos comandos activan automáticamente un comando A, B ó E
(el que convenga) con cualquier ocurrencia de <cadena1> en una nueva línea
actual. También se aplican a la línea actual que está en efecto cuando se
llama al comando.

  GA [calificador] <cadena1> <cadena2>
  GB [calificador] <cadena1> <cadena2>
  GE [calificador] <cadena1> <cadena2>

Por ejemplo, si quiere cambiar DF0: por DF2: para un fichero entero,
introduzca:

  GE /DF0:/DF2:/

  Cancelar un comando	CG [<número de	Cancela un comando global. El número
  global              identificación>]  de identificación dado con un
	              			comando GA, GB o GE se envía al
                                        fichero de identificación o a la
                                        pantalla si EDIT es interactivo.
                                        Si no indica ningún argumento,
					todas las operaciones globales serán
					canceladas. Para cancelar una
					operación concreta, introduzca el
					número de identificación después
					del comando CG.ver

  Suspender un comando	SG [<número de	Suspende un comando global. Todas
  global	      identificación>]	las operaciones globales se
		  			suspenden si no se indica ningún
                                        argumento. Introduzca el número de
                                        identificación para suspender una
                                        operación concreta.

  Activar un comando	EG [<número de	Continúa una operación global que
  global	      identificación>]	había sido suspendida con el comando
					SG. A menos que se indique un número
                                        de identificación específico, se
                                        activarán todos los comandos
                                        globales.

  Mostrar los comandos	SHG		Muestra los comandos globales
  globales				actuales y sus números de
                                        identificación. También indica el
					número de veces que cada cadena
					global fue encontrada.

@endnode

@NODE CEDIT "Cambiando ficheros de comandos, de entrada y de salida"

Cambiando ficheros de comandos, de entrada y de salida

Estos comandos cambian la configuración de los ficheros cuando carga EDIT
desde Shell. Estos ficheros son:

- el fichero de comandos; utilizado con la opción WITH.

- el fichero de entrada; el fichero fuente especificado con FROM.

- el fichero de salida; el fichero destino especificado con TO.

  Cambio del fichero	C <nombre de	Lee comandos de EDIT desde el fichero
  de comandos		fichero>	indicado. Delimite el fichero usando
                                        un carácter que no sea la barra
                                        inclinada (/), ya que el AmigaDOS
                                        usa estos caracteres para separar
                                        los nombres de fichero. Cuando todos
                                        los comandos del fichero indicado
                                        se hayan ejecutado, el fichero
                                        se cerrará. Puede introducir los
                                        comandos mediante el teclado.

  Cambio del fichero	FROM <nombre	Lee líneas de otro fichero fuente.
  de entrada		de fichero>	EDIT no cierra el fichero fuente
                                        original. Re-elija el fichero fuente
                                        introduciendo el comando FROM sin
                                        argumento. Para ver algunos ejemplos
                                        de cómo usar el comando FROM, mire
                                        la tabla que aparece más adelante.

  Cerrar un fichero	CF <nombre	Cierra el fichero destino que se
			de fichero>	indicó originalmente con el comando
                                        TO. Entonces puede abrir ese fichero
                                        como entrada. CF también puede
                                        cerrar un nuevo fichero de entrada
                                        que se abra. Para ver algunos
                                        ejemplos del uso del comando CF,
					mire la tabla que aparece más
					adelante.

  Cambio del fichero	TO <nombre	Indica un fichero diferente como
  de salida		de fichero>	fichero destino. El comando TO
                                        escribe las líneas del buffer
					existentes en el nuevo fichero TO.
					El nuevo fichero TO se usa hasta
					que se indique otro fichero. Re-elija
					el fichero destino original usando el
					comando TO sin argumento. El fichero
					de salida alternativo permanece
					abierto, pero no se usa. Para ver
					algunos ejemplos del comando TO, mire
					la tabla que aparece más adelante.

  Detiene la ejecución	Q		Hace que EDIT detenga la ejecución
  del fichero de			del fichero de comandos especificado
  comandos				con la palabra clave WITH o con el
                                        comando C. EDIT utiliza entonces
                                        cualquier fichero de comandos abierto
                                        anteriormente. Usar Q en el nivel
                                        más externo equivale a usar el
                                        comando W.

Los comandos FROM, CF y TO se usan de la forma siguiente:

-----------------------------------------------------------------------------
Comando				Acción
-----------------------------------------------------------------------------

M10				Pasa las líneas 1-9 del fichero fuente
				original al buffer de salida.

FROM .XYZ.			Selecciona el fichero XYZ como nueva
                                entrada; la línea 10 del fichero fuente
                                original sigue siendo la línea actual.

M6				Pasa la línea 10 del fichero original y
                                después pasa las líneas 1-5 del fichero XYZ
				al buffer de salida. La línea 6 de XYZ es la
                                nueva línea actual.

FROM				Re-elige el fichero fuente original.

M14				Pasa la línea 6 de XYZ, luego las líneas 11-
				13 del fichero fuente original al buffer de
				salida. La línea 14 del fichero fuente es la
				nueva línea actual.

FROM .XYZ.			Re-elige el fichero XYZ. La línea 14 del
				fichero fuente es todavía la línea actual.

M*				Pasa la línea 14 del fichero fuente y todas
				las líneas que queden en el fichero XYZ al
				buffer de salida. Se añade una línea extra
				al final del fichero XYZ. Esa línea será la
				nueva línea actual.

FROM				Re-elige el fichero fuente original. La
				línea extra añadida al fichero XYZ es
				todavía la línea actual.

CF .XYZ.			Cierra el fichero XYZ.

M*				Pasa las líneas que queden en el fichero
				fuente (las líneas de la 15 al final del
				fichero) al buffer de salida.

M11				Pasa las líneas 1-10 del fichero fuente al
				fichero destino original.

TO .XYZ.			Hace que XYZ sea el nuevo fichero de salida.

M21				Pasa las líneas 11-20 al fichero XYZ.

TO M31				Hace actual el fichero destino original, y
				pasa al mismo las líneas 21-30.

TO .XYZ.			Hace que XYZ sea el fichero de salida actual.

M41				Pasa las líneas 31-40 a XYZ.

TO				Hace actual el fichero destino original.

TO .XYZ.			Envía el buffer de salida al fichero XYZ.

1000N				Avanza por las siguientes 1000 líneas del
				fichero fuente.

TO				Selecciona el fichero destino original.

CF .XYZ.			Cierra el fichero XYZ.

I2000 .XYZ.			Inserta las 1000 líneas del fichero fuente
				que fueron enviadas al fichero XYZ de vuelta
                                al fichero fuente, por encima de la línea
                                2000.

@endnode

@NODE AdiósEDIT "Saliendo de EDIT"

SALIENDO DE EDIT

Estos comandos le permiten salir de EDIT.

  Salir grabando los	W	Sale de EDIT, grabando todos los cambios en
  cambios			el fichero destino indicado por TO. EDIT
				deja el sistema después de alcanzar el
				final de la fuente, cerrando todos los
				ficheros, y recuperando espacio libre de
				memoria. Si cargó EDIT sin indicar un
				fichero destino, el programa renombra el
				destino temporal con el mismo nombre que
				el fichero fuente original, que cambia su
				nombre por T:Edit-backup. Este backup está
				solamente disponible hasta la próxima vez
				que ejecute EDIT.

  Salir sin grabar	STOP	Detiene EDIT inmediatamente sin grabar los
  los cambios			cambios realizados en el fichero fuente.
				Evita que EDIT sobreescriba el fichero
				fuente original, asegurándose de que no
				se han realizado cambios en la información
				original de entrada.

@endnode

@NODE guiones "USANDO SCRIPTS"

				   Capítulo 5


				 USANDO SCRIPTS
				 ==============


Los ficheros script son ficheros de texto que contienen listas de comandos
para realizar tareas complicadas o repetitivas o para realizar la misma
operación sobre varios ficheros diferentes. Este capítulo incluye la
siguiente información sobre los ficheros script:

                          @{" Comprendiendo los scripts " link ComprendeScripts}

                     @{" Caracteres especiales en los scripts " link CaracEspecScripts}

                           @{" Comandos de los scripts " link ComandosScripts}

                            @{" Banderas condicionales " link BanderasCondicionales}

                        @{" Depuración de ficheros script " link DepuraScripts}

                         @{" Uso de variables de entorno " link UsaEnvVarScripts}

@endnode

@NODE ComprendeScripts "Comprendiendo los scripts"

COMPRENDIENDO LOS SCRIPTS
-------------------------

Un script es un fichero de texto que contiene una serie de comandos. El uso
de scripts es una forma de automatizar tareas complejas o repetitivas,
especialmente aquellas que necesite realizar regularmente. Un script puede
realizar virtualmente cualquier operación hecha normalmente a base de un
comando cada vez, incluyendo el trabajo con programas y ficheros de datos,
realización de cálculos y el funcionamiento interactivo, aceptando y
mostrando información. Básicamente, un script es un pequeño programa que
puede editarse fácilmente.

Para crear un script, siga estos pasos:

1. Cargue un editor de texto, como ED, que salve los ficheros en formato
   ASCII.

2. En el editor de texto, introduzca los comandos del script de forma
   secuencial, en el orden en el que se vayan a ejecutar.

3. Grabe el fichero. El directorio S: es el utilizado más habitualmente para
   los ficheros script, pero puede guardar un script en cualquier parte.

Luego puede ejecutar el script desde el Shell, introduciendo el comando
EXECUTE seguido por la senda completa del script.

NOTA: Puede evitar tener que usar el comando EXECUTE y la senda completa
      activando el bit de protección "s" del script. Introduzca el comando
      PROTECT <script> +s, indicando la senda completa del script. Cuando
      el bit "s" esté activado, sólo necesitará indicar el nombre del script
      para ejecutarlo.

@endnode

@NODE TiposDeScripts "Tipos de scripts"

TIPOS DE SCRIPTS

Hay varios tipos de scripts que puede utilizar en el Amiga, incluyendo
scripts de comandos AmigaDOS, scripts de comandos ARexx, y scripts de
comandos de ED. Para más detalles sobre cómo preparar scripts ARexx, mire
la "Guía del usuario de ARexx". Mire la sección que habla de @{"ED" link MiraED} para más
información sobre los scripts de comandos ED.
@endnode

@NODE CuándoUsarARexx "Cuándo usar ARexx"

Cuándo usar ARexx

Puede crear scripts tanto de AmigaDOS como ARexx en el Amiga. Estos scripts
no son mutuamente exclusivos; bajo AmigaDOS 2.0 y superior, los comandos
ARexx pueden aparecer en scripts AmigaDOS, y viceversa. Sin embargo, hay
ciertas tareas que pueden ser más apropiadas para un sistema u otro.

Al contrario que ARexx, el AmigaDOS no es un lenguaje de programación de
propósito general. El AmigaDOS está orientado hacia el manejo básico de
ficheros y tareas de configuración del sistema. ARexx está pensado para
realizar tareas más complejas que los procesos sencillos con ejecuciones
condicionales.
@endnode

@NODE ScriptsSencillos "Scripts sencillos"

Scripts sencillos

Un script puede ser algo tan simple como una serie de sendas, diciéndole al
Amiga que ejecute ciertos programas. Un fichero User-startup es un buen
ejemplo de un script sencillo. Puede añadir varios comandos de configuración
tales como la orden ADDBUFFERS a un script como éste sin preocuparse por si
afectará al flujo de los programas, o también podría usar algún control de
errores. Para más información sobre el fichero User-startup, mire el
apartado correspondiente del @{" apéndice D " link OtrosFicherosArranque}.
@endnode

@NODE ScriptsAutomáticos "Scripts automáticos"

Scripts automáticos

Puede generar scripts automáticamente usando el comando LIST. LIST tiene una
opción LFORMAT que le permite modificar su salida para incluir cualquier
texto que desee además de la salida normal de LIST. Este texto podría ser
un comando y algunas palabras clave, con el nombre de fichero LISTado
apareciendo como un argumento del comando. Si lista el contenido de un
directorio de esta forma, redireccionando la salida hacia un fichero, puede
construir automáticamente un script que aplique un comando al contenido de
ese directorio.

Cuando una operación sobre varios ficheros es demasiado complicada para ser
realizada por un sólo comando, use un script generado automáticamente para
ejecutar el comando sobre cada uno de los ficheros. Por ejemplo, una
operación que cambia de nombre una serie de ficheros, dando a sus nombres
una extensión común, no puede realizarse con un sólo comando RENAME. Mire la
sección @{"LIST" link list} del capítulo 6 para más información sobre la opción LFORMAT de
este comando y los @{"ejemplos del capítulo 8" link GeneraScriptsLFORMAT} para ver una ilustración de
esta técnica.
@endnode

@NODE CaracEspecScripts "Caracteres especiales en los scripts"

CARACTERES ESPECIALES EN LOS SCRIPTS
------------------------------------

El punto y coma, el apóstrofe inverso, el dólar, el doble dólar y el signo
de interrogación son caracteres especiales que se usan principalmente en los
scripts para añadir comentarios, ejecutar comandos desde el interior de las
cadenas, introducir variables de entorno, llamar al número de Shell actual
y aceptar la redirección de la entrada.


PUNTO Y COMA (;)

Los signos de punto y coma añaden comentarios a las líneas de comandos.
Todos los caracteres situados a la derecha de un punto y coma se ignoran,
lo que le permite colocar comentarios descriptivos en la misma línea que
contenga comandos AmigaDOS. Por ejemplo:

  ASSIGN T: RAM:t			; configura el directorio T:
                                        ; para scripts

Los comentarios pueden continuar en líneas adicionales si son demasiado
largos para caber en una línea. Las nuevas líneas deberán comenzar también
con un punto y coma y deberían empezar en el mismo punto del tabulador que
el comentario anterior para mayor claridad.


APÓSTROFE INVERSO (`)

El apóstrofe inverso se utiliza para ejecutar comandos desde dentro de una
cadena. Si se imprime una cadena que contiene un comando indicado entre
apóstrofes inversos, el comando se ejecutará automáticamente. Por ejemplo:

  1.> ECHO "La fecha y hora son: `date`"

imprime "La fecha y hora son: " y a continuación la salida del comando DATE.
Cuando un comando como DIR, que produce múltiples líneas en su salida, se
indica dentro de una orden ECHO, la salida no se formatea adecuadamente:
toda ella aparece en una sola línea.

NOTA: Los comandos que apelan al directorio actual no trabajan correctamente
      cuando son invocados desde dentro de una cadena con el apóstrofe
      inverso. Al usar el apóstrofe inverso, automáticamente se configura
      un sub-Shell reservado automáticamente para ese comando. Así pues, al
      llamar al directorio actual lo que se hace es llamar al directorio de
      ese sub-Shell.


DÓLAR ($)

El signo de dólar se usa de dos formas: como un operador que introduce una
variable de entorno (que también trabaja desde fuera de un script) y en una
orden indicada entre corchetes para separar el valor de una variable de un
valor por defecto.

Por ejemplo, con una variable de entorno:

  1.> ECHO "Versión del Kickstart actual: $Kickstart"
  Versión del Kickstart actual: 39.106

Como un separador por defecto en un script:

  COPY otra.librería TO <LIBS:$LibreríaUsuario>

Puede cambiar el carácter que ofrece esta función; es decir, en lugar del
signo del dólar puede hacer uso de otro diferente usando la palabra clave
para scripts .DOLLAR.


DOBLE DÓLAR ($$)

Un signo de doble dólar entre corchetes (<$$>) sustituye al número de
proceso actual. Puede referirse al número de Shell actual mediante la cadena
de caracteres <$$>, incluyendo siempre los corchetes, ya que siempre
devuelve el número de proceso actual en forma de cadena. Cuando cree ficheros
temporales en un entorno multitarea, es esencial que estos ficheros tengan
nombres únicos de forma que ningún proceso interfiera con otro. Añadiendo
la cadena <$$> a los nombres de fichero creará nombres únicos para ficheros
temporales, asignaciones lógicas y PIPEs. Se necesita una orden .KEY en
cualquier script que use <$$>. .KEY se describe en el apartado titulado
@{"Permitiendo argumentos" link PermiteArgumentosScripts}. Para evitar conflictos con los argumentos de
redirección, los corchetes de las cadenas <$$> pueden redefinirse usando los
comandos .BRA y .KET. Los comandos .BRA y .KET se describen también en el
apartado @{"Permitiendo argumentos" link PermiteArgumentosScripts}.


SIGNO DE INTERROGACIÓN (?)

El signo de interrogación, cuando se usa como un argumento separado en un
comando, hace que el comando acepte la redirección de entrada.

@endnode

@NODE ComandosScripts "Comandos de los scripts"

COMANDOS DE LOS SCRIPTS
-----------------------

Cualquier comando AmigaDOS puede utilizarse en un script. Sin embargo, hay
algunos comandos que se usan SÓLO en los scripts. Puede hacer lo siguiente
con los comandos de script:

- Sustitución de parámetros

- Introducir argumentos en la línea de comando

- Redirección de Entrada/Salida

- Especificar cadenas por defecto

- Introducir comentarios

- Anidar comandos en los scripts

- Crear scripts interactivos

- Crear scripts que repiten comandos

@endnode

@NODE ComandosSóloScripts "Comandos específicos de los scripts"

COMANDOS ESPECÍFICOS DE LOS SCRIPTS

Los siguientes comandos normalmente sólo se usan en los scripts:

-----------------------------------------------------------------------------
Comando de script	Significado
-----------------------------------------------------------------------------

@{"ASK" link Ask}			Pedir una respuesta del usuario.

@{"ECHO" link Echo}			Imprimir una cadena de texto.

@{"ELSE" link Else}			Permitir una alternativa en un bloque condicional.

@{"ENDIF" link EndIf}			Terminar un bloque IF.

@{"ENDSKIP" link EndSkip}		Terminar un bloque SKIP.

@{"EXECUTE" link Execute}		Ejecutar un script con una sustitución de argumentos
			opcional.

@{"FAILAT" link Failat}			Ajustar la condición de fallo de un script.

@{"IF" link If}			Manejar las operaciones condicionales.

@{"LAB" link Lab}			Especificar una etiqueta; se usa con SKIP.

@{"QUIT" link Quit}			Especifica un código de retorno y sale de un script.

@{"REQUESTCHOICE" link RequestChoice}		Permite a los scripts de AmigaDOS y ARexx usar los
			requesters del sistema para pedir información al
			usuario.

@{"REQUESTFILE" link RequestFile}		Permite a los scripts AmigaDOS y ARexx usar el
			requester de ficheros del sistema.

@{"SKIP" link Skip}			Saltarse la ejecución de una parte del script hasta
			alcanzar una etiqueta determinada.

@{"WAIT" link Wait}			Esperar el tiempo indicado.

@endnode

@NODE ComandosPunto "Comandos de tipo .comando"

COMANDOS DE TIPO .COMANDO

Los comandos de tipo .comando son palabras clave que comienzan con un punto
y que se usan solamente en scripts. Las líneas con comandos especiales de
este tipo incluidas en su script pueden indicar lugares en los que se
realiza una sustitución de parámetros. Introduzca estos parámetros como
argumentos del comando EXECUTE. La siguiente tabla lista los comandos de
tipo .comando.

-----------------------------------------------------------------------------
Comando			Significado
-----------------------------------------------------------------------------

.KEY			Sintaxis de argumento que se emplea para indicar
			el formato de los argumentos; puede usarse la
			abreviatura .K. Separe los argumentos de .KEY con
			comas. No use espacios. Mire el apartado con el
			nombre @{"Permitiendo argumentos" link PermiteArgumentosScripts} para más información
			sobre el uso de .KEY.

.DOT <ch>		Cambia el carácter de .punto por <ch>, donde <ch> es
			el carácter que es sustituido.

.BRA <ch>		Cambia el carácter de apertura de corchete (<) por
			el indicado en <ch>.

.KET <ch>		Cambia el carácter de cierre de corchete (>) por el
			indicado en <ch>.

.DOLLAR <ch>		Cambia el carácter usado por defecto de $ por <ch>;
			puede abreviarse con .DOL.

.DEF <palabra clave>	Da un valor por defecto al parámetro.
 <valor>

.<espacio>		Línea de comentario. Asegúrese de incluir un espacio
			después del punto para evitar que ocurra un error.
			Fijese en que el mejor método para introducir
			comentarios es usar el punto y coma (;).

.			Línea de comentario en blanco. Asegúrese de que no
			hay nada más en la línea con el punto para evitar
			producir un error.

Cuando emplea EXECUTE para ejecutar un script, el AmigaDOS busca la primera
línea del script. Si comienza por un comando con punto, el AmigaDOS busca
en el script las sustituciones de los parámetros descritas anteriormente y
construye un fichero temporal en el directorio T:. Si el fichero no comienza
por un comando con punto, el AmigaDOS asume que no es necesaria una
sustitución de parámetros, y comienza a ejecutar el fichero inmediatamente
sin copiarlo a T:. Dado que los comandos con punto necesitan accesos a disco
extra e incrementan el tiempo de ejecución, no los utilice si no necesita
hacer una sustitución de parámetros.

@endnode

@NODE PermiteArgumentosScripts "Permitiendo argumentos"

Permitiendo argumentos

La palabra clave .KEY (o .K) indica tanto nombres de palabra clave como
posiciones en la línea de comando. Ordena ejecutar un número de parámetros y
enseña cómo interpretarlos. Sólo una orden .KEY está permitida en un script;
de estar presente, debería ser la primera línea del fichero. Cualquier
script que contenga <$$> debe también contener una orden .KEY.

Los argumentos de la línea .KEY pueden darse con las directivas /A y /K, que
funcionan del mismo modo que en la sintaxis del AmigaDOS (la @{"sintaxis" link SintaxisComandos} se
describe en el apartado 6). Son imprescindibles los argumentos seguidos por
/A; los argumentos seguidos por /K necesitan el nombre de ese argumento como
palabra clave. Use comas para separar varios argumentos en la línea .KEY,
no espacios.

Por ejemplo, si un script comienza con una orden .KEY NombreFichero/A, esto
significa que deberá indicarse un nombre de fichero en la línea de comando
EXECUTE después del nombre del script. Este nombre de fichero se utiliza en
sucesivas líneas del script. Por ejemplo, si tiene un script llamado Texto
y su primera línea es:

  .KEY NombreFichero/A,TO/K

deberá especificar una variable de nombre de fichero. La variable TO es
opcional, pero, si la indica, deberá usar también la palabra clave TO.
Lo que sigue es una forma válida de ejecutar el script Texto:

  1.> EXECUTE Texto Fichero1 TO FicheroNuevo

@endnode

@NODE SustituciónEnScripts "Sustitución"

Sustitución

Antes de la ejecución, el AmigaDOS busca por el script cualquier cosa
encerrada entre los caracteres .BRA y .KET (por defecto, < y >). Tales cosas
serían una palabra clave o una palabra clave y un valor por defecto. EXECUTE
intenta sustituir un parámetro cuando encuentra una palabra clave encerrada
entre corchetes angulados. Sin embargo, si quiere usar una cadena en su
fichero script que contenga corchetes angulados o si su script usa este tipo
de corchetes para la redirección de entrada o salida, deberá definir un
sustituto para estos corchetes con los comandos .BRA y .KET. .BRA <ch> cambia
el carácter de apertura de corchete por <ch>, mientras que .KET <ch> cambia
el carácter del corchete de cierre por <ch>.

Por ejemplo, el siguiente script, llamado Demo, usa estas líneas:

  .KEY NombreFichero
  ECHO "Esta línea NO imprime corchetes <angulados>."
  .BRA {
  .KET }
  ECHO "Esta línea SÍ imprime corchetes <angulados>."
  ECHO "El nombre de fichero es {NombreFichero}."

  1.> EXECUTE Demo FicheroPrueba

y el script produce la siguiente salida:

  Esta línea NO imprime corchetes angulados.
  Esta línea SÍ imprime corchetes <angulados>.
  El nombre de fichero es FicheroPrueba.

La primera orden ECHO hace que el AmigaDOS busque una variable para
sustituir el parámetro <angulados>. Como no se nombra ningún argumento
llamado "angulados" en la línea de comando EXECUTE, se utiliza una cadena
vacía. Los comandos .BRA y .KET le dicen al script que use llaves en lugar
de los corchetes angulados para rodear a los parámetros. Cuando se ejecuta
la segunda orden ECHO, los corchetes angulados -una vez eliminado su
carácter especial- se imprimen como texto corriente. La tercera orden ECHO
demuestra que ahora las llaves funcionan como lo hacían antes los corchetes
angulados.

Redefina los corchetes angulados de <$$> siempre con .BRA y .KET para evitar
conflictos con la redirección.

@endnode

@NODE DefaultValuesScripts "Valores por defecto"

Valores por defecto

Cuando indica una palabra clave entre caracteres corchete, también puede
indicar una cadena que se use por defecto si no se especifica una variable
en la línea de comando. Los valores por defecto se indican de dos formas:
cada vez que haga llamadas a un parámetro o usando el comando .DEF.

Si indica el valor por defecto haciendo referencia a un parámetro, deberá
separar las dos cadenas con un signo de dólar ($).

Por ejemplo, en la siguiente orden:

  ECHO "<Pal1$defPal1> es el valor por defecto de Pal1."

defPal1 es el valor por defecto especificado por Pal1. Se imprime si no se
da otra variable para Pal1. Sin embargo, si quiere indicar ese valor por
defecto varias veces en un script, deberá usar <Pal1$defPal1> cada vez.

La definición de un valor por defecto usando el comando .DEF le permite
indicar un valor por defecto para cada palabra clave especificada. Por
ejemplo:

  .DEF Palabra1 "ValorPalabra1"

asigna ValorPalabra1 como el valor por defecto del parámetro Palabra1 para
el resto del script. La siguiente orden:

  ECHO "<Palabra1> es el valor por defecto de Palabra1."

hace aparecer la misma información que la orden ECHO anterior:

  Palabra1 es el valor por defecto de Palabra1.

El comando .DOLLAR <ch> le permite cambiar el carácter utilizado por defecto
de $ por <ch> (también puede usar .DOL <ch>). Por ejemplo:

  .DOL #
  ECHO "<Pal1#DefPal1> es el valor por defecto de Pal1."

@endnode

@NODE ComentariosScripts "Comentarios"

COMENTARIOS

También puede incluir comentarios en un script indicándolos después de un
signo de punto y coma (;) o introduciendo un punto (.) seguido por un
espacio y luego el comentario. Las líneas en blanco se aceptan, aunque son
ignoradas en los scripts.

NOTA: Le recomendamos que use el método del punto y coma al introducir
      comentarios para evitar los errores que aparecerían si se olvidase
      de incluir el espacio después del punto.
@endnode

@NODE NestedComScripts "Comandos anidados"

COMANDOS ANIDADOS

El AmigaDOS ofrece algunos comandos que pueden utilizarse en los scripts,
como IF, ELSE, SKIP, LAB y QUIT. Estos comandos, así como el comando
EXECUTE, pueden anidarse en el script.

Para detener la ejecución de un script que esté funcionando, pulse Ctrl+D.
Si ha anidado ficheros script, también puede detener el o los comandos
EXECUTE pulsando Ctrl+C.


Ejemplo 1:

Supongamos que el script "Imprime" contiene lo siguiente:

  .KEY fichero
  RUN COPY <fichero> TO PRT: +
  ECHO "Impresión de <fichero> finalizada."

El siguiente comando:

  EXECUTE Imprime Prueba2

responde como si hubiese introducido los siguientes comandos desde el
teclado:

  1.> RUN COPY Prueba2 TO PRT: +
  ECHO "Impresión de Prueba2 finalizada."

Fíjese en el uso del signo de suma (+) al final de la primera línea. Si
pulsa Return después del signo de suma, el comando RUN también ejecuta el
comando de la segunda línea cuando el primer comando haya finalizado.


Ejemplo 2:

Otro ejemplo, "Muestra", usa más funciones que las descritas en el ejemplo
anterior:

  .KEY fichero/A
  IF EXISTS <fichero>
    TYPE <fichero> NUMBER	; si el fichero está en el directorio señalado,
  				; lo muestra con los números de línea
  ELSE
    ECHO "<fichero> no está en este directorio"
  ENDIF

El comando:

  1.> EXECUTE Muestra Work:fichero5

muestra en pantalla el fichero Work:fichero5, con los números de línea
incluidos, si el fichero Muestra está en el directorio actual. Si el
fichero no está en él, aparecerá en pantalla un mensaje de error. La /A
requiere que se indique un nombre de fichero en la línea de comando después
de Muestra; de lo contrario, ocurrirá un error.

@endnode

@NODE ScriptsInterac "Ficheros script interactivos"

FICHEROS SCRIPT INTERACTIVOS

Puede crear scripts que se detengan para pedir información al usuario antes
de continuar. Los comandos @{"REQUESTCHOICE" link RequestChoice} y @{"REQUESTFILE" link RequestFile} para la creación de
requesters Amiga estándar le permiten usar el entorno Workbench para pedir
una respuesta al usuario. Esto puede dar lugar a condiciones variables en un
sencillo script. Por ejemplo, el siguiente script copia seis ficheros de un
disco duro a un disco flexible. Una vez que se han copiado los seis
ficheros, el script pide confirmación para continuar la copia, dando así
tiempo para insertar un nuevo disco flexible en la disquetera si es
necesario.

  COPY 2k.eps DF0:
  COPY 2m.eps DF0:
  COPY 2n.eps DF0:
  COPY 2o.eps DF0:
  COPY 2t.eps DF0:
  COPY 2v.eps DF0:
  ECHO "Copiados los ficheros del capítulo 2."
  ASK "¿ Quiere continuar copiando ?"
  IF WARN
    COPY 3a.eps DF0:
    COPY 3c.eps DF0:
    COPY 3g.eps DF0:
    COPY 3aa.eps DF0:
    COPY 3bb.eps DF0:
    COPY 3ff.eps DF0:
  ENDIF

En el requester "¿ Quiere continuar copiando ?", introduzca Y para copiar
el resto de ficheros al disco que haya en DF0:. Pulse N o Return para
finalizar el proceso de copia.

@endnode

@NODE RepComandosScripts "Repetición de comandos"

REPETICIÓN DE COMANDOS

Puede crear scripts que repitan el mismo comando, utilizando un nombre de
fichero diferente en cada línea de comando. Por ejemplo, para cambiar de
nombre ocho ficheros en una sola operación, podría crear el siguiente
script:

  RENAME sección1 capítulo1.1
  RENAME sección2 capítulo1.2
  RENAME sección3 capítulo1.3
  RENAME sección4 capítulo1.4
  RENAME sección5 capítulo1.5
  RENAME sección6 capítulo1.6
  RENAME sección7 capítulo1.7
  RENAME sección8 capítulo1.8

Este ejemplo asume que los ficheros se encuentran en el directorio actual de
Shell; si no es éste el caso, deberá especificar la senda completa para cada
fichero.

Los scripts como éste pueden a menudo generarse automáticamente usando la
opción @{"LFORMAT" link GeneraScriptsLFORMAT} del comando LIST.

@endnode

@NODE FinalizaScripts "Finalización de un script"

FINALIZACIÓN DE UN SCRIPT

En general, los scripts terminan cuando han acabado de ejecutar todos los
comandos que contienen. Los códigos de retorno avisan de si los comandos
ejecutados hicieron sin problemas su trabajo o si fallaron. Puede incluir
un comando @{"QUIT" link QUIT} en el script para hacerlo terminar, pero a menos que quiera
que el script termine automáticamente al producirse una determinada
condición, no es necesario incluir el comando QUIT. También puede detener
un script pulsando Ctrl+D en la ventana desde la que se está ejecutando.
@endnode

@NODE BanderasCondicionales "Banderas condicionales"

BANDERAS CONDICIONALES
----------------------

Las banderas condicionales indican la condición bajo la que un comando en
particular deja de funcionar. Cuando se ejecutan comandos, los códigos de
retorno avisan de si éstos cumplieron su trabajo o si fallaron. Los códigos
de retorno estándar son:

  0		El comando funcionó bien.

  5		Representa un aviso de precaución. Por ejemplo, indica que
		ha ocurrido algún tipo de error, pero que este error no ha
		tenido la suficiente importancia como para interrumpir el
		comando. Si el comando es parte de un script, se ejecutarán
		los comandos que le sucedan. Hay varios comandos que ajustan
		la bandera de condición a WARN para indicar que un comando
		no ha producido error alguno.

  10		Representa un error. Un código de retorno de 10 interrumpe
		un script, a menos que se haya dispuesto un límite superior
		con el comando @{"FAILAT" link failat}.

  20		Representa un fallo importante.

Algunas aplicaciones pueden devolver valores diferentes a éstos. En estos
casos, los valores indicados arriba se consideran como límites bajos de la
condición específica, de la forma siguiente:

  0-4		Sin error

  5-9		Aviso

  10-19		Error

  20 o más	Fallo importante

Algunos comandos, como ASK y SEARCH, usan la bandera WARN para señalar
ciertas condiciones al probar scripts.

Por ejemplo, en el script de ejemplo que se presenta en el apartado llamado
@{"Scripts interactivos" link ScriptsInterac}, el comando ASK pide confirmación para continuar la
copia:

  ASK "¿ Quiere continuar copiando ?"
  IF WARN
    COPY 3a.eps DF0:

Pulsando Y, la bandera de condición se pone a 5 (WARN, aviso), permitiendo
que se ejecute el bloque IF. Pulsando N o Return, la bandera de condición
se pone a 0 (Sin error), interrumpiendo el script porque la orden IF no
recibe el código de retorno indicado.

@endnode

@NODE DepuraScripts "Depuración de ficheros script"

DEPURACIÓN DE FICHEROS SCRIPT
-----------------------------

Si un script de comandos falla, tal vez aparezca uno de los siguientes
mensajes de error:

  <comando>: comando desconocido

Esto ocurre cuando ha introducido un comando que el sistema no reconoce.

  <comando> failed returncode 20

Esto ocurre cuando los argumentos de un comando no se han introducido
correctamente. Introduzca WHY en el prompt inmediatamente después de
haberse producido el error para tener más información sobre el mismo.

Si aparece un error, use un editor de texto (ED, MEmacs o un procesador de
textos que pueda grabar ficheros ASCII) para corregir la línea que contiene
ese comando.

Insertar la línea SET ECHO ON en un script ayuda a encontrar errores. Esta
orden hace que las siguientes líneas de comando aparezcan en la pantalla
según se van ejecutando. Los mensajes de error se imprimen después de que el
sistema haya intentado ejecutar el comando que produce el error. Para anular
la orden SET ECHO, introduzca esta otra: SET ECHO OFF o borre la línea SET
ECHO ON.

@endnode

@NODE UsaEnvVarScripts "Usando variables de entorno"

USO DE VARIABLES DE ENTORNO
---------------------------

Las variables de entorno se usan en los scripts para guardar información
de estado y de cadena. Las variables pueden sustituir a cadenas que son
demasiado largas o aburridas de teclear. Cambiar el valor de la variable
es más sencillo que reeditar el script cuando cambia el valor de la cadena.

Las variables de entorno son guardadas siempre por el AmigaDOS, y no se
pierden como lo hace un programa cuando hace que salga del sistema. Estas
variables están disponibles para ser utilizadas por diferentes programas o
scripts. Cuando se encuentra en un script el nombre de una variable
precedido inmediatamente por un signo de dólar ($), el nombre de la
variable es sustituido por el valor asignado a dicha variable. Entonces
la línea se ejecuta como si hubiese tecleado en ese momento el valor
completo de la variable.

Por ejemplo, el AmigaDOS mantiene las variables Workbench y Kickstart,
que guardan los números de versión actuales de sus sistemas Workbench y
Kickstart. Si ejecuta la línea siguiente, se indicará el número de versión
del Workbench:

  ECHO "Disco Workbench del Amiga. Versión número $Workbench"

Algunas variables, como las mencionadas Workbench y Kickstart, ya están
creadas. El Shell responde a la variable ECHO y mantiene automáticamente
los valores de las variables locales PROCESS, RC y RESULT2. A continuación
se explican estas variables:

  ECHO			Cuando el valor de esta variable es ON, los comandos
			se presentan en la pantalla cuando son ejecutados.
			Cuando es OFF (el valor por defecto), los comandos
			no se muestran en la pantalla.

  PROCESS		Guarda el número del proceso CLI actual.

  RC			Guarda la bandera condicional de código de retorno
			del último comando ejecutado (0, 5, 10 o 20). Esta
			variable se usa a menudo en scripts.

  RESULT2		Guarda el código de retorno secundario, o número de
			error, que explica por qué falló un comando.

Por ejemplo, si incluye el comando SET ECHO ON al principio de un script,
cada línea del script se mostrará en la pantalla cuando se ejecute.

Cuando a una variable de entorno se le da un valor numérico, la variable
puede utilizarse en cálculos y expresiones. Por ejemplo, si asigna el valor
9 a una variable llamada Nueve, use $Nueve en las expresiones @{"EVAL" link Eval}. Por
ejemplo:

  1.> SETENV Nueve 9
  2.> EVAL 5 * $Nueve
  45

@{"EVAL" link Eval} es un comando del AmigaDOS que evalúa expresiones enteras y de Boole.
Sin embargo, no funciona con variables de entorno que tienen un valor
numérico que usa decimales; asegúrese de que usa números enteros al
utilizar @{"EVAL" link Eval}.

@endnode

@NODE CreaEnvVarScripts "Creando variables de entorno"

CREANDO VARIABLES DE ENTORNO

Las variables de entorno pueden crearse con los comandos SET y SETENV.
@endnode

@NODE SETScripts "SET"

SET

SET crea variables de entorno locales, que son reconocidas solamente por el
Shell que las creó y por los Shells abiertos desde éste. Por ejemplo, si
crea una variable de entorno en su ventana Shell y luego ejecuta el comando
@{"NEWSHELL" link NewShell} mediante la opción de menú "Ejecutar Comando", el nuevo Shell no
reconocerá ninguna de las variables creadas antes. Sin embargo, si abre un
segundo Shell introduciendo el comando @{"NEWSHELL" link NewShell} en la ventana en la que creó
la variable, el nuevo Shell sí reconocerá la variable.
@endnode

@NODE SETENVScripts "SETENV"

SETENV

SETENV crea variables de entorno globales, que son reconocidas por todos los
Shells. Las variables globales se almacenan como pequeños ficheros ASCII en
el directorio ENV:. SETENV muestra el valor asociado con variables globales,
mientras que UNSETENV elimina estas variables. Use variables globales sólo
cuando necesite que ciertos valores deban estar disponibles para otros
procesos.

Algunas aplicaciones usan variables de entorno. Por ejemplo, el programa
MORE soporta una variable de entorno llamada Editor. Puede usar SETENV para
hacer que MEmacs sea el editor a utilizar:

  1.> SETENV Editor Extras:Tools/MEmacs

Asegúrese de especificar la senda completa de MEmacs.

Si usa MORE para ver el contenido del fichero User-startup, pulsando
Mayúsculas + E a la vez hará que se abra automáticamente una pantalla de
MEmacs con este fichero cargado y listo para su edición.

@endnode

@NODE veamos "Referencia de comandos del AmigaDOS"

				  Capítulo 6
				  ==========


		      REFERENCIA DE COMANDOS DEL AmigaDOS
		      ===================================


Los comandos que se explican en este capítulo se ejecutan desde la ventana
Shell. Se describen en orden alfabético; sin embargo, algunos comandos que
están reservados para el uso del sistema aparecen juntos al final del
capítulo.

La siguiente tabla ofrece una completa guía en orden alfabético para todos
los comandos expuestos en este capítulo y su función:

-----------------------------------------------------------------------------
Comando			Función
-----------------------------------------------------------------------------

@{"ADDBUFFERS" link AddBuffers}		Ordena al sistema de ficheros que añada o muestre
			buffers caché para un drive concreto.

@{"ADDDATATYPES" link AddDataTypes}		Construye una lista de datatypes o tipos de datos
			(este es un comando del sistema)

@{"ALIAS" link Alias}			Ajusta o muestra alias de comandos.

@{"ASK" link Ask}			Pide una respuesta sí/no al usuario durante la
			ejecución de un fichero script.

@{"ASSIGN" link Assign}			Controla las asignaciones que se efectúan a los
			dispositivos lógicos.

@{"AVAIL" link Avail}			Muestra la cantidad de memoria disponible.

@{"BINDDRIVERS" link BindDrivers}		Activa los drivers de dispositivos del cajón
			Espansion (este es un comando del sistema).

@{"BREAK" link Break}			Fija banderas de atención en el proceso que se
			indique.

@{"CD" link CD}			Cambia o muestra el directorio actual.

@{"CHANGETASKPRI" link ChangeTaskPri}		Cambia la prioridad de los procesos Shell.

@{"CONCLIP" link ConClip}		Traslada información entre las ventanas de consola
			y el Portapapeles (comando del sistema).

@{"COPY" link Copy}			Copia ficheros y directorios.

@{"CPU" link CPU}			Ajusta y muestra opciones relacionadas con el
			microprocesador.

@{"DATE" link Date}			Cambia o muestra la fecha y hora del sistema.

@{"DELETE" link Delete}			Borra ficheros y directorios.

@{"DIR" link Dir}			Muestra una lista ordenada de los ficheros de un
			directorio.

@{"DISKCHANGE" link DiskChange}		Informa al Amiga de que se ha cambiado el disco que
			había en una unidad de disco.

@{"ECHO" link Echo}			Muestra una cadena.

@{"ED" link Ed}			Edita ficheros de texto.

@{"EDIT" link Edit}			Edita ficheros de texto (editor de líneas).

@{"ELSE" link Else}			Indica una alternativa para una orden IF en un
			fichero script.

@{"ENDCLI" link EndCLI}			Finaliza un proceso Shell.

@{"ENDIF" link EndIf}			Finaliza un bloque IF en un fichero script.

@{"ENDSHELL" link EndShell}		Finaliza un proceso Shell.

@{"ENDSKIP" link EndSkip}		Finaliza un bloque SKIP en un fichero script.

@{"EVAL" link Eval}			Evalúa expresiones enteras o booleanas.

@{"EXECUTE" link Execute}		Ejecuta un script; opcionalmente se pueden indicar
			argumentos.

@{"FAILAT" link Failat}			Instruye a una secuencia de comandos para que no se
			produzca fallo a menos que se alcance un valor
			determinado.

@{"FAULT" link Fault}			Imprime el mensaje que corresponde al número de
			error especificado.

@{"FILENOTE" link FileNote}		Añade un comentario a un fichero.

@{"GET" link Get}			Obtiene el valor de una variable local.

@{"GETENV" link GetEnv}			Obtiene el valor de una variable global.

@{"ICONX" link IconX}			Permite la ejecución de un fichero script a partir
			de un icono.

@{"IF" link If}			Evalúa operaciones condicionales en los ficheros
			script.

@{"INFO" link Info}			Da información sobre los dispositivos montados en
			el sistema.

@{"INSTALL" link Install}		Escribe o comprueba el bloque raíz de un disco.

@{"IPREFS" link IPrefs}			Monitorea las preferencias del sistema (comando del
			sistema).

@{"JOIN" link Join}			Toma dos o más ficheros y los une para forma uno
			solo.

@{"LAB" link Lab}			Indica una etiqueta en un fichero script.

@{"LIST" link List}			Lista información sobre directorios y ficheros.

@{"LOADRESOURCE" link LoadResource}		Pre-carga recursos en la memoria para evitar
			excesivos cambios de disco.

@{"LOADWB" link LoadWB}			Carga el Workbench.

@{"LOCK" link Lock}			Ajusta el estado de protección contra escritura de
			un dispositivo.

@{"MAGTAPE" link MagTape}		Rebobina o hace avanzar rápidamente las cintas SCSI.

@{"MAKEDIR" link MakeDir}		Crea un nuevo directorio.

@{"MAKELINK" link MakeLink}		Crea una unión entre nombres de ficheros.

@{"MOUNT" link Mount}			Hace que esté disponible un dispositivo conectado al
			sistema.

@{"NEWCLI" link NewCLI}			Abre una nueva ventana Shell.

@{"NEWSHELL" link NewShell}		Abre una nueva ventana Shell.

@{"PATH" link Path}			Controla la lista de directorios que utiliza Shell
			para encontrar los comandos.

@{"PROMPT" link Prompt}			Cambia la cadena del prompt del Shell actual.

@{"PROTECT" link Protect}		Cambia los bits de protección de un fichero o
			directorio.

@{"QUIT" link Quit}			Sale de un fichero script con un código de retorno
			específico.

@{"RELABEL" link Relabel}		Cambia el nombre de volumen del disco contenido en
			una disquetera determinada por el nombre indicado.

@{"REMRAD" link RemRAD}			Elimina el disco RAM recuperable o RAD:

@{"RENAME" link Rename}			Cambia el nombre o traslada un fichero o directorio.

@{"REQUESTCHOICE" link RequestChoice}		Permite a los scripts de AmigaDOS y de ARexx usar
			requesters propios.

@{"REQUESTFILE" link RequestFile}		Permite a los scripts AmigaDOS y ARexx usar un
			requester de ficheros estándar del sistema.

@{"RESIDENT" link Resident}		Muestra y modifica la lista de comandos residentes.

@{"RUN" link run}			Ejecuta comandos como procesos en segundo plano.

@{"SEARCH" link Search}			Busca una cadena de texto determinada en los
			ficheros contenidos en los directorios indicados.

@{"SET" link Set}			Modifica una variable local.

@{"SETCLOCK" link SetClock}		Ajusta o lee el reloj de batería del sistema.

@{"SETDATE" link SetDate}		Cambia la fecha de creación de un fichero o
			directorio.

@{"SETENV" link SetEnv}			Crea una variable global.

@{"SETFONT" link SetFont}		Cambia la fuente de texto que utiliza Shell.

@{"SETKEYBOARD" link SetKeyboard}		Elige el mapa de teclado (keymap) que utiliza el
			sistema.

@{"SETPATCH" link SetPatch}		Hace parches en la ROM del sistema (comando del
			sistema).

@{"SKIP" link Skip}			Hace que la ejecución de un fichero script siga a
			partir de una etiqueta determinada.

@{"SORT" link Sort}			Ordena alfabéticamente las líneas de un fichero de
			texto.

@{"STACK" link Stack}			Muestra o modifica el tamaño de pila del Shell
			actual.

@{"STATUS" link Status}			Lista información sobre los procesos Shell.

@{"TYPE" link Type}			Imprime el contenido de un fichero de texto.

@{"UNALIAS" link UnAlias}		Elimina un alias.

@{"UNSET" link UnSet}			Elimina una variable local.

@{"UNSETENV" link UnSetEnv}		Elimina una variable global.

@{"VERSION" link Version}		Muestra los números de versión y revisión del
			software.

@{"WAIT" link Wait}			Espera un tiempo determinado.

@{"WHICH" link Which}			Busca la senda que corresponde a un objeto en
			particular.

@{"WHY" link Why}			Imprime un mensaje de error que explica por qué
			falló el comando anterior.

@endnode

@NODE ReferenciaComandosDOS "Documentación de los comandos"

DOCUMENTACIÓN DE LOS COMANDOS
-----------------------------

Cada comando documentado en este manual se muestra con el formato,
argumentos, opciones, símbolos y abreviaturas que se necesitan para
usarlo correctamente.

Este capítulo y el capítulo 7 ofrecen especificaciones sobre los comandos
del AmigaDOS y los programas del Workbench accesibles desde Shell utilizando
el estilo siguiente:

  Formato		Todos los argumentos y opciones aceptados por el
			comando. Los caracteres especiales que indican el
			tipo particular de argumento se describen en el
			apartado @{" Formato " link FormatoComandos}.

  Sintaxis		Un recordatorio del formato de uso del comando que
			está programado dentro del código del propio
			programa. Si introduce un comando seguido por un
			espacio y un signo de interrogación (por ejemplo,
			DIR ?), se mostrará la sintaxis. En el apartado
			@{" Sintaxis " link SintaxisComandos} se ofrece una completa descripción
			de la sintaxis convencional de los comandos.

  Localización		El directorio en el que está guardado normalmente el
			comando.

  Ejemplos		Un ejemplo de cómo usar el programa. El "1.> "
			representa el prompt de Shell; no lo teclee como
			parte del comando. Las líneas de ejemplo que no van
			precedidas del "1.> " representan la salida impresa
			del comando. Los nombres de comandos y palabras clave
			se muestran siempre en mayúsculas, mientras que los
			nombres de ficheros y directorios se muestran
			normalmente con la primera letra en mayúscula; en
			ningún caso tienen estos nombres porqué teclearse
			así. Recuerde pulsar Return al final para ejecutar
			la línea de comando.

Separe los comandos y los argumentos con espacios. Use la puntuación sólo
cuando se necesite según la sintaxis de cada comando en particular.

@endnode

@NODE FormatoComandos "Formato"

FORMATO

A continuación ofrecemos una lista de los caracteres que indican el tipo de
argumento mostrado en el listado de comandos. No use estos caracteres como
parte del comando.

  < >		Los corchetes angulados indican dónde debe ponerse la
		información adicional, como el nombre de un fichero. Este
		argumento es opcional si no va encerrado entre los corchetes
		angulados (por ejemplo, [<NombreFichero>], mire más abajo).

  [ ]		Los corchetes rectos rodean argumentos y palabras clave
		opcionales. A pesar de que no son necesarios, estos
		argumentos y palabras clave son aceptados por el comando.

  { }		Las llaves rodean cosas que pueden indicarse una vez, o que
		pueden repetirse un cierto número de veces. Por ejemplo,
		{<args>} indica que pueden darse varias cosas con este
		argumento.

  |		Las barras verticales separan listas de opciones entre las
		cuales puede elegir una. Por ejemplo, [OPT R|S|RS] indica
		que puede elegir entre las opciones R, S o ambas a la vez.

  <n>		Se espera que indique un valor numérico con este argumento.
  
  @{I}PALABRA CLAVE @{UI}Las palabras clave en letras itálicas indican que es
		necesario que éstas sean tecleadas si decide usar el
		argumento.

  ...		Unos puntos suspensivos después de un argumento de cadena
		indican que la cadena debe ser el último argumento de la
		línea. No se permite añadir ningún comentario. El resto de
		la línea de comando se toma como la cadena deseada. No se
		necesita usar comillas para rodear a la cadena, a pesar de
		que contenga espacios. Si introduce comillas, se tomarán
		como parte de la cadena. Si especifica la palabra clave,
		puede poner espacios al principio y al final de la cadena.

  Justificación	En las líneas de comando que son demasiado largas para
  de la línea	indicarlas en una sola línea, este manual las muestra en
  de comando	varias líneas, sólo por motivos informativos. En la práctica,
		el siguiente trozo de línea se alinea automáticamente con
		el principio del prompt del Shell.

El formato del comando COPY ilustra el uso de estas convenciones:

  COPY [FROM]{<nombre|patrón>}[TO]<nombre|patrón>[ALL][QUIET] [@{I}BUF|BUFFER@{UI}=
       <n>][CLONE][DATES][NOPRO][COM][NOREQ]

La palabra clave [FROM] es opcional. Si no se indica, el comando lee el
nombre de fichero o patrón a copiar según su posición en la línea de
comando.

El argumento {<nombre|patrón>} debe indicarse obligatoriamente. Deberá
indicar un nombre de fichero o patrón. Las llaves indican que puede darse
más de un nombre de fichero o patrón.

La palabra clave [TO] es opcional. Si no se indica, el comando lee el nombre
de fichero o dispositivo a copiar por su posición en la línea de comando.

El argumento <nombre|patrón> debe indicarse obligatoriamente. Puede indicar
solamente un destino.

Los argumentos [QUIET], [CLONE], [DATES], [NOPRO], [COM] y [NOREQ] son
opcionales.

El argumento [BUF|BUFFER=<n>] es opcional. Si se indica, deberá usar la
palabra clave, pero puede usar tanto BUF como BUFFER con el argumento
numérico. Por ejemplo, tanto BUF=5 como BUFFER=5 se aceptan. El argumento
numérico también puede introducirse sin el signo de igualdad; los espacios
son opcionales.

@endnode

@NODE SintaxisComandos "Sintaxis"

SINTAXIS

La sintaxis está incorporada en el sistema para servirle como un
recordatorio en línea de la forma de usar un comando y permitirle ejecutar
el comando desde la línea de sintaxis ofreciendo un prompt en el que puede
teclear los argumentos del comando.

Para ver la sintaxis de un comando, teclee el comando seguido por un espacio
y un signo de interrogación (?). El Shell asume que desea ejecutar el
comando y espera que introduzca los argumentos después del signo de dos
puntos. Por ejemplo:

  1.> TYPE ?
  FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S:

Pulsando Return ejecutará el comando en caso de que éste no necesite de
argumentos para funcionar correctamente. Introduciendo los argumentos y sus
palabras clave correspondientes y luego pulsando Return también ejecutará el
comando. Si un comando necesita argumentos y no los indica o si introduce
otra cosa que no son los argumentos que se necesitan, y pulsa Return,
aparecerá un mensaje de error. Recuerde que no necesita introducir el
formato completo para un comando en el prompt; sólo los argumentos que sean
necesarios.

La sintaxis se lista con los argumentos separados por comas, seguidos por
una barra inclinada y una letra mayúscula que indica el tipo de argumento.
Estas combinaciones barra inclinada/letra se muestran para recordarle las
necesidades particulares de un comando, y no se introducen como parte del
comando. La siguiente tabla muestra la notación empleada:

-----------------------------------------------------------------------------
Notación de sintaxis	Equivalente en		Significado
			formato
-----------------------------------------------------------------------------

argument/A		<nombre>		El argumento es
                                                imprescindible.

option/K		@{I}PALABRA CLAVE @{UI} 		La palabra clave que activa
                                                el argumento se necesita
                                                si éste se indica.

option/S		[PALABRA CLAVE]		La opción trabaja como un
                                                interruptor. El nombre de la
                                                opción debe ser introducido
                                                para especificarlo. La mayor
                                                parte de las palabras clave
                                                son interruptores.

value/N			<n>			El argumento es numérico.

argument/M		{<nombre>}		Se aceptan múltiples objetos
                                                para este argumento. Aunque
                                                no existe un número límite
                                                de argumentos, deben
                                                indicarse antes del siguiente
                                                argumento u opción.

string/F		Argumento...		La cadena debe ser el último
                                                argumento de la línea de
                                                comando. El resto de la línea
                                                de comando se toma como la
                                                línea deseada.

=                       PACLAVE | PALABRA CLAVE	Las dos formas de indicar la
                                                palabra clave son
                                                equivalentes y por tanto
                                                aceptables. El signo de
						igualdad no se introduce
                                                como parte del comando.

La sintaxis del comando COPY ilustra el uso de los argumentos:

  FROM/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,NOPRO/S,COM/S,
  NOREQ/S

FROM/M indica que el argumento debe indicarse obligatoriamente, y que se
acepta más de un argumento.

TO/A indica que el argumento debe indicarse obligatoriamente.

ALL/S, QUIET/S, CLONE/S, DATES/S, NOPRO/S, COM/S y NOREQ/S indican que las
palabras clave actúan como interruptores. Si la palabra clave está presente
en la línea, la opción correspondiente estará activada.

BUF=BUFFER/K/N indica que la palabra clave (/K) BUF o BUFFER es necesaria
para indicar este argumento numérico (/N). Tanto BUF como BUFFER se aceptan
como palabras clave (=).

Las palabras clave y sus argumentos pueden unirse con un signo de igualdad
(=) para asegurar que las asignaciones se hacen correctamente en casos
complejos. Por ejemplo, BUF=20.

@endnode

@NODE ADDBUFFERS

@{B}ADDBUFFERS@{UB}

Instruye al sistema de ficheros para que añada o muestre buffers caché a un
drive concreto.

@{B}Formato@{UB}		ADDBUFFERS <drive> [<n>]

@{B}Sintaxis@{UB}	DRIVE/A,BUFFERS/N

@{B}Localización@{UB}	C:

ADDBUFFERS añade <n> buffers a la lista de buffers disponibles para <drive>.
A pesar de que añadir buffers acelera el acceso a disco, cada buffer
adicional reduce la memoria libre aproximadamente en 512 bytes. La reserva
por defecto de buffers es de 5 para las unidades de disco y de 30 para las
particiones de disco duro.

La cantidad de memoria extra disponible dicta el número de buffers que
puede añadir. No hay un límite máximo concreto; sin embargo, añadir
demasiados buffers reduce el rendimiento general del sistema, ya que se
ocupa RAM que otras funciones del sistema podrían necesitar. Especificando
un valor negativo se restan buffers a la reserva actual de los mismos. El
número mínimo de buffers es uno; sin embargo, esto no se recomienda nunca.

Veinte buffers es el valor recomendado para una unidad de disco en un
sistema basado en disco flexible. Use el valor por defecto recomendado por
el programa HDToolbox para los discos duros (puede ver este valor
seleccionando el gadget "Advanced Options" en la pantalla de particiones).

Si sólo se especifica el argumento <drive>, ADDBUFFERS mostrará el número
de buffers que actualmente están reservados para ese drive.

@{B}Ejemplo:@{UB}

  1.> ADDBUFFERS DF0:
  DF0: has 5 buffers

En el capítulo 8 aparece @{"otro ejemplo" link CrearUserStartup} del uso de ADDBUFFERS.

@endnode

@NODE ALIAS

@{B}ALIAS@{UB}

Modifica o muestra alias de comandos.

@{B}Formato@{UB}		ALIAS [<nombre>] [<cadena...>]

@{B}Sintaxis@{UB}	NAME,STRING/F

@{B}Localización@{UB}	Interno

ALIAS crea alias o nombres alternativos para comandos del AmigaDOS. ALIAS
puede utilizarse para abreviar comandos usados frecuentemente o sustituir
nombres de comandos estándar por otros nombres diferentes.

Cuando el AmigaDOS encuentra <nombre>, lo sustituye con la <cadena>
especificada, usando el resultado con el resto de la línea de comando,
e intenta interpretar y ejecutar la línea resultante como un comando del
AmigaDOS. <Nombre> es el alias para el comando, mientras que <cadena> es
el comando que se ejecutará al llamar a este alias.

El alias debe ser introducido al principio de la línea de comando. Puede
introducir argumentos después del alias, pero no puede crear un alias que
represente a una serie de argumentos de comando. Por ejemplo, en la
siguiente línea de comando:

  1.> NEWSHELL WINDOW=CON:0/250/640/150/Shell2/CLOSE

el argumento WINDOW no puede cambiarse por un alias.

Puede cambiar un nombre de fichero u otra instrucción con un alias,
colocando corchetes ([]) sin nada entre ellos en la <cadena>. Cualquier
argumento introducido posteriormente después del alias se insertará en la
posición de los corchetes.

ALIAS <nombre> muestra la <cadena> de ese alias. Introduciendo únicamente
el comando ALIAS, aparecerá una lista con los alias actuales.

Los alias son locales al Shell en el que fueron definidos. Si crea otro
Shell con el comando NEWSHELL, éste comparte los mismos alias que el Shell
que lo abrió. Sin embargo, si crea otro Shell con la opción de menú
"Ejecutar Comando", este Shell no reconocerá los alias creados en aquel
Shell. Puede crear un alias global, que sea reconocido por todos los Shell
que se abran, creando el alias en el fichero Shell-startup.

Para eliminar un ALIAS, use el comando @{"UNALIAS" link unalias}.

@{B}Ejemplo 1:@{UB}

  1.> ALIAS d1 DIR DF1:

Ahora, introduciendo "d1" se mostrará un directorio con el contenido del
disco que esté en DF1:, como si hubiese tecleado "DIR DF1:".

@{B}Ejemplo 2:@{UB}

  1.> ALIAS hex TYPE [] HEX

crea un alias llamado "hex" que muestra el contenido de un fichero concreto
en formato hexadecimal. Los dos corchetes juntos indican dónde se insertará
en este ejemplo el nombre del fichero. Introduciendo ahora:

  1.> hex Mifichero

se mostrará el contenido de Mifichero en formato hexadecimal.

Mire también: @{"UNALIAS" link unalias}. En el capítulo 8 encontrará @{"más ejemplos" link CreaciónDeAlias} sobre el
uso de ALIAS.

@endnode

@NODE ASK

@{B}ASK@{UB}

Obtiene una respuesta afirmativa o negativa del usuario durante la ejecución
de un fichero script.

@{B}Formato@{UB}		ASK <prompt>

@{B}Sintaxis@{UB}	PROMPT/A

@{B}Localización@{UB}	Interno

ASK se usa en los ficheros script para imprimir la cadena de texto <prompt>
en la ventana actual y esperar una respuesta del usuario a través del
teclado. Las respuestas válidas son Y (afirmativo), N (negativo) y Return
(negativo). Seleccionando Y la @{"bandera de condición" link BanderasCondicionales} se pone a 5 (WARN).
Seleccionando N o pulsando directamente Return, la @{"bandera de condición" link BanderasCondicionales}
se pone a 0.

Si el prompt contiene espacios, deberá indicarse entre comillas.

@{B}Ejemplo:@{UB}

Supongamos que un script contiene los siguientes comandos:

  ASK "¿Seguimos?"
  IF WARN
    ECHO Sí
  ELSE
    ECHO No
  ENDIF

Al ejecutar el comando ASK, el prompt "¿Seguimos?" se muestra en la ventana
actual. Si se introduce Y, se mostrará "Sí" en la ventana. Si se introduce
N o si se pulsa inmediatamente Return, se mostrará "No".

Mire también: @{"IF" link if}, @{"ELSE" link else}, @{"ENDIF" link endif}, @{"REQUESTCHOICE" link requestchoice}, @{"WARN" link BanderasCondicionales}.

@endnode

@NODE ASSIGN

@{B}ASSIGN@{UB}

Controla la asignación de ficheros y directorios a nombres de dispositivos
lógicos.

@{B}Formato@{UB}		ASSIGN [<nombre>:] [{<objetivo>}] [LIST] [EXISTS] [DISMOUNT]
			[DEFER] [PATH] [ADD] [REMOVE] [VOLS] [DIRS]
			[DEVICES]

@{B}Sintaxis@{UB}	NAME,TARGET/M,LIST/S,EXISTS/S,DISMOUNT/S,DEFER/S,PATH/S,
			ADD/S,REMOVE/S,VOLS/S,DIRS/S,DEVICES/S

@{B}Localización@{UB}	C:

ASSIGN permite las referencias a ficheros y directorios usando nombres más
cortos y sencillos de dispositivos lógicos, en lugar de tener que emplear
los nombres normales o las sendas completas. El comando ASSIGN puede crear
asignaciones, cambiar asignaciones o listar algunas o todas las asignaciones
actuales.

Si se dan los argumentos <nombre> y {<objetivo>}, ASSIGN asigna el nombre
lógico indicado al objetivo designado. Cada vez que se aluda al nombre de
dispositivo lógico asignado, el AmigaDOS accederá al objetivo elegido. Si
el <nombre> dado está ya asignado a un fichero o directorio, el nuevo
objetivo sustituirá al anterior. Debe poner un signo de dos puntos (:) al
final del argumento <nombre>.

Si sólo se indica el argumento <nombre>, cualquier asignación de un fichero
o directorio a ese nombre de dispositivo lógico quedará cancelada.

Puede asignar varios nombres de dispositivos lógicos al mismo objetivo
utilizando múltiples comandos ASSIGN.

Puede asignar un nombre de dispotivo lógico a varios objetivos indicando
cada fichero o directorio después del argumento <nombre> o usando varios
comandos ASSIGN con la opción ADD. Indicar la opción ADD no sustituye el
objetivo ya asignado a <nombre>. Este objetivo se añade a la lista de
asignaciones y el sistema busca en todos los objetivos cuando se alude a
<nombre>. Si el primer objetivo no está disponible, ASSIGN empleará el
siguiente objetivo designado.

La opción REMOVE borra el nombre de un objetivo de la lista de asignaciones.

Si no se dan argumentos con ASSIGN o si se usa la palabra clave LIST, se
mostrará una lista con todas las asignaciones actuales. Si se indica el
interruptor VOLS, DIR o DEVICES, ASSIGN se limitará a mostrar los volúmenes,
los directorios o los dispositivos, respectivamente.

Cuando se introduce la palabra clave EXISTS con un nombre de dispositivo
lógico, el AmigaDOS busca en la lista de asignaciones ese nombre y muestra
el volumen y el directorio asignados a ese dispositivo. Si no encuentra el
nombre de dispositivo, la @{"bandera de condición" link BanderasCondicionales} se pone a 5 (WARN).

Cuando se indica el argumento {<objetivo>}, el AmigaDOS busca inmediatamente
ese fichero o directorio. Si los comandos ASSIGN son parte del fichero User-
startup, los objetivos deben estar presentes en un disco montado durante el
proceso de arranque. Si no puede encontrarse un objetivo asignado, un
requester le pedirá el volumen que lo contenga. Sin embargo, si usa las
opciones DEFER y PATH hará que el sistema espere a que el objetivo se
necesite antes de dedicarse a buscarlo.

NOTA: El nombre asignado no tiene porqué ser idéntico al nombre del
      fichero o directorio, y no tiene porqué estar en mayúsculas. Por
      ejemplo, el nombre CLIPS: o Clips: puede asignarse al directorio
      Ram Disk:Clipboards.

La opción DEFER crea una asignación de espera. Esta asignación hace efecto
únicamente cuando el objeto asignado es necesario por primera vez, en lugar
de cuando se ejecuta el comando ASSIGN. Cuando se usa la opción DEFER, el
disco que contiene el objetivo asignado no es necesario hasta que se realice
una llamada al objeto. Entonces la asignación permanecerá válida hasta que
se cambie de forma explícita.

Si asigna FONTS: al directorio DF0:Fonts con la opción DEFER, el sistema
asociará FONTS: con el disco que esté en DF0: cuando se llame a FONTS:. Por
ejemplo, si tiene un disco del Workbench en DF0: al mismo tiempo que es
necesario el directorio FONTS:, el sistema asociará FONTS: con ese disco de
Workbench en particular. Si luego quita ese disco e inserta otro diferente
en la unidad, a pesar de que contenga un directorio Fonts, el sistema le
pedirá que inserte el disco de antes cuando necesite acceder a FONTS:.

La opción PATH crea una asignación no exclusiva. Una asignación no exclusiva
actúa de forma parecida a si hubiese utilizado la opción DEFER; la
diferencia está en que la asignación se evalúa cada vez que se alude al
nombre asignado. Por ejemplo, si asigna FONTS: a DF0:Fonts con la opción
PATH, cualquier disco que se inserte en DF0: se utilizará todas las veces
que se aluda a FONTS:. Siempre que el disco contenga un directorio Fonts,
la asignación será válida. No puede asignar múltiples directorios con PATH.

Los usuarios de sistemas basados en disco flexible encontrarán que el uso
de la opción PATH elimina la necesidad de reinsertar los discos originales
del Workbench usados para arrancar el sistema. Siempre que el drive asignado
con la opción PATH contenga un disco que disponga del directorio asignado,
el sistema usará ese disco.

La opción DISMOUNT desconecta un volumen o dispositivo de la lista de
dispositivos montados. Debe indicar el nombre de dispositivo en el
argumento. DISMOUNT elimina el nombre de la lista, pero no libera recursos.
No puede cancelar una orden DISMOUNT sin arrancar de nuevo el sistema.
DISMOUNT está pensada para ser usada por programadores solamente, y puede
producir un fallo en el software si no se utiliza correctamente.

@{B}Ejemplo 1:@{UB}

  1.> ASSIGN FONTS: MisFuentes:DirFont

asigna el directorio FONTS: al directorio DirFont de MisFuentes:.

@{B}Ejemplo 2:@{UB}

  1.> ASSIGN LIST
  Volumes:
  Ram Disk [Mounted]
  Workbench [Mounted]
  MisFuentes [Mounted]

  Directories:
  LOCALE	Workbench:Locale
  KEYMAPS	Workbench:Devs/Keymaps
  PRINTERS	Workbench:Devs/Printers
  REXX		Workbench:S
  CLIPS		Ram Disk:Clipboards
  ENV		Ram Disk:Env
  T		Ram Disk:T
  ENVARC	Workbench:Prefs/Env-Archive
  SYS		Workbench:
  C		Workbench:C
  S		Workbench:S
  L		Workbench:L
  FONTS		Misfuentes:DirFont
  DEVS		Workbench:Devs
  LIBS		Workbench:Libs
              + Workbench:Classes

  Devices:
  PIPE AUX RAM CON
  RAW PAR SER PRT DF0

muestra una lista típica de todas las asignaciones actuales. El signo de
suma indica que los directorios adicionales disponen de la misma asignación.

@{B}Ejemplo 3:@{UB}

  1.> ASSIGN FONTS: EXISTS
  FONTS: Misfuentes:DirFont

es una pregunta sobre la asignación de FONTS:. El AmigaDOS responde
indicando que FONTS: está asignado al directorio DirFont del volumen
Misfuentes. El código de retorno se pone a 0 si existe o a 5 si no existe.

@{B}Ejemplo 4:@{UB}

  1.> ASSIGN LIBS: SYS:Libs Librerías:Libs ADD

es una asignación a múltiples directorios que crea una senda de búsqueda que
contiene dos directorios Libs. Al indicar ADD, se evita que la asignación
estándar SYS:Classes sea anulada. Estos directorios se investigan de forma
consecutiva cada vez que se invoca LIBS:.

@{B}Ejemplo 5:@{UB}

  1.> ASSIGN DEVS:

elimina la asignación a DEVS: del sistema.

@{B}Ejemplo 6:@{UB}

  1.> ASSIGN WorkDisk: DF0: DEFER
  1.> ASSIGN WorkDisk: EXISTS
  WorkDisk <DF0:>

configura una asignación de espera del dispositivo lógico WorkDisk:. Hasta
la primera vez que sea necesario acceder a WorkDisk:, no necesitará
insertarlo en DF0:. ASSIGN muestra DF0: entre corchetes angulados para
indicar que se trata de una asignación de espera. En cuanto se haga uso de
WorkDisk:, el nombre del disco que se inserte en DF0: quedará asignado
definitivamente y sustituirá a <DF0:>.

@{B}Ejemplo 7:@{UB}

  1.> ASSIGN C: DF0:C PATH
  1.> ASSIGN C: EXISTS
  C: [DF0:C]

hace que el sistema acuda al directorio C del disco que esté en DF0: cuando
se necesite un comando. ASSIGN muestra DF0:C entre corchetes rectos para
indicar que se trata de una asignación no exclusiva.

@{B}Ejemplo 8:@{UB}

  1.> ASSIGN LIBS: Disco4:Libs ADD

añade Disco4:Libs a la lista de directorios asignados como LIBS:.

@{B}Ejemplo 9:@{UB}

  1.> ASSIGN LIBS: Disco4:Libs REMOVE

elimina Disco4:Libs de la lista de directorios asignados como LIBS:.

Para ver @{"más ejemplos" link CreaAssign} del uso de ASSIGN, mire el capítulo 8.

@endnode

@NODE AVAIL

@{B}AVAIL@{UB}

Muestra la cantidad de memoria Chip y Fast disponible.

@{B}Formato@{UB}		AVAIL [CHIP|FAST|TOTAL] [FLUSH]

@{B}Sintaxis@{UB}	CHIP/S,FAST/S,TOTAL/S,FLUSH/S

@{B}Localización@{UB}	C:

AVAIL da un sumario de la memoria RAM del sistema, tanto Chip como Fast.
Para cada tipo de memoria, AVAIL muestra la cantidad total de memoria que
está disponible, cuánta se está usando en ese momento, y el mayor bloque
continuo de memoria que todavía no se ha reservado.

A menos que quiera una lista completa de la memoria, use las opciones CHIP,
FAST y TOTAL para hacer que AVAIL muestre solamente el número de bytes
disponibles de memoria Chip, Fast o total.

La opción FLUSH libera memoria eliminando las librerías, dispositivos,
fuentes y catálogos que no se estén utilizando.

@{B}Ejemplo 1:@{UB}

  1.> AVAIL
  Type  Available    In-Use   Maximum   Largest
  chip     233592    282272    515864     76792
  fast     341384    182896    524280    197360
  total    574976    465168   1040144    197360

Se muestra una lista completa de la memoria RAM disponible.

@{B}Ejemplo 2:@{UB}

  1.> AVAIL CHIP
  233592

El número de bytes disponibles de Chip RAM se muestra.

Mire el capítulo 8 para ver @{"más ejemplos" link AdiósBasura} del uso de AVAIL.

@endnode

@NODE BREAK

@{B}BREAK@{UB}

Ajusta banderas de atención en el proceso especificado.

@{B}Formato@{UB}		BREAK <proceso> [ALL|C|D|E|F]

@{B}Sintaxis@{UB}	PROCESS/A/N,ALL/S,C/S,D/S,E/S,F/S

@{B}Localización@{UB}	C:

BREAK ajusta las banderas de atención indicadas en el <proceso> indicado.
Use el comando @{"STATUS" link status} para ver los números de proceso actuales. C ajusta la
bandera Ctrl+C. D ajusta la bandera Ctrl+D, etcétera. ALL activa todas las
banderas, desde Ctrl+C hasta Ctrl+F. Por defecto, sólo está activada la
bandera Ctrl+C.

BREAK actúa de la misma forma que si seleccionase el proceso Shell
correspondiente y pulsase la combinación Ctrl+tecla equivalente.

Ctrl+C es la combinación por defecto establecida para enviar una señal de
BREAK que detenga un proceso. Los procesos interrumpidos de esta forma
muestran el mensaje "***Interrumpido" en la ventana Shell. Ctrl+D interrumpe
la ejecución de un fichero script. El comando @{"STATUS" link status} muestra los números
de los procesos actuales. La combinación Ctrl+E no está definida.

La combinación Ctrl+F es utilizada por los programas que abren ventanas para
activar su ventana y hacer que aparezca delante de todas las demás. No todos
los programas responden a Ctrl+F.

@{B}Ejemplo 1:@{UB}

  1.> BREAK 7

activa la bandera de atención Ctrl+C del proceso 7. Esto es lo mismo que
seleccionar el proceso 7 y pulsar Ctrl+C.

@{B}Ejemplo 2:@{UB}

  1.> BREAK 5 D

activa la bandera de atención Ctrl+D del proceso 5.

Mire también: @{"STATUS" link status}.

@endnode

@NODE CD

@{B}CD@{UB}

Cambia o indica el directorio actual.

@{B}Formato@{UB}		CD [<dir|patrón>]

@{B}Sintaxis@{UB}	DIR

@{B}Localización@{UB}	Interno

CD sin argumentos indica el nombre del directorio actual. Cuando se indica
un nombre de directorio válido, CD convierte al directorio designado en el
directorio actual.

Debe especificar la senda completa del directorio, ya que CD no es capaz
de buscarlo él sólo por el disco. Si CD no puede encontrar el directorio
indicado en el directorio actual ni en la senda de búsqueda, mostrará el
mensaje "no encuentro objeto".

Para subir un nivel por la jerarquía de ficheros hasta el directorio padre
del directorio actual, introduzca CD seguido por un espacio y una barra
inclinada (/). Puede ir a otro directorio que contenga al directorio actual
teclendo su nombre inmediatamente después de la barra. Si el directorio
actual es el directorio raíz, la orden "CD /" no tendrá efecto alguno. Use
varias barras seguidas para subir más de un nivel con una sola orden.

Para ir directamente al directorio raíz del dispositivo actual, use CD
seguido por un espacio y el signo de dos puntos; es decir, "CD :".

El AmigaDOS soporta el CD implícito, de forma que, a menudo, el comando CD
puede omitirse. Introduzca el nombre de directorio, senda, signo de dos
puntos o barras inclinadas en el prompt directamente.

CD también soporta la búsqueda por patrón. Cuando se encuentra un directorio
que responde al patrón indicado, automáticamente se convierte en el
directorio actual. Si hay más de un directorio que coincide con el patrón
indicado, se mostrará un mensaje de error. No puede usar la búsqueda por
patrón y el CD implícito a la vez. Para más información sobre la búsqueda
por patrón, mire el apartado @{"uso de comodines" link UsoDeComodines} en el capítulo 3.

@{B}Ejemplo 1:@{UB}

  1.> CD DF1:Work

hace que el directorio actual sea el directorio Work del disco que esté en
DF1:.

@{B}Ejemplo 2:@{UB}

  1.> CD SYS:Com/Basic

hace que el subdirectorio Basic del directorio Com sea el nuevo directorio
actual.

@{B}Ejemplo 3:@{UB}

  1.> //

hace uso del CD implícito, llevándole dos niveles hacia arriba por la
estructura de directorios.

@{B}Ejemplo 4:@{UB}

  1.> CD SYS:Li#?

usa el patrón #? para buscar el directorio LIBS:.

Para ver @{"más ejemplos" link ChangeCDShell} del uso del comando CD, mire el capítulo 8.

@endnode

@NODE CHANGETASKPRI

@{B}CHANGETASKPRI@{UB}

Cambia la prioridad de un proceso que está funcionando actualmente.

@{B}Formato@{UB}		CHANGETASKPRI <prioridad> [@{I}PROCESS @{UI}<número de proceso>]

@{B}Sintaxis@{UB}	PRI=PRIORITY/A/N,PROCESS/K/N

@{B}Localización@{UB}	C:

CHANGETASKPRI cambia la prioridad del proceso Shell que se indique. Si no
se indica proceso alguno, se asumirá que el usuario se refiere al proceso
actual. Cualquier proceso Shell originado por el <número de proceso> tendrá
su misma prioridad.

Use el comando @{"STATUS" link status} para ver los números de los procesos actuales.

La gama de valores aceptables de <prioridad> va de -128 a 127, siempre con
números enteros; cuanto mayor es el número, mayor es la prioridad del
proceso y más proporción de tiempo de la CPU se adjudica. Sin embargo, no
introduzca valores de más de +10 para evitar irrumpir en tareas importantes
del sistema.

@{B}Ejemplo:@{UB}

  1.> CHANGETASKPRI 4 PROCESS 2

La prioridad del proceso 2 pasa a ser de 4. Cualquier proceso Shell abierto
por este Shell también tendrá una prioridad de 4. Estos Shells tendrán
prioridad sobre otras tareas del usuario creadas sin usar CHANGETASKPRI
(tareas que tendrán una prioridad de 0).

Mire también: @{"STATUS" link status}. Para ver @{"otro ejemplo" link IconXRun} del uso de CHANGETASKPRI, mire
el capítulo 8.

@endnode

@NODE COPY

@{B}COPY@{UB}

Copia ficheros y directorios.

@{B}Formato@{UB}		COPY [FROM] {<nombre|patrón>} [TO] <nombre> [ALL] [QUIET]
			[@{I}BUF@{UI}|@{I}BUFFER@{UI}=<n>] [CLONE] [DATES] [NOPRO] [COM]
 			[NOREQ]

@{B}Sintaxis@{UB}	FROM/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,
			DATES/S,NOPRO/S,COM/S,NOREQ/S

@{B}Localización@{UB}	C:

COPY copia el fichero o directorio indicado con el argumento FROM al fichero
o directorio indicado por el argumento TO. Puede copiar varias cosas a la
vez indicando más de un nombre/patrón en el argumento FROM, pero recuerde
que deberá separarlos con espacios. Si el argumento FROM es un patrón que
consiste en varios nombres, el argumento TO deberá ser un directorio.

Si ya existe el nombre de fichero TO, COPY sustituirá ese fichero con el
indicado por el argumento FROM. Puede usar un par de comillas juntas ("")
para aludir al directorio actual. Cuando se usa como argumento FROM, ""
copia todos los ficheros del directorio actual. No ponga espacios entre las
dos comillas.

Si el argumento FROM es un directorio, sólo se copiarán los ficheros del
mismo; los subdirectorios no se copiarán. Use la opción ALL para copiar el
directorio completo, incluyendo todos los ficheros, subdirectorios y
ficheros que contengan estos subdirectorios. Es posible crear un directorio
nuevo en el momento de hacer la copia de más de un fichero. Para dar un
nombre al nuevo directorio, indique este nombre como el último componente
de la senda del argumento TO. Puede ser cualquier nombre, incluyendo el
mismo nombre que tenía el original si está en una senda diferente.

COPY imprime en pantalla el nombre de cada fichero que va copiando. Esto
puede impedirse con la opción QUIET.

La opción BUF= se usa para ajustar el número de buffers de 512 bytes
utilizados durante el proceso de copia (el valor por defecto es de 128
buffers, es decir, 64Kb de RAM). No use demasiados buffers cuando la copia
sea hacia RAM:. BUF=0 usa un buffer del mismo tamaño que el fichero que se
va a copiar.

Por defecto, COPY ajusta la fecha del fichero destino según el momento en
el que se haga la copia, en lugar de dejar la fecha del fichero original.
También por defecto, los comentarios unidos al fichero original no se copian,
mientras que los bits de protección sí lo hacen. Puede modificar estos
valores por defecto usando las siguientes opciones:

  CLONE		La fecha y hora, el comentario y los bits de protección del
		fichero original permanecen en el fichero destino.

  DATES		La fecha de creación del fichero original se copia al
		fichero destino.

  COM		El comentario del fichero original se guarda con el fichero
		destino.

  NOPRO		Los bits de protección del fichero original no se copian al
		fichero destino; el fichero destino recibe los bits de
		protección estándar, es decir, r, w, e y d.

COPY muestra un requester si el comando COPY no puede continuar. Cuando se
da la opción NOREQ, cualquier requester se suprimirá. Use esta opción en los
scripts para evitar que un error de COPY detenga el script para pedir una
respuesta del usuario. Con la opción NOREQ, el comando COPY simplemente deja
de funcionar, pero el script continúa.

@{B}Ejemplo 1:@{UB}

  1.> COPY Fichero1 TO :Work/Fichero2

copia Fichero1 del directorio actual al directorio Work que está contenido
en el directorio raíz del dispositivo actual, y cambia su nombre por el de
Fichero2.

@{B}Ejemplo 2:@{UB}

  1.> COPY Capítulo#? to DF1:Backup

copia todos los ficheros cuyos nombres empiecen por "Capítulo" del
directorio actual al directorio Backup del disco que esté en DF1:. El
directorio Backup se crea automáticamente si todavía no existe.

@{B}Ejemplo 3:@{UB}

  1.> COPY Work:Prueba TO ""

copia los ficheros del directorio Prueba que está en Work: al directorio
actual; los subdirectorios de Prueba no se copian.

@{B}Ejemplo 4:@{UB}

  1.> COPY Work:Prueba TO DF0:Prueba ALL

copia todos los ficheros y subdirectorios del directorio Prueba de Work: al
directorio Prueba de DF0:. Si no existe todavía un directorio Prueba en DF0:
COPY creará uno.

@{B}Ejemplo 5:@{UB}

  1.> COPY DF0: TO DF1: ALL QUIET

copia todos los ficheros y directorios del disco que esté en DF0: al que
esté en DF1:, sin mostrar en pantalla ningún nombre de fichero o directorio
durante la copia (con discos que están llenos menos de la mitad, esto puede
resultar más rápido que usar @{"Diskcopy" link UtiDiskCopy}).

Para ver @{"más ejemplos" link CopiaConShell} del uso de COPY, mire el capítulo 8.

@endnode

@NODE CPU

@{B}CPU@{UB}

Modifica o muestra opciones del procesador.

@{B}Formato@{UB}		CPU [CACHE|NOCACHE] [BURST|NOBURST] [DATACACHE|NODATACACHE] 
			[DATABURST|NODATABURST] [INSTCACHE|NOINSTCACHE]
			[INSTBURST|NOINSTBURST] [FASTROM|NOFASTROM]
			[TRAP|NOTRAP] [COPYBACK|NOCOPYBACK] [EXTERNALCACHE|
			NOEXTERNALCACHE] [NOMMUTEST] [CHECK 68010|68020|
			68030|68040|68881|68882|68851|MMU|FPU]

@{B}Sintaxis@{UB}	CACHE/S,BURST/S,NOCACHE/S,NOBURST/S,DATACACHE/S,
			NODATACACHE/S,DATABURST/S,NODATABURST/S,INSTCACHE/S,
			NOINSTCACHE/S,INSTBURST/S,NOINSTBURST/S,COPYBACK/S,
			NOCOPYBACK/S,EXTERNALCACHE/S,NOEXTERNALCACHE/S,
			FASTROM/S,NOFASTROM/S,TRAP/S,NOTRAP/S,NOMMUTEST/S,
			CHECK/K

@{B}Localización@{UB}	C:

CPU ajusta varias opciones del microprocesador instalado en su Amiga. CPU
también muestra el procesador y las opciones utilizadas actualmente.

Muchas opciones sólo trabajan con ciertas versiones de la familia de
procesadores 680x0. El 68020 tiene un tipo especial de memoria conocido
como caché de instrucciones. Cuando se usa el caché de instrucciones, las
instrucciones se ejecutan más rápidamente. El 68030 y el 68040 tienen dos
tipos de memoria caché: de instrucciones y de datos.

Si se indican opciones mutuamente exclusivas, se utilizará la opción más
segura. El poder usar una opción en particular depende del tipo de
procesador presente.

  CACHE				Activa todos los cachés.

  NOCACHE			Desactiva todos los cachés.

  BURST				Activa el modo burst tanto para datos como
				para instrucciones.

  NOBURST			Desactiva el modo burst tanto para datos
				como para instrucciones.

  DATACACHE			Activa el caché de datos.

  NODATACACHE			Desactiva el caché de datos.

  DATABURST			Activa el modo burst para datos.

  NODATABURST			Desactiva el modo burst para datos.

  INSTCACHE			Activa el caché de instrucciones.

  NOINSTCACHE			Desactiva el caché de instrucciones.

  INSTBURST			Activa el modo burst para instrucciones.

  NOINSTBURST			Desactiva el modo burst para instrucciones.

  FASTROM			Cuando esta opción se utiliza con un
				procesador que soporta MMU, copia la ROM
				del sistema a RAM de 32 bits, haciendo que
				el acceso al sistema operativo sea
				significativamente más rápido. Entonces CPU
				protege contra escritura la zona de RAM de
				forma que la información no pueda ser
				modificada.

  NOFASTROM			Desactiva FASTROM.

  TRAP				Esta opción es sólo para programadores.

  NOTRAP			Esta opción es sólo para programadores.

  COPYBACK			Activa el caché copyback del 68040.

  NOCOPYBACK			Desactiva el caché copyback del 68040.

  EXTERNALCACHE			Activa el caché externo.

  NOEXTERNALCACHE		Desactiva el caché externo.

  NOMMUTEST			Permite cambiar los ajustes de MMU sin tener
				que comprobar si se está utilizando MMU.

La opción CHECK, cuando se da con una palabra clave (68010, 68020, 68030,
68040, 68881, 68882 o 68851, MMU, FPU) comprueba la presencia del procesador
indicado por la palabra clave.

@{B}Ejemplos:@{UB}

  1.> CPU
  System: 68030 68881 (INST: Cache Burst) (DATA: Cache NoBurst)

  1> CPU NODATACACHE FASTROM
  System: 68030 68881 FastROM (INST: Cache Burst) (DATA: NoCache NoBurst)

  1.> CPU NOBURST DATACACHE NOINSTCACHE
  System: 68030 68881 (INST: NoCache NoBurst) (DATA: Cache NoBurst)

@endnode

@NODE DATE

@{B}DATE@{UB}

Muestra o cambia la fecha y/o hora del sistema.

@{B}Formato@{UB}		DATE [<día>] [<fecha>] [<hora>] [<@{I}TO|VER @{UI}<NombreFichero>]

@{B}Sintaxis@{UB}	DAY,DATE,TIME,TO=VER/K

@{B}Localización@{UB}	C:

DATE sin argumentos muestra la fecha y hora actuales del sistema, incluyendo
el día de la semana. La hora se muestra usando un reloj de 24 horas.

DATE <fecha> cambia sólo la fecha. El formato de entrada y presentación de
<fecha> es DD-MMM-YY (día-mes-año). Se necesitan los guiones por medio. No
se necesita poner un cero al principio de la fecha si ésta es de menos de
10. Debe indicarse en castellano el número de las primeras tres letras del
mes, así como las últimas dos cifras del año.

Si la fecha ya está ajustada, puede resetearla indicando el nombre de un
día de la semana, por ejemplo. También puede usar "mañana" o "ayer" como
argumento <día>. No puede usar un nombre de día de la semana si la fecha
está a más de siete días vista, tanto hacia adelante como hacia atrás.

DATE <hora> ajusta la hora. El formato de entrada y presentación de <hora>
es HH:MM:SS (horas:minutos:segundos). Los segundos son opcionales.

Si su Amiga no tiene un reloj de batería y no ajusta la fecha, cuando el
sistema arranque tomará la fecha del fichero más reciente que haya en el
disco de arranque.

Si indica la opción TO o VER, junto con un nombre de fichero, la salida del
comando DATE se enviará a ese fichero, eliminando cualquier contenido
anterior del mismo.

Los ajustes realizados con el comando DATE sólo cambian el reloj del
sistema; se pierden al apagar el ordenador. Para ajustar el reloj de batería
desde Shell, deberá ajustar la fecha y usar @{"SETCLOCK" link setclock} SAVE.

A pesar de que DATE acepta y muestra la fecha y la hora de una forma muy
básica, programas como Clock (el reloj guardado en el cajón Tools) muestran
la fecha y la hora según los ajustes de @{"Locale" link EditorLocale}.

@{B}Ejemplo 1:@{UB}

  1.> DATE
  jueves 19-may-94 08:04:03

@{B}Ejemplo 2:@{UB}

  1.> DATE 6-sep-92

ajusta la fecha al 6 de septiembre de 1992. La hora no cambia.

@{B}Ejemplo 3:@{UB}

  1.> DATE mañana

adelanta el reloj 24 horas.

@{B}Ejemplo 4:@{UB}

  1.> DATE TO Fechado

envía una nota con la fecha actual al fichero Fechado.

@{B}Ejemplo 5:@{UB}

  1.> DATE 23:00

pone el reloj a las 11 de la noche (las 23 horas y 0 minutos).

@{B}Ejemplo 6:@{UB}

  1.> DATE 1-ene-02

pone la fecha al 1 de enero del 2002. La fecha más antigua que puede poner
es el 1 de enero de 1978.

@endnode

@NODE DELETE

@{B}DELETE@{UB}

Borra ficheros y directorios.

@{B}Formato@{UB}		DELETE {<nombre|patrón>} [ALL] [QUIET] [FORCE]

@{B}Sintaxis@{UB}	FILE/M/A,ALL/S,QUIET/S,FORCE/S

@{B}Localización@{UB}	C:

DELETE intenta borrar los ficheros y directorios indicados. Puede borrar
varias cosas a la vez indicándolas individualmente o usando un comodín para
borrar un conjunto específico de ficheros que respondan a un patrón. El
patrón puede especificar niveles de directorios, así como nombres. Para
interrumpir un DELETE que trabaja sobre varios objetos, pulse Ctrl+C. Un
DELETE sobre múltiples objetos se detendrá automáticamente si encuentra algo
que no puede borrar; por ejemplo, un fichero que está protegido contra
escritura o que está siendo utilizado por otra tarea. Un DELETE que use un
patrón eliminará todo lo que pueda y dará un listado con todo lo que no
pudo borrar, si tal cosa ocurrió.

NOTE: AmigaDOS no pide confirmación al borrar. No use la búsqueda por patrón
      para borrar cosas si aún no se ha familiarizado con el procedimiento;
      no podrá recuperar lo que borre, a menos que tenga una copia de
      seguridad actualizada de lo que haya borrado.

Un mensaje de error le avisará de que no puede borrar directorios que
contengan todavía ficheros. Puede evitar este error usando la opción ALL.
DELETE ALL borra el directorio, sus subdirectorios y todos los ficheros
incluidos en los mismos.

Los nombres de fichero se van mostrando en la pantalla una vez que han sido
borrados. Para suprimir la aparición de texto en pantalla, use la opción
QUIET.

Si el bit de protección d (borrable) de un fichero o directorio ha sido
desactivado, el objeto no podrá borrarse a menos que se use la opción FORCE.

@{B}Ejemplo 1:@{UB}

  1.> DELETE FicheroViejo

borra el fichero llamado FicheroViejo del directorio actual.

@{B}Ejemplo 2:@{UB}

  1.> DELETE Work/Prog1 Work/Prog2 Work

borra los ficheros Prog1 y Prog2 del directorio Work y luego borra el
directorio Work si no le quedan más ficheros.

@{B}Ejemplo 3:@{UB}

  1.> DELETE T#?/#?(1|2)

borra todos los ficheros que terminen en 1 o 2 de los directorios que
comiencen por T.

@{B}Ejemplo 4:@{UB}

  1.> DELETE DF1:#? ALL FORCE

borra todos los ficheros de DF1:, incluso aquellos que estén protegidos
contra su borrado.

Mire también: @{"PROTECT" link protect}. Para más ejemplos de uso de DELETE, mire el capítulo
8.

@endnode

@NODE DIR

@{B}DIR@{UB}

Muestra una lista ordenada de los ficheros que contiene un directorio.

@{B}Formato@{UB}		DIR [<dir|patrón>] [@{I}OPT @{UI}A|I|AI|D|F] [ALL] [DIRS] [FILES]
			[INTER]

@{B}Sintaxis@{UB}	DIR,OPT/K,ALL/S,DIRS/S,FILES/S,INTER/S

@{B}Localización@{UB}	C:

DIR muestra los nombres de los ficheros y directorios contenidos en el
directorio indicado o en el directorio actual. Primero se muestran los
directorios, y a continuación una lista alfabética de los ficheros, en
dos columnas. Pulsar Ctrl+C interrumpe el listado del comando.

Las opciones son:

  ALL		Muestra todos los subdirectorios y sus ficheros.

  DIRS		Muestra solamente los directorios.

  FILES		Muestra solamente los ficheros.

  INTER		Entra en un modo de listado interactivo.

Las palabras clave ALL, DIRS, FILES e INTER equivalen a las opciones OPT A,
D, F e I, respectivamente. Las palabras clave más viejas se mantienen para
guardar compatibilidad con versiones anteriores del AmigaDOS. No use OPT con
las palabras clave completas: ALL, DIRS, FILES o INTER.

El modo de listado interactivo se para después de cada nombre para mostrar
un signo de interrogación tras el cual puede introducir comandos. A
continuación mostramos las respuestas aceptables:

  Pulsar Return		Muestra el siguiente nombre de la lista.

  E			Introduce un directorio: los ficheros de ese
			directorio se mostrarán inmediatamente.

  B			Vuelve hacia atrás un nivel en el directorio.

  Del o DELETE		Borra un fichero o un directorio vacío. DEL no es
			la tecla "Del"; introduzca las letras D, E y L.

  T			Muestra el contenido de un fichero.

  C o COMMAND		Le permite introducir comandos adicionales del
			AmigaDOS.

  Q			Sale de la edición interactiva.

  ?			Muestra una lista de los comandos disponibles en
			modo interactivo.

La opción COMMAND le permite ejecutar casi cualquier comando del AmigaDOS
durante el listado interactivo. Para usar un comando, introduzca C (o bien
COMMAND) después del prompt de la interrogación. DIR le pedirá el comando.
Introduzca el comando que quiera y pulse Return. El comando se ejecuta y DIR
continúa. También puede combinar la C y el comando en una sola línea
poniendo el comando entre comillas después de la C.

Por ejemplo,

  ? C "TYPE Prefs.info HEX"

es equivalente a pulsar Q para salir del DIR interactivo, volver al prompt
normal de Shell e introducir:

  1.> TYPE Prefs.info HEX

para mostrar el fichero Prefs.info en la pantalla usando el formato
hexadecimal.

No se recomienda formatear un disco desde el modo interactivo de DIR, ya
que el formateo tiene lugar inmediatamente, sin la aparición de requesters
pidiendo confirmación. Tampoco debe arrancar otro DIR interactivo desde el
que está usando, ya que esto produce una salida de texto ininteligible.

@{B}Ejemplo 1:@{UB}

  1.> DIR Workbench:

muestra una lista de los directorios y ficheros del disco Workbench.

@{B}Ejemplo 2:@{UB}

  1.> DIR MiDisco:#?.memo

muestra todos los directorios y ficheros de MiDisco que terminen en ".memo".

@{B}Ejemplo 3:@{UB}

  1.> DIR Extras: ALL

muestra todo el contenido del volumen Extras: todos los directorios,
subdirectorios y ficheros, incluyendo los contenidos dentro de los
subdirectorios.

@{B}Ejemplo 4:@{UB}

  1.> DIR Workbench: DIRS

muestra solamente los directorios del disco Workbench.

@{B}Ejemplo 5:@{UB}

  1.> DIR Workbench: INTER

comienza un listado interactivo del contenido del disco Workbench.

Para ver @{"más ejemplos" link MuestraDirShell} sobre cómo usar el comando DIR, mire el capítulo 8.

@endnode

@NODE DISKCHANGE

@{B}DISKCHANGE@{UB}

Informa al Amiga de que ha cambiado el disco de una unidad de disco.

@{B}Formato@{UB}		DISKCHANGE <dispositivo>

@{B}Sintaxis@{UB}	DRIVE/A

@{B}Localización@{UB}	C:

Debe usar el comando DISKCHANGE para informar al sistema de que ha cambiado
el disco o el cartucho de una unidad de disco flexible de 5.25 pulgadas o
de una unidad de almacenamiento removible que no dispone de hardware que se
encargue de la detección automática del cambio de disco.

@{B}Ejemplo:@{UB}

Si un requester le pide que inserte un nuevo disco en su drive de 5.25
pulgadas, conocido como DF2:, deberá insertar el disco y luego introducir:

  1.> DISKCHANGE DF2:

El AmigaDOS entonces reconocerá el nuevo disco y podrá continuar.

@endnode

@NODE ECHO

@{B}ECHO@{UB}

Muestra una cadena de texto.

@{B}Formato@{UB}		ECHO [<cadena>] [NOLINE] [@{I}FIRST @{UI}<n>] [@{I}LEN @{UI}<n>] [@{I}TO @{UI}
			<NombreFichero>]

@{B}Sintaxis@{UB}	/M,NOLINE/S,FIRST/K/N,LEN/K/N,TO/K

@{B}Localización@{UB}	Interno

ECHO escribe la cadena de texto indicada en la ventana de salida o
dispositivo actual. Por defecto, la cadena se envía a la pantalla, pero
si usa la opción TO, puede enviarla a cualquier dispositivo o fichero que
desee.

Cuando se indica la opción NOLINE, ECHO no coloca el cursor automáticamente
en la línea siguiente una vez impresa la cadena.

Las opciones FIRST y LEN le permiten mostrar una parte de la cadena. FIRST
<n> indica la posición del carácter desde el que quiere mostrar la cadena;
LEN <n> indica el número de caracteres a mostrar desde la posición indicada
por FIRST. Si se omite la opción FIRST y se da sólo la palabra clave LEN, la
cadena impresa serán los últimos <n> caracteres de la cadena principal. Por
ejemplo, si su cadena tiene 20 caracteres de largo y usa LEN 4, se mostrarán
los caracteres 17, 18, 19 y 20 de la cadena.

@{B}Ejemplos:@{UB}

  1.> ECHO "¿Cómo están ustedes?"
  ¿Cómo están ustedes?

  2.> Echo "¿Cómo están ustedes?" NOLINE FIRST 0 LEN 5
  ¿Cómo1.>

Para ver más ejemplos del uso de ECHO, mire el capítulo 8.

@endnode

@NODE ED

@{B}ED@{UB}

Edita ficheros de texto (un editor de pantalla).

@{B}Formato@{UB}		ED [FROM] <Fichero> [SIZE <n>] [@{I}WITH @{UI}<fichero>] [@{I}WINDOW @{UI}
 			<EspecificacionesDeVentana>] [TABS <n>] [WIDTH|
			COLS <n>] [HEIGHT|ROWS <n>]

@{B}Sintaxis@{UB}	FROM/A,SIZE/N,WITH/K,WINDOW/K,TABS/N,WIDTH=COLS/N,
			HEIGHT=ROWS/N

@{B}Localización@{UB}	C:

Para más información sobre @{"ED" link MiraED}, mire el capítulo 4. Mire el capítulo 8 para
un ejemplo del uso de @{"ED" link MiraED}.

@endnode

@NODE EDIT

@{B}EDIT@{UB}

Edita ficheros de texto procesando el fichero original de forma secuencial
(un editor de líneas).

@{B}Formato@{UB}		EDIT [FROM] <Fichero> [[TO] <Fichero>] [@{I}WITH @{UI}<fichero>]
 			[@{I}VER @{UI}<fichero>] [@{I}OPT @{UI}P <líneas>|W <chars>|
			P<líneas>W<chars>] [WIDTH <chars>] [PREVIOUS
			<líneas>]

@{B}Sintaxis@{UB}	FROM/A,TO,WITH/K,VER/K,OPT/K,WIDTH/N,PREVIOUS/N

@{B}Localización@{UB}	C:

Para más información sobre @{"EDIT" link MiraEDIT}, mire el capítulo 4.

@endnode

@NODE ELSE

@{B}ELSE@{UB}

Especifica una alternativa para una orden IF en un fichero script.

@{B}Formato@{UB}		ELSE

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

ELSE debe usarse junto con el comando IF. ELSE se usa en un bloque IF de un
fichero script para indicar una acción alternativa si la condición de IF no
es cierta. Si la condición IF no es cierta, la ejecución del script salta
de la línea IF a la línea indicada después de ELSE; todos los comandos que
haya en medio se ignoran. Si la condición IF es cierta, los comandos que
sigan inmediatamente a la orden IF serán ejecutados hasta encontrar la orden
ELSE. Entonces la ejecución salta a la orden ENDIF que concluye el bloque
IF.

@{B}Ejemplo:@{UB}

Supongamos que tiene un script, llamado Muestra, que contiene el siguiente
bloque:

  IF EXISTS Dibujo
    Multiview Dibujo
  ELSE
    ECHO "El dibujo no está en este directorio."
  ENDIF

Si el sistema encuentra el fichero Dibujo en el directorio actual, el
programa Multiview será ejecutado y el fichero de dibujo aparecerá en la
pantalla.

Si no se encuentra este fichero en el directorio actual, el script salta al
comando ECHO y el siguiente mensaje aparece en la pantalla:

  El dibujo no está en este directorio.

Mire también: @{"IF" link if}, @{"ENDIF" link endif}, @{"EXECUTE" link execute}.

@endnode

@NODE ENDCLI

@{B}ENDCLI@{UB}

Finaliza un proceso Shell.

@{B}Formato@{UB}		ENDCLI

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

ENDCLI finaliza un proceso Shell.

Mire también: @{"ENDSHELL" link endshell}.

@endnode

@NODE ENDIF

@{B}ENDIF@{UB}

Finaliza un bloque IF en un fichero script.

@{B}Formato@{UB}		ENDIF

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

ENDIF debe usarse junto con un comando IF. ENDIF se usa en los scripts
al final de un bloque IF. Si la condición IF no es cierta o si los comandos
que responden a la condición verdadera se ejecutan y se encuentra una
instrucción ELSE, la ejecución del script salta al siguiente comando ENDIF
que aparezca. Cada orden IF debe terminar en un ENDIF.

El ENDIF está relacionado con el comando IF o ELSE más reciente.

Mire también: @{"IF" link IF}, @{"ELSE" link ELSE}. Para más ejemplos del uso del comando ENDIF, mire
el capítulo 8.

@endnode

@NODE ENDSHELL

@{B}ENDSHELL@{UB}

Finaliza un proceso Shell.

@{B}Formato@{UB}		ENDSHELL

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

ENDSHELL finaliza un proceso Shell y cierra la ventana Shell.

El proceso Shell también puede ser finalizado con ENDCLI, pulsando en el
gadget de cierre o pulsando Ctrl+\.

Use ENDSHELL solamente cuando el Workbench u otro Shell estén corriendo. Si
abandona el Workbench y cierra su único Shell, no podrá comunicarse con el
Amiga sin arrancarlo de nuevo.

La ventana Shell no puede cerrarse si algún proceso lanzado desde Shell y no
independiente del mismo está todavía corriendo. A pesar de que la ventana
pueda permanecer abierta, ésta no aceptará la entrada de información.
Deberá finalizar esos procesos para poder cerrar la ventana. Por ejemplo, si
abrió un editor desde Shell, la ventana Shell no se cerrará hasta que haga
que el editor abandone el sistema.

Para ver algunos ejemplos sobre el uso del comando ENDSHELL, mire el
capítulo 8.

@endnode

@NODE ENDSKIP

@{B}ENDSKIP@{UB}

Finaliza un bloque SKIP en un fichero script.

@{B}Formato@{UB}		ENDSKIP

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

ENDSKIP se usa en los scripts para finalizar la ejecución de un bloque SKIP.
Un bloque SKIP le permite saltarse varios comandos si se produce cierta
condición. Cuando se encuentra ENDSKIP, la ejecución del script continúa en
la línea que se encuentra después de ENDSKIP. La @{"bandera de condición" link BanderasCondicionales} se
pone a 5 (WARN).

Mire también: @{"SKIP" link skip}

@endnode

@NODE EVAL

@{B}EVAL@{UB}

Evalúa expresiones enteras o de Boole.

@{B}Formato@{UB}		EVAL <valor1> {[<operación>] [<valor2>]} [@{I}TO @{UI}<fichero>] 
			[@{I}LFORMAT@{UI}=<cadena>]

@{B}Sintaxis@{UB}	VALUE1/A,OP,VALUE2/M,TO/K,LFORMAT/K

@{B}Localización@{UB}	C:

EVAL se usa para evaluar e imprimir el resultado de una expresión entera. La
porción decimal de los valores de entrada y de los resultados finales se
elimina. Si se da un valor no entero como valor de entrada, la evaluación se
detiene en el punto decimal.

<Valor1> y <Valor2> pueden ser números decimales (el valor por defecto),
hexadecimales u octales. Los números hexadecimales se indican con un 0 o un
signo # al principio. Los caracteres alfabéticos se indican con un apóstrofe
(') al principio, y se evalúan según su valor ASCII.

La palabra clave LFORMAT indica la cadena-formato que se usa para imprimir
la respuesta. Puede usar %X (hexadecimal), %O (octal), %N (decimal) o %C
(carácter). Las opciones %X y %O necesitan que se indique un número de
dígitos (por ejemplo, %X8 da ocho dígitos de salida hexadecimal). Cuando
use la palabra clave LFORMAT, podrá indicar que se imprima una nueva línea
incluyendo *N en la cadena.

Las operaciones soportadas y sus símbolos correspondientes se muestran en la
siguiente tabla:

  adición			+

  sustracción			-

  multiplicación		*

  división			/

  módulo			mod, M, m ó %

  operador AND			&

  operador OR			|

  operador NOT			~

  Mayúsculas izquierda		Mayúsculas izquierda, L ó l

  Mayúsculas derecha		Mayúsculas derecha, R ó r

  negación			-

  OR exclusivo			xor, X ó x

  equivalencia de bits		eqv, E ó e

EVAL puede utilizarse en los scripts como contador en los bucles. En este
caso, use la opción TO para enviar la salida de EVAL a ese fichero.

Los paréntesis pueden utilizarse en las expresiones.

@{B}Ejemplo 1:@{UB}

  1.> EVAL 64 / 8 + 2
  10

@{B}Ejemplo 2:@{UB}

  1.> EVAL 0x5f / 010 LFORMAT="La respuesta es %X4*N"
  La respuesta es 000B
  1.>

Esto divide el hexadecimal 5f (95) por el octal 10 (8), lo que da como
resultado 000B, que es la porción entera de la respuesta decimal 11.875 (el
prompt 1.> aparece inmediatamente después de 000B si *N no se indica en la
cadena LFORMAT).

Para ver @{"más ejemplos" link BuclesAmigaDOS} del uso del comando EVAL, mire el capítulo 8.

@endnode

@NODE EXECUTE

@{B}EXECUTE@{UB}

Ejecuta un script, haciendo opcionalmente una sustitución de argumentos.

@{B}Formato@{UB}		EXECUTE <script> [{<argumentos>}]

@{B}Sintaxis@{UB}	FILE/A

@{B}Localización@{UB}	C:

EXECUTE se utiliza para ejecutar scripts de comandos AmigaDOS. Las líneas
del script se ejecutan como si se hubieran introducido en el prompt del
Shell. Si el bit de protección "s" del fichero está activado y el fichero
está en la senda de búsqueda, sólo necesita introducir el nombre del
fichero; el comando EXECUTE no es necesario.

Puede hacer una sustitución de parámetros en los scripts que contienen
palabras clave especiales. Cuando se usan estas palabras clave, puede
pasarle variables al script incluyendo estas variables en la línea de
comando EXECUTE. Antes de ejecutar el script, el AmigaDOS contrasta los
nombres de los parámetros del script con los argumentos dados en la línea
de comando. Si alguno coincide, el AmigaDOS usa los valores especificados
en la línea de comando para sustituir los nombres de parámetros del script.
También puede indicar valores por defecto para que el AmigaDOS haga uso de
ellos si no hay variables. Si no ha indicado una variable y tampoco hay una
por defecto indicada en el script, entonces el valor del parámetro es nulo
(no se realiza sustitución).

Las palabras clave permitidas en la sustitución de parámetros se explican en
el @{"capítulo 5" link ComandosPunto}. Cada palabra clave de la línea de comando debe ir precedida
por un punto (.).

Mire también: @{"IF" link if}, @{"SKIP" link skip}, @{"FAILAT" link failat}, @{"LAB" link lab}, @{"ECHO" link echo}, @{"RUN" link run}, @{"QUIT" link quit}. Para ver más
ejemplos del uso del comando EXECUTE, mire el capítulo 8.

@endnode

@NODE FAILAT

@{B}FAILAT@{UB}

Hace que una secuencia de comandos no se interrumpa a menos que se alcance
una determinada condición de error.

@{B}Formato@{UB}		FAILAT [<n>]

@{B}Sintaxis@{UB}	RCLIM/N

@{B}Localización@{UB}	Interno

Los comandos avisan de que han fallado ajustando un código de retorno que no
es cero. El código de retorno, normalmente 5, 10 o 20, indica la gravedad
del error. Un código de retorno superior o igual a un cierto límite, el
límite de fallo, hace que se detenga una secuencia de comandos no
interactivos (comandos especificados después de @{"RUN" link RUN} o en un script).

Use el comando FAILAT para cambiar el límite de fallo RCLIM (Return Code
Limit), que en su estado original es de 10. Si incrementa el límite, hará
que el ordenador considere que ciertos tipos de error no son fatales,
permitiendo que siga con su tarea a pesar de la aparición de estos errores.
El argumento de este comando ha de ser un número positivo. El límite de
fallo vuelve a su valor inicial de 10 al salir de una secuencia de comandos.

Si se omite el argumento, se muestra el límite de fallo actual.

@{B}Ejemplo:@{UB}

Supongamos que un script contiene las siguientes líneas:

  COPY DF0:MiFichero TO RAM:
  ECHO "MiFichero ha sido copiado a RAM:"

Si el ordenador no encuentra MiFichero, el script se detiene y aparece el
siguiente mensaje en la ventana Shell:

  Can't open MiFichero for input - no encuentro objeto
  copy failed returncode 20

Sin embargo, si cambia el límite de fallo por un valor superior a 20, el
script continuará a pesar de que el comando COPY produzca un error. Por
ejemplo, si modificase el script para que fuese:

  FAILAT 21
  COPY DF0:MiFichero TO RAM:
  ECHO "MiFichero ha sido copiado a RAM:"

a pesar de que el ordenador no encuentra MiFichero, el script continúa. El
siguiente mensaje aparecerá en la ventana Shell:

  Can't open MiFichero for input - no encuentro objeto
  MiFichero ha sido copiado a RAM:

Mire también: @{"ECHO" link echo}, @{"EXECUTE" link execute}.

@endnode

@NODE FAULT

@{B}FAULT@{UB}

Imprime el mensaje que corresponde a los números de error indicados.

@{B}Formato@{UB}		FAULT {<n>}

@{B}Sintaxis@{UB}	/N/M

@{B}Localización@{UB}	Interno

FAULT imprime los mensajes que corresponden a los números de error que se
indiquen. Puede indicar en una sola línea los números de error que quiera,
separándolos por un espacio.

@{B}Ejemplo:@{UB}

Si recibe el mensaje de error:

  Error al abrir DF1:Dibujo 205

y necesita más información, introduzca:

  1.> FAULT 205
  Fault 205: no encuentro objeto

Esto quiere decir que el error se produjo al no encontrar el fichero Dibujo
en DF1:.

En el @{"apéndice A" link ApéndiceA} aparece una lista completa de los mensajes de error.

@endnode

@NODE FILENOTE

@{B}FILENOTE@{UB}

Une un comentario a un fichero.

@{B}Formato@{UB}		FILENOTE [FILE] <fichero|patrón> [COMMENT <comentario>]
			[ALL] [QUIET]

@{B}Sintaxis@{UB}	FILE/A,COMMENT,ALL/S,QUIET/S

@{B}Localización@{UB}	C:

FILENOTE une un comentario opcional de hasta 79 caracteres al fichero
indicado o a todos los ficheros que respondan a un patrón determinado.

Si el <comentario> incluye espacios, deberá indicarse entre comillas.
Para poner comillas como parte del comentario, cada comilla deberá ir
inmediatamente precedida por un asterisco (*), y además el comentario
entero deberá indicarse entre comillas, sin importar si tiene o no espacios.

Si el argumento <comentario> se omite, se eliminará el comentario que pueda
tener el fichero indicado.

Crear un comentario con FILENOTE es lo mismo que introducir un comentario
en el gadget "Comentario" de la ventana de información de un icono. Así
pues, los cambios realizados por FILENOTE se reflejan en la ventana de
información, y viceversa.

Use el comando LIST para ver los comentarios hechos con FILENOTE. Si un
fichero tiene comentarios, LIST los mostrará inmediatamente debajo del
nombre del fichero en el listado.

Cuando se realiza una copia sobre un fichero ya existente (indicado como el
argumento TO del comando COPY), este fichero pierde su contenido original,
a excepción de su comentario. El comentario del fichero indicado como
argumento FROM del comando COPY no se copia, a menos que se utilice la
opción CLONE o COM del comando COPY.

Si se da la opción ALL, FILENOTE añade el <comentario> a todos los ficheros
y subdirectorios que coinciden con el patrón indicado. Si se da la opción
QUIET, se suprime la salida de información hacia la pantalla.

@{B}Ejemplo 1:@{UB}

  1.> FILENOTE Sonata "allegro non troppo"

une el comentario @{B}allegro non troppo@{UB} al fichero Sonata.

@{B}Ejemplo 2:@{UB}

  1.> FILENOTE Toccata "*"presto*""

une el comentario @{B}"presto"@{UB} al fichero Toccata.

@endnode

@NODE GET

@{B}GET@{UB}

Obtiene el valor de una varible local.

@{B}Formato@{UB}		GET <nombre>

@{B}Sintaxis@{UB}	NAME/A

@{B}Localización@{UB}	Interno

GET se usa para recuperar y mostrar el valor de una variable de entorno
local. El valor se muestra en la ventana actual.

Las variables de entorno locales sólo son reconocidas por el Shell en el que
fueron creadas y por los Shells abiertos por un comando NEWSHELL ejecutado
en ese Shell. Si abre un Shell aparte abriendo el icono Shell o usando la
opción de menú "Ejecutar comando", las variables de entorno locales creadas
antes no se reconocen.

@{B}Ejemplo:@{UB}

  1.> GET editor
  Extras:Tools/MEmacs

Mire también: @{"SET" link set}.

@endnode

@NODE GETENV

@{B}GETENV@{UB}

Obtiene el valor de una variable global.

@{B}Formato@{UB}		GETENV <nombre>

@{B}Sintaxis@{UB}	NAME/A

@{B}Localización@{UB}	Interno

GETENV se usa para recuperar y mostrar el valor de una variable de entorno
global. El valor se muestra en la ventana actual. Las variables globales se
almacenan en ENV:, y son reconocidas por todos los Shells.

@{B}Ejemplo:@{UB}

  1.> GETENV editor
  Extras:Tools/MEmacs

Mire también: @{"SETENV" link setenv}.

@endnode

@NODE ICONX

@{B}ICONX@{UB}

NOTA: ICONX se usa solamente como herramienta por defecto en los iconos de
      proyecto, y no puede utilizarse directamente como comando en Shell.

Permite la ejecución de un fichero script de comandos AmigaDOS desde un
icono.

@{B}Formato@{UB}		ICONX

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	C:

Para usar ICONX, primero tiene que crear o copiar un icono de proyecto y
asignárselo a un script. Abra entonces la ventana de información del icono y
cambie la herramienta por defecto por C:ICONX, y seleccione "Grabar" para
guardar el cambio realizado en el fichero .info. Ahora puede ejecutar el
script pulsando dos veces sobre el icono.

Cuando el icono se abre, ICONX cambia el directorio actual por el directorio
en el que se encuentra el icono de proyecto antes de ejecutar el script. Si
el script produce una salida de información, ésta se mostrará en una ventana
de consola en la pantalla Workbench.

Pueden indicarse varios tipos de herramientas (antes conocidas como
"ToolTypes") en el icono del script. El tipo de herramienta WINDOW hace que
se utilice un tipo de ventana de entrada/salida alternativo. Por defecto,
las características de la ventana son:

  WINDOW=CON:0/50//80/IconX/AUTO/WAIT/CLOSE

La opción AUTO abre una ventana sólo si el script produce una salida de
información. Si se abre una ventana, la opción WAIT obliga a ésta a
permanecer abierta aunque el script haya terminado, hasta que usted
personalmente la cierre. La opción CLOSE añade a la ventana un gadget de
cierre.

El tipo de herramienta WAIT (no lo confunda con la opción WAIT del tipo de
herramienta WINDOW ya explicado) indica el número de segundos que la ventana
de entrada/salida permanecerá abierta después de que el script haya
terminado. Si usa esta opción, la ventana por defecto de entrada/salida no
podrá cerrarse hasta que el tiempo indicado haya pasado. También hay un tipo
de herramienta llamado DELAY, que funciona de una forma similar, exceptuando
el hecho de que su argumento se debe indicar en 1/50avos de segundo, en lugar
de hacerlo en segundos.

El tipo de herramienta STACK especifica el número de bytes que se usarán como
pila durante la ejecución del script. Si no se usa este tipo de herramienta,
se usará por defecto una pila de 4096 bytes.

Finalmente, el tipo de herramienta USERSHELL ejecuta el script usando el
Shell actual del usuario, en lugar del Shell normal guardado en ROM. Deberá
indicar USERSHELL=YES. Los Shells del usuario son Shells que puede adquirir
e instalar en su sistema para sustituir el entorno Shell estándar del Amiga.

La selección extendida pasa al script los ficheros que tienen iconos. El
script toma estos nombres de fichero como palabras clave. Para usar esta
característica, la palabra clave .KEY debe aparecer al principio del script.
En este caso, el comando EXECUTE del AmigaDOS se usa para ejecutar el
fichero script.

Mire también: @{"EXECUTE" link execute}. Para @{"más ejemplos" link IconXRun} del uso del comando ICONX, mire el
capítulo 8.

@endnode

@NODE IF

@{B}IF@{UB}

Evalúa operaciones condicionales en los ficheros script.

@{B}Formato@{UB}		IF [NOT] [WARN|ERROR|FAIL] [<cadena> @{I}EQ@{UI}|@{I}GT@{UI}|@{I}GE @{UI}<cadena>]
 			[VAL] [@{I}EXISTS@{UI} <fichero>]

@{B}Sintaxis@{UB}	NOT/S,WARN/S,ERROR/S,FAIL/S,EQ/K,GT/K,GE/K,VAL/S,
			EXISTS/K

@{B}Localización@{UB}	Interno

En un fichero script, IF, cuando su condición es cierta, lleva a cabo los
comandos indicados a continuación hasta encontrar una orden ENDIF o ELSE.
IF debe utilizarse junto con ENDIF; sin embargo, ELSE es opcional. Cuando
la condición no es cierta, la ejecución salta directamente a ENDIF o a
ELSE. Las condiciones y los comandos de los bloques IF y ELSE pueden
ocupar más de una línea antes de su ENDIF correspondiente.

Los IFs anidados saltan al ENDIF más cercano.

Las palabras clave adicionales se describen a continuación:

  NOT			Invierte la interpretación del resultado.

  WARN			Se cumple si el código de retorno anterior es
			superior o igual a 5.

  ERROR			Se cumple si el código de retorno anterior es
			superior o igual a 10; sólo está disponible si
			FAILAT se ajusta a un valor superior a 10.

  FAIL			Se cumple si el código de retorno anterior es
			superior o igual a 20; sólo está disponible si
			FAILAT se ajusta a un valor superior a 20.

  <a> GT <b>		Se cumple si el texto de <a> da un valor superior
			al de <b> (sin importar el uso de mayúsculas o
			minúsculas). Use NOT GT para hacer la operación
			"menor que".

  <a> GE <b>		Se cumple si el texto de <a> es mayor o igual al
			texto de <b> (sin importar el uso de mayúsculas o
			minúsculas). Use NOT GE para hacer la operación
			"menor o igual que".

  <a> EQ <b>		Se cumple si los textos de <a> y el de <b> son
			idénticos (no se tiene en cuenta la diferencia
			entre mayúsculas y minúsculas).

  VAL			Indica una comparación numérica.

  EXISTS <fichero>	Se cumple si el fichero existe.

Si se da más de una palabra clave de las que hacen uso de una condición
(WARN, ERROR y FAIL), se usará la que haga uso de un valor más bajo.

Puede usar variables locales o globales con IF colocando un signo "$"
inmediatamente antes del nombre de la variable.

@{B}Ejemplo 1:@{UB}

  IF EXISTS Work/Prog
    TYPE Prog HEX
  ELSE
    ECHO "No está allí."
  ENDIF

El AmigaDOS muestra el contenido del fichero Work/Prog si éste se encuentra
en el directorio actual. Si no puede encontrarlo allí, el AmigaDOS mostrará
el mensaje "No está allí." y continuará con las órdenes que haya después de
ENDIF.

@{B}Ejemplo 2:@{UB}

  IF ERROR
    SKIP errlab
  ENDIF
  ECHO "No hay error"
  LAB errlab

Si el comando anterior produce un código de retorno superior o igual a 10,
el AmigaDOS se saltará el comando ECHO para ir a la etiqueta "errlab".

Mire también: @{"EXECUTE" link execute}, @{"FAILAT" link failat}, @{"LAB" link lab}, @{"QUIT" link quit}, @{"SKIP" link skip}. Para ver más ejemplos
del uso del comando IF, mire el capítulo 8.

@endnode

@NODE INFO

@{B}INFO@{UB}

Da información sobre los dispositivos montados en el sistema.

@{B}Formato@{UB}		INFO [<dispositivo>]

@{B}Sintaxis@{UB}	DEVICE

@{B}Localización@{UB}	C:

INFO muestra una línea con información sobre cada dispositivo de
almacenamiento montado, incluyendo disqueteras y particiones de disco
duro. Se indican el nombre de unidad, el tamaño máximo del disco, el
espacio ocupado y el espacio libre en bloques, el porcentaje del disco
lleno, el número de errores de software ocurridos en el disco, el estado
del disco y el nombre del mismo.

Si se indica el argumento <dispositivo>, INFO ofrece información solamente
sobre el dispositivo o volumen especificado.

@{B}Ejemplo:@{UB}

  1.> INFO
  Mounted disks:
  Unit	    Size    Used    Free Full Errs   Status   Name
  RAM:       40K      40       0 100%   0  Read/Write Ram Disk
  DH0:     8363K    8731    7995  52%   0  Read/Write Workbench
  DF0:      879K    1257     501  72%   0  Read/Write Varios2
  DH1:      195M   59318  340928  15%   0  Read/Write Work
  DH2:      163M   16194  317684   5%   0  Read/Write Archivos

  Volumes available:
  Varios2 [Mounted]
  Ram Disk [Mounted]
  Archivos [Mounted]
  Work [Mounted]
  Workbench [Mounted]

@endnode

@NODE INSTALL

@{B}INSTALL@{UB}

Escribe o inspecciona el bloque de arranque de un disco flexible formateado
o de una tarjeta PCMCIA, informando así al sistema de que puede arrancar
desde ese dispositivo.

@{B}Formato@{UB}		INSTALL [DRIVE] <DF0:|DF1:|DF2:|DF3:|CC0:> [NOBOOT] [CHECK]
			[FFS]

@{B}Sintaxis@{UB}	DRIVE/A,NOBOOT/S,CHECK/S,FFS/S

@{B}Localización@{UB}	C:

INSTALL borra el bloque de arranque de un disco flexible o tarjeta de
memoria PCMCIA, escribiendo luego un bloque de arranque válido. INSTALL
no afecta a los ficheros ni a los directorios del disco o tarjeta en
cuestión. El dispositivo debe contar con los ficheros y directorios
necesarios para poder actuar como dispositivo válido de arranque.

La opción NOBOOT borra el bloque raíz de un disco o tarjeta AmigaDOS,
impidiendo que pueda utilizarse para arrancar el sistema.

La opción CHECK comprueba si hay un código de arranque válido. Avisa de si
un disco o tarjeta puede servir para arrancar el ordenador, y si el código
de arranque estándar de Commodore-Amiga está presente en ese medio. Esto es
útil para detectar algunos virus.

El interruptor FFS se ignora. Permanece como parte de la sintaxis solamente
para asegurar la compatibilidad con scripts y programas antiguos.

@{B}Ejemplo 1:@{UB}

  1.> INSTALL DF0: CHECK
  No bootblock installed

indica que hay un disco flexible en DF0: que no sirve para arrancar el
sistema.

@{B}Ejemplo 2:@{UB}

  1.> INSTALL DF0:

hace que el disco de la unidad DF0: pueda servir para arrancar el sistema.

@{B}Ejemplo 3:@{UB}

  1.> INSTALL DF0: CHECK
  Appears to be 2.0 DC-FFS bootblock

indica que hay un disco flexible en DF0: que tiene un bloque de arranque de
tipo FFS con caché de directorios.

@endnode

@NODE JOIN

@{B}JOIN@{UB}

Une dos o más ficheros.

@{B}Formato@{UB}		JOIN [FILE] {fichero|patrón} @{I}AS@{UI}|@{I}TO @{UI}<fichero>

@{B}Sintaxis@{UB}	FILE/M/A,AS=TO/K/A

@{B}Localización@{UB}	C:

JOIN copia los ficheros indicados, en el orden dado, para construir un nuevo
fichero. Este fichero destino no puede tener el mismo nombre que ninguno de
los ficheros fuente. Debe indicar un fichero destino. Los ficheros
originales permanecen sin cambios. Pueden unirse tantos ficheros como se
desee en una sola operación.

TO puede utilizarse como sinónimo de AS.

@{B}Ejemplo:@{UB}

  1.> JOIN Parte1 Parte2 Parte3 AS FicheroGlobal

Para ver @{"otro ejemplo" link SortJoinFicheros} de JOIN, mire el capítulo 8.

@endnode

@NODE LAB

@{B}LAB@{UB}

Indica una etiqueta en un fichero script.

@{B}Formato@{UB}		LAB [<cadena>]

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

LAB se usa en los scripts para definir una etiqueta a la que poder saltar
desde un comando SKIP. La etiqueta <cadena> puede tener cualquier longitud,
pero debe ser alfanumérica; no se permiten símbolos. Si la cadena <cadena>
contiene espacios, deberá indicarse entre comillas.

Mire también: @{"SKIP" link skip}, @{"IF" link if}, @{"EXECUTE" link execute}. Para más ejemplos de LAB, mire el
capítulo 8.

@endnode

@NODE LIST

@{B}LIST@{UB}

Lista información sobre directorios y ficheros.

@{B}Formato@{UB}		LIST [{<dir|patrón|fichero>}] [@{I}P@{UI}|@{I}PAT @{UI}<patrón>] [KEYS]
			[DATES] [NODATES] [@{I}TO @{UI}<nombre>] [@{I}SUB @{UI}<cadena>] 
			[@{I}SINCE @{UI}<fecha>] [@{I}UPTO @{UI}<fecha>] [QUICK] [BLOCK]
			[NOHEAD] [FILES] [DIRS] [@{I}LFORMAT @{UI}<cadena>] [ALL]

@{B}Sintaxis@{UB}	DIR/M,P=PAT/K,KEYS/S,DATES/S,NODATES/S,TO/K,SUB/K,SINCE/K,
			UPTO/K,QUICK/S,BLOCK/S,NOHEAD/S,FILES/S,DIRS/S,
			LFORMAT/K,ALL/S

@{B}Localización@{UB}	C:

LIST muestra información sobre el contenido del directorio actual. Si
indica un argumento <dir>, <patrón> o <fichero>, LIST muestra información
sobre el directorio especificado, los directorios y los ficheros que
responden a ese patrón, o sobre el fichero indicado, respectivamente. El
argumento PAT le permite indicar un patrón adicional.

A menos que indique otras opciones, LIST muestra lo siguiente:

  nombre		El nombre del fichero o directorio.

  tamaño		El tamaño del fichero en bytes. Si no hay nada en
			este fichero, el campo mostrará "vacío". Con los
			directorios, en lugar del tamaño se muestra "Dir".

  protección		Los bits de protección de los que dispone este
			fichero se muestran como letras. Los bits
			desactivados se indican como guiones. La mayor
			parte de los ficheros muestran los bits de
			protección por defecto, "----rwed", que significa
			que el fichero puede leerse, modificarse, ejecutarse
			y borrarse. Mire el comando @{"PROTECT" link protect} para más
			información sobre los bits de protección.

  fecha y hora		La fecha y hora en la que el fichero fue creado o
			modificado por última vez.

  comentario		El comentario, si lo hay, asignado al fichero usando
			el comando @{"FILENOTE" link FILENOTE}. Va precedido por un signo de
			dos puntos (:).

LIST usa las siguientes opciones para cambiar la forma en que se muestra la
salida de información:

  KEYS			Muestra el bloque a partir del cual está grabado el
			fichero o directorio.

  DATES			Muestra las fechas (por ejemplo, DD-MMM-YY es el
			valor por defecto que se utiliza en EE.UU.)

  NODATES		No muestra la información sobre la fecha y la hora.

  TO <nombre>		Indica un fichero o dispositivo que va a recibir
			la salida de LIST; por defecto, LIST envía la
			información a la ventana actual.

  SUB <cadena>		Muestra solamente los ficheros que contienen la
			cadena <cadena> en su nombre.

  SINCE <fecha>		Muestra solamente los ficheros creados desde la
			fecha indicada.

  UPTO <fecha>		Muestra solamente los ficheros creados antes o en
			la fecha indicada.

  QUICK			Muestra solamente los nombres de los ficheros y los
			directorios.

  BLOCK			Muestra el tamaño de los ficheros en forma de
			bloques de 512 bytes, en lugar de bytes.

  NOHEAD		Suprime la información sobre el directorio buscado
			y la línea de los totales.

  FILES			Lista solamente los ficheros (no los directorios).

  DIRS			Lista solamente los directorios (no los ficheros).

  LFORMAT		Define una cadena que se utilizará para formatear
			la salida de información de LIST.

  ALL			Lista el contenido de todos los directorios y los
			subdirectorios.

La opción LFORMAT modifica la salida de LIST y puede utilizarse como una
forma rápida de generar ficheros script. Cuando use LFORMAT, deberá indicar
una cadena de formato de salida; esta cadena se produce por cada fichero o
directorio listado normalmente. Puede contener cualquier texto que desee,
además de la información producida por LIST. Cuando se usa LFORMAT, las
opciones QUICK y NOHEAD se seleccionan automáticamente. Para grabar la
salida, deberá redireccionarla a un fichero usando el operador > o
indicando un fichero como argumento TO (para @{"más ejemplos" link GeneraScriptsLFormat} del uso de
la opción LFORMAT, mire el capítulo 8).

Los operadores sustitutorios disponibles son:

  %A		Imprime los atributos del fichero (los bits de protección).

  %B		Imprime el tamaño del fichero en bloques.

  %C		Imprime los comentarios del fichero.

  %D		Imprime la fecha asociada al fichero.

  %E		Imprime solamente la extensión del fichero.

  %K		Imprime el bloque inicial del fichero.

  %L		Imprime la longitud del fichero en bytes.

  %M		Imprime solamente el nombre del fichero, omitiendo cualquier
		extensión.

  %N		Imprime el nombre del fichero.

  %P		Imprime la senda padre del fichero.

  %S		Esta opción ha sido superada por %N y %P, pero aún funciona.

  %T		Imprime la hora asociada al fichero.

Puede poner un especificador de longitud y/o justificación entre el signo
porcentual (%) y el especificador de campo. Para indicar la justificación
izquierda, coloque un signo menos (-) antes del especificador de longitud.
De lo contrario, la información mostrada se justificará a la derecha.

La salida por defecto del comando LIST usa el siguiente formato:

  %-24 %7L %A %D %T

@{B}Ejemplo 1:@{UB}

  1.> LIST Dirs
  ENV                          Dir ----rwed Hoy       09:39:35
  Clipboards                   Dir ----rwed Hoy       09:39:32
  T                            Dir ----rwed Hoy       09:39:37
3 directories - 6 blocks used

Solamente los directorios del directorio actual, en este caso Ram Disk:, se
mostrarán.

@{B}Ejemplo 2:@{UB}

  1.> LIST LI#? TO RAM:Libs.file

LIST buscará los directorios y ficheros que comiencen por LI. La salida de
LIST se enviará al fichero Libs.file en RAM:.

@{B}Ejemplo 3:@{UB}

  1.> LIST DF0:Documentos UPTO 9-Oct-90

Solamente se mostrarán los directorios y los ficheros del directorio
Documentos de DF0: que no hayan sido creados ni modificados desde el 9
de octubre de 1990.

Para ver @{"otros ejemplos" link MuestraDirShell 64} del comando LIST, mire el capítulo 8.

@endnode

@NODE LOADRESOURCE

@{B}LOADRESOURCE@{UB}

Pre-carga recursos en la memoria para evitar excesivos cambios de disco.

@{B}Formato@{UB}		LOADRESOURCE {<nombre>} [LOCK|UNLOCK]

@{B}Sintaxis@{UB}	NAME/M,LOCK/S,UNLOCK/S

@{B}Localización@{UB}	C:

LOADRESOURCE reduce la necesidad de cambiar de discos frecuentemente en los
sistemas basados en disco flexible pre-cargando los siguientes tipos de
recursos en la memoria:

  Librerías		Indique el nombre de senda de la librería.

  Dispositivos		Indique el nombre de senda del dispositivo; no puede
			bloquear dispositivos de la memoria con la opción
			LOCK.

  Fuentes de texto	Indique el nombre de senda del fichero de fuente que
			quiera cargar.

  Catálogos		Indique un nombre de senda como LOCALE:Catalogs/
			<idioma>/Sys/<Catálogo>.

La opción {<nombre>} indica las sendas correspondientes a los recursos que
quiere cargar. La opción LOCK ordena al comando que "eche el candado" sobre
los recursos, como librerías, fuentes, y catálogos cargados en la memoria.
Esto evita que el sistema se deshaga de ese recurso al quedarse escaso de
memoria. Aunque puede pre-cargar recursos en la memoria usando LOADRESOURCE,
no puede obligarles a permanecer allí usando la opción LOCK. La opción
UNLOCK le dice al comando que "abra el candado" que mantiene los recursos
en la memoria, permitiendo que el sistema pueda deshacerse de ellos si anda
escaso de memoria.

Introduciendo LOADRESOURCE sin opciones, se listarán todos los recursos que
están guardados "bajo candado" en RAM.

@{B}Ejemplo 1:@{UB}

  LOADRESOURCE LIBS:asl.library

carga asl.library en la memoria. El sistema puede quitar esta librería de la
RAM si se queda escaso de memoria, a menos que indique la opción LOCK en la
línea de comando.

@{B}Ejemplo 2:@{UB}

  LOADRESOURCE FONTS:topaz/11

carga el tamaño 11 de la fuente Topaz en la memoria.

@{B}Ejemplo 3:@{UB}

  LOADRESOURCE LOCALE:Catalogs/Español/Sys/monitors.catalog

es un nombre de senda válido.

@endnode

@NODE LOADWB

@{B}LOADWB@{UB}

Carga el Workbench.

@{B}Formato@{UB}		LOADWB [-DEBUG] [DELAY] [CLEANUP] [NEWPATH]

@{B}Sintaxis@{UB}	-DEBUG/S,DELAY/S,CLEANUP/S,NEWPATH/S

@{B}Localización@{UB}	C:

LOADWB carga el Workbench. Normalmente, esto se hace en el fichero startup-
sequence, que carga el Workbench al arrancar el sistema. Si cierra el
Workbench, LOADWB puede cargarlo de nuevo desde Shell.

La opción -DEBUG hace aparecer un menú especial para los programadores,
"Depurar", en la barra de menú del Workbench. Si se indica la opción DELAY,
LOADWB esperará tres segundos antes de ejecutarse para permitir que cese la
actividad del disco. La opción CLEANUP reorganiza automáticamente la ventana
de disco inicial.

El Workbench "recuerda" las sendas actuales cuando se ejecuta el comando
LOADWB y usa estas sendas en cada Shell abierto desde el Workbench. NEWPATH
le permite indicar una nueva senda desde el Shell actual.

@{B}Ejemplo 1:@{UB}

Si abandona el Workbench y está trabajando en una ventana Shell, introduzca:

  1.> LOADWB

para volver al Workbench. Si introduce LOADWB con el Workbench ya cargado,
el comando no tiene efecto alguno.

@{B}Ejemplo 2:@{UB}

  1.> PATH DF1:bin ADD
  1.> LOADWB NEWPATH

carga el Workbench. Los Shells abiertos desde el icono tienen la misma senda
que el Shell desde el que se ejecutó el comando LOADWB NEWPATH.

@endnode

@NODE LOCK

@{B}LOCK@{UB}

Controla el estado de protección contra escritura de un dispositivo.

@{B}Formato@{UB}		LOCK <drive> [ON|OFF] [<clave>]

@{B}Sintaxis@{UB}	DRIVE/A,ON/S,OFF/S,PASSKEY

@{B}Localización@{UB}	C:

LOCK activa o desactiva el estado de protección contra escritura de un
dispositivo o partición. El bloqueo permanece activo hasta que el sistema
se resetea o hasta que el bloqueo se anula con el comando LOCK OFF.

Puede indicarse una clave de forma opcional. Si se usa una clave para
bloquear una partición de disco duro, será necesario indicar la misma
clave para desbloquearla. La clave puede tener cualquier número de
caracteres.

@{B}Ejemplo:@{UB}

  1.> LOCK Work: ON CódigoSecreto

La partición Work queda bloqueada. Puede leer el contenido de Work con
comandos como DIR, LIST o MORE, pero no podrá modificar el contenido de la
partición. Si intenta cambiar el contenido de un fichero de la partición
Work, un requester le indicará que Work está protegida contra escritura.
Por ejemplo, si intenta crear un nuevo directorio con una línea como esta:

  1.> MAKEDIR Work:Test

aparecerá el siguiente mensaje:

  Can't create directory Work:Test
  disco protegido contra escritura

Para desbloquear la partición, introduzca:

  1.> LOCK Work: OFF

Si no se usa clave, el bloqueo sólo funciona durante la sesión actual. Si
el Amiga se resetea o si se apaga y se vuelve a encender, el bloqueo ya no
es efectivo.

@endnode

@NODE MAGTAPE

@{B}MAGTAPE@{UB}

Tensa, rebobina y adelanta cintas SCSI (Small Computer System Interface).

@{B}Formato@{UB}		MAGTAPE [@{I}DEVICE @{UI}<Dispositivo>] [@{I}UNIT @{UI}<n>] [RET|RETENSION]
			[REW|REWIND] [@{I}SKIP @{UI}<n>]

@{B}Sintaxis@{UB}	DEVICE/K,UNIT/N/K,RET=RETENSION/S,REW=REWIND/S,SKIP/N/K

@{B}Localización@{UB}	C:

Por defecto, MAGTAPE usa la unidad 4 de dispositivo SCSI. Para cambiar el
valor por defecto, debe usar las palabras clave DEVICE y UNIT.

La opción RET|RETENSION hace correr la cinta hasta el final y la rebobina.
La opción REW|REWIND rebobina la cinta. La opción SKIP <n> se salta <n>
ficheros de la cinta.

MAGTAPE comprueba si la unidad está lista antes de enviar el comando. Si
la cinta no está en línea, deberá repetir el comando.

@{B}Ejemplo:@{UB}

  1.> MAGTAPE DEVICE second_scsi.device UNIT 0 REW

@endnode

@NODE MAKEDIR

@{B}MAKEDIR@{UB}

Crea un nuevo directorio.

@{B}Formato@{UB}		MAKEDIR {<nombre>}

@{B}Sintaxis@{UB}	NAME/M

@{B}Localización@{UB}	C:

MAKEDIR crea nuevos directorios con los nombres que indique. El comando
funciona con un nivel de directorio cada vez, así que los directorios de
los que partan las sendas dadas deben existir previamente. El comando
producirá un error si intenta crear un directorio con un nombre que coincide
con el de un fichero o directorio que ya existe en el directorio en el que
intenta crear el nuevo directorio. 

MAKEDIR no crea un icono de cajón para el nuevo directorio.

@{B}Ejemplo 1:@{UB}

  1.> MAKEDIR Pruebas

crea un directorio llamado Pruebas en el directorio actual.

@{B}Ejemplo 2:@{UB}

  1.> MAKEDIR DF1:Xyz

crea un directorio llamado Xyz en el directorio raíz del disco que esté en
DF1:.

@{B}Ejemplo 3:@{UB}

  1.> CD DF0:
  1.> MAKEDIR Documentos Cheques Envíos

crea tres directorios en el disco que haya en DF0: con el nombre Documentos,
Cheques y Envíos.

Para ver más ejemplos de MAKEDIR, mire el capítulo 8.

@endnode

@NODE MAKELINK

@{B}MAKELINK@{UB}

Crea un enlace entre ficheros.

@{B}Formato@{UB}		MAKELINK [FROM] <fichero> [TO] <fichero> [HARD] [FORCE]

@{B}Sintaxis@{UB}	FROM/A,TO/A,HARD/S,FORCE/S

@{B}Localización@{UB}	C:

MAKELINK hace que el fichero FROM apunte a otro fichero, el fichero TO.
Cuando una aplicación o comando llame al fichero FROM, se usará en su lugar
el fichero TO. Por defecto, MAKELINK soporta solamente enlaces por hardware;
el fichero FROM y el fichero TO deben estar en el mismo volumen.

Los enlaces por software, que pueden funcionar entre diferentes volúmenes,
no están implementadas actualmente.

Normalmente, MAKELINK no soporta enlaces entre directorios. Para crear un
enlace de directorios, deberá usar la opción FORCE. Si MAKELINK detecta que
está creando un enlace recursivo, como un enlace hacia un directorio padre,
se mostrará el mensaje "link loop from xxx to xxxxx not allowed".

@endnode

@NODE MOUNT

@{B}MOUNT@{UB}

Hace que un dispositivo conectado al sistema esté disponible para su uso.

@{B}Formato@{UB}		MOUNT {dispositivo} [@{I}FROM @{UI}<fichero>]

@{B}Sintaxis@{UB}	DEVICE/M,FROM/K

@{B}Localización@{UB}	C:

MOUNT lee de un fichero los parámetros de la configuración de un
dispositivo. Entonces usa la información de estos parámetros para @{I}montar@{UI}
los dispositivos (hacer que éstos estén disponibles para el sistema).
Pueden montarse varios dispositivos con un solo comando. El argumento
{dispositivo} indica los nombres de los dispositivos a montar.

MOUNT puede procesar tanto ficheros de montaje de DOSDrivers como las
entradas tradicionales basadas en un fichero MountList, dependiendo de
cómo se indiquen los argumentos. Éstos pueden indicarse de las tres
formas siguientes:

  1. Dando un nombre de dispositivo, MOUNT intenta encontrar un fichero de
     montaje con ese nombre en DEVS:DOSDrivers, luego en SYS:Storage/
     DOSDrivers y finalmente en DEVS:MountList. Éste es el mejor método si
     sólo tiene una configuración para ese dispositivo en su sistema.

  2. Dando una senda, MOUNT busca un fichero de montaje en ese lugar. Pueden
     utilizarse comodines para montar varios dispositivos, como en la línea

       MOUNT DEVS:DOSDrivers/~(#?.info)

     Use este método cuando no tenga los ficheros de montaje solamente
     guardados en los cajones DOSDrivers o tenga que procesar a la vez
     varios ficheros de montaje.

  3. Dando la palabra clave FROM y una senda, MOUNT sabrá el lugar del
     fichero MountList a utilizar. Use este método si no tiene el fichero
     MountList guardado en DEVS: o si tiene varios ficheros MountList.

NOTA: Los tipos de herramientas (antes conocidos como "Tooltypes"), si
      existen en la ventana de información del icono de un fichero de
      montaje, tienen prioridad sobre los propios parámetros indicados en
      el mismo fichero de montaje.

@{B}Ejemplo 1:@{UB}

  1.> MOUNT PIPE:

Esta orden hace que se busque el fichero de montaje DEVS:DOSDrivers/PIPE y
que de existir, sea procesado inmediatamente. Si el fichero DEVS:DOSDrivers/
PIPE no existe, MOUNT buscará entonces el fichero SYS:Storage/DOSDrivers/
PIPE. Si tampoco puede encontrar este fichero, MOUNT buscará la entrada
referente a PIPE: en el fichero DEVS:MountList.

@{B}Ejemplo 2:@{UB}

  1.> MOUNT Work:Devices/PIPE

Esta orden hace que se busque un fichero de montaje para PIPE en Work:
Devices.

@{B}Ejemplo 3:@{UB}

  1.> MOUNT PIPE: FROM SYS:Dispositivos/MountList

Esta orden hace que se busque una entrada para PIPE: en el fichero SYS:
Dispositivos/MountList.

Mire el @{"apéndice B" link UsoDeMountList} para más información sobre los ficheros MountList.

@endnode

@NODE NEWCLI

@{B}NEWCLI@{UB}

Abre una nueva ventana Shell.

@{B}Formato@{UB}		NEWCLI [<Especificación>] [FROM <fichero>]

@{B}Sintaxis@{UB}	WINDOW,FROM

@{B}Localización@{UB}	Interno

NEWCLI abre un nuevo proceso Shell. Equivale a usar el comando @{"NEWSHELL" link newshell}.

@endnode

@NODE NEWSHELL

@{B}NEWSHELL@{UB}

Abre una nueva ventana Shell.

@{B}Formato@{UB}		NEWSHELL [<especificación>] [FROM <fichero>]

@{B}Sintaxis@{UB}	WINDOW,FROM

@{B}Localización@{UB}	Interno

La nueva ventana Shell se convierte automáticamente en la ventana y proceso
actual. La nueva ventana tiene el mismo directorio actual, cadena de prompt,
variables de entorno locales y tamaño de pila que la ventana que la invocó.
Sin embargo, cada ventana Shell es independiente, permitiendo la entrada y
salida de información y la ejecución de programas de forma totalmente
independiente.

La ventana puede cambiarse de tamaño, arrastrarse, modificarse rápidamente
de tamaño con el gadget zoom y colocarse delante o detrás de otras ventanas,
igual que la mayor parte de las otras ventanas del Amiga.

Para crear una ventana de tipo diferente, puede incluir el argumento
<especificación>. Deberá indicar las dimensiones iniciales, la situación
y el título de la ventana con la siguiente sintaxis:

  CON:x/y/anchura/altura/título/opciones

donde:

  x		Es el número de pixels que se dejarán desde el borde
		izquierdo de la pantalla hasta el borde izquierdo de la
 		ventana Shell. No use ningún valor (//) para usar el número
		mínimo de pixels.

  y		Es el número de pixels que se dejarán desde el borde
		superior de la pantalla hasta el borde superior de la
		ventana Shell. No use ningún valor (//) para usar el número
		mínimo posible de pixels.

  anchura	Es la anchura de la ventana Shell, en pixels. No use ningún
		valor (//) para indicar la anchura total de la pantalla.

  altura	Es la altura de la ventana Shell, en pixels. No use ningún
		valor (//) para indicar la altura mínima posible.

  título	Es el texto que aparece en la barra de título de la ventana
		Shell.

Use barras inclinadas para separar los parámetros y las opciones. Si quiere
poner algún espacio en el argumento, deberá indicar el argumento completo
entre comillas ("").

Las opciones permitidas son:

  AUTO		La ventana aparece automáticamente cuando el programa
		necesita la entrada de información o produce una salida
		de la misma. En el caso de la ventana Shell, ésta se abre
		inmediatamente para permitir la entrada de información.
		La ventana sólo podrá cerrarse con el comando ENDSHELL.
		Seleccionar el gadget de cierre de la ventana sirve para
		cerrarla, pero se abre de nuevo, ya que está esperando la
		entrada de información.

  ALT		La ventana aparece con el tamaño y en la posición indicados
		al pulsar el gadget de zoom. Los cuatro parámetros deben ir
		separados por barras inclinadas (por ejemplo, ALT30/30/200/
		200).

  BACKDROP	La ventana aparece pegada al fondo de la pantalla, detrás
		de todas las ventanas del Workbench. Esta ventana Shell no
		puede traerse a la parte frontal de la pantalla; tendrá que
		manipular las demás ventanas para poder verla.

  CLOSE		La ventana tiene todos los gadgets estándar, incluyendo un
		gadget de cierre. Éste es el valor por defecto de las
		ventanas Shell, pero deberá indicar esta opción si quiere
		conseguir una ventana estándar al usar el argumento WINDOW.

  INACTIVE	La ventana se abre, pero no se convierte en la ventana
		activa.

  NOBORDER	La ventana se abre sin los bordes izquierdo ni inferior, y
		cuenta solamente con los gadgets de zoom, de cambio de
		tamaño y de posición adelante/atrás.

  NOCLOSE	La ventana no tiene gadget de cierre. Si abre una consola
		normalmente, no hay gadget de cierre. Si abre una consola
		usando la opción AUTO, automáticamente hay un gadget de
		cierre en la ventana.

  NODEPTH	La ventana no tiene gadget de posición adelante/atrás.

  NODRAG	La ventana no puede arrastrarse. Tiene gagdets de zoom, de
		posición adelante/atrás y de cambio de tamaño, pero no
		gadget de cierre.

  NOSIZE	La ventana sólo tiene el gadget adelante/atrás.

  SCREEN	La ventana se abre en una pantalla pública. Esta pantalla
		debe existir previamente. Debe indicar el nombre de la
		pantalla después de la palabra clave SCREEN.

  SIMPLE	Si aumenta el tamaño de la ventana, el texto se expande
		para aprovechar el nuevo espacio disponible, permitiéndole
		ver el texto que se había ido por la parte superior de la
		ventana. Este valor se usa por defecto en las ventanas Shell
		estándar.

  SMART		Si aumenta el tamaño de la ventana, el texto no se expande
		para cubrir el nuevo espacio disponible. Esto ahorra
		memoria.

  WAIT		La ventana sólo puede cerrarse seleccionando el gadget de
		cierre o introduciendo Ctrl+\. Si WAIT es la única opción,
		no habrá gadget de cierre.

NEWSHELL usa el fichero de arranque por defecto, S:Shell-startup, a menos
que se indique otro fichero con la opción FROM. Por ejemplo, podría tener
varios ficheros Shell-startup diferentes, teniendo cada uno diferentes alias
de comandos. De esta forma podría crear diferentes Shells con FROM.

El comando NEWCLI tiene el mismo efecto que NEWSHELL; invoca a un nuevo
proceso Shell.

@{B}Ejemplo 1:@{UB}

  1.> NEWSHELL

abre una nueva ventana Shell con la especificación por defecto para la
ventana.

@{B}Ejemplo 2:@{UB}

  1.> NEWSHELL "CON://640/200/Mi Shell/CLOSE"

abre una ventana Shell que comienza en la esquina superior izquierda de la
pantalla y que mide 640 pixels de ancho por 200 pixels de alto. La ventana
se titula "Mi Shell" y tiene un gadget de cierre. El argumento completo va
entre comillas porque el título contiene un espacio. Si añade el comando a
su fichero User-startup, se abrirá una ventana Shell cada vez que arranque
su Amiga.

@{B}Ejemplo 3:@{UB}

  1.> NEWSHELL FROM S:Programa.startup

abre un nuevo Shell, pero en lugar de ejecutar el fichero Shell-startup,
se ejecutará el fichero S:Programa.startup. Podría tener alias y comandos
de prompt en el fichero Programa.startup que usaría solamente cuando
estuviese programando, por ejemplo.

Para ver @{"más ejemplos" link PersonalizaNewShell} de NEWSHELL, mire el capítulo 8.

@endnode

@NODE PATH

@{B}PATH@{UB}

Controla la lista de directorios en los que Shell buscará los comandos.

@{B}Formato@{UB}		PATH [{<dir>}] [ADD] [SHOW] [RESET] [REMOVE] [QUIET]

@{B}Sintaxis@{UB}	PATH/M,ADD/S,SHOW/S,RESET/S,REMOVE/S,QUIET/S

@{B}Localización@{UB}	Interno

PATH le permite ver, hacerle añadidos o modificar la senda de búsqueda que
sigue el AmigaDOS cuando busca un comando o programa para ejecutarlo. Cuando
un directorio se encuentra en la senda de búsqueda, no necesita indicar la
senda completa para hacer uso de un comando contenido en ese directorio. Con
sólo introducir el nombre, el AmigaDOS buscará por los directorios de la
senda de búsqueda hasta que encuentre el fichero.

NOTA: La senda de búsqueda sólo se utiliza cuando el AmigaDOS busca un
      comando o un programa que ejecutar. Siempre es necesario indicar
      la senda completa para los argumentos de comandos como COPY y DELETE.

Puede introducir el comando PATH solamente o con la opción SHOW para ver
los nombres de los directorios de la senda de búsqueda actual. Normalmente,
cuando PATH muestra los nombres de los directorios, aparece un requester si
el sistema no encuentra un volumen que forma parte de la senda de búsqueda.
Por ejemplo, si añade un disco flexible a la senda de búsqueda y luego quita
ese disco de la disquetera, un requester le pedirá que inserte el disco.

Si usa la opción QUIET, no hará aparecer requesters para pedirle los
volúmenes que no estén montados. Si PATH encuentra un volumen no montado,
mostrará el mensaje "unidad (o volumen) no montado". Los nombres de los
directorios de ese volumen incluido en la senda no se mostrarán.

La opción ADD hace que se añadan nombres de directorios a la senda de
búsqueda actual. Puede añadir cualquier número de directorios con un solo
comando PATH ADD (la palabra clave ADD es opcional); los nombres de los
directorios han de separarse al menos con un espacio. Cuando usa el comando
PATH, el AmigaDOS comprueba los directorios añadidos.

Para sustituir la senda de búsqueda actual por otra nueva, use PATH RESET
indicando los nombres de los nuevos directorios. La senda de búsqueda
actual, exceptuando el directorio actual y C:, se pierde y se cambia por
la nueva.

La opción REMOVE elimina el directorio nombrado de la senda de búsqueda.

@{B}Ejemplo:@{UB}

  1.> PATH EXTRAS:Tools ADD

añade el directorio Tools del disco Extras a la senda de búsqueda de Shell.
Si EXTRAS: no se encuentra en ninguna disquetera, un requester le pedirá que
lo inserte en cualquier unidad.

Si quita EXTRAS: de la unidad e introduce:

  1.> PATH

se mostrará una lista con los directorios de la lista de búsqueda. Un
requester le pedirá que inserte EXTRAS:. Pero si introduce:

  1.> PATH QUIET

la lista de directorios aparecerá igualmente, pero en este caso aparecerá
un mensaje de error en la lista en lugar de presentar un requester.

Mire también: @{"ASSIGN" link assign}. Para ver @{"más ejemplos" link ChangePathShell} sobre PATH, mire el capítulo 8.

@endnode

@NODE PROMPT

@{B}PROMPT@{UB}

Cambia la cadena del prompt del Shell actual.

@{B}Formato@{UB}		PROMPT [<prompt>]

@{B}Sintaxis@{UB}	PROMPT

@{B}Localización@{UB}	Interno

PROMPT le permite modificar la cadena del prompt, que es el texto impreso
por Shell al principio de la línea de comando. La cadena del prompt puede
contener cualquier carácter, incluyendo secuencias de Escape.

Este manual le muestra la cadena del prompt como 1.>.

La cadena del prompt por defecto es:

  "%N.%S> "

que muestra el número de Shell, un punto, el directorio actual, un corchete
angulado hacia la derecha y un espacio. Introduciendo PROMPT sin ningún
argumento de cadena, el prompt vuelve a su valor por defecto.

Las sustituciones disponibles para la cadena <prompt> son:

  %N		Muestra el número de proceso de Shell.

  %S		Muestra el directorio actual.

  %R		Muestra el código de retorno de la última operación.

No se añade un espacio automáticamente al final de la cadena. Si quiere que
aparezca un espacio entre el prompt y el texto que teclee, colóquelo en la
cadena, y encierre la cadena entre comillas.

Puede usar comandos dentro de la cadena del prompt poniendo el comando entre
apóstrofes inversos (`).

@{B}Ejemplo 1:@{UB}

  1.> PROMPT %N
  1

Sólo aparece el número de Shell. El signo > se elimina del prompt.

@{B}Ejemplo 2:@{UB}

  1.> PROMPT "%N.%S.%R> "
  1.Work:Anim.0> 

Se muestran el número de Shell, el directorio actual y el código de retorno
del comando anterior. Después del signo > se añade un espacio.

Para ver @{"más ejemplos" link CambiaElPrompt} del comando PROMPT, mire el capítulo 8.

@endnode

@NODE PROTECT

@{B}PROTECT@{UB}

Cambia los bits de protección de un fichero o directorio.

@{B}Formato@{UB}		PROTECT [FILE] <fichero|patrón> [FLAGS] [+|-] [<banderas>]
			[ADD|SUB] [ALL] [QUIET]

@{B}Sintaxis@{UB}	FILE/A,FLAGS,ADD/S,SUB/S,ALL/S,QUIET/S

@{B}Localización@{UB}	C:

Todos los ficheros y directorios tienen una serie de bits de protección
(atributos) guardados con ellos que controlan sus propiedades. Estos bits
pueden modificarse para indicar el tipo de fichero y las operaciones
permitidas. PROTECT se usa para activar o desactivar los bits de protección.
Para los directorios, sólo el bit "d" resulta útil.

Los bits de protección se representan con letras:

  s		El fichero es un script.

  p		El fichero es un comando puro y por tanto puede hacerse
		residente.

  a		El fichero ha sido archivado.

  r		El fichero puede ser leído.

  w		El fichero puede ser modificado.

  e		El fichero es ejecutable (un programa o comando).

  d		El fichero o directorio puede borrarse (los ficheros que se
		encuentran dentro de un directorio protegido contra borrado
		todavía pueden borrarse).

Use el comando @{"LIST" link list} para ver los bits de protección asociados con un
fichero. El apartado de los bits de protección muestra los bits de protección
activados con sus letras y los desactivados como guiones. Por ejemplo, un
fichero que es legible, modificable y borrable tiene "----rw-d" en el
apartado de los bits de protección.

Para indicar todo el campo de los bits de protección al mismo tiempo,
introduzca las letras de los bits que quiera activar como el argumento
FLAGS sin otras palabras clave. Los bits nombrados se activarán, mientras
que los demás se desactivarán.

Los símbolos + y - (o las palabras clave equivalentes, ADD y SUB) se usan
para controlar bits específicos sin afectar al estado de los bits no
especificados. Poniendo + ó - antes de las letras de los bits a activar o
desactivar, respectivamente, hará que se cambien solamente esos bits. No
ponga ningún espacio entre el signo y las letras. El orden de las letras
no importa. ADD y SUB trabajan de forma similar, pero debe haber un espacio
entre la palabra clave y las letras. No puede activar y desactivar bits con
el mismo comando.

La opción ALL añade o elimina los bits de protección indicados de todos los
ficheros y subdirectorios que respondan al patrón indicado. La opción QUIET
suprime la salida de información hacia la pantalla.

@{B}Ejemplo 1:@{UB}

  1.> PROTECT DF0:Memo +rw

activa solamente los bits de protección r (legible) y w (escribible o
modificable) del fichero Memo de DF0:. Los demás bits de protección
seguirán igual.

@{B}Ejemplo 2:@{UB}

  1.> PROTECT L:#? e SUB

desactiva el bit de protección e (ejecutable) en todos los ficheros del
directorio L:.

@{B}Ejemplo 3:@{UB}

  1.> PROTECT Work:Paint rwed

El estado de los bits de protección de Work:Paint pasa a ser "----rwed".

@endnode

@NODE QUIT

@{B}QUIT@{UB}

Sale de un fichero script con un determinado código de retorno.

@{B}Formato@{UB}		QUIT [<código de retorno>]

@{B}Sintaxis@{UB}	RC/N

@{B}Localización@{UB}	Interno

QUIT detiene la ejecución del script con el código de retorno indicado.
El código de retorno por defecto es de cero. Le recomendamos que emplee
los valores de código de retorno estándar de 5, 10 y 20.

@{B}Ejemplo:@{UB}

  ASK "¿Quiere parar ahora?"
  IF WARN
    QUIT 5
  ENDIF
  ECHO "OK"
  ECHO "El script continúa"

Si pulsa Y en el prompt, el script se interrumpe, ya que WARN es igual al
código de retorno de 5. Si pulsa N o Return:

  OK
  El script continúa

se muestra en la ventana Shell.

@endnode

@NODE RELABEL

@{B}RELABEL@{UB}

Cambia el nombre de volumen del disco que está en la unidad indicada por
otro diferente.

@{B}Formato@{UB}		RELABEL [DRIVE] <drive> [NAME] <nombre>

@{B}Sintaxis@{UB}	DRIVE/A,NAME/A

@{B}Localización@{UB}	C:

Los nombres de volumen se ponen cuando los discos son formateados. RELABEL
le permite cambiar el nombre de volumen de un disco por el nombre que
prefiera.

En los sistemas basados en disco flexible que sólo cuentan con una unidad
de disco, asegúrese de indicar los discos por su nombre de volumen en lugar
de por su nombre de dispositivo.

@{B}Ejemplos:@{UB}

  1.> RELABEL Workbench: MiDisco

cambia el nombre del disco Workbench por MiDisco. No es necesario un signo
de dos puntos al final del segundo nombre.

  1.> RELABEL DF2: Datos

cambia el nombre del disco que está en DF2: por Datos.

@endnode

@NODE REMRAD

@{B}REMRAD@{UB}

Elimina el disco RAM recuperable.

@{B}Formato@{UB}		REMRAD [<dispositivo>] [FORCE]

@{B}Sintaxis@{UB}	DEVICE,FORCE/S

@{B}Localización@{UB}	C:

REMRAD le permite eliminar de la memoria el disco RAM recuperable
(normalmente montado como RAD:) sin apagar el ordenador. Si ha montado
más de un disco RAM recuperable, indique el DISPOSITIVO en particular.

REMRAD hace que RAD: borre todos sus ficheros y quede desactivado. Sin
embargo, el icono del disco RAD:RAM_0 no desaparece. La próxima vez que
el Amiga se resetee, RAD: desaparecerá completamente de la memoria y el
icono ya no aparecerá.

Si el dispositivo está siendo utilizado cuando se llama al comando REMRAD,
la operación se interrumpe mientras aparece un mensaje que avisa de que el
dispositivo está siendo usado. Para eliminarlo mientras está en uso, deberá
utilizar la opción FORCE.

@endnode

@NODE RENAME

@{B}RENAME@{UB}

Cambia el nombre o el lugar de un fichero o directorio.

@{B}Formato@{UB}		RENAME [FROM] {<nombre>} [TO|AS] <nombre> [QUIET]

@{B}Sintaxis@{UB}	FROM/A/M,TO=AS/A,QUIET/S

@{B}Localización@{UB}	C:

RENAME cambia el nombre del fichero o directorio FROM por el nombre indicado
como argumento TO. Los ficheros o directorios FROM y TO deben estar en el
mismo volumen. Si el nombre es de un directorio, RENAME cambia el nombre del
directorio sin afectar a los nombres de los ficheros o directorios de ese
directorio. Cuando hay varias cosas en el argumento FROM, el argumento TO
debe ser un directorio.

Si cambia de nombre a un directorio o si usa RENAME para dar a un fichero
el nombre de otro directorio, el AmigaDOS cambia la posición de ese
directorio o fichero dentro de la jerarquía del sistema de ficheros.
Efectivamente, esto traslada el fichero o directorio.

@{B}Ejemplo 1:@{UB}

  1.> RENAME Work/Ex1 AS :Test/Ex2

cambia el nombre del fichero Ex1 por Ex2 y lo traslada del directorio Work
al directorio Test. El directorio Test debe existir previamente en el
directorio raíz para que el comando funcione.

@{B}Ejemplo 2:@{UB}

  1.> RENAME 3.doc 5.doc a.doc TO Docs

traslada los ficheros 3.doc, 5.doc y a.doc al directorio Docs. El directorio
Docs debe existir previamente.

@endnode

@NODE REQUESTCHOICE

@{B}REQUESTCHOICE@{UB}

Permite a los scripts del AmigaDOS y de ARexx usar requesters
personalizados.

@{B}Formato@{UB}		REQUESTCHOICE <título> <cuerpo> {<gadgets>}
			[PUBSCREEN <nombre de la pantalla pública>]

@{B}Sintaxis@{UB}	TITLE/A,BODY/A,GADGET/A/M,PUBSCREEN/K

@{B}Localización@{UB}	C:

El argumento <título> indica el título del requester.

El argumento <cuerpo> indica el texto del requester. Pueden indicarse los
saltos de línea usando *N.

El argumento <gadgets> indica el texto que aparecerá en los diferentes
gadgets. Las etiquetas de los gadgets se indicarán dejando un espacio entre
ellas.

El número del gadget seleccionado se imprime como resultado para la consola.
Para permitir su evaluación en un fichero script, puede redireccionar esta
salida a una variable de entorno. Si el requester no puede abrirse, el
comando genera un código de retorno de 20.

El argumento PUBSCREEN permite que el requester abra su ventana en una
pantalla pública.

@{B}Ejemplo:@{UB}

  1.> RequestChoice >ENV:rcnum "Nuevo Título" "Este es mi requester*nElija
      un gadget" "OK" "A lo mejor" "Cancelar"

ENV:rcnum contiene 0, 1 o 2 después de la selección del gadget. El script
puede usar este valor para controlar la ejecución de los siguientes
comandos.

@endnode

@NODE REQUESTFILE

@{B}REQUESTFILE@{UB}

Permite al AmigaDOS y al ARexx usar un requester de ficheros.

@{B}Formato@{UB}		REQUESTFILE [DRAWER <cajón>] [@{I}FILE @{UI}<fichero>] [@{I}PATTERN @{UI}
 			<patrón>] [@{I}TITLE @{UI}<título>] [@{I}POSITIVE @{UI}<texto>]
			[@{I}NEGATIVE @{UI}<texto>] [@{I}ACCEPTPATTERN @{UI}<patrón>]
			[@{I}REJECTPATTERN @{UI}<patrón>] [SAVEMODE] [MULTISELECT]
			[DRAWERSONLY] [NOICONS] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	DRAWER,FILE/K,PATTERN/K,TITLE/K,POSITIVE/K,NEGATIVE/K,
			ACCEPTPATTERN/K,REJECTPATTERN/K,SAVEMODE/S,
			MULTISELECT/S,DRAWERSONLY/S,NOICONS/S,PUBSCREEN/K

@{B}Localización@{UB}	C:

Cuando se introduce sin argumentos, se crea un requester con los botones OK,
Volúmenes, Anterior y Cancel. Sus gadgets de cadena Directorio y Fichero
están vacíos y muestra el contenido del directorio actual.

El argumento DRAWER indica el contenido inicial del gadget de Directorio.

La opción FILE indica el contenido inicial del gagdet Fichero.

La opción PATTERN le permite usar un patrón estándar AmigaDOS. El requester
incluirá un gadget Patrón e indicará el contenido del gadget. Si esta opción
no se usa, el requester no tendrá el gadget Patrón.

La opción TITLE indica el título del requester.

La opción POSITIVE indica el texto que aparecerá en la opción positiva
(izquierda) en el requester de ficheros.

La opción NEGATIVE indica el texto que aparecerá como opción negativa
(a la derecha) en el requester de ficheros.

La opción ACCEPTPATTERN indica un patrón estándar AmigaDOS. Sólo los
ficheros que respondan a este patrón aparecerán en el requester de ficheros.

La opción REJECTPATTERN indica también un patrón estándar del AmigaDOS. En
este caso, los ficheros que respondan a este patrón no se mostrarán en el
requester de ficheros.

Si se indica SAVEMODE, el requester se utilizará para grabar ficheros en
disco. Si se usa MULTISELECT, el requester permitirá seleccionar varios
ficheros a la vez. Si se usa DRAWERSONLY, el requester no tendrá el gadget
Fichero. Efectivamente, esto hace que el requester se convierta en un
requester de directorios. Si se usa NOICONS, el requester no mostrará los
iconos (los ficheros .info).

Los ficheros seleccionados se devuelven a la línea de comando, encerrados
entre comillas y separados por espacios. El comando genera un código de
retorno de 0 si selecciona un fichero o 5 si cancela el requester.

El argumento PUBSCREEN permite que el requester abra su ventana en una
pantalla pública.

@{B}Ejemplo:@{UB}

  1.> REQUESTFILE DRAWER Devs: TITLE "Mi requester" NOICONS

@endnode

@NODE RESIDENT

@{B}RESIDENT@{UB}

Muestra y modifica la lista de comandos residentes.

@{B}Formato@{UB}		RESIDENT [<nombre residente>] [<nombre de fichero>] [REMOVE]
			[ADD] [REPLACE] [PURE] [FORCE] [SYSTEM]

@{B}Sintaxis@{UB}	NAME,FILE,REMOVE/S,ADD/S,REPLACE/S,PURE=FORCE/S,SYSTEM/S

@{B}Localización@{UB}	Interno

RESIDENT carga un comando en la memoria y lo añade a la lista de comandos
residentes que guarda el Shell. Esto permite ejecutar el comando sin tener
que cargarlo desde disco cada vez. Si se invoca RESIDENT sin opciones,
aparecerá la lista de comandos residentes.

Para hacer residente un comando, éste debe ser puro; esto significa que
debe ser reentrante y re-ejecutable. Un comando reentrante es un comando
que funciona correctamente cuando es utilizado por dos o más programas al
mismo tiempo. Un comando re-ejecutable es un comando que no tiene que ser
cargado de nuevo para poder ser ejecutado. Los comandos que tienen estas
características son considerados puros y por ello tienen el bit p (puro)
activado.

Los siguientes comandos no pueden hacerse residentes: @{"BINDDRIVERS" link binddrivers}, @{"CONCLIP" link conclip},
@{"IPREFS" link iprefs}, @{"LOADRESOURCE" link loadresource}, @{"LOADWB" link loadwb} y @{"SETPATCH" link setpatch}.

Haga un @{"LIST" link list}ado del directorio C para comprobar la presencia del bit de
protección "p" y determinar qué comandos son puros.

Muchos de los comandos del directorio C:, así como el comando MORE del cajón
Utilities, son comandos puros, y pueden por tanto hacerse residentes. Si un
comando no tiene su bit p activado, probablemente no puede hacerse residente
con seguridad (el hecho de activar el bit p de un comando o programa no lo
convierte en puro).

La opción REPLACE es la opción por defecto y no necesita ser indicada
explícitamente. Si no se indica el <nombre residente> (por ejemplo, si sólo
indica un nombre de fichero), RESIDENT usa la parte del nombre de fichero
como el nombre de la lista residente. Debe indicar la senda completa para
el fichero.

Si indica <nombre residente> y RESIDENT encuentra un programa con ese
nombre en la lista, intentará sustituir el comando. Deberá entonces usar
ese <nombre residente> para aludir a la versión residente del comando. La
sustitución tiene éxito sólo si el comando previamente residente no está en
uso.

Para evitar la sustitución y hacer varias versiones de un comando residentes
simultáneamente, use la opción ADD, dando un <nombre residente> diferente
a cada versión cargada.

Si usa la opción SYSTEM, el comando se añadirá a la porción de sistema de
la lista residente, y estará disponible como un componente residente. Los
comandos añadidos a la lista residente con la opción SYSTEM no pueden
eliminarse. Para listar estos ficheros en la lista de RESIDENT, deberá usar
la opción SYSTEM.

La opción PURE obliga a RESIDENT a cargar comandos que no estén marcados
como puros a fin de poder así usarlos para comprobar su grado de pureza.
Use la opción PURE con precaución. Asegúrese de que los programas que hace
residentes responden a las características exigibles a tales comandos, o
tenga cuidado de no usarlos en más de un proceso a la vez.

También puede saber si un comando es interno con RESIDENT. Para desactivar
un comando interno (por ejemplo, si una aplicación tiene un comando con el
mismo nombre), use RESIDENT <comando> REMOVE. El comando puede activarse de
nuevo con la opción REPLACE.

@{B}Ejemplo 1:@{UB}

  1.> RESIDENT C:COPY

hace residente el comando COPY (sustituyendo cualquier versión anterior del
mismo).

@{B}Ejemplo 2:@{UB}

  1.> RESIDENT Copy2 DF1:C/COPY ADD

añade otra versión de COPY a la lista de comandos residentes, bajo el nombre
Copy2.

@{B}Ejemplo 3:@{UB}

  1.> RESIDENT XDir DF1:C/XDir PURE

hace residente una versión no pura del comando DIR para hacer experimentos
con ella.

@{B}Ejemplo 4:@{UB}

  1.> RESIDENT CD REMOVE

hace que no esté disponible la versión interna del comando CD.

@{B}Ejemplo 5:@{UB}

  1.> RESIDENT CD REPLACE

restaura el comando CD para permitir su uso de nuevo.

Mire también: @{"PROTECT" link protect}, @{"LIST" link list}.

@endnode

@NODE RUN

@{B}RUN@{UB}

Ejecuta comandos como procesos en segundo plano.

@{B}Formato@{UB}		RUN <comando...> [{+<comando>}]

@{B}Sintaxis@{UB}	COMMAND/F

@{B}Localización@{UB}	Interno

RUN se usa para ejecutar procesos en segundo plano. Un proceso en segundo
plano no abre su propia ventana para la entrada o la salida ni tampoco se
adueña del Shell actual.

RUN intenta ejecutar el <comando> y los posibles argumentos introducidos en
la línea de comando. Puede ejecutar varias líneas de comando separándolas
con un signo de suma (+). Si pulsa Return después del signo de suma, RUN
interpretará la siguiente línea como una continuación de la misma línea de
comando.

Para hacer que sea posible cerrar la ventana Shell desde la que se ejecutó
el proceso, deberá redirigir la salida de RUN con RUN >NIL: <comando>.

El nuevo Shell en segundo plano tiene la misma senda de búsqueda y tamaño
de pila de comando que el Shell desde el que se ejecutó el RUN.

Puede ejecutar comandos almacenados en la lista residente. Los comandos
residentes son comprobados antes de los comandos de la senda de búsqueda.
Un Shell abierto con RUN NEWSHELL usa el fichero de arranque por defecto,
S:Shell-startup.

@{B}Ejemplo 1:@{UB}

  1.> RUN COPY Texto TO PRT: +
  DELETE Texto +
  ECHO "Impresión terminada."

imprime el fichero Texto copiándolo al dispositivo de impresión, luego lo
borra y después muestra el mensaje indicado. El signo de suma permite
indicar varias líneas de comando seguidas antes de ser ejecutadas una por
una.

@{B}Ejemplo 2:@{UB}

  1.> RUN EXECUTE Comseq

ejecuta en segundo plano todos los comandos del fichero script Comseq.

Para ver @{"más ejemplos" link TrabajaConShellCaray} del comando RUN, mire el capítulo 8.

@endnode

@NODE SEARCH

@{B}SEARCH@{UB}

Busca la cadena de texto indicada en los ficheros contenidos en los
directorios especificados.

@{B}Formato@{UB}		SEARCH [FROM] {<nombre|patrón>} [SEARCH] <cadena|patrón> 
			[ALL] [NONUM] [QUIET] [QUICK] [FILE] [PATTERN]

@{B}Sintaxis@{UB}	FROM/M,SEARCH/A,ALL/S,NONUM/S,QUIET/S,QUICK/S,FILE/S,
			PATTERN/S

@{B}Localización@{UB}	C:

SEARCH busca en todos los ficheros del directorio FROM la cadena de texto
indicada en la cadena especificada en SEARCH (las palabras clave FROM y
SEARCH son opcionales). Si se usa el interruptor ALL, SEARCH también
buscará en los subdirectorios del directorio FROM. SEARCH muestra el
nombre del fichero en el que busca y la línea que contiene la cadena
en cuestión. Deberá usar comillas para indicar una cadena que contenga
espacios. La búsqueda no contempla diferencias entre mayúsculas y
minúsculas.

Las opciones son:

  NONUM			No se imprimen números de línea con las cadenas.

  QUIET			La búsqueda es silenciosa; no se muestran los
			nombres de los ficheros que están siendo
			investigados.

  QUICK			Usa un formato de salida más compacto.

  FILE			Busca un fichero con el nombre especificado, en
			lugar de una cadena de texto.

  PATTERN		Usa un patrón para buscar la cadena.

SEARCH devuelve un cero como bandera de condición si se encuentra el objeto,
o un 5 (WARN) si no lo encuentra. Para dejar de buscar el fichero actual y
pasar al siguiente (si lo hay), pulse Ctrl+D. SEARCH puede interrumpirse con
Ctrl+C.

@{B}Ejemplos:@{UB}

  1.> SEARCH DEVS: DOSDrivers globvec
      DOSDrivers (dir)
        MOUNTLIST..
      19     GlobVec = -1

  1.> SEARCH Utilities #?.info FILE
      Workbench:Utilities/Clock.info
      Workbench:Utilities/Multiview.info

@endnode

@NODE SET

@{B}SET@{UB}

Crea una variable local.

@{B}Formato@{UB}		SET [<nombre>] [<cadena...>]

@{B}Sintaxis@{UB}	NAME,STRING/F

@{B}Localización@{UB}	Interno

SET sin argumentos da una lista de las variables locales actuales.

SET con los argumentos <nombre> y <cadena> crea una nueva variable de
entorno. La primera palabra después de SET se toma como <nombre>. Todo
lo demás de la línea de comando se toma como el argumento <cadena>. No
son necesarias las comillas.

Una variable de entorno creada con SET es local para el Shell en la que se
ha creado. Si crea un nuevo Shell con el comando NEWSHELL, ese Shell también
reconocerá las variables creadas en su Shell padre. Sin embargo, si crea un
nuevo Shell con la opción "Ejecutar comando" del Workbench o abriendo el
icono Shell, las variables creadas con SET no se reconocerán en los nuevos
Shells.

Puede llamar a variables de entorno en un script o en una línea de comando
colocando un signo de dólar ($) inmediamente antes de su nombre.

Para eliminar la definición de una variable de entorno local, use el comando
@{"UNSET" link unset}.

@{B}Ejemplos:@{UB}

  1.> SET Origen Este proceso ha sido lanzado desde el icono.

crea la variable local Origen, que contiene un mensaje que le recuerda que
un Shell ha sido invocado desde un icono en lugar de con NEWSHELL.

  1.> ECHO $Origen
  Este proceso ha sido lanzado desde el icono.

Mire también: @{"GET" link get}, @{"UNSET" link unset}.

@endnode

@NODE SETCLOCK

@{B}SETCLOCK@{UB}

Ajusta o lee la fecha y la hora del reloj de batería.

@{B}Formato@{UB}		SETCLOCK LOAD|SAVE|RESET

@{B}Sintaxis@{UB}	LOAD/S,SAVE/S,RESET/S

@{B}Localización@{UB}	C:

SETCLOCK SAVE graba la fecha y la hora actuales del sistema en el reloj de
batería (si su sistema dispone de uno). La hora y la fecha actuales pueden
ajustarse con el editor @{"Time" link EditorTime} o con el comando @{"DATE" link date}. SETCLOCK SAVE se usa
normalmente después del comando @{"DATE" link date}.

SETCLOCK LOAD pone el sistema en hora según la hora y fecha almacenados en
el reloj de batería. En los sistemas que usan la versión 2 o superior del
AmigaDOS, esto se hace automáticamente durante el proceso de arranque.

La opción RESET resetea el reloj completamente. Use esta opción si
accidentalmente el reloj se apaga o si LOAD y SAVE parecen no funcionar
correctamente.

@{B}Ejemplo:@{UB}

  1.> DATE 22-ENE-93 7:15:25
  1.> SETCLOCK SAVE

graba la fecha, 22 de enero de 1993, y la hora, 7:15 y 25 segundos de la
mañana, en el reloj de batería. Cuando el sistema arranque, el reloj del
sistema se pondrá en hora automáticamente gracias al reloj de batería.

Algunos modelos del Amiga no disponen de relojes de batería a menos que se
instale un módulo de expansión en el sistema.

Mire también: @{"DATE" link date}.

@endnode

@NODE SETDATE

@{B}SETDATE@{UB}

Cambia la fecha de un fichero o directorio.

@{B}Formato@{UB}		SETDATE <fichero|patrón> [<día de la semana>] [<fecha>] 
			[<hora>] [ALL]

@{B}Sintaxis@{UB}	FILE/A,WEEKDAY,DATE,TIME,ALL/S

@{B}Localización@{UB}	C:

SETDATE cambia la fecha y la hora de creación o de última modificación de
un fichero o directorio. SETDATE <fichero> cambia la fecha y la hora del
fichero por la fecha y la hora actuales del sistema. SETDATE ALL cambia la
fecha y la hora de todos los ficheros y subdirectorios que respondan al
patrón introducido.

Los relojes del sistema no se ven afectados por SETDATE.

Puede usar la salida del comando @{"DATE" link date} como entrada para SETDATE.

@{B}Ejemplo 1:@{UB}

  1.> SETDATE Fichero

cambia la fecha y la hora de Fichero por la fecha y la hora actual.

@{B}Ejemplo 2:@{UB}

  1.> SETDATE Fichero 1-4-91 13:45:32

Cambia la fecha y la hora de Fichero por el 1 de abril de 1991, a la 1:45 y
32 segundos de la tarde.

Mire también: @{"DATE" link date}.

@endnode

@NODE SETENV

@{B}SETENV@{UB}

Crea una variable global.

@{B}Formato@{UB}		SETENV [<nombre>] [<cadena...>]

@{B}Sintaxis@{UB}	NAME,STRING/F

@{B}Localización@{UB}	Interno

SETENV sin argumentos da una lista con las variables globales actuales.

SETENV con los argumentos <nombre> y <cadena> crea una nueva variable
de entorno global. La primera palabra después de SETENV se toma como el
<nombre>. El resto de la línea de comando se toma como argumento <cadena>.
No se necesitan comillas.

Las variables globales se almacenan en el directorio ENV: y están
disponibles para todos los procesos. Sin embargo, si una variable local
(definida por @{"SET" link set}) y una variable global tienen el mismo nombre, se usará la
variable local.

Las variables de entorno son llamadas por los scripts u otros comandos
incluyendo un signo de dólar ($) delante del nombre de la variable.

Para eliminar la definición de una variable global, use el comando @{"UNSETENV" link unsetenv}.

@{B}Ejemplo 1:@{UB}

  1.> SETENV Editor Extras:Tools/MEmacs

crea la variable de entorno Editor, que puede utilizarse con la utilidad
MORE. Esta variable indica MEmacs como editor, que se encuentra en el cajón
Tools de EXTRAS:. La variable Editor estará disponible para cualquier Shell.

@{B}Ejemplo 2:@{UB}

  1.> SETENV Editor C:ED

hace lo mismo que el ejemplo anterior, sólo que en este caso el editor será
ED.

  1.> ECHO $Editor
  C:ED

Mire también: @{"GETENV" link getenv}, @{"UNSETENV" link unsetenv}.

@endnode

@NODE SETFONT

@{B}SETFONT@{UB}

Cambia la fuente utilizada por el Shell actual.

@{B}Formato@{UB}		SETFONT <fuente> <tamaño> [SCALE] [PROP] [ITALIC] [BOLD]
			[UNDERLINE]

@{B}Sintaxis@{UB}	NAME/A,SIZE/N/A,SCALE/S,PROP/S,ITALIC/S,BOLD/S,UNDERLINE/S

@{B}Localización@{UB}	C:

SETFONT le permite cambiar la fuente utilizada en una ventana Shell en
particular, ignorando así los ajustes seleccionados en el editor Font.
SETFONT sólo hace efecto sobre la ventana en la que es invocado.

Debe indicar el nombre de la fuente y su tamaño al llamar al comando
SETFONT. Las otras opciones son:

  SCALE			Permite la escalación de fuentes bitmap.

  PROP			Permite usar fuentes proporcionales.

  ITALIC		La fuente aparece en forma itálica.

  BOLD			La fuente aparece en letras negritas.

  UNDERLINE		La fuente aparece subrayada.

Invocando SETFONT se borra todo el contenido de la ventana Shell y se
muestra un nuevo prompt, usando la nueva fuente, en el extremo superior de
la ventana. No se recomienda usar fuentes proporcionales en Shell, ya que
el espaciado variable de los caracteres impide alinear correctamente las
columnas de información y hacen que la edición en la línea de comando sea
más difícil.

@{B}Ejemplo:@{UB}

  1.> SETFONT topaz 11 BOLD UNDERLINE

La ventana Shell se borra y aparece un nuevo prompt usando la fuente Topaz
de 11 puntos, subrayada y en negrita.

@endnode

@NODE SETKEYBOARD

@{B}SETKEYBOARD@{UB}

Elige el mapa del teclado (keymap) desde Shell.

@{B}Formato@{UB}		SETKEYBOARD <nombre del mapa de teclado>

@{B}Sintaxis@{UB}	KEYMAP/A

@{B}Localización@{UB}	C:

SETKEYBOARD elige el mapa de teclado usado por el sistema. A continuación
presentamos los ficheros disponibles para el mapa de teclado:

-----------------------------------------------------------------------------
Mapa de teclado		Teclado
-----------------------------------------------------------------------------

  cdn			Canadiense francés

  ch1			Suizo

  ch2			Alemán suizo

  d			Alemán

  dk			Danés

  e			Español

  f			Francés

  gb			Británico

  i			Italiano

  n			Noruego

  po			Portugués

  s			Sueco

  usa			Americano

  usa2			Dvorak

Para indicar un mapa de teclado de forma permanente, use el editor de
preferencias @{"Input" link EditorInput} para grabar su elección.

@{B}Ejemplo:@{UB}

Para cambiar a un mapa de teclado canadiense francés, introduzca:

  1.> SETKEYBOARD cdn

El fichero cdn debe encontrarse en el directorio KEYMAPS: para que
SETKEYBOARD pueda encontrarlo.

@endnode

@NODE SKIP

@{B}SKIP@{UB}

Salta a una etiqueta durante la ejecución de ficheros script.

@{B}Formato@{UB}		SKIP [<etiqueta>] [BACK]

@{B}Sintaxis@{UB}	LABEL,BACK/S

@{B}Localización@{UB}	Interno

SKIP se usa en los scripts para permitirle saltar hacia adelante en un
script hasta una <etiqueta> definida por una orden @{"LAB" link lab}. Si no se indica una
<etiqueta>, SKIP salta a la siguiente orden @{"LAB" link lab}.

SKIP siempre va hacia adelante partiendo de la línea actual del fichero. Sin
embargo, cuando se usa la opción BACK, SKIP comienza a buscar la etiqueta
desde el comienzo del fichero. Esto permite a SKIP saltar a una etiqueta que
se encuentra antes del mismo.

Sólo puede saltar atrás hasta la última orden EXECUTE. Si no hay órdenes
EXECUTE en un script, el SKIP podrá ir hasta el principio del fichero.

Si SKIP no encuentra la etiqueta indicada, la secuencia de comandos se
interrumpe y se muestra el mensaje "Label <etiqueta> not found by Skip".

@{B}Ejemplo:@{UB}

  .KEY nombre
  IF EXISTS <nombre>
    SKIP mensaje
  ELSE
    ECHO "<nombre> no está en este directorio."
    QUIT
  ENDIF
  LAB mensaje
  ECHO "El fichero <nombre> existe."

Puede ejecutar el script introduciendo:

  1.> EXECUTE Prueba Documento

Si el fichero Ducumento existe en el directorio actual, la ejecución del
script salta con SKIP hasta el siguiente comando LAB. En pantalla aparece
el siguiente mensaje:

  El fichero Documento existe.

Si el fichero Documento no está en el directorio actual, la ejecución del
script salta hasta la línea que está después de la orden @{"ELSE" link else}, mostrando el
mensaje:

  Documento no está en este directorio.

Mire también: @{"EXECUTE" link execute}, @{"LAB" link lab}. Para ver más ejemplos del comando SKIP, mire el
capítulo 8.

@endnode

@NODE SORT

@{B}SORT@{UB}

Ordena alfabéticamente las líneas de un fichero.

@{B}Formato@{UB}		SORT [FROM] <fichero|patrón> [TO] <fichero> [@{I}COLSTART @{UI}<n>]
			[CASE] [NUMERIC]

@{B}Sintaxis@{UB}	FROM/A,TO/A,COLSTART/K,CASE/S,NUMERIC/S

@{B}Localización@{UB}	C:

SORT ordena el fichero FROM alfabéticamente, línea a línea, enviando el
resultado al fichero TO. SORT asume que el fichero es un fichero normal
de texto, cuyas líneas van separadas por los saltos de línea habituales.
Normalmente, SORT no contempla las diferencias entre las letras mayúsculas
y minúsculas. Sin embargo, si se da el interruptor CASE, las letras
mayúsculas se tomarán primero que las minúsculas.

La palabra clave COLSTART indica la columna de carácter en la que
comenzará la ordenación. SORT comienza a comparar las líneas desde ese
punto, volviendo al principio de la línea si las líneas comparadas
coinciden al final.

Cuando se usa la opción NUMERIC, las líneas se interpretan como números
desde la primera columna hacia la derecha, deteniéndose al principio del
primer carácter no numérico. Las líneas que no comienzan con un número se
tratan como un 0. Las líneas quedan finalmente ordenadas por orden numérico.
La opción CASE se ignora si se usa la opción NUMERIC.

@{B}Ejemplo:@{UB}

  1.> SORT DF0:Glosario TO DF0:Glosario.alfa

ordena las líneas del fichero Glosario de forma alfabética, y luego las
envía a un nuevo fichero llamado Glosario.alfa. No se tiene en cuenta la
diferencia entre letras mayúsculas y minúsculas.

Para ver @{"más ejemplos" link SortJoinFicheros} del comando SORT, mire el capítulo 8.

@endnode

@NODE STACK

@{B}STACK@{UB}

Muestra o cambia el tamaño de la pila del Shell actual.

@{B}Formato@{UB}		STACK [[SIZE] <tamaño>]

@{B}Sintaxis@{UB}	SIZE/N

@{B}Localización@{UB}	Interno

Shell usa un cierto tamaño de pila, que es una zona especial de la memoria
que Shell se reserva para su uso. Cada Shell tiene un tamaño de pila
determinado. Si un programa produce un fallo del sistema, cambiar el tamaño
de pila de Shell puede resolver el problema. Los comandos que realizan
operaciones que tienen varios niveles pueden necesitar espacio de pila
adicional.

Los tamaños de pila van normalmente de 4096 a 40000 bytes. Si el tamaño de
pila es demasiado pequeño, puede ocurrir un fallo en el sistema. Por otra
parte, si el tamaño de pila es excesivo, puede consumirse demasiada memoria.

NOTA: Si se queda sin espacio para la pila, se mostrará un mensaje de fallo
      importante en el software. En este caso deberá aumentar el tamaño de
      pila del Shell que causó el error.

Introduciendo el comando STACK sin argumentos, se mostrará el tamaño actual
de la pila.

@endnode

@NODE STATUS

@{B}STATUS@{UB}

Ofrece información sobre los procesos Shell.

@{B}Formato@{UB}		STATUS [<proceso>] [FULL] [TCB] [CLI|ALL] [@{I}COM@{UI}|@{I}COMMAND @{UI}
			<comando>]

@{B}Sintaxis@{UB}	PROCESS/N,FULL/S,TCB/S,CLI=ALL/S,COM=COMMAND/K

@{B}Localización@{UB}	C:

STATUS sin argumentos lista los números de los procesos Shell actuales,
así como el programa o comando que cada uno está ejecutando. El argumento
<proceso> indica un número de proceso, haciendo que STATUS se limite a
mostrar información solamente sobre ese proceso.

Para tener una completa información sobre el tamaño de pila, tamaño global
de vector, prioridad y comando actual de cada proceso, use la palabra clave
FULL. La palabra clave TCB es similar, omitiendo la información sobre el
comando. La palabra clave CLI=ALL da sólo información sobre el comando.

STATUS busca un comando cuando usa la opción COMMAND. STATUS busca por
la lista de Shell, para encontrar el <comando> indicado. Si no consigue
encontrarlo, mostrará el número de proceso de Shell y la @{"bandera de condición" link BanderasCondicionales}
se pondrá a 0. De lo contrario, la @{"bandera" link BanderasCondicionales} se pondrá a 5 (WARN).

@{B}Ejemplo 1:@{UB}

  1.> STATUS 1
  Process 1: Loaded as command: status

@{B}Ejemplo 2:@{UB}

  1.> STATUS 1 FULL
  Process 1: stk 4000, gv 150, pri   0 Loaded as command: status

@{B}Ejemplo 3:@{UB}

  1.> STATUS >RAM:Xyz COMMAND=COPY
  1.> BREAK <RAM:Xyz >NIL: ?

envía una señal de interrupción al proceso que está ejecutando COPY.

@endnode

@NODE TYPE

@{B}TYPE@{UB}

Muestra el contenido de un fichero.

@{B}Formato@{UB}		TYPE {<fichero|patrón>} [@{I}TO @{UI}<nombre>] [@{I}OPT@{UI} H|N] [HEX|NUMBER]

@{B}Sintaxis@{UB}	FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S

@{B}Localización@{UB}	C:

TYPE muestra el contenido del fichero indicado en la ventana actual si no se
da otro destino ni se indica un fichero que reciba esta salida. La palabra
clave TO envía la información a un fichero específico. Si se indica más de
un nombre de fichero, estos nombres de fichero deberán teclearse en
secuencia.

Las opciones OPT H y OPT N equivalen a las palabras clave HEX y NUMBER,
respectivamente. Sin embargo, las dos opciones se excluyen mutuamente.
La opción HEX imprime el fichero en columnas de números hexadecimales,
incluyendo una columna que interpreta los caracteres ASCII. La opción
NUMBER numera las líneas según las va mostrando.

Para detener temporalmente la salida, pulse la barra espaciadora. Para
continuar la salida, pulse Retroceso, Return o Ctrl+X. Para interrumpir
la salida totalmente, pulse Ctrl+C (en cuyo caso se mostrará el mensaje
"***Interrumpido").

@{B}Ejemplo:@{UB}

  1.> TYPE S:Startup-sequence

El contenido del fichero Startup-sequence del directorio S: se muestra en
la pantalla.

Para ver más ejemplos del comando TYPE, mire el capítulo 8.

@endnode

@NODE UNALIAS

@{B}UNALIAS@{UB}

Elimina un alias.

@{B}Formato@{UB}		UNALIAS [<nombre>]

@{B}Sintaxis@{UB}	NAME

@{B}Localización@{UB}	Interno

UNALIAS elimina el alias indicado de la lista de alias. Indicado sin
argumentos, UNALIAS muestra los alias actuales.

Mire también: @{"ALIAS" link alias}.

@endnode

@NODE UNSET

@{B}UNSET@{UB}

Elimina una variable local.

@{B}Formato@{UB}		UNSET [<nombre>]

@{B}Sintaxis@{UB}	NAME

@{B}Localización@{UB}	Interno

UNSET elimina la variable local nombrada de la lista de variables del
proceso actual. Sin argumentos, UNSET lista las variables actuales.

Mire también: @{"SET" link set}.

@endnode

@NODE UNSETENV

@{B}UNSETENV@{UB}

Elimina una variable global.

@{B}Formato@{UB}		UNSETENV [<nombre>]

@{B}Sintaxis@{UB}	NAME

@{B}Localización@{UB}	Interno

UNSETENV elimina la variable global nombrada de la lista de variables
actual. Sin argumentos, UNSETENV lista las variables actuales.

Mire también: @{"SETENV" link setenv}.

@endnode

@NODE VERSION

@{B}VERSION@{UB}

Indica los números de versión y revisión del software.

@{B}Formato@{UB}		VERSION [<librería|dispositivo|fichero>] [<versión @{I}#@{UI}>] 
			[<revisión @{I}#@{UI}>] [<unidad @{I}#@{UI}>] [FILE] [INTERNAL] [RES]
			[FULL]

@{B}Sintaxis@{UB}	NAME,VERSION/N,REVISION/N,UNIT/N,FILE/S,INTERNAL/S,RES/S,
			FULL/S

@{B}Localización@{UB}	C:

VERSION indica el número de versión y revisión de una librería, dispositivo,
comando o disco de Workbench. VERSION también puede buscar la presencia
de un número de versión y revisión específico y ajustar según el mismo las
@{"banderas de condición" link BanderasCondicionales} si el número es mayor del esperado.

VERSION sin argumento <librería|dispositivo|fichero> imprime el número de
versión del Kickstart y del Workbench, ajustando de paso las dos variables
de entorno correspondientes. Si se indica un nombre, VERSION intenta abrir
la librería, dispositivo, drive o fichero en cuestión para leer la
información sobre su versión. Puede indicar el nombre de un dispositivo,
como DF0: o DH0:, para saber la versión del sistema de ficheros usado con
ese dispositivo.

Cuando se indica un número <versión #> o <revisión #>, VERSION pone la
bandera de condición a 0 si el número de versión y revisión del Kickstart,
librería o driver de dispositivo es superior o igual a los valores
especificados. De lo contrario, la bandera se pone a 5 (WARN). Si no se
indica ningún número de revisión, no se comparará el número de revisión.

La opción <unidad #> está obsoleta y sólo se mantiene para asegurar la
compatibilidad con programas antiguos.

La opción FILE obliga a VERSION a ignorar los drivers o librerías cargados
actualmente. Esto le permite obtener el número de versión de una librería o
fichero ".device" de un disco aunque haya una librería o dispositivo con ese
nombre en la memoria o disponible en LIBS:. La opción RES obtiene la versión
de los comandos residentes.

Los comandos integrados en Shell tienen la misma cadena de versión que el
Shell. La opción INTERNAL también está obsoleta y se mantiene por una
cuestión de compatibilidad. La opción FULL imprime la versión completa de
la cadena, incluyendo la fecha.

@{B}Ejemplos:@{UB}

  1.> VERSION
  Kickstart 39.106, Workbench 39.29

  1.> VERSION Alpha:Libs/xyz.library FILE FULL
  xyz.library 1.13 (05-11-93)

@endnode

@NODE WAIT

@{B}WAIT@{UB}

Espera un tiempo determinado.

@{B}Formato@{UB}		WAIT [<n>] [SEC|SECS|MIN|MINS] [@{I}UNTIL@{UI} <hora>]

@{B}Sintaxis@{UB}	/N,SEC=SECS/S,MIN=MINS/S,UNTIL/K

@{B}Localización@{UB}	C:

WAIT se usa en secuencias de comandos o después de RUN para esperar un
cierto período de tiempo o hasta un momento determinado. El período de
tiempo de espera por defecto es de un segundo.

El argumento <n> indica el número de segundos o minutos que se esperará.
Estas opciones son mutuamente exclusivas; sólo puede introducir segundos
o minutos.

Use la palabra clave UNTIL para hacer que se espere hasta una hora
particular del día, usando el formato HH:MM.

@{B}Ejemplo 1:@{UB}

  1.> WAIT 10 MINS

esperará 10 minutos.

@{B}Ejemplo 2:@{UB}

  1.> WAIT UNTIL 21:15

esperará hasta las 9:15 de la noche.

@endnode

@NODE WHICH

@{B}WHICH@{UB}

Busca la senda de comando de un objeto en particular.

@{B}Formato@{UB}		WHICH <comando> [NORES] [RES] [ALL]

@{B}Sintaxis@{UB}	FILE/A,NORES/S,RES/S,ALL/S

@{B}Localización@{UB}	C:

WHICH le permite buscar un comando, programa o directorio en particular
introduciendo su nombre. Si el objeto indicado está en la senda de búsqueda,
WHICH mostrará la senda completa del objeto. WHICH lista los comandos
residentes como RES y los comandos internos como INTERNAL.

Normalmente, WHICH busca en la lista de comandos residentes, en el
directorio actual, en la senda de comandos y en el directorio C:. Si no
consigue encontrar el objeto, WHICH ajustará la @{"bandera de condición" link BanderasCondicionales}
a 5 (WARN), pero no imprimirá ningún mensaje de error.

Si usa la opción NORES, el comando no buscará en la lista de comandos
residentes. Por el contrario, si usa la opción RES, la búsqueda sólo se
hará en esta lista.

El interruptor ALL continúa buscando por toda la senda de búsqueda, listando
todos los lugares en los que encuentre el comando o programa. Sin embargo,
es posible que esto produzca varios listados del mismo comando si éste se
encuentra siguiendo más de una ruta (como C: y el directorio actual).

@{B}Ejemplos:@{UB}

  1.> WHICH avail
  C:Avail

  1.> WHICH C:
  Workbench:C

  1.> WHICH alias
  INTERNAL alias

@endnode

@NODE WHY

@{B}WHY@{UB}

Imprime un mensaje que explica por qué se produjo el error del mensaje
anterior.

@{B}Formato@{UB}		WHY

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Interno

Cuando un comando falla, en pantalla se muestra un breve mensaje.
Normalmente, este mensaje incluye el nombre del fichero, si ese fue el
problema, pero sin dar más detalles. Si la razón del fallo no le parece
evidente, introduzca WHY para obtener una explicación más completa.

@endnode

@NODE ComandosDelSistema "COMANDOS DEL SISTEMA"

COMANDOS DEL SISTEMA
--------------------

Los comandos del sistema son necesarios para el funcionamiento normal del
mismo. Estos comandos se utilizan en el Startup-sequence estándar y son
llamados automáticamente por el sistema y ciertas aplicaciones. Normalmente,
el usuario no hace uso directo de estos comandos.

@endnode

@NODE ADDDATATYPES

@{B}ADDDATATYPES@{UB}

Construye una lista con los tipos de datos que datatypes.library puede
entender.

@{B}Formato@{UB}		ADDDATATYPES [FILES] {ficheros} [QUIET] [REFRESH]

@{B}Sintaxis@{UB}	FILES/M,QUIET/S,REFRESH/S

@{B}Localización@{UB}	C:

Los ficheros que describen los tipos de datos se almacenan en DEVS:DataTypes.
Estos ficheros permiten a programas como Multiview interpretar diferentes
tipos de ficheros de datos. ADDDATATYPES también puede ser utilizado por
scripts encargados de instalar aplicaciones para añadir sus propios tipos de
datos a la lista.

El argumento FILES indica los nombres de los ficheros descriptores de tipos
de datos que se añadirán a la lista existente de descriptores de tipos de
datos.

Usando la opción QUIET se suprimirán los mensajes de error y de salida de
información.

Usando la opción REFRESH, se observará el directorio DEVS:DataTypes para
comprobar si hay descriptores de tipos de datos nuevos o cambiados.

@endnode

@NODE BINDDRIVERS

@{B}BINDDRIVERS@{UB}

Asocia los drivers de dispositivos al hardware.

@{B}Formato@{UB}		BINDDRIVERS

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	C:

BINDDRIVERS carga y ejecuta drivers de dispositivos para hardware añadido al
sistema. Estos dispositivos se configuran automáticamente en la librería de
expansión si sus drivers están en el directorio SYS:Expansion.

El comando BINDDRIVERS debe aparecer en el fichero Startup-sequence para
configurar automáticamente el hardware al arrancar el sistema.

@endnode

@NODE CONCLIP

@{B}CONCLIP@{UB}

Traslada información entre las ventanas de consola y el Portapapeles.

@{B}Formato@{UB}		CONCLIP [CLIPUNIT|UNIT <número de unidad>] [OFF]

@{B}Sintaxis@{UB}	CLIPUNIT=UNIT/N,OFF/S

@{B}Localización@{UB}	C:

CONCLIP se llama desde el Startup-sequence estándar. Este programa envía al
Portapapeles la información que ha sido recortada en estas ventanas.

La opción CLIPUNIT le permite indicar la unidad del clipboard.device que se
usará. Puede indicar cualquier unidad de 0 a 255. El número por defecto es
0. Recomendamos que sólo usen esta opción los usuarios experimentados o los
programadores que deseen usar diferentes unidades para diferentes tipos de
información, como podría ser una para texto y otra para gráficos. Ejecute el
comando desde Shell, indicando el nuevo número de unidad. La próxima vez que
copie y pegue, se utilizará esa unidad del Portapapeles.

Usando la opción OFF con Shell, MEmacs o ED, estos comandos dejarán de
interactuar con el Portapapeles del sistema durante las operaciones de
copiar y pegar. Le recomendamos que no use esta opción.

@endnode

@NODE IPREFS

@{B}IPREFS@{UB}

Envía la información de los ficheros producidos por los editores de
preferencias al sistema operativo.

@{B}Formato@{UB}		IPREFS

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	C:

IPREFS lee individualmente los ficheros de preferencias del sistema y pasa
esta información al sistema. IPREFS se ejecuta normalmente en el Startup-
sequence después de copiar los ficheros de preferencias a ENV:. Cada vez que
el usuario elige Grabar o Usar en un editor, IPREFS recibe un aviso y pasa
la información al sistema. Si es necesario, IPREFS resetea el Workbench para
implementar estos cambios. Si alguna ventana Shell, de proyecto o de
aplicación está abierta, IPREFS mostrará un requester pidiéndole que la
cierre.
@endnode

@NODE SETPATCH

@{B}SETPATCH@{UB}

Hace parches en ROM para el software del sistema.

@{B}Formato@{UB}		SETPATCH [QUIET] [NOCACHE] [REVERSE]

@{B}Sintaxis@{UB}	QUIET/S,NOCACHE/S,REVERSE/S

@{B}Localización@{UB}	C:

SETPATCH instala modificaciones temporales en el sistema operativo. Debe
ejecutarse al principio del fichero Startup-sequence. Frecuentemente
aparecen versiones actualizadas de SETPATCH cuando es necesario mientras
continúa el desarrollo del AmigaDOS.

Si se indica QUIET, no se enviará ningún mensaje de salida a la pantalla.

NOCACHE impide que se active el caché de datos en algunos sistemas basados
en los procesadores 68030 y 68040.

REVERSE guarda los parches en orden inverso. Esta opción sólo es útil para
los programadores de CDTV.

@endnode

@NODE veamos2 "REFERENCIA DE COMANDOS RELACIONADOS CON EL WORKBENCH"

				  Capítulo 7
				  ==========


	      REFERENCIA DE COMANDOS RELACIONADOS CON EL WORKBENCH
	      ====================================================


Los comandos descritos en este capítulo son los equivalentes de la línea
de comando a los mismos programas del Workbench. Están divididos en las
siguientes categorías según su función:

  - Editores de preferencias

  - Programas de comodidades

  - Otras herramientas y programas relacionados con el Workbench

Los comandos se han agrupado así únicamente con propósitos documentales.

NOTA: En la "Guía del Usuario del Workbench" puede encontrar una completa
      descripción del uso de todos los editores, herramientas y programas
      del Workbench.

La siguiente tabla ofrece una rápida referencia ordenada alfabéticamente de
todos los comandos descritos en este capítulo, indicando en cada caso el
propósito del comando o programa:

-----------------------------------------------------------------------------
Comando			Propósito
-----------------------------------------------------------------------------

@{"AutoPoint" link CoAutoPoint}		Selecciona automáticamente la ventana sobre la que
			se encuentra el puntero del ratón.

@{"Blanker" link CoBlanker}		Hace que la pantalla del monitor se oscurezca si no
			se produce ningún acontecimiento durante un tiempo
			determinado.

@{"Calculator" link UtiCalculadora}		Hace aparecer una calculadora en la pantalla.

@{"ClickToFront" link CoClickToFront}		Le permite traer una ventana a la parte frontal de
			la pantalla mediante dos pulsaciones del ratón.

@{"Clock" link UtiReloj}			Hace aparecer un reloj en la pantalla.

@{"CMD" link UtiCMD}			Redirige la salida de impresora a un fichero.

@{"CrossDOS" link CoCrossDOS}		Ajusta el filtro de texto y las opciones de
			conversión de los dispositivos manejados por CrossDOS.

@{"DiskCopy" link UtiDiskCopy}		Copia el contenido de un disco a otro.

@{"Exchange" link CoExchange}		Monitorea y controla los programas de comodidades.

@{"FixFonts" link UtiFixFonts}		Actualiza los ficheros .font del directorio FONTS:.

@{"FKey" link CoFKey}			Asigna comandos a las teclas de función.

@{"Font" link EditorFont}			Elige las fuentes que utilizará el sistema.

@{"Format" link UtiFormat}			Formatea un disco para su uso con el Amiga.

@{"GraphicDump" link UtiGraphicDump}		Imprime la pantalla que esté en primer plano.

@{"IconEdit" link UtiIconEdit}		Edita el aspecto y el tipo de los iconos.

@{"IControl" link EditorIControl}		Especifica algunos parámetros utilizados por el
			Workbench.

@{"InitPrinter" link UtiInitPrinter}		Inicializa una impresora según las opciones de
			impresión escogidas en los editores de preferencias.

@{"Input" link EditorInput}			Elige la velocidad del ratón y del teclado, y
			selecciona el mapa de teclado.

@{"Intellifont" link UtiIntellifont}		Maneja las fuentes escalables Intellifont.

@{"KeyShow" link UtiKeyShow}		Muestra el mapa de teclado actual.

@{"Locale" link EditorLocale}			Permite elegir el lenguaje que utilizará el sistema
			para relacionarse con el usuario.

@{"MEmacs" link UtiMEmacs}			Permite la edición de texto orientada a pantalla.

@{"More" link UtiMore}			Muestra el contenido de un fichero de texto ASCII.

@{"MouseBlanker" link CoMouseBlanker}		Quita de la pantalla el puntero del ratón mientras
			se está introduciendo texto con el teclado.

@{"MultiView" link UtiMultiview}		Muestra ficheros de dibujo, ficheros AmigaGuide,
			ficheros de sonido y ficheros de gráficos animados.

@{"NoCapsLock" link CoNoCapsLock}		Desactiva la tecla Caps Lock.

@{"NoFastMem" link UtiNoFastMem}		Obliga al Amiga a utilizar solamente Chip RAM.

@{"Overscan" link EditorOverscan}		Cambia el tamaño de las áreas de visualización de
			texto y gráficos.

@{"Palette" link EditorPalette}		Cambia los colores de la pantalla Workbench.

@{"Pointer" link EditorPointer}		Cambia el aspecto del puntero del ratón.

@{"PrepCard" link UtiPrepCard}		Prepara las tarjetas de memoria PCMCIA para su uso
			como disco o memoria RAM.

@{"Printer" link EditorPrinter}		Selecciona una impresora, así como las opciones
                        básicas de impresión.

@{"PrinterGfx" link EditorPrinterGFX}		Indica las opciones de impresión de gráficos.

@{"PrinterPS" link EditorPrinterPS}		Indica las opciones de una impresora PostScript.

@{"ScreenMode" link EditorScreenMode}		Selecciona un modo de visualización.

@{"Serial" link EditorSerial}			Ajusta las opciones de comunicación a través del
			puerto serie.

@{"Sound" link EditorSound}			Controla el tipo de sonido utilizado por el bip de
			aviso de error.

@{"Time" link EditorTime}			Ajusta el reloj del sistema.

@{"WBPattern" link EditorWBPattern}		Crea diseños de fondo para el Workbench y las
			ventanas.

@endnode

@NODE EditoresPrefs "EDITORES DE PREFERENCIAS"

EDITORES DE PREFERENCIAS
------------------------

Los comandos listados en esta sección invocan a los editores de preferencias
del Workbench.

En muchas de las líneas de comando que llaman a estos editores se usan los
mismos argumentos e interruptores. Éstos tienen el mismo significado para
cada comando que los use, y se describen a continuación:

-----------------------------------------------------------------------------
Argumento		Significado
-----------------------------------------------------------------------------

[FROM <fichero>]	Indica un fichero de preselección que se ha de
			abrir. Este fichero debe haber sido grabado
			previamente con la opción "Grabar como..." del editor
			en particular. Normalmente, estos ficheros tienen la
			extensión .pre y están guardados en el cajón Presets.

[EDIT]			Abre el editor. Esta opción se usa por defecto si
			sólo teclea el nombre del editor.

[USE]			Usa los ajustes del fichero FROM sin abrir el editor.

[SAVE]			Graba los ajustes del fichero FROM como los que se
			utilizarán por defecto sin abrir el editor.

[PUBSCREEN <nombre de	Permite al editor abrir su ventana en una pantalla
la pantalla pública>]	pública.

[UNIT]			Hace que aparezca un gadget de texto adicional en
			el editor para ajustar el número de unidad por
			defecto.

[CLIPUNIT <unidad>]	Determina qué unidad del Portapapeles se empleará
			durante las operaciones de copia y pegado.

[NOREMAP]		Desactiva el remapeo de color, de forma que el
			sistema muestre los ficheros de dibujo usando los
			colores con los que éstos fueron grabados.

@endnode

@NODE EditorFont "Editor FONT"

@{B}FONT@{UB}

Indica las fuentes que utilizará el sistema.

@{B}Formato@{UB}		FONT [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> FONT

abre el editor Font. Es lo mismo que pulsar dos veces sobre el icono del
editor.

@endnode

@NODE EditorIControl "Editor IControl"

@{B}ICONTROL@{UB}

Indica los parámetros utilizados por el sistema operativo.

@{B}Formato@{UB}		ICONTROL [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> ICONTROL Prefs/Presets/IControl.pre

Abre el editor IControl y carga los ajustes grabados en el fichero de
preselección Icontrol.pre para su edición.

@endnode

@NODE EditorInput "Editor INPUT"

@{B}INPUT@{UB}

Elige la velocidad del ratón y el teclado, así como el mapa de teclado que
usará el sistema.

@{B}Formato@{UB}		INPUT [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> INPUT Prefs/Presets/Input.fast USE

carga y comienza a usar los ajustes del fichero de preselección Input.fast
sin abrir el editor. Si el sistema se resetea, se usarán los ajustes por
defecto grabados.
@endnode

@NODE EditorLocale "Editor LOCALE"

@{B}LOCALE@{UB}

Le permite elegir el idioma que usará el sistema para comunicarse con usted.

@{B}Formato@{UB}		LOCALE [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> LOCALE Prefs/Presets/Locale.UK SAVE

Carga los ajustes del fichero de preseleción Locale.UK y los graba como el
valor por defecto sin abrir el editor. El sistema mantendrá los ajustes de
Locale.UK aunque se resetee.
@endnode

@NODE EditorOverscan "Editor OVERSCAN"

@{B}OVERSCAN@{UB}

Cambia los tamaños de las zonas de visualización para texto y gráficos.

@{B}Formato@{UB}		OVERSCAN [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<fichero>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> OVERSCAN PUBSCREEN MiBench

Abre el editor Overscan en la pantalla pública llamada MiBench.
@endnode

@NODE EditorPalette "Editor PALETTE"

@{B}PALETTE@{UB}

Cambia los colores de la pantalla Workbench.

@{B}Formato@{UB}		PALETTE [FROM <fichero>] [EDIT|USE|SAVE]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S

@{B}Localización@{UB}	Extras:Prefs
@endnode

@NODE EditorPointer "Editor POINTER"

@{B}POINTER@{UB}

Cambia el aspecto del puntero del ratón.

@{B}Formato@{UB}		POINTER [FROM <fichero>] [EDIT|USE|SAVE] [@{I}CLIPUNIT @{UI}<unidad>]
			[NOREMAP]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,CLIPUNIT/K/N,NOREMAP/S

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> POINTER CLIPUNIT 1

Abre el editor Pointer y elige la unidad 1 del Portapapeles. Esto es útil
si la unidad por defecto del Portapapeles (0) está ocupada actualmente.
@endnode

@NODE EditorPrinter "Editor PRINTER"

@{B}PRINTER@{UB}

Selecciona una impresora y las opciones de impresión básicas.

@{B}Formato@{UB}		PRINTER [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]
			[UNIT]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K,UNIT/S

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> PRINTER Prefs/Presets/Printer.post UNIT

Abre el editor Printer, cargando la preselección Printer.post. Un gadget de
texto aparecerá en la ventana del editor para que pueda indicar la unidad
de impresión asociada a la preselección.
@endnode

@NODE EditorPrinterGfx "Editor PrinterGFX"

@{B}PRINTERGFX@{UB}

Indica las opciones de impresión de gráficos.

@{B}Formato@{UB}		PRINTERGFX [FROM <fichero>] [EDIT|USE|SAVE]
			[@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs
@endnode

@NODE EditorPrinterPS "Editor PRINTERPS"

@{B}PRINTERPS@{UB}

Controla las funciones de las impresoras PostScript.

@{B}Formato@{UB}		PRINTERPS [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}
			<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

Este editor sólo se utiliza si tiene una impresora PostScript y elige
"PostScript" en el editor de preferencias @{"Printer" link EditorPrinter}.
@endnode

@NODE EditorScreenMode "Editor SCREENMODE"

@{B}SCREENMODE@{UB}

Selecciona un modo de visualización para la pantalla Workbench.

@{B}Formato@{UB}		SCREENMODE [FROM <fichero>] [EDIT|USE|SAVE]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> SCREENMODE Prefs/Presets/OtraPantalla USE

Se le pedirá que cierre todas las ventanas que no sean de cajón; el sistema
entonces reseteará los valores actuales y seleccionará los ajustes grabados
en el fichero OtraPantalla. La ventana del editor no se abrirá. Si resetea
el sistema, el modo de visualización volverá a ser el mismo de antes, que
era el que estaba grabado.
@endnode

@NODE  EditorSerial "Editor SERIAL"

@{B}SERIAL@{UB}

Ajusta las opciones para la comunicación a través del puerto serie.

@{B}Formato@{UB}		SERIAL [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]
			[UNIT]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K,UNIT/S

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> SERIAL Prefs/Presets/Serial.9600 PUBSCREEN MidTerm UNIT

Abre el editor Serial, cargando la preselección del fichero Serial.9600. El
editor se abre en la pantalla pública llamada MidTerm y su ventana contiene
un gadget de unidad.
@endnode

@NODE EditorSound "Editor SOUND"

@{B}SOUND@{UB}

Controla el tipo de sonido y los atributos del sonido producido por el Amiga
cuando hay un error.

@{B}Formato@{UB}		SOUND [FROM <fichero>] [EDIT|USE|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs
@endnode

@NODE EditorTime "Editor TIME"

@{B}TIME@{UB}

Ajusta el reloj del sistema.

@{B}Formato@{UB}		TIME [EDIT|SAVE] [@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	EDIT/S,SAVE/S,PUBSCREEN/K

@{B}Localización@{UB}	Extras:Prefs

Dado que ajustar la hora desde Shell siempre se hace para grabar, la opción
USE se omite para el editor Time.
@endnode

@NODE EditorWBPattern "Editor WBPATTERN"

@{B}WBPATTERN@{UB}

Crea diseños de fondo para el Workbench y sus ventanas.

@{B}Formato@{UB}		WBPATTERN [FROM <fichero>] [EDIT|USE|SAVE] [@{I}CLIPUNIT @{UI}
			<unidad>] [NOREMAP]

@{B}Sintaxis@{UB}	FROM,EDIT/S,USE/S,SAVE/S,CLIPUNIT/K/N,NOREMAP/S

@{B}Localización@{UB}	Extras:Prefs

@{B}Ejemplo:@{UB}

  1.> WBPattern Prefs/Presets/PapelCharol.patrón NOREMAP

Abre el editor WBPattern, cargando la preselección PapelCharol.patrón. La
opción NOREMAP impide que se remapeen los colores al cargar dibujos y
patrones.
@endnode

@NODE ProgramasCommodities "PROGRAMAS DE COMODIDADES"

PROGRAMAS DE COMODIDADES
------------------------

Los siguientes comandos invocan a las utilidades de comodidad del Workbench.
Se encuentran en el directorio Tools/Commodities.

Los siguientes argumentos de las líneas de comando que llaman a los programas
de comodidades tienen el mismo significado en todos los casos. Usar estos
argumentos es lo mismo que indicarlos como un tipo de herramienta en la
ventana de información del icono del programa.

-----------------------------------------------------------------------------
Argumento		Significado
-----------------------------------------------------------------------------

[CX_PRIORITY		Elige la prioridad de la comodidad en relación a los
<prioridad>]		demás programas de comodidades. El valor por defecto
			es 0; los valores superiores a 0 dan a la comodidad
			prioridad sobre las demás en cuanto a la respuesta a
			las "hot-keys" y otras cuestiones. Esto no tiene
			nada que ver con su prioridad como tarea.

[CX_POPKEY <tecla>]	Le permite indicar la tecla de llamada que abrirá
			la ventana del programa. Si indica más de una tecla,
			deberá incluirlas entre comillas (por ejemplo,
			CX_POPKEY="Shift F1").

[CX_POPUP <yes/no>]	Indica si la ventana del programa se abrirá al
			invocar el comando.

@endnode

@NODE CoAutoPoint "AUTOPOINT"

@{B}AUTOPOINT@{UB}

Selecciona automáticamente cualquier ventana sobre la que se encuentre el
puntero del ratón.

@{B}Formato@{UB}		AUTOPOINT [@{I}CX_PRIORITY @{UI}<prioridad>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K

@{B}Localización@{UB}	Extras:Tools/Commodities

Pulse Ctrl+C o use el comando @{"BREAK" link break} para salir de AutoPoint cuando lo
cargue desde Shell.
@endnode

@NODE CoBlanker "BLANKER"

@{B}BLANKER@{UB}

Hace que la pantalla del monitor se oscurezca o muestre una animación si no
se produce ninguna intervención por parte del usuario durante un determinado
período de tiempo. Esto ayuda a prolongar la vida del monitor.

@{B}Formato@{UB}		BLANKER [@{I}CX_PRIORITY @{UI}<prioridad>] [@{I}CX_POPKEY @{UI}<tecla>]
 			[@{I}CX_POPUP@{UI}=<yes|no>] [@{I}SECONDS @{UI}<tiempo>]
 			[@{I}CYCLECOLORS @{UI}<yes|no>] [@{I}ANIMATION @{UI}<yes|no>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K,CX_POPKEY/K,CX_POPUP/K,SECONDS/N/K,
			CYCLECOLORS/K,ANIMATION/K

@{B}Localización@{UB}	Extras:Tools/Commodities

Los argumentos de Blanker son los mismos que los tipos de herramientas de la
ventana de información del icono Blanker.

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar Blanker si lo ha cargado
desde Shell.

@{B}Ejemplo 1:@{UB}

  1.> BLANKER SECONDS 45

La ventana de Blanker se abre y muestra "45" dentro del gadget de texto. Si
no hay señal proveniente del ratón ni del teclado durante 45 segundos, la
pantalla se oscurecerá.

@{B}Ejemplo 2:@{UB}

  1.> BLANKER CX_POPUP=no

El programa Blanker se carga. Si no recibe señal alguna durante 60 segundos
(el valor por defecto), la pantalla se oscurecerá. La ventana de Blanker no
se abre.

En el capítulo 8 puede encontrar otro ejemplo de Blanker.

@endnode

@NODE CoClickToFront "CLICKTOFRONT"

@{B}CLICKTOFRONT@{UB}

Le permite traer una ventana a la parte frontal de la pantalla con sólo
pulsar dos veces sobre ella.

@{B}Formato@{UB}		CLICKTOFRONT [@{I}CX_PRIORITY @{UI}<prioridad>] [@{I}QUALIFIER @{UI}
			<calificador>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K,QUALIFIER/K

@{B}Localización@{UB}	Extras:Tools/Commodities

ClickToFront no abre ninguna ventana. Los argumentos son los mismos que los
tipos de herramientas de la ventana de información del icono ClickToFront.

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar ClickToFront si lo ha
cargado desde Shell.
@endnode

@NODE CoCrossDOS "CROSSDOS"

@{B}CROSSDOS@{UB}

Ajusta el filtro de texto y las opciones de conversión de los dispositivos
CrossDOS.

@{B}Formato@{UB}		CROSSDOS [@{I}CX_PRIORITY @{UI}<prioridad>] [@{I}CX_POPKEY @{UI}<tecla>]
			[@{I}CX_POPUP @{UI}<yes|no>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K,CX_POPKEY/K,CX_POPUP/K

@{B}Localización@{UB}	Extras:Tools/Commodities

CrossDOS le permite leer y escribir los discos formateados por sistemas
MS-DOS usando las disqueteras estándar de su Amiga.

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar CrossDOS si lo ha
cargado desde Shell.
@endnode

@NODE CoExchange "EXCHANGE"

@{B}EXCHANGE@{UB}

Monitorea y controla los programas de comodidades.

@{B}Formato@{UB}		EXCHANGE [@{I}CX_PRIORITY @{UI}<prioridad>] [@{I}CX_POPKEY @{UI}<tecla>]
			[@{I}CX_POPUP @{UI}<yes|no>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K,CX_POPKEY/K,CX_POPUP/K

@{B}Localización@{UB}	Extras:Tools/Commodities

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar Exchange si lo ha
cargado desde Shell.

@{B}Ejemplo:@{UB}

  1.> EXCHANGE CX_POPKEY "Shift F1"

Se carga el programa Exchange y su ventana aparece en la pantalla. Cuando la
ventana está oculta, pulsando Mayúsculas+F1 aparece de nuevo.

@endnode

@NODE CoFKey "FKEY"

@{B}FKEY@{UB}

Asigna comandos a secuencias especiales de teclas, eliminando la necesidad
de teclear un texto repetidas veces.

@{B}Formato@{UB}		FKEY [@{I}CX_PRIORITY @{UI}<prioridad>] [@{I}CX_POPKEY @{UI}<tecla>]
			[@{I}CX_POPUP @{UI}<yes|no>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K,CX_POPKEY/K,CX_POPUP/K

@{B}Localización@{UB}	Extras:Tools/Commodities

FKey asigna uno de entre ocho comandos a cualquier combinación de teclas que
pueda introducirse.

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar FKEY si lo ha cargado
desde Shell.
@endnode

@NODE CoMouseBlanker "MOUSEBLANKER"

@{B}MOUSEBLANKER@{UB}

Quita el puntero del ratón de la pantalla mientras se está introduciendo un
texto desde el teclado.

@{B}Formato@{UB}		MOUSEBLANKER [@{I}CX_PRIORITY @{UI}<prioridad>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K

@{B}Localización@{UB}	Extras:Tools/Commodities

Pulse Ctrl+C o use el comando @{"BREAK" link break} para abandonar MouseBlanker si lo ha
cargado desde Shell.
@endnode

@NODE CoNoCapsLock "NOCAPSLOCK"

@{B}NOCAPSLOCK@{UB}

Desactiva la tecla Caps Lock.

@{B}Formato@{UB}		NOCAPSLOCK [@{I}CX_PRIORITY @{UI}<prioridad>]

@{B}Sintaxis@{UB}	CX_PRIORITY/N/K

@{B}Localización@{UB}	Extras:Tools/Commodities

Pulse Ctrl+C o use el comando @{"BREAK" link Break} para abandonar NoCapsLock si lo ha
cargado desde Shell.
@endnode

@NODE UtilEtc "OTRAS HERRAMIENTAS"

OTRAS HERRAMIENTAS Y PROGRAMAS RELACIONADOS CON EL WORKBENCH
------------------------------------------------------------

El siguiente grupo de comandos invoca a otras herramientas, utilidades y
programas del Workbench.
@endnode

@NODE UtiCalculadora "Calculator"

@{B}CALCULATOR@{UB} (CALCULADORA)

Hace aparecer una calculadora en la pantalla.

@{B}Formato@{UB}		CALCULATOR [@{I}PUBSCREEN @{UI}<nombre>] [@{I}TAPE @{UI}<ventana>]

@{B}Sintaxis@{UB}	PUBSCREEN,TAPE/K

@{B}Localización@{UB}	Extras:Tools

La salida de la calculadora puede copiarse y pegarse en cualquier ventana
de tipo consola, como Shell o @{"ED" link MiraED}.

TAPE crea una ventana para la calculadora de un tamaño específico en la
que se muestra la entrada y salida de información. La especificación de
<ventana> tiene la forma siguiente:

  TAPE=RAW:x/y/anchura/altura/título/opciones

Para ver una descripción de las opciones y argumentos utilizados por la
ventana de TAPE, mire la descripción sobre la especificación de ventana
del comando @{"NEWSHELL" link newshell} en el capítulo 6.

@endnode

@NODE UtiReloj "CLOCK"

@{B}CLOCK@{UB} (RELOJ)

Hace aparecer un reloj en la pantalla.

@{B}Formato@{UB}		CLOCK [DIGITAL] [<LEFT>] [<TOP>] [<WIDTH>] [<HEIGHT>]
			[24HOUR] [SECONDS] [DATE] [<FORMAT> <n>]
			[@{I}PUBSCREEN @{UI}<nombre>]

@{B}Sintaxis@{UB}	DIGITAL/S,LEFT/N,TOP/N,WIDTH/N,HEIGHT/N,24HOUR/S,SECONDS/S,
			DATE/S,FORMAT/N,PUBSCREEN/K

@{B}Localización@{UB}	SYS:Utilities

La opción DIGITAL abre un reloj digital. Por defecto, se abre un reloj
analógico que puede cambiarse de tamaño.

Las opciones LEFT, TOP, WIDTH y HEIGHT le permiten indicar el tamaño y
la posición del reloj. Las palabras clave son opcionales; si no se indican,
los argumentos numéricos se interpretan según su posición, de la forma
siguiente:

  primer número		El reloj se abre a <n> pixels del borde izquierdo
			de la pantalla.

  segundo número	El reloj se abre a <n> pixels del borde superior
			de la pantalla.

  tercer número		El reloj analógico es de <n> pixels de ancho.

  cuarto número		El reloj analógico es de <n> pixels de alto.

Por ejemplo, si indica solamente la anchura y la altura del reloj, use las
palabras clave WIDTH y HEIGHT. Cuando sólo introduce dos números, el reloj
los toma como las posiciones de los argumentos LEFT y TOP. No puede usar
WIDTH ni HEIGHT si usa un reloj digital.

La opción 24HOUR muestra la hora en el modo de 24 horas; no está disponible
para el reloj analógico.

La opción SECONDS hace aparecer otra manecilla para mostrar los segundos en
el reloj analógico; no tiene efecto sobre el reloj digital.

La opción DATE hace que se muestre la fecha.

La opción FORMAT se aplica solamente al reloj digital. Toma un valor de 0 a
5 que determina cuál de 6 formatos digitales se usará. Los formatos 4 y 5
varían, dependiendo de los ajustes de preferencias del editor @{"Locale" link EditorLocale}. Para
indicar un formato digital, incluya la palabra clave FORMAT o use los
valores LEFT, TOP, WIDTH y HEIGHT; los valores de las opciones WIDTH y
HEIGHT se toman solamente como los lugares en los que se situará la
ventana, y serán ignorados.

@{B}Ejemplo 1:@{UB}

Para abrir un reloj a 75 pixels del borde izquierdo de la pantalla, a 75
pixels del borde superior, de 300 pixels de ancho y 100 de alto, introduzca:

  1.> CLOCK 75 75 300 100

@{B}Ejemplo 2:@{UB}

Para usar las opciones SECONDS y DATE, introduzca:

  1.> CLOCK SECONDS DATE

@{B}Ejemplo 3:@{UB}

Para abrir un reloj digital de 24 horas que muestre los segundos y que se
coloque a 320 pixels del borde izquierdo de la pantalla, situándose sobre
la barra de título de la misma (o sea, a 0 pixels de la parte superior de
la pantalla), introduzca:

  1.> CLOCK DIGITAL 320 0 FORMAT 2

Para ver @{"más ejemplos" link RunProgShell} del reloj, mire el capítulo 8.

@endnode

@NODE UtiCMD "CMD"

@{B}CMD@{UB}

Redirige la salida del puerto serie o paralelo hacia un fichero.

@{B}Formato@{UB}		CMD <dispositivo> <fichero> [@{I}OPT @{UI}S|M|N]

@{B}Sintaxis@{UB}	DEVICENAME/A,FILENAME/A,OPT/K

@{B}Localización@{UB}	Extras:Tools

El <dispositivo> puede ser "serial" o "parallel". Para redirigir la salida
de la impresora, el dispositivo deberá ser el mismo que se ha indicado en
el editor Printer. <Fichero> es el nombre del fichero al que se enviará la
salida redirigida.

Las opciones de CMD son las siguientes:

  S		Se salta cualquier escritura inicial corta (normalmente, una
		señal de Reset si se redirige un volcado de pantalla).

  M		Redirige varios ficheros hasta que se introduce un comando
		@{"BREAK" link break} o se pulsa Ctrl+C.

  N		El sistema informa al usuario del progreso de la operación
		(se muestran mensajes en la pantalla).

@{B}Ejemplo:@{UB}

  1.> CMD parallel RAM:cmd_file

Cualquier información enviada al puerto paralelo será conducida a un fichero
en RAM: llamado cmd_file.

@endnode

@NODE UtiDiskCopy "DiskCopy"

@{B}DISKCOPY@{UB}

Copia el contenido de un disco a otro.

@{B}Formato@{UB}		DISKCOPY [FROM] <dispositivo> [TO] <dispositivo>
			[@{I}NAME @{UI}<nombre>] [NOVERIFY] [MULTI]

@{B}Sintaxis@{UB}	FROM/A,TO/A,NAME/K,NOVERIFY/S,MULTI/S

@{B}Localización@{UB}	SYS:System

Los parámetros <dispositivo> indican el nombre de las disqueteras desde y
hacia las que se hará la copia; por ejemplo, DF0: y DF1:.

Por defecto, el disco destino tiene el mismo nombre que el disco fuente. Si
indica la opción NAME, podrá darle al disco destino un nombre diferente.

Normalmente, durante el proceso de copia, el Amiga copia y verifica cada
cilindro de información. La opción NOVERIFY le permite saltarse el proceso
de verificación, lo que hace que la copia sea más rápida.

La opción MULTI carga la información del disco fuente en la memoria,
permitiéndole hacer varias copias sin tener que leer la información del
disco fuente cada vez.

@{B}Ejemplo 1:@{UB}

  1.> DISKCOPY DF0: TO DF2:

copia el contenido del disco de la unidad DF0: al disco de la unidad DF2:,
borrando el contenido del disco que recibe la copia.

@{B}Ejemplo 2:@{UB}

  1.> DISKCOPY DF0: TO DF2: NAME MiDisco NOVERIFY

copia el contenido del disco de la unidad DF0: al disco que haya en la
unidad DF2:, dando a este disco el nombre MiDisco. El disco no se verifica
durante la copia.

@endnode

@NODE UtiFixFonts "FixFonts"

@{B}FIXFONTS@{UB}

Actualiza los ficheros .font del directorio FONTS:.

@{B}Formato@{UB}		FIXFONTS

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	SYS:System

FixFonts no abre ninguna ventana ni produce salida alguna de información.
Mientras se actualiza el directorio FONTS:, la luz de actividad del drive
permanece encendida. Cuando la actualización haya terminado, esta luz se
apagará y volverá a aparecer el prompt de Shell. Si el disco necesario para
actualizar el directorio FONTS: no está disponible o si hay algún problema
con el mismo, FixFonts hará aparecer un requester estándar según el problema
de que se trate.

Use FixFonts siempre que haga cambios en el directorio FONTS:; por ejemplo,
cuando copie nuevos ficheros de fuentes o los borre.

@endnode

@NODE UtiFormat "Format"

@{B}FORMAT@{UB}

Formatea un disco para su uso con el Amiga.

@{B}Formato@{UB}		FORMAT @{I}DEVICE@{UI}|@{I}DRIVE @{UI}<dispositivo> @{I}NAME @{UI}<nombre> [OFS|FFS]
			[INTERNATIONAL|NOINTERNATIONAL] [DIRCACHE|NODIRCACHE]
			[NOICONS] [QUICK]

@{B}Sintaxis@{UB}	DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,INTL=INTERNATIONAL/S,
			NOINTL=NOINTERNATIONAL/S,DIRCACHE/S,NODIRCACHE/S,
			NOICONS/S,QUICK/S

@{B}Localización@{UB}	SYS:System

Debe indicar las palabras clave DEVICE y NAME para formatear un disco. El
nombre puede tener hasta 31 caracteres de longitud. Si hay espacios en el
mismo, indíquelo entre comillas.

La opción OFS formatea el disco usando el Old File System (el viejo sistema
de ficheros estándar del Amiga). La opción FFS formatea el disco usando el
Fast File System (el sistema rápido de ficheros). Los discos formateados con
FFS son de acceso ligeramente más rápido que los discos formateados con OFS;
sin embargo, los discos FFS no son compatibles con los ordenadores Amiga que
utilizan una versión del sistema operativo anterior a la 2.04. El ajuste por
defecto para los discos flexibles es OFS, mientras que para las tarjetas
PCMCIA y las particiones de disco duro es FFS.

La opción INTERNATIONAL formatea discos usando las versiones internacionales
de los sistemas de ficheros. Los sistemas de ficheros internacionales
manejan las conversiones de letras minúsculas y mayúsculas de los caracteres
internacionales en los nombres de los ficheros. La opción NOINTERNATIONAL
obliga al sistema a emplear el sistema de ficheros no internacional en los
dispositivos en los que el modo Internacional es el que se usa por defecto.
El ajuste por defecto para los discos flexibles y tarjetas PCMCIA es
NOINTERNATIONAL, mientras que para particiones de disco duro es
INTERNATIONAL. Los discos creados con el modo INTERNATIONAL no son
compatibles con los modelos Amiga que usan una versión del sistema
operativo anterior a la 2.04.

La opción DIRCACHE habilita el caché de directorios, lo cual acelera la
apertura de cajones, ficheros, requesters y listados. El uso de caché de
directorios en discos flexibles y sistemas con discos duros lentos acelera
los listados de directorios y la apertura de ventanas en el Workbench. El
caché de directorios no resulta útil en los sistemas con discos duros
rápidos. La opción NODIRCACHE desactiva el caché de directorios. Los discos
formateados con caché de directorios no son compatibles con los modelos
Amiga con una versión del sistema operativo anterior a la 3.0. El ajuste
por defecto para discos flexibles, tarjetas PCMCIA y discos duros es
NODIRCACHE.

La opción NOICONS impide que se añada el icono de la papelera y su
correspondiente cajón al nuevo disco formateado.

La opción QUICK hace que el proceso de formateo sólo formatee y cree el
bloque raíz (y pista), el bloque de arranque (y pista) y los bloques bitmap.
Esto sólo puede hacerse sobre discos previamente formateados. Sin embargo,
no puede hacer esto para reformatear discos en sistema AmigaDOS que han
sido previamente formateados con el sistema CrossDOS, y viceversa.

@{B}Ejemplo 1:@{UB}

  1> FORMAT DRIVE DF0: NAME DiscoVacío

Formatea el disco de la unidad DF0:, borrando cualquier información que éste
pudiese contener, y lo llama DiscoVacío.

@{B}Ejemplo 2:@{UB}

  1.> FORMAT DRIVE DF2: NAME NuevoDisco QUICK

Reformatea o borra el disco de DF2:, que ya contenga información.

Para ver más ejemplos del comando FORMAT, mire el capítulo 8.

@endnode

@NODE UtiGraphicDump "GraphicDump"

@{B}GRAPHICDUMP@{UB}

Imprime la pantalla que esté en primer plano.

@{B}Formato@{UB}		GRAPHICDUMP [TINY|SMALL|MEDIUM|LARGE|<xdots>:<ydots>]

@{B}Sintaxis@{UB}	TINY/S,SMALL/S,MEDIUM/S,LARGE/S,<xdots>:<ydots>/S

@{B}Localización@{UB}	Extras:Tools

GraphicDump espera diez segundos antes de comenzar a imprimir para
permitirle traer la pantalla deseada a la parte frontal de la visualización.

Las opciones de tamaño, que corresponden a los tipos de herramientas
aceptados por el programa, determinan la anchura de la salida impresa:

  TINY		1/4 de la anchura máxima permitida por la impresora.

  SMALL		1/2 de la anchura máxima permitida por la impresora.

  MEDIUM	3/4 de la anchura máxima permitida por la impresora.

  LARGE		La anchura máxima permitida por la impresora.

La altura de la salida impresa mantiene las proporciones de la pantalla.

Para indicar las dimensiones exactas, indique la anchura en puntos con
<xdots> y la altura con <ydots>, separando los dos argumentos solamente con
un signo de dos puntos (:).

@{B}Ejemplo 1:@{UB}

  1.> GRAPHICDUMP SMALL

produce una salida impresa de la pantalla en primer plano con la mitad de la
anchura máxima permitida por la impresora.

@{B}Ejemplo 2:@{UB}

  1.> GRAPHICDUMP 600:300

produce una salida impresa que tiene 600 puntos de ancho por 300 puntos de
alto.

@endnode

@NODE UtiIconEdit "IconEdit"

@{B}ICONEDIT@{UB}

Edita el aspecto y el tipo de los iconos. IconEdit carga el programa
IconEdit. El comando no soporta ningún argumento. Para una información
detallada sobre IconEdit, mire la "Guía del Usuario del Workbench".
@endnode

@NODE UtiInitPrinter "InitPrinter"

@{B}INITPRINTER@{UB}

Inicializa la impresora con las opciones de impresión elegidas en los
editores de preferencias.

@{B}Formato@{UB}		INITPRINTER

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	Extras:Tools

Después de ejecutar InitPrinter, el prompt Shell aparece de nuevo una vez
que la impresora ha sido inicializada. La impresora se inicializa
automáticamente al acceder a ella por primera vez, pero si por cualquier
razón la apaga, podría necesitar inicializarla con InitPrinter.
@endnode

@NODE UtiIntellifont "Intellifont"

@{B}INTELLIFONT@{UB}

Ejecuta el programa Intellifont para manejar fuentes escalables.

@{B}Formato@{UB}		INTELLIFONT [VALIDATE]

@{B}Sintaxis@{UB}	VALIDATE/S

@{B}Localización@{UB}	SYS:System

Intellifont instala nuevas fuentes escalables en su sistema, habilita
nuevos tamaños para las fuentes existentes y borra las fuentes innecesarias.
También puede crear versiones bitmap de cualquier tamaño de una fuente
escalable para cualquier aplicación que no soporte directamente el uso de
las fuentes escalables.

Usando la opción VALIDATE, el programa se asegurará de que las fuentes
estén instaladas correctamente y de que todos los ficheros y directorios
necesarios para su correcto uso estén presentes.
@endnode

@NODE UtiKeyShow "KeyShow"

@{B}KEYSHOW@{UB}

Muestra el mapa de teclado (keymap) actual. No hay argumentos para el
comando KeyShow. Para tener una información detallada sobre KeyShow, mire
la "Guía del Usuario del Workbench".
@endnode

@NODE UtiMEmacs "MEmacs"

@{B}MEMACS@{UB}

Permite la edición de texto orientada a pantalla.

@{B}Formato@{UB}		MEMACS [<fichero>] [@{I}OPT @{UI}W] [@{I}GOTO @{UI}<n>]

@{B}Sintaxis@{UB}	FROM/M,OPT/K,GOTO/K

@{B}Localización@{UB}	Extras:Tools

@{"MEmacs" link MEmacs} se describe en el capítulo 4 de este manual.
@endnode

@NODE UtiMore "More"

@{B}MORE@{UB}

Muestra el contenido de un fichero de texto ASCII en la ventana Shell. More
no tiene icono. Este programa ha sido superado por el programa MultiView;
sin embargo, aún está disponible.

@{B}Formato@{UB}		MORE <fichero>

@{B}Sintaxis@{UB}	(ninguna)

@{B}Localización@{UB}	SYS:Utilities

Deberá indicar la senda completa del fichero si éste no se encuentra en el
directorio actual. More hace aparecer un requester de ficheros si no indica
fichero alguno.

Pulsando la tecla H aparecerán las teclas de comando de More. Puede usar las
siguientes teclas con More:

  <espacio>		Pasa a la página siguiente.

  <Return>		Siguiente línea.

  Q ó Ctrl+C		Salir de More.

  H			Ayuda.

  /cadena		Busca la cadena de texto (distingue mayúsculas de
			minúsculas). Indicando una "n" antes de la cadena,
			se buscará la siguiente aparición de la cadena.

  .cadena		Busca la cadena (no distingue mayúsculas de
			minúsculas).

  N			Busca la siguiente aparición de la cadena.

  Ctrl+L		Redibuja la ventana.

  <			Salta a la primera página del texto.

  >			Salta a la última página del texto.

  %N			Va al punto que está en el N% del texto.

  B o <Retroceso>	Vuelve a la página anterior.

  E			Edita el fichero usando el editor indicado por la
			variable ENV:EDITOR.

More también acepta la entrada desde PIPE. Los comandos Página Anterior
(B ó Retroceso), Última Página (>) e Ir al punto N% del fichero (%N) quedan
anulados cuando la entrada de More proviene de PIPE, ya que la entrada
estándar de PIPE tiene una longitud desconocida.

Cuando usa More desde Shell, puede abrir un editor para usarlo sobre el
fichero que esté viendo (pulse Mayúsculas+E) si la varible EDITOR ha sido
definida. Indique la senda completa para el editor en la variable EDITOR;
por ejemplo, C:ED.

@{B}Ejemplo:@{UB}

  1.> MORE DF0:Documento

muestra el contenido del fichero ASCII llamado Documento que se encuentra
en el disco de la unidad DF0:.

@endnode

@NODE UtiMultiview "Multiview"

@{B}MULTIVIEW@{UB}

Muestra ficheros de dibujo, de texto, AmigaGuide, de sonido y de gráficos
animados.

@{B}Formato@{UB}		MULTIVIEW [FILE <fichero>] [CLIPBOARD] [@{I}CLIPUNIT @{UI}<unidad>]
			[SCREEN] [@{I}PUBSCREEN @{UI}<nombre>] [REQUESTER] [BOOKMARK]
			[@{I}FONTNAME @{UI}<fuente>] [@{I}FONTSIZE @{UI}<tamaño>] [BACKDROP] 
			[WINDOW] [@{I}PORTNAME @{UI}<nombre del puerto ARexx>]

@{B}Sintaxis@{UB}	FILE,CLIPBOARD/S,CLIPUNIT/K/N,SCREEN/S,PUBSCREEN/K,
			REQUESTER/S,BOOKMARK/S,FONTNAME/K,FONTSIZE/K/N,
			BACKDROP/S,WINDOW/S,PORTNAME/K

@{B}Localización@{UB}	SYS:Utilities

Asegúrese de indicar la senda completa para el fichero si éste no se
encuentra en el directorio actual. MultiView hará aparecer un requester
de ficheros si no indica el fichero a cargar.

Si usa CLIPBOARD, se visionará el Portapapeles en lugar de un fichero. CLIPUNIT
indica la unidad del Portapapeles que se usará al utilizar la palabra clave
CLIPBOARD.

SCREEN indica que quiere que el objeto aparezca en su propia pantalla en
lugar de hacerlo en una ventana de la pantalla del Workbench, usando el
modo de visualización dictado por el objeto. Por ejemplo, si se trata de
un fichero de dibujo ILBM en baja resolución, MultiView abrirá una pantalla
en baja resolución.

Si usa REQUESTER, MultiView hará aparecer un requester de ficheros.

BOOKMARK recuerda el objeto y la posición cuando se abre un fichero con
esta opción.

FONTNAME indica la fuente que se usará para mostrar ficheros de texto.
FONTSIZE indica el tamaño de la fuente en puntos que se usará al mostrar
ficheros de texto.

BACKDROP hace que la ventana quede pegada al fondo de la pantalla Workbench.

WINDOW permite a la ventana de MultiView abrirse sin pedir un fichero que
cargar. Usando esta opción, la ventana de MultiView se abre en la pantalla
del Workbench de forma que pueda arrastrar hasta la misma los iconos de los
ficheros que quiera ver.

PORTNAME le permite indicar el nombre de un puerto ARexx cuando ejecuta
MultiView. Si no indica ningún nombre, cada ventana de MultiView recibirá
el nombre de puerto por defecto, MultiView.x, donde x será el número de slot
comenzando por 1 (por ejemplo, si tiene tres ventanas de MultiView abiertas,
sus nombres de puerto serán MultiView.1, MultiView.2 y MultiView.3). Este
nombre de puerto le permite aludir a una ventana de MultiView en particular
desde un script ARexx.

MultiView soporta los siguientes comandos ARexx:

  OPEN			Carga un objeto con el nombre de fichero o unidad
			de Portapapeles especificado. Las opciones son las
			siguientes:

			FILENAME/K	Indica el nombre del fichero.

			CLIPBOARD/K	Indica que el objeto proviene del
			                Portapapeles.

			CLIPUNIT/K	Indica la unidad del Portapapeles de
			                la que se obtendrá el objeto si se
			                usa la opción CLIPBOARD.

  RELOAD		Carga otra vez el objeto actual.

  SAVEAS		Graba el objeto en el fichero que se indique. Si hay
			un bloque seleccionado, entonces sólo se grabará ese
			bloque. SAVEAS tiene una opción: NAME/K.

  PRINT			Imprime el contenido actual. Si hay un bloque
			seleccionado, entonces solamente se imprimirá ese
			bloque.

  ABOUT			Muestra el requester "Sobre...".

  QUIT			Cierra MultiView.

  COPY			Copia el contenido actual al Portapapeles. Si hay un
			bloque seleccionado, entonces solamente se copiará
			ese bloque.

  CLEARSELECTED		Libera el bloque seleccionado.

  GETTRIGGERINFO	Devuelve los comandos de los métodos gatillo del
			objeto actual. Las opciones son VAR/S y STEM/K.

			Si usa la opción STEM, se usan las siguientes
			extensiones:

			.COUNT		Número de elementos

			.n.LABEL	Etiqueta

			.n.COMMAND	Comando

			.n.METHOD	Método numérico

  DOTRIGGERMETHOD	Realiza el método gatillo sobre el objeto actual.
			La opción es METHOD/A.

  SCREEN		Indica si el objeto se mostrará en una pantalla. Las
			opciones son TRUE/S y FALSE/S.

  PUBSCREEN		Indica el nombre de la pantalla pública en la que se
			mostrará el objeto. La opción es NAME/A.

  GETCURRENTDIR		Devuelve el nombre completo del directorio actual
			asociado con el objeto actual.

  GETFILEINFO		Devuelve la senda completa y nombre de fichero
			asociados con el objeto actual.

  GETOBJECTINFO		Devuelve el nombre, nombre base, grupo e
			IDentificación del objeto actual. Las opciones son
			VAR/S y STEM/K.

			Si usa la opción STEM, se usan las siguientes
			extensiones con stem:

			.FILENAME	Nombre de fichero del objeto

			.NAME		Nombre descriptivo del DataType

			.BASENAME	Nombre base del DataType

			.GROUP		Grupo que contiene el DataType

			.ID		Cadena ID del DataType

  MINIMUMSIZE		Ajusta la ventana al tamaño mínimo según el tipo de
			contenido actual.

  NORMALSIZE		Ajusta la ventana al tamaño normal según el tipo de
			contenido actual.

  MAXIMUMSIZE		Ajusta la ventana a su tamaño máximo según el tipo
			de contenido actual.

  WINDOWTOFRONT		Lleva la ventana a la parte frontal de la
			visualización.

  WINDOWTOBACK		Lleva la ventana a la parte más oculta de la
			visualización (la parte más atrasada).

  SCREENTOFRONT		Trae la pantalla al primer plano de la visualización.

  SCREENTOBACK		Coloca la pantalla detrás de todas las demás que
			haya abiertas.

  ACTIVATEWINDOW	Activa la ventana.

  BEEPSCREEN		Produce un bip en la pantalla en la que se encuentra
			la ventana.

@endnode

@NODE UtiNoFastMem "NoFastMem"

@{B}NOFASTMEM@{UB}

Obliga al Amiga a usar solamente Chip RAM. NoFastMem desactiva la memoria
Fast y de expansión que haya instalada en el sistema. La memoria añadida
puede activarse de nuevo enviando una señal de BREAK a NoFastMem, ya sea
mediante el comando @{"BREAK" link break} o pulsando Ctrl+C. NoFastMem no tiene opciones.
Para una información detallada sobre NoFastMem, mire la "Guía del Usuario
del Workbench".
@endnode

@NODE UtiPrepCard "PrepCard"

@{B}PREPCARD@{UB}

Prepara una tarjeta de memoria PCMCIA para ser usada como dispositivo de
almacenamiento (disco) o RAM del sistema en los modelos del Amiga que
disponen de un slot de expansión de este tipo.

@{B}Formato@{UB}		PREPCARD [DISK|RAM]

@{B}Sintaxis@{UB}	DISK/S,RAM/S

@{B}Localización@{UB}	Extras:Tools

La opción DISK prepara la tarjeta PCMCIA para su uso como dispositivo de
disco CC0:. Leer y escribir en la tarjeta preparada como disco es lo mismo
que leer o escribir en un disco flexible. Le recomendamos que use una
tarjeta que cuente con batería si va a configurarla como disco de
almacenamiento y no quiere perder su trabajo.

La opción RAM prepara la tarjeta PCMCIA para su uso como RAM del sistema.
Si arranca o resetea el Amiga estando la tarjeta insertada en el slot, la
memoria de la tarjeta se añade a la memoria existente en el Amiga. Puede
usar cualquier tarjeta PCMCIA como RAM, excepto las tarjetas de tipo Read
Only (ROM).

Las opciones DISK y RAM son mutuamente exclusivas; si hace uso de las dos
opciones a la vez, PrepCard atenderá a la primera opción indicada e ignorará
la segunda. Aparecerá un mensaje de error si intenta usar PrepCard en un
sistema que no cuenta con un slot para este tipo de tarjetas.

@endnode

@NODE examples "EJEMPLOS DE COMANDOS"


				  Capítulo 8
				  ==========


		    EJEMPLOS SOBRE EL USO DE LOS COMANDOS
		    =====================================


Los ejemplos de comandos de este manual están pensados principalmente para
ilustrar la sintaxis correcta y el funcionamiento en general del AmigaDOS.
Este capítulo le muestra cómo usar los comandos que se necesitan para
realizar una gran variedad de tareas muy comunes.

Este capítulo está organizado de la forma siguiente:

                                @{"Tareas básicas" link TareasBásicasConAmigaDOS}

                              @{"Tareas ocasionales" link TareasOcasionales}

                               @{"Tareas avanzadas" link HuyHuyHuy}

@endnode

@NODE TareasBásicasConAmigaDOS "Tareas básicas"

TAREAS BÁSICAS
--------------

Esta sección está pensada para el usuario novato de Shell, mostrándole los
comandos y pequeños scripts con los que puede realizar tareas muy básicas.
Use los comandos mostrados como modelos para sus propios comandos, cambiando
los nombres indicados por los que a usted le interesen para sus discos,
directorios y ficheros. Para usar los comandos, teclee lo que aparezca tras
el prompt (normalmente "1.> "). Pulse Return para introducir la línea de
comando que haya tecleado.
@endnode

@NODE OpenShell "Abrir una ventana Shell"

ABRIR UNA VENTANA SHELL

@{B}Para abrir una ventana Shell desde el Workbench:@{UB}

1. Abra el cajón System de su disco o partición Workbench.

2. Pulse dos veces sobre el icono Shell.

  O

1. Elija la opción "Ejecutar comando..." del menú Workbench.

2. En el requester que aparece, teclee el comando NEWSHELL y pulse Return.

@{B}Para abrir otra ventana Shell desde el Shell actual, introduzca el comando
NEWSHELL en el prompt:@{UB}

  1.> NEWSHELL
@endnode

@NODE RunProgShell "Ejecución de programas desde el Shell"

EJECUCIÓN DE PROGRAMAS DESDE SHELL

@{B}Para ejecutar un programa que está en la senda de búsqueda, introduzca el
nombre del programa en el prompt:@{UB}

  1.> Clock

@{B}Para ejecutar un programa que no está en la senda de búsqueda, introduzca la
senda completa para el programa:@{UB}

  1.> Tempus:Fugit/Utils/SuperReloj

@{B}Para ejecutar un programa que no está en la senda de búsqueda pero que está
en un subdirectorio del directorio actual, introduzca la senda que conduce al
programa:@{UB}

  1.Tempus:Fugit> Utils/SuperReloj
@endnode

@NODE StopProgShell "Detener un programa"

DETENER UN PROGRAMA

Los comandos AmigaDOS y la mayor parte de los programas del Workbench que se
ejecutan desde Shell pueden abandonarse (detenerse mientras están corriendo)
pulsando Ctrl+C. Esto es importante en caso de que necesite interrumpir un
@{"DELETE" link delete} que está borrando una gran cantidad de ficheros según un patrón, o
si quiere interrumpir un directorio que se está mostrando, o cualquier otro
proceso largo. Los scripts pueden detenerse con Ctrl+D.

@{B}Para detener un comando o programa que está corriendo actualmente:@{UB}

1. Haga que la ventana Shell desde la que se ejecutó el comando o programa
   sea la ventana actual, simplemente pulsando sobre ella.

2. Pulse Ctrl+C.

En algunos casos es necesario que pulse Return después de la combinación
Ctrl+C para hacer que aparezca el prompt de Shell.

@{B}Para interrumpir un script que está corriendo actualmente:@{UB}

1. Haga que la ventana Shell desde la que se ejecutó el script sea la
ventana actual, simplemente pulsando sobre ella.

2. Pulse Ctrl+D.

@endnode

@NODE ChangeCDShell "Cambio de directorio"

CAMBIO DEL DIRECTORIO ACTUAL

Normalmente, el directorio actual es parte del prompt estándar de Shell,
como por ejemplo "1.Workbench> ". En los siguientes ejemplos, fíjese en el
prompt para ver cómo cambia el directorio actual.

@{B}Para ahorrar trabajo tecleando, cambie el directorio actual por aquél en el
que esté trabajando.@{UB}

Si está usando dos o más comandos que usan cosas de un determinado
directorio, haga que ese directorio sea el directorio actual usando el
comando @{"CD" link cd}. Los siguientes dos bloques de comandos hacen la misma tarea:

  1.Workbench:> COPY Storage/Keymaps/usa2 TO DEVS:Keymaps
  1.Workbench:> DELETE Storage/Keymaps/usa2


  1.Workbench:> CD Storage/Keymaps
  1.Workbench:Storage/Keymaps> COPY usa2 TO DEVS:Keymaps
  1.Workbench:Storage/Keymaps> DELETE usa2

Si introduce el segundo conjunto de comandos en lugar del primero, se ahorra
más de una docena de pulsaciones. Este ahorro es todavía mayor si tiene que
hacer más cosas en el directorio Storage/Keymaps.

@{B}Para cambiar el directorio actual tecleando lo menos posible, omita el
comando @{"CD" link cd} y use solamente los dos puntos y la barra inclinada para moverse
por la estructura de directorios:@{UB}

  1.Workbench:Devs/Monitors> /Printers
  1.Workbench:Devs/Printers> :Prefs/Presets
  1.Workbench:Prefs/Presets> /
  1.Workbench:Prefs>

@{B}Para moverse rápidamente entre dos directorios, use el script @{"PCD" link ScriptPCD} (que se
encuentra en el directorio S:):@{UB}

  1.Workbench:> PCD Devs/DOSDrivers
  1.Workbench:Devs/DOSDrivers> Extras:Storage
  1.Extras:Storage> PCD
  1.Workbench:>

@{B}Para ver el directorio actual si el prompt no se lo muestra, use el comando
CD sin argumentos:@{UB}

  1.> CD
  Workbench:
  1.>

@endnode

@NODE ChangePathShell "Cambio de la senda de búsqueda"

CAMBIO DE LA SENDA DE BÚSQUEDA

@{B}Para crear un directorio en el volumen SYS: en el que se guardarán comandos
adicionales y hacer que este directorio se encuentre en la senda de búsqueda
del Shell actual:@{UB}

  1.> MAKEDIR SYS:MisComandos
  1.> PATH SYS:MisComandos ADD

@{B}Para añadir MisComandos a la senda de búsqueda y que esté disponible para
todo el sistema, use el comando @{"ASSIGN" link assign} en lugar de @{"PATH" link path}:@{UB}

  1.> ASSIGN C: SYS:MisComandos ADD

@{B}Para hacer que el Amiga busque los comandos del directorio C en cualquier
disco que se inserte en la unidad DF0:, use @{"ASSIGN" link assign} con la opción @{"PATH" link path}:@{UB}

  1.> ASSIGN C: DF0:C PATH
@endnode

@NODE MuestraDirShell "Mostrar el contenido de un directorio"

MOSTRAR EL CONTENIDO DE UN DIRECTORIO

@{B}Para ver los ficheros y los subdirectorios que contiene un directorio, use
@{"DIR" link dir}:@{UB}

  1.> DIR DEVS:
     DataTypes (dir)
     DOSDrivers (dir)
     Keymaps (dir)
     Monitors (dir)
     Printers (dir)
  clipboard.device                 DataTypes.info
  DOSDrivers.info                  Keymaps.info
  mfm.device                       Monitors.info
  MOUNTLIST                        mountlist.bak
  NARRATOR.DEVICE                  parallel.device
  postscript_init.ps               printer.device
  Printers.info                    RAMDRIVE.DEVICE
  serial.device                    system-configuration

@{B}Para mostrar los nombres de los ficheros, subdirectorios y los ficheros de
estos subdirectorios que estén dentro de un directorio, añada la palabra
clave ADD (aquí mostramos una parte del listado):@{UB}

  1.> DIR DEVS: ALL
     DataTypes (dir)
       8SVX                             8SVX.info
       AmigaGuide                       AmigaGuide.info
       FTXT                             FTXT.info
       ILBM                             ILBM.info
       JPEG                             JPEG.info
     DOSDrivers (dir)
       PIPE                             PIPE.info
     Keymaps (dir)
       e                                e.info
     Monitors (dir)
       DblNTSC                          DblNTSC.info
       DblPAL                           DblPAL.info

@{B}Para mostrar solamente los nombres de los ficheros, excluyendo los
directorios, añada la palabra clave FILES:@{UB}

  1.> DIR DEVS: FILES
  clipboard.device                 DataTypes.info
  DOSDrivers.info                  Keymaps.info
  mfm.device                       Monitors.info
  MOUNTLIST                        mountlist.bak
  NARRATOR.DEVICE                  parallel.device
  postscript_init.ps               printer.device
  Printers.info                    RAMDRIVE.DEVICE
  serial.device                    system-configuration

@{B}Para ver solamente los nombres de los ficheros excluyendo los ficheros .info
use el siguiente patrón:@{UB}

  1.> DIR DEVS:~(#?.info) FILES
  clipboard.device                 mfm.device
  MOUNTLIST                        mountlist.bak
  NARRATOR.DEVICE                  parallel.device
  postscript_init.ps               printer.device
  RAMDRIVE.DEVICE                  serial.device
  system-configuration             

@{B}Para ver información sobre los ficheros, incluyendo su tamaño y sus bits de
protección, pero sin mostrar la fecha ni la hora de creación, use @{"LIST" link list} con
las palabras clave FILES y NODATES:@{UB}

  1.> LIST DEVS:~(#?.info) FILES NODATES
  Directory "devs:" on sábado 21-may-94
  clipboard.device            6944 ---arw-d
  mfm.device                  6684 ---arw-d
  parallel.device             4272 ---arw-d
  postscript_init.ps          5014 ---arw-d
  printer.device             27420 ---arw-d
  serial.device               5412 ---arw-d
  system-configuration         232 ---arw-d
  NARRATOR.DEVICE            65760 ---arw-d
  MOUNTLIST                   2842 ----rw-d
  RAMDRIVE.DEVICE             2128 ---arw-d
  mountlist.bak               2819 ----rw-d
  11 files - 270 blocks used

@{B}Para mostrar información sobre un fichero solamente, use @{"LIST" link list} indicando la
senda del fichero:@{UB}

  1.> LIST S:Startup-sequence
  Directory "S:" on sábado 21-may-94
  Startup-sequence            1214 ----rwed 25-abr-94 05:32:44
  1 file - 4 blocks used

@{B}Para ver la cantidad de espacio ocupado por un directorio y su contenido,
incluyendo todos los ficheros de sus subdirectorios, use la palabra clave
ALL:@{UB}

  1.> LIST ALL

Después de listar el contenido del directorio actual, aparecerá una línea de
totales como la siguiente:

  TOTAL: 83 files - 875 blocks used

Dividiendo el número de bloques por dos, obtendrá el número de kilobytes
(Kb).

@{B}Para ver información de LIST, DIR u otros comandos que hayan desaparecido
por la parte superior de la ventana Shell:@{UB}

Seleccione el gadget de zoom de la ventana Shell una vez para elegir su
tamaño alternativo, que normalmente cubre toda la pantalla. En la ventana
aparecerá todo el texto anterior que quepa. Seleccione el gadget zoom de
nuevo para devolver la ventana a su tamaño anterior.

Si el tamaño máximo de la ventana no es suficiente para ver lo que le
interesa, llame al comando de nuevo pulsando la tecla de flecha arriba y
pulsando Return. Detenga o deje continuar el movimiento del texto hacia
arriba cuando lo necesite pulsando la barra espaciadora y la tecla de
borrado, respectivamente.

@{B}Para combinar los comandos @{"CD" link cd} y @{"DIR" link dir}:@{UB}

Cree el siguiente script y grábelo como S:CDD (para ver un ejemplo de cómo
crear un script, mire más adelante "@{"Creación de un fichero User-startup" link CrearUserStartup}".

  .KEY dirpath
  CD <dirpath>
  DIR

Active el bit de protección "s" del script introduciendo PROTECT S:CDD +s.
Ahora, siempre que introduzca CDD seguido por la senda de un directorio, el
script convertirá a ese directorio en el directorio actual, y listará su
contenido.

@endnode

@NODE CopiaConShell "Copia de ficheros y directorios"

COPIA DE FICHEROS Y DIRECTORIOS

Cuando copie un fichero de un sitio a otro, necesitará indicar las sendas
de cada uno. Las palabras clave FROM y TO son opcionales. Para mayor
claridad, la mayor parte de los ejemplos de COPY que hay en este manual usan
la palabra clave TO, pero omiten la palabra clave FROM.

@{B}Para copiar un fichero de un directorio ya existente usando palabras clave
opcionales:@{UB}

  1.> COPY FROM DF0:Pix/Fractal3 TO Work:Dibujos

@{B}Para copiar el fichero omitiendo las palabras clave opcionales:@{UB}

  1.> COPY DF0:Pix/Fractal3 Work:Dibujos

@{B}Para copiar un fichero y cambiar su nombre al mismo tiempo, indique el nuevo
nombre como el argumento TO:@{UB}

  1.> COPY DF0:Pix/Fractal3 TO Work:Dibujos/Dibujo3

@{B}Para copiar todos los ficheros de un directorio a otro, sin copiar el
directorio en sí ni los subdirectorios que contiene:@{UB}

  1.> COPY DF0:Pix TO Work:Dibujos

El contenido de DF0:Pix pasa a Work:Dibujos, sin incluir el directorio en
sí. Si Pix contiene directorios, éstos no se copian, pero los ficheros .info
de los cajones que pueda contener sí se copiarán.

@{B}Para copiar todos los ficheros de un directorio a otro directorio, copiando
el directorio en sí pero no los subdirectorios que contiene:@{UB}

  1.> COPY DF0:Pix TO Work:Dibujos/Pix

El directorio Pix se crea en Work:Dibujos si todavía no existía. El
directorio destino no tiene que tener el mismo nombre que el directorio
fuente; puede copiarlo con el nombre Work:Dibujos/Fractales, por ejemplo.

@{B}Para copiar un directorio completo y su contenido a otro directorio, use la
palabra clave ALL:@{UB}

  1.> COPY DF0:Pix TO Work:Dibujos/Pix ALL

Work:Dibujos/Pix será ahora una copia de DF0:Pix.

@{B}Para copiar solamente algunos ficheros a otro directorio, use un patrón si
sus nombres son parecidos:@{UB}

  1.> COPY DF0:Pix/Fractal[3-7] TO Work:Dibujos/Pix

Los ficheros de DF0:Pix cuyos nombres empiecen por Fractal y terminen en los
dígitos del 3 al 7, se copiarán a Work:Dibujos/Pix.

Para copiar unos ficheros determinados a otro directorio, incluya todos los
nombres de fichero. Cambie primero al directorio fuente para evitar tener
que teclear la senda completa para cada fichero.

  1.> CD DF0:Pix
  1.> COPY Fractal3 Julia Cielo TO Work:Dibujos/Pix

Cuando copia más de un fichero a la vez sin usar la palabra clave TO, COPY
espera que el último nombre sea el directorio destino. En las operaciones
en las que se usa un patrón con varios directorios y ficheros, COPY menciona
los nombres de los ficheros y directorios copiados y los nuevos directorios
creados durante su ejecución.

@endnode

@NODE CrearUserStartup "Creación de un fichero User-startup"

CREACIÓN DE UN FICHERO USER-STARTUP

Un fichero User-startup es el equivalente en Shell del cajón WBStartup para
el Workbench. Se trata de un fichero de texto que es ejecutado como un
script por el fichero Startup-sequence estándar. Coloque aquí los comandos de
configuración (como @{"ASSIGN" link assign}) y los nombres de los programas que quiera
ejecutar automáticamente al arrancar el sistema.

@{B}Para crear un fichero User-Startup:@{UB}

  1.> RUN ED S:User-startup

Después de que se haya abierto la ventana de ED, introduzca los comandos que
quiera en sucesivas líneas. Por ejemplo, puede añadir unos cuantos buffers
caché para acelerar el acceso a los discos flexibles, añadir un directorio
en la senda de búsqueda en el que se guardarán algunos comandos, y ejecutar
el protector de monitor @{"Blanker" link CoBlanker} introduciendo estas líneas:

  ADDBUFFERS >NIL: DF0: 25
  PATH >NIL: SYS:MisComandos ADD
  RUN Blanker CX_POPUP=NO SECONDS=600 ANIMATION=YES

Luego grabe el fichero y abandone ED pulsando Esc,X,Return. La próxima
vez que arranque o resetee el Amiga, estos comandos se ejecutarán
automáticamente. Cuando tenga más comandos que añadir, edite este fichero
introduciendo "RUN ED S:User-startup" de nuevo.

@endnode

@NODE CreaAssign "Creación de una asignación"

CREACIÓN DE UNA ASIGNACIÓN

En los sistemas basados en disco flexible, es costumbre que aparezca en
pantalla un requester pidiéndole que inserte un determinado disco flexible
en la disquetera.

En los sistemas basados en disco duro, la razón más probable de que aparezca
este tipo de requester es, aparte de que haya podido indicar un comando con
un signo de dos puntos (:) mal colocado, que una aplicación que esté
ejecutando necesite que se haga una asignación con el comando @{"ASSIGN" link assign}. A
menudo esto lo hace automáticamente un programa de instalación, pero no
siempre las aplicaciones disponen de un programa de instalación o de uno
que funcione correctamente en todos los sistemas.

La asignación obliga a la aplicación a buscar en el disco duro las cosas que
necesite, en lugar de acudir a un disco flexible. Si usa esa aplicación con
cierta asiduidad, es más que recomendable que coloque una orden ASSIGN en
su fichero User-startup. Cuando el requester aparece por primera vez,
incluso puede realizar la asignación desde una ventana Shell y luego
seleccionar el gadget "Reintentar" del requester para continuar su trabajo.

@{B}Para poder continuar su trabajo con un programa instalado desde un disco
llamado ProFusion al volumen Work:, introduzca la orden:@{UB}

  1.> ASSIGN ProFusion: Work:ProFusion

donde el primer argumento será el volumen solicitado por el requester,
terminado en un signo de dos puntos, mientras que el segundo argumento será
el dispositivo y el directorio donde se instaló ProFusion. Pulse sobre el
gadget Reintentar después de introducir el comando. Si la orden es correcta,
la aplicación dejará de molestarle y ello significará que ésa es la orden
que debe poner en el fichero User-startup. Si no funciona, entonces deberá
modificar el segundo argumento.

@endnode

@NODE MenúsExpandDeED "Acceso a los menús expandidos de ED"

ACCEDIENDO A LOS MENÚS EXPANDIDOS DE ED

El fichero S:Ed-startup por defecto configura una serie de menús para el
editor de texto ED. También hay un conjunto expandido de menús que está
incorporado en ED, y que contiene más opciones. Puede hacer que estas
opciones estén disponibles cambiando de nombre el fichero Ed-startup
actual, lo que impedirá que este fichero sea ejecutado.

Para permitir el acceso a los menús expandidos de ED, introduzca el
siguiente comando:

  1.> RENAME S:Ed-startup TO S:Ed-startup.bak

@endnode

@NODE TrabajaConShellCaray "Trabajo con una ventana Shell"

TRABAJANDO CON UNA VENTANA SHELL

A pesar de que puede abrir varias ventanas Shell independientes a la vez,
posiblemente prefiera no llenar la pantalla Workbench con ventanas. Si
ejecuta un programa desde Shell, normalmente ese Shell queda "tomado" por
el programa mientras éste se está ejecutando, obligándole a abrir otro Shell
si necesita introducir más comandos. Use las siguientes técnicas para evitar
esto y poder ejecutar todos los programas que quiera con un único Shell.

@{B}Para ejecutar un programa en segundo plano de forma que no se pierda el
prompt del Shell, use el comando @{"RUN" link run}:@{UB}

  1.> RUN DMC OPT def RHYME on
  [CLI 2]
  1.>

El mensaje que aparece entre corchetes indica el número del nuevo proceso
abierto para ejecutar el programa. El prompt vuelve inmediatamente.

Incluso cuando un programa se ejecuta de esta forma, la ventana Shell no
puede cerrarse hasta que todos los programas abiertos desde la misma
abandonan el sistema. Para evitar esto, puede independizar el programa
usando la redirección.

@{B}Para independizar un programa, ejecútelo con @{"RUN" link run}, añadiendo la redirección
de salida hacia el dispositivo NIL:@{UB}

  1.> RUN >NIL: MultiView 8SVX/Sample
  [CLI 2]
  1.>

Ahora puede cerrar la ventana Shell si lo desea.

NOTA: La redirección hacia NIL: también impide que la salida de información
      que el programa pueda producir sea enviada hacia la ventana de consola
      de Shell.

@endnode

@NODE UsaIconos "Uso de iconos"

ASOCIANDO ICONOS

Para asociar un icono a un fichero o directorio, puede crear un icono con
la herramienta @{"IconEdit" link UtiIconEdit}. Sin embargo, a menudo es más sencillo limitarse a
copiar un icono ya existente con un comando de Shell.

Debe copiar un fichero .info del tipo correcto de icono, dándole un nombre
que coincida con el fichero o directorio al que quiera asociarlo, y por
supuesto añadiéndole la extensión .info. Si es necesario, use la opción de
menú "Información..." para cambiar la herramienta por defecto en caso de
que haya copiado un icono de proyecto, o para cambiar los tipos de
herramienta en caso de que haya copiado un icono de herramienta.

NOTA: El nombre que use para nombrar el fichero .info será el que aparezca
      en el icono del Workbench representando a ese objeto, sin importar si
      el nombre que tenía el objeto tenía letras mayúsculas o minúsculas.

@{B}Para asociar un icono a un fichero llamado PCX en el directorio DataTypes,
copie el fichero .info de un datatype existente en el directorio:@{UB}

  1.> COPY DataTypes/ILBM.info TO DataTypes/PCX.info

Un icono llamado PCX aparecerá en la ventana DataTypes cuando la abra o
seleccione la opción "Actualizar" del menú Ventana.

NOTA: Si el icono que ha copiado tenía fijada su posición en la ventana, el
      nuevo icono usará esa misma posición, apareciendo encima del icono
      original. Arrastre el nuevo icono hasta una posición diferente y use
      la opción Congelar para mantener los dos iconos separados.

@{B}Para asociar un icono diferente a un disco llamado VidTools, copie el
fichero .info de disco que quiera al directorio raíz del disco, dándole el
nombre "disk.info":@{UB}

  1.> COPY SYS:disk.info TO VidTools:disk.info

Deberá quitar e insertar de nuevo el disco o resetear el sistema para que el
nuevo icono del disco aparezca en el Workbench.

@endnode

@NODE CreaScriptsDurmiendo "Creando scripts cómodamente"

CREANDO SCRIPTS CÓMODAMENTE

@{B}Para hacer más ácil la creación y la edición de scripts:@{UB}

Cree un script que contenga las siguientes líneas, y grábelo como S:Edscr
(para ver un ejemplo de cómo crear un script, mire más atrás el apartado
"@{"Creando un fichero User-startup" link CrearUserStartup}").

  .KEY script/A
  ED S:<script>
  FAILAT 11
  IF EXISTS S:<script>
    PROTECT S:<script> srwd
  ENDIF

Active el bit de protección de script introduciendo "PROTECT S:Edscr srwd".
Ahora, usando Edscr puede crear y editar scripts sin tener que decidir
dónde ponerlos ni preocuparse por si olvida activar su bit "s". Simplemente
introduzca Edscr y el nombre del script.

Cuando grabe y salga de @{"ED" link MiraED}, el script en el que haya trabajado se grabará
bajo el nombre que le haya dado. Su bit de protección "s" se activará
automáticamente para que pueda ejecutar el script desde Shell sin necesitar
usar el comando @{"EXECUTE" link execute}.

@endnode

@NODE TareasOcasionales "Tareas ocasionales"

TAREAS OCASIONALES
------------------

Las tareas descritas en esta sección se usan menos a menudo, pero casi
cualquier usuario necesitará hacerlas en algún momento. En estos ejemplos
se asume que conoce un poco el AmigaDOS y el Shell.

@endnode

@NODE CreaciónDeAlias "Creación de alias para ahorrar trabajo"

CREACIÓN DE ALIAS PARA AHORRAR TRABAJO

Los alias listados a continuación pueden ayudarle a acelerar su trabajo
con Shell reduciendo el número de pulsaciones necesarias para ejecutar los
comandos más habituales.

Para activar estos alias como globales, edite el fichero Shell-startup como
se ha descrito anteriormente para el fichero User-startup, añadiendo estas
líneas:

  ALIAS c0 CD DF0:
  ALIAS cs CD SYS:
  ALIAS css CD S:
  ALIAS d0 DIR DF0:
  ALIAS dr DIR RAM:
  ALIAS qdir DIR ~(#?.info)
  ALIAS ls LIST
  ALIAS cp COPY
  ALIAS cc COPY [] CLONE
  ALIAS del DELETE
  ALIAS ren RENAME
  ALIAS ns NEWSHELL
  ALIAS es ENDSHELL
  ALIAS pf PRINTFILES
  ALIAS fmt0 FORMAT DRIVE DF0: NAME [] FFS NOICONS DIRCACHE
  ALIAS edus RUN ED S:User-startup
  ALIAS edsh RUN ED S:Shell-startup
  ALIAS ednew RUN ED RAM:NuevoFichero
  ALIAS chip ECHO "Hay `avail chip` bytes libres de Chip RAM."

Modifique los nombres de los alias si quiere. Use estos comandos como
modelos para sus propios alias.

@endnode

@NODE PersonalizaNewshell "Personalización de NEWSHELL"

PERSONALIZACIÓN DE NEWSHELL

Puede controlar la ventana de Shell con el argumento WINDOW del comando
NEWSHELL. Esta opción le permite indicar un tamaño determinado para la
ventana, su posición y ciertas funciones de la misma. A continuación
mostramos dos ejemplos sobre diferentes especificaciones para la ventana.

@{B}Para abrir una ventana Shell de un tipo determinado en la pantalla
Workbench, introduzca el siguiente comando en el Shell o como una línea
en el fichero User-startup:@{UB}

  NEWSHELL CON://400/100/NuevoShell/CLOSE/ALT0/12/640/388

Esta orden crea una pequeña ventana Shell titulada NuevoShell que no ocupa
el lado izquierdo de la ventana del Workbench, de forma que pueda ver
fácilmente los iconos de disco. Esta ventana tiene un gadget de cierre y,
en una pantalla entrelazada de alta resolución, se expande para cubrir la
pantalla completa excepto la parte de la barra de título cuando selecciona
su gadget de zoom.

@{B}Para abrir una ventana Shell en una pantalla pública, como por ejemplo en la
pantalla de un programa de comunicaciones, use la especificación de ventana
incluyendo la opción SCREEN:@{UB}

  CON:0/20///???/CLOSE/SCREENTerminal

Esta orden crea una ventana Shell llamada ??? que se coloca cerca del borde
superior de la pantalla y que es tan ancha y achatada como es posible. La
ventana se abre en una pantalla pública llamada Terminal, si tal pantalla
está disponible. Si no lo está, la ventana aparecerá en la pantalla del
Workbench.

@endnode

@NODE CambiaElPrompt "Modificación del prompt"

MODIFICANDO EL PROMPT

El prompt del Shell puede modificarse fácilmente usando el comando @{"PROMPT" link prompt}.
Puede poner cualquier texto en el prompt, incluyendo si lo desea los
operadores que hacen que se muestre el número de proceso, directorio actual
y código de retorno. Colocar secuencias de Escape en el prompt le permite
hacer que el prompt destaque visualmente del resto de la línea de comando.
También puede incluir un comando en el prompt usando el apóstrofe inverso
(`).

Si introduce la línea:

  PROMPT "<Esc>[1m<Esc>[32m%n.%s> <Esc>[0m"

el prompt usará caracteres en negrita de color blanco (mire el @{"apéndice D" link Escape}
para ver una lista de las secuencias de Escape). Tenga en cuenta que donde
ponemos "<Esc>" queremos decir que debe pulsar la tecla Esc.

Si introduce la línea:

  PROMPT "%s (*`date*`) %n$ "

el prompt recupera su aspecto normal, si bien incluye el comando @{"DATE" link date} usando
el apóstrofe inverso y cambia el carácter final por un signo de dólar ($).

@endnode

@NODE DiscoRamLoco "Creación de un icono de disco RAM diferente"

CREACIÓN DE UN ICONO DE DISCO RAM DIFERENTE

Para usar un icono de disco RAM diferente, tendrá que colocar una orden @{"COPY" link copy}
en el fichero User-startup. Primero cree el icono en @{"IconEdit" link UtiIconEdit}. Asegúrese
de que es un icono de tipo disco y grábelo en su disco de arranque como
DEVS:Ramdisk.info.

NOTA: Este ejemplo usa el directorio DEVS:, pero no importa dónde guarde
      este icono. No podrá verlo ni siquiera con la opción "Mostrar/Todos
      los ficheros", ya que los iconos de disco sólo pueden verse en la
      ventana del Workbench.

@{B}Para hacer que su nuevo icono de disco RAM aparezca en la ventana del
Workbench, introduzca esta línea en el fichero S:User-startup, grabe el
fichero tal como está ahora y resetee el ordenador:@{UB}

  COPY DEVS:Ramdisk.info TO RAM:disk.info

Si también quiere cambiar el nombre del disco RAM, incluya una orden
@{"RELABEL" link relabel} en el fichero User-startup después de la orden @{"COPY" link copy}, como ésta:

  RELABEL RAM: DiscoRAM

@endnode

@NODE BorraFicherosConInfo "Borrado de ficheros con icono"

BORRANDO FICHEROS CON ICONO

@{B}Para borrar un fichero que tiene un icono y el fichero .info correspondiente
con un sólo comando:@{UB}

  1. Cree y grabe el siguiente script como S:Delinf:

    .KEY file/A
    DELETE <file> <file>.info QUIET

  2. Introduzca "EXECUTE Delinf" con el nombre del fichero como argumento.
@endnode

@NODE ProbandoComandos "Probando comandos"

PROBANDO COMANDOS

A veces es necesario comprobar el resultado de ciertos comandos antes de
usarlos en nuestros ficheros. Esto resulta particularmente cierto cuando se
trata de usar un patrón complejo con comandos potencialmente destructivos,
como @{"DELETE" link delete}, o secuencias de Escape, con las cuales puede resultar difícil
preveer su resultado. Hay varias formas de probar comandos que son rápidas y
seguras.

@{B}Para probar un comando usando un patrón potencialmente destructivo:@{UB}

  1. Introduzca un comando que no resulte destructivo, como @{"LIST" link list}, usando el
     patrón. Por ejemplo:

     LIST ~(#?.info|#?.c|[0-9]#?)

  2. Compruebe la salida de información del comando para ver si el patrón
     alude a los ficheros que le interesan.

  3. Modifique el patrón si es necesario y repita el comando hasta que el
     comando liste solamente los ficheros que le interesen.

  4. Introduzca ahora el comando deseado, usando el mismo patrón.

@{B}Para probar los efectos de las secuencias de Escape:@{UB}

  1. Introduzca un comando @{"ECHO" link echo} que contenga las secuencias de Escape y una
     palabra de ejemplo. Por ejemplo:

     ECHO "*E[1mBOLD*E[0m"

  2. Compruebe si la salida de información es la deseada.

  3. Modifique la secuencia de Escape si es necesario y repita el comando
     hasta que se produzca exactamente el resultado apetecido.

  4. Use las secuencias de Escape ahora con el comando que deseaba utilizar,
     como @{"PROMPT" link prompt}.

Para borrar la ventana y resetear todos los modos de secuencias de Escape a
sus valores por defecto, pulse Esc, c y luego Return. Debe usar la "c" en
minúsculas. Después de limpiar la ventana y hacer el reset, el Shell
mostrará el mensaje ": Comando desconocido", pero no se preocupe.

@{B}Para crear un fichero de prueba en el disco RAM, introduzca:@{UB}

  1.> ECHO "Esto sólo es una prueba" TO RAM:prueba

Esto ofrece un pequeño fichero sobre el que puede probar los comandos que
quiera. Es mejor crear un fichero así en RAM: para evitar llenar sus discos
con pequeños ficheros que no sirven para nada.

@{B}Para probar comandos de forma segura en los ficheros auténticos, copie
primero los ficheros a un directorio del disco RAM y haga pruebas con estos
ficheros:@{UB}

  1.> COPY Work:MisFicheros/#? TO RAM:DirPruebas

@endnode

@NODE ScriptCopiador "Creación de un script para trasladar ficheros"

CREACIÓN DE UN SCRIPT PARA TRASLADAR FICHEROS

El AmigaDOS no cuenta con un comando que pase un objeto de un lugar a otro.
Normalmente, hay dos formas de trasladar un fichero con el AmigaDOS: con el
comando @{"RENAME" link rename} o con una combinación de los comandos @{"COPY" link copy} y @{"DELETE" link delete}.

Usar @{"RENAME" link rename} para trasladar un fichero sólo es posible cuando el traslado se
efectúa dentro del mismo volumen. Si intenta hacer un cambio de nombre a
través de dos dispositivos distintos, se producirá un error. Por otro lado,
el método de copia y borrado trabaja en cualquier situación, pero es menos
elegante.

@{B}Para crear un comando Move que le permita trasladar un fichero incluso entre
dos dispositivos con un sólo comando, cree un script con los siguientes
comandos:@{UB}

  1.> RUN ED S:Move +
  PROTECT S:Move swrd

@{B}Ahora introduzca estos comandos en la ventana ED:@{UB}

  .KEY source/A,to/A
  .BRA {
  .KET }
  FAILAT 21
  RENAME >NIL: {source} TO {to}
  IF WARN
    COPY {source} TO {to}
    IF WARN
      ECHO "No he podido trasladar el fichero {source}."
      QUIT 20
    ENDIF
    DELETE {source} QUIET
  ENDIF
  ECHO "He trasladado el fichero {source} hasta {to}."

Grabe el script y salga de ED. El bit de protección "s" se activa
automáticamente al salir de ED.

Use este script como lo haría con el comando. Introduzca MOVE seguido por
dos argumentos: la senda actual del fichero a trasladar y la senda del
destino deseado.

@endnode

@NODE DirInteractivo "Borrar con un DIR interactivo"

BORRANDO CON UN DIR INTERACTIVO

El comando @{"DIR" link dir} tiene un modo interactivo que hace que su funcionamiento se
detenga momentáneamente despúes de listar cada fichero o directorio para
permitirle introducir un comando. Una de las opciones es borrar el objeto,
lo cual puede resultar muy útil en ciertas ocasiones.

Por ejemplo, si accidentalmente nombra a un fichero "#?" (la combinación
de comodines que alude a todo), intentar borrarlo mediante los métodos
habituales es muy poco aconsejable. Esto se debe a que la orden "DELETE #?"
borra TODO lo que haya en el directorio, incluyendo cualquier otro fichero
que pueda haber en él.

El @{"DIR" link dir} interactivo puede resolver este problema si lo usa como una
herramienta para borrar que pide confirmación antes de hacerlo. Esto resulta
muy útil cuando tiene un gran directorio que contiene muchas cosas que
quiere borrar, pero cuyos nombres no tienen lo suficiente en común como
para hacer que un comando @{"DELETE" link delete} con un patrón sea efectivo.

@{B}Para borrar varios ficheros de un disco llamado "Debris" de forma segura con
un @{"DIR" link dir} interactivo, teclee:@{UB}

  1.> DIR Debris: INTER

@{"DIR" link dir} listará los nombres de los ficheros de Debris de forma alfabética uno
por uno, indicando un signo de interrogación (?) al final como prompt. Pulse
Return para pasar al siguiente fichero o E para introducir un directorio.
Cuando aparezca el nombre de un fichero que quiera borrar, introduzca DEL
para eliminarlo. Introduzca Q cuando quiera abandonar el @{"DIR" link dir} interactivo.

@endnode

@NODE GeneraScriptsLFORMAT "Generando scripts con LIST LFORMAT"

GENERANDO SCRIPTS CON LIST LFORMAT

Uno de los objetivos principales de la opción LFORMAT del comando @{"LIST" link LIST} es
crear automáticamente scripts que luego sirvan para procesar un conjunto de
ficheros determinado. Puede producir un script de esta forma usando una
orden @{"LIST" link list} con LFORMAT, un argumento TO para redirigir la salida de @{"LIST" link list}
hacia un fichero, y también un patrón. Luego puede ver el script y editarlo
manualmente si es necesario antes de ejecutarlo.

@{B}Para crear un script que cambie de nombre todos los ficheros del directorio
actual, que añada la extensión .IFF a sus nombres actuales y que los coloque
en un directorio llamado Dibujos de la partición Work:@{UB}

  1.> LIST #? TO T:Cambia LFORMAT="RENAME %P%N TO Work:Dibujos/%N.IFF"

Introduzca "ED T:Cambia" para comprobar el script, que debería coincidir con
el expuesto a continuación. Si el patrón hace que aparezcan ficheros que no
quiere usar o si la cadena LFORMAT no hace lo que usted esperaba, puede
editar el script o modificarlo y reintroducir el comando.

  RENAME Paint:Vicente TO Work:Dibujos/Vicente.IFF
  RENAME Paint:Enrique TO Work:Dibujos/Enrique.IFF
  RENAME Paint:Alfonso TO Work:Dibujos/Alfonso.IFF
  RENAME Paint:Alfredo TO Work:Dibujos/Alfredo.IFF
  RENAME Paint:Alberto TO Work:Dibujos/Alberto.IFF

Cuando el script sea correcto, abandone @{"ED" link MiraED} e introduzca "EXECUTE T:Cambia".

Mire el ejemplo @{"Scripts recursivos con comandos AmigaDOS" link ScriptsRecursivos} más adelante para
ver un uso más avanzado de LIST LFORMAT.

@endnode

@NODE PersonalizaList "Personalizando la salida de LIST"

PRESONALIZANDO LA SALIDA DE LIST

También puede usar la opción LFORMAT para modificar la salida de @{"LIST" link LIST} o para
tareas especiales. Para mayor comodidad, grabe la línea como un alias para
hacer más fácil su uso en el futuro.

@{B}Para crear un alias de LIST que muestre solamente información sobre los
ficheros creados desde la fecha que le indique, con la fecha primero y
omitiendo la información referente a los bits de protección y a la hora de
creación:@{UB}

  1.> ALIAS Ldesde LIST FILES SINCE [] LFORMAT="%D %-25N %L"

Si el directorio actual es S:, la salida de información de la orden "Ldesde
1-sep-92" será parecida a esta:

01-dic-93 BRUtab                    1843
02-sep-92 DPat                      709
02-sep-92 Ed-startup                615
01-dic-93 HDBackup.config           1559
02-sep-92 PCD                       248
lunes     Shell-Startup             558
02-sep-92 SPat                      283
13-may-94 User-Startup              832
25-abr-94 startup-sequence          1214

@endnode

@NODE IconXRun "Uso de ICONX para ejecutar scripts"

USANDO ICONX PARA EJECUTAR SCRIPTS

Si prefiere trabajar con el ratón lo más posible o está preparando el Amiga
para un usuario solamente de Workbench, @{"ICONX" link IconX} le será útil. Usando ICONX
como la herramienta por defecto de un icono de proyecto, podrá ejecutar un
script (o un comando que eche en falta en el interfaz Workbench) desde el
icono. @{"ICONX" link IconX} le permite ejecutar el script abriendo el icono, como si el
script fuese una herramienta más del Workbench.

Abrir programas de esta forma también tiene sus ventajas añadidas para el
usuario avanzado, como puede ser definir unos pasos previos (por ejemplo,
cargar una preselección de un programa de preferencias) antes de lanzar un
programa o cambiar fácilmente la prioridad de tarea de una herramienta. El
siguiente ejemplo demuestra estas técnicas.

@{B}Para ejecutar una aplicación llamada Corredor desde un icono de ICONX,
cargando primero una fuente determinada como preselección de preferencias,
y ajustando la prioridad de tarea de la aplicación, cree el siguiente script
para el icono:@{UB}

  CD SYS:
  Prefs/Font FROM SYS:Prefs/Presets/defscrn.pre USE
  CHANGETASKPRI -1
  Corredor

@endnode

@NODE ChitónScript "Eliminación de la salida de información de los scripts"

IMPIDIENDO LA SALIDA DE INFORMACIÓN DE LOS SCRIPTS

En los scripts, a menudo deseará que un comando no muestre ninguna
información al ser ejecutado. La finalidad de esto podría ser impedir la
aparición de una serie de mensajes o evitar que se abra una ventana de
salida en un momento inoportuno.

@{B}Para evitar cualquier salida hacia la consola, redirija la salida del
comando hacia un destino especial llamado NIL de la forma siguiente:@{UB}

  1.> DELETE >NIL: T:FicheroTemporal

El argumento >NIL: evita que aparezca el mensaje "T:FicheroTemporal deleted"
o cualquier mensaje de error.

@{B}Para evitar la salida hacia la consola exceptuando los mensajes de error,
use la opción QUIET con aquellos comandos que la soporten:@{UB}

  1.> DELETE T:FicheroTemporal QUIET

El mensaje "T:FicheroTemporal deleted" no se imprimirá; sin embargo, si
el fichero T:FicheroTemporal no existe, aparecerá el mensaje "No file to
delete".

@endnode

@NODE PruebaElARexx "Introducción y prueba de macros ARexx"

INTRODUCCIÓN Y PRUEBA DE MACROS AREXX

@{B}Para hacer más sencilla la introducción y prueba de macros ARexx:@{UB}

Introduzca el siguiente script AmigaDOS y grábelo como S:Edrx:

  .KEY mac
  ED REXX:<mac>.rexx
  PROTECT S:<mac>.rexx +S-E
  RX REXX:<mac>

Use este script para experimentar con macros ARexx. Introduzca "Edrx"
seguido por el nombre de la macro. Edrx llama al editor sin que tenga que
teclear la extensión .rexx, invocando directamente al intérprete RX de
ARexx con la macro como argumento cuando sale.
@endnode

@NODE SortJoinFicheros "Ordenación y unión de ficheros"

ORDENACIÓN Y UNIÓN DE FICHEROS

Si regularmente toma una lista de nuevos ficheros cada vez que conecta con
un servicio de telecomunicaciones, es posible que quiera hacer una lista de
los ficheros existentes y ordenar esta lista según la fecha. Cada nombre de
fichero tiene el mismo prefijo y un sufijo que indica la fecha, como puede
ser "NuevosFicheros090193" para la lista de ficheros del 9 de enero de 1993.

@{B}Para crear una sencilla lista de ficheros, ordenando estos ficheros según la
fecha, use los comandos @{"JOIN" link join} y @{"SORT" link sort} con un patrón:@{UB}

  JOIN NuevosFicheros.#? TO RAM:Temp.unidos
  SORT RAM:Temp.unidos TO NuevosFicheros.ordenados
  DELETE RAM:Temp.unidos
@endnode

@NODE HuyHuyHuy "TAREAS AVANZADAS"

TAREAS AVANZADAS
----------------

Los siguientes ejemplos ilustran tareas avanzadas para usuarios que ya estén
familiarizados con el AmigaDOS.

@endnode

@NODE PruebaVersiones "Probando versiones del software"

PROBANDO VERSIONES DEL SOFTWARE

A lo mejor necesita controlar lo que hace un script dependiendo de la
versión del sistema operativo que tiene el usuario del script. Resulta
fácil saber los números de versión desde un script.

@{B}Para saber si un script está corriendo en un Amiga con el sistema operativo
versión 2, indique antes de los comandos que hacen el trabajo principal una
secuencia como ésta:@{UB}

  VERSION >NIL: 37
  IF WARN
    ECHO "Oiga, es hora de que actualice su sistema."
    QUIT
  ELSE
    ECHO "Tiene la versión 2 o superior. ¡Bien!"
    ECHO "Continuemos..."
  ENDIF

Las números de versión por debajo de 37 son anteriores al sistema operativo
versión 2, el número 38 indica la versión 2.1, el número 39 indica la
versión 3, y el número 40 nos indica la presencia de la versión 3.1.

@endnode

@NODE AdiósBasura "Eliminación de fuentes y librerías inútiles"

ELIMINACIÓN DE FUENTES Y LIBRERÍAS INÚTILES

Cuando carga fuentes y librerías en la memoria, éstas permanecen allí a
pesar de que no se estén utilizando, y sólo se eliminan cuando el sistema
necesita el espacio al haberse quedado escaso de memoria. En algunos casos
tal vez quiera quitar los recursos innecesarios manualmente.

Por ejemplo, si quiere editar y luego probar una fuente, o bien saber el
número de versión de una librería, que están en un nuevo disco, puede
parecer que el Amiga no es capaz de ver la nueva fuente o librería. Esto
se debe a que el AmigaDOS usa la fuente o librería que tiene en la memoria
siempre que le es posible. Puede eliminar los recursos innecesarios de la
memoria para evitar la fragmentación de la misma usando la opción FLUSH del
comando @{"AVAIL" link avail}.

@{B}Para eliminar una fuente o librería inútil de la memoria sin tener que
resetear el Amiga, introduzca:@{UB}

  1.> AVAIL FLUSH

Para que este comando elimine una fuente o librería, el objeto no debe estar
siendo utilizado por el Workbench ni ninguna otra aplicación.

@endnode

@NODE BuclesAmigaDOS "Bucles AmigaDOS usando EVAL"

BUCLES AmigaDOS USANDO EVAL

@{B}Para crear un bucle en el AmigaDOS que pregunte el número de veces que
quiera que se repita el bucle:@{UB}

Introduzca el siguiente script y grábelo como "UnBucle":

  .KEY loop
  ; cambia los caracteres de paréntesis usados para hacer sustituciones, ya
  ; que el script usa < y > para la redirección:
  .BRA {
  .KET }
  ; comprueba si el usuario ha indicado un argumento para el número de
  ; bucles; si no es así, lo solicita inmediatamente:
  IF NOT {loop}
    ECHO "Por favor, introduzca el número de repeticiones"
    ECHO "y pulse Return: " NOLINE
    SETENV >NIL: loop{$$} ?
  ELSE
    ; ya había un argumento, así que guardamos su valor
    ECHO >ENV:Loop{$$} {loop}
  ENDIF
  ;
  LAB Comienzo                  ; comienza el bucle...
  ECHO "Repetición #" NOLINE    ; sustituye el comando
  TYPE ENV:Loop{$$}             ; a repetir
  EVAL <ENV:Loop{$$} >NIL: TO=T:Qwe{$$} VALUE2=1 OP=- ?
  TYPE >ENV:Loop{$$} T:Qwe{$$}
  IF VAL $loop{$$} GT 0
    SKIP Comienzo BACK          ; bucle aún no terminado
  ENDIF
  ;
  DELETE ENV:loop{$$} T:Qwe{$$} QUIET   ; limpia
  ECHO "Listo."

Si invoca a este script sin indicar un número como argumento, se le pedirá
que introduzca este número, y este valor se utilizará como el número de
bucle inicial. Si indica un número, como por ejemplo:

  1.> EXECUTE UnBucle 5

aparecerá la siguiente información:

  Repetición #5
  Repetición #4
  Repetición #3
  Repetición #2
  Repetición #1
  Listo.

Lo único que hace el bucle es mostrar el número de repetición actual. Sin
embargo, puede insertar las órdenes que quiera usando la variable de entorno
Loop{$$}.

El primer bloque IF comprueba si se ha indicado un argumento en el momento
de invocar el script. Si no es así, el script le pedirá este valor. En
cualquier caso, el script guarda el valor en el fichero de variable ENV:Loop
{$$}. El operador {$$} une el número de proceso al nombre "Loop" para crear
un único nombre de fichero y evitar posibles conflictos al trabajar en
multitarea. Por ejemplo, el nombre de fichero que está en ENV: podría ser
Loop4.

Durante el bucle, un comando ECHO junto con un comando TYPE muestra
"Repetición #" seguido por el número dado como el argumento del bucle.
La primera vez que se ejecuta el bucle, se muestra "Repetición #5".

El comando EVAL toma el número que se encuentra en el fichero ENV:Loop{$$}
como <value1>, haciendo que sea necesario poner el signo de interrogación al
final de la línea. <Value2> es 1 y la operación es una sustracción. La
salida del comando EVAL se envía al fichero T:Qwe{$$}. El siguiente comando
TYPE envía el valor de T:Qwe{$$} al fichero ENV:Loop{$$}. La función de estas
dos líneas es sustraer 1 al valor de ENV:Loop{$$}.

La orden IF hace que el script comience de nuevo en cuanto el valor de Loop
{$$} sea mayor de 0. Esto hace que se imprima de nuevo la línea "Repetición
#", mostrando el nuevo valor.

El script continúa hasta que Loop{$$} es igual a 0. Al final del script se
borran los dos ficheros temporales.

@endnode

@NODE VamosConPIPE "Usando PIPE"

USANDO PIPE:

@{B}Para enviar un listado con el contenido de un dispositivo hacia otro
proceso:@{UB}

Desde el proceso 1:

  1.> LIST Work: TO PIPE: ALL

Desde el proceso 2:

  1.> TYPE pipe:

@{B}Para unir los resultados de varias compilaciones de C:@{UB}

  1.> sc >pipe:ll leche.c
  1.> sc >pipe.ll snap.c
  1.> sc >pipe:ll bum.c
  1.> sc >pipe:ll pop.c
  1.> TYPE pipe:ll

@{B}Para usar nombres de canal:@{UB}

  1.> LIST >pipe:loco

Esto envía el listado a un PIPE llamado "loco".

  1.> COPY #?.c TO >pipe:todo_c/32000

Esto indica un canal llamado "todo_c" y un tamaño de buffer de 32000 bytes.

@{B}Para ajustar el límite del número de buffers a 5:@{UB}

  1.> DIR >pipe://5

Esto crea un canal sin usar un nombre de canal, y permite sólo 5 buffers.

@endnode

@NODE ScriptsRecursivos "Scripts recursivos con comandos AmigaDOS"

SCRIPTS RECURSIVOS CON COMANDOS AmigaDOS

@{B}Para crear un script que le permita aplicar cualquier comando AmigaDOS
al contenido de un directorio, incluyendo todos sus subdirectorios y sus
contenidos correspondientes, introduzca este script y grábelo como S:RPAT:@{UB}

  .KEY COM/A,PATH,OPT,RD
  ; introduce el comando en COM, la senda del árbol de directorios a
  ; procesar en PATH, si no es el directorio actual, e introduce una opción
  ; del comando en OPT. No necesita introducir nada para RD.
  ;
  .BRA {
  .KET }
  FAILAT 21
  ;                ; no se detiene en caso de que LIST no encuentre nada
  ; primero busca ficheros, y luego genera un nuevo script:
  LIST >T:trf{$$} "{PATH}" FILES LFORMAT="{COM} *"%p%n*" {OPT}"
  IF EXISTS T:trf{$$}
    ; se encontraron ficheros, así que ejecutamos el nuevo script y luego
    ; lo borramos
    EXECUTE T:trf{$$}
    DELETE T:trf{$$}
  ENDIF
  ;
  ; lista los subdirectorios, llamando a RPAT por cada uno:
  LIST >T:trd{$$}{RD} "{PATH}" DIRS LFORMAT="RPAT *"{COM}*" *"%p%n*"
    *"{OPT}*" RD=.{RD}"  ; << @{B}ESTE TROZO PERTENECE A LA LÍNEA ANTERIOR@{UB}
  ; el argumento RD añade puntos a los nombres de los ficheros script
  ; temporales para distinguir cada nivel
  ;
  IF EXISTS T:trd{$$}{RD}
    ; existen subdirectorios, así que ejecutamos el nuevo fichero script y
    ; luego lo borramos
    EXECUTE T:trd{$$}{RD}
    DELETE T:trd{$$}{RD}
  ENDIF

Asegúrese de que el script RPAT tiene su bit de protección "s" activado y
de que RPAT está en la senda de búsqueda cuando lo ejecute. Examine los
scripts S:SPAT y S:DPAT que vienen incluidos en su sistema para ver más
ejemplos usando técnicas similares.

@endnode

@NODE ApéndiceA "MENSAJES DE ERROR"

				   Apéndice A
				   ==========


				MENSAJES DE ERROR
				=================


Este apéndice lista los errores del AmigaDOS, indicando en cada caso las
posibles causas y consejos para solucionarlos. Estos mensajes de error los
muestra el sistema cuando un programa falla o si un comando no llega a
ejecutarse debido a un fallo del usuario. Los mensajes de error difieren
de los requesters, que son mensajes del sistema que le permiten introducir
correcciones específicas, cambios, o una determinada información para que
el programa, script o comando pueda continuar su trabajo. Un requester que
no quede satisfecho por la respuesta producirá asimismo un error.

-----------------------------------------------------------------------------
Error	Mensaje		Posible causa		Solución aconsejada
-----------------------------------------------------------------------------

103	No hay 		No hay suficiente	Cierre las ventanas y las
	suficiente	memoria en su Amiga	aplicaciones que no necesite
	memoria 	para hacer un    	y vuelva a ejecutar el
	disponible.    	determinado trabajo.	comando. Resetee el sistema
	        	Tal vez la memoria	si no es suficiente. Es
	          	esté fragmentada.	posible que necesite añadir
                                                más memoria RAM a su sistema.

115	Número		El comando necesita	Use el formato correcto del
	erróneo		un argumento numérico.	comando.

116	Falta argumento	El comando necesita	Use el formato correcto del
			un argumento y se le	comando.
			ha olvidado indicarlo.

117	Falta valor en	Ha nombrado una		Use el formato correcto del
	palabla clave	palabra clave y no ha	comando.
			indicado el argumento
			que ésta necesita.

118	Número de	Demasiados o muy	Use el formato correcto del
	argumentos	pocos argumentos.	comando.
	erróneo

119	Faltan comillas	Ha usado un número	Use las comillas al
			impar de comillas.	principio y al final de
	                                        la senda o cadena.

120	Línea de	Su línea de comando	Use el formato correcto del
	argumentos	es incorrecta o		comando.
	inválida o muy	contiene demasiados
	larga		argumentos.

121	Fichero no	Ha indicado mal el	Vuelva a teclear el nombre
	ejecutable	nombre de un comando,	del fichero, asegurándose de
			o bien el fichero o	que se trata de un fichero
			script que ha indicado	de programa. Para ejecutar
			no es ejecutable.	un script, su bit de
                                                protección "s" deberá estar
                                                activado, o de lo contrario
                                                tendrá que usar el comando
                                                @{"EXECUTE" link execute}.

202	Objeto en uso	El fichero o		Abandone la aplicación que
			directorio indicado	está usando el fichero o
			está siendo editado	directorio o elimine la
			por otra aplicación,	asignación.
			o bien está asignado.

203	Objeto ya	El nombre indicado	Use otro nombre o borre
	existe		está asignado a otro	el fichero o directorio
			fichero o directorio.	existente primero.

204	No encuentro	El AmigaDOS no puede	Compruebe el nombre y el
	directorio	encontrar el		lugar del directorio (use
			directorio que le ha	@{"DIR" link dir} si es necesario).
			indicado.

205	No encuentro	El AmigaDOS no puede	Compruebe el nombre del
	objeto		encontrar el fichero	fichero (use @{"DIR" link dir}) o el nombre
			o dispositivo que le	del dispositivo (use @{"INFO" link info}).
			ha indicado.

206	Descripción	Ocurre cuando indica	Use la especificación de
	de ventana	un tipo determinado	ventana correcta.
	inválida	de ventana para Shell,
			@{"ED" link MiraED} o @{"ICONX" link IconX}. La ventana
			a lo mejor es demasiado
			grande o demasiado
			pequeña, o bien ha
			omitido un argumento
			fundamental. También
			ocurre con el comando
			@{"NEWSHELL" link newshell}, si ha
			indicado un nombre de
			dispositivo que no
			corresponde a una
			ventana.

209	Petición de	El manejador del	Compruebe que se ha enviado
	paquete de tipo	dispositivo no puede	el código de solicitud
	desconocido	hacer la operación que	correcto al manejador de
			le ha ordenado hacer.	dispositivo.
			Por ejemplo, el
			manejador de consola
			no puede cambiar el
			nombre de una cosa.

210	Nombre de	Hay un carácter		Vuelva a teclear el nombre;
	objeto inválido	dentro del nombre del	no use caracteres no
			fichero que no es	válidos ni rebase la
			válido, o bien el	longitud máxima permitida.
			nombre del fichero
			es demasiado largo.

212	El objeto no	Tal vez ha indicado	Use el nombre y formato de
	es del tipo	un nombre de fichero	comando correctos.
	requerido	en una operación que
			necesita el nombre de
			un directorio, o
			viceversa.

213	Disco sin	Si acaba de introducir  Espere a que termine el
	validar		un disco, tal vez el	proceso de validación.
			el proceso de		Fíjese si la luz de la
			validación del mismo	unidad se ha apagado. Tendrá
			no haya terminado aún.	que esperar algunos segundos
			También es posible que	si se trata de discos
			el disco esté corrupto.	flexibles o varios minutos
                                                si es un disco duro. Los
						discos corruptos no pueden
						validarse. Si un disco está
                                                corrupto, intente pasar
                                                todos los ficheros que
                                                pueda a otro disco.

214	Disco		El pequeño cuadrado	Saque el disco, mueva el
	protegido	plástico está en la	cuadrado plástico e inserte
	contra		posición que hace que	de nuevo el disco, o bien
        escritura	el disco esté		cambie de disco o use el
			protegido contra	comando LOCK OFF sobre él.
			escritura, o bien el	Si se ha usado el comando
			disco ha sido		LOCK con una clave para
			bloqueado con el	bloquear el disco, deberá
                        comando @{"LOCK" link lock}.          usar esta clave para
						desbloquearlo.

215	Intento de	@{"RENAME" link rename} puede pasar	Use @{"COPY" link copy} para copiar el
	renombrar	un fichero de un	fichero al volumen destino
	entre unidades	directorio a otro,	y luego borre el fichero
			pero no de un volumen   original si quiere. Entonces
	                a otro.                 puede cambiar el nombre del
	                                        fichero destino si lo desea.

216	El directorio	Ha intentado borrar	Use la opción ALL de @{"DELETE" link delete}
	no está vacío	un directorio que	si quiere borrar el
			todavía contiene	directorio y todo su
			ficheros u otros	contenido.
                        subdirectorios.

217	Demasiados	La anidación de los	Reorganice los directorios
	niveles		directorios es		de forma que haya menos
			excesivamente		niveles o cambie poco a poco
                        profunda.               de directorio actual hasta
                                                alcanzar el nivel deseado.

218	Unidad (o	Si el dispositivo en	Inserte el disco flexible
	volumen) no	cuestión es un disco	correcto, monte el
	montado		flexible, éste no ha	dispositivo, compruebe que
			sido insertado en la	ha indicado bien el nombre
			unidad de disco. Si	del dispositivo, revise su
			es otro tipo de		fichero de montaje/MountList
			dispositivo, entonces	o asigne el nombre de
			es que no lo ha		dispositivo como sea
			montado, o ha indicado  necesario.
			mal el nombre.

219	Error en 	Ha ocurrido un error	Asegúrese de que sólo busca
	búsqueda	mientras se estaba	dentro del fichero. No puede
			trabajando en un	buscar por la parte exterior
			fichero.		de un fichero.

220	Comentario	Ha indicado un		Use un comentario más
	demasiado	comentario que supera	pequeño.
	largo		el número máximo de
			caracteres permitido
			(79).

221	Disco lleno	No hay espacio		Borre los ficheros y los
			suficiente en el disco	directorios que no necesite
			para hacer la tarea	o use un disco diferente.
			indicada.

222	Objeto		El bit de protección	Si está seguro de que
	protegido	"d" (borrable) del	quiere borrar el fichero o
	contra borrado	fichero o directorio	directorio, use @{"PROTECT" link protect}
			está desactivado.	para activar el bit "d" o bien
	                                        use la opción FORCE del
	                                        comando @{"DELETE" link delete}.

223	Fichero		El bit de protección	Si está seguro de que
	protegido	"w" (escribible o	quiere sobreescribir el
	contra		modificable) del	fichero, use @{"PROTECT" link protect} para
	escritura	fichero está		activar el bit "w".
			desactivado.

224	Fichero		El bit de protección	Use @{"PROTECT" link protect} para activar el
	protegido	"r" del fichero está	bit "r" del fichero.
	contra lectura	desactivado.

225	No es disco de	El disco insertado en	Asegúrese de usar el disco
	formato DOS	la unidad no es un	correcto. Si había usado
			disco AmigaDOS, no ha	este disco antes, entonces
			sido formateado o bien	use un programa especializado
			está corrupto.		para recuperar sus ficheros.
                                                Formatee el disco si no
                                                lo había hecho todavía.

226	No hay disco	No hay ningún disco	Inserte el disco que
	en la unidad	insertado en la unidad	corresponda en la unidad
			indicada.		indicada.

232	No hay más	La función de llamada	Deje de llamar a EXNEXT.
	entradas en el	EXNEXT del AmigaDOS no
	directorio	tiene más entradas en
			el directorio que
			está examinando.

233	Objeto con	Se ha intentado usar	No es posible recuperar
	enlace blando	un enlace blando (por	este error.
			software) con un
			dispositivo que no
			lo soporta.

235	Hunk de carga	El programa cargado	Cargue una nueva copia del
	incorrecto	está corrupto.		programa, o bien el original.

241	Colisión de	Otra aplicación está	Intente acceder a la base de
	bloqueos	accediendo a la base	datos de nuevo.
			de datos.

242	Error bloqueo	Otra aplicación tiene	Inténtelo de nuevo o salga de
	fuera de	bloqueado el acceso a	la otra aplicación primero.
	tiempo		la base de datos.

303	Buffer lleno	Ocurre si una cadena	Use una cadena patrón más
			de patrón es demasiado	corta.
			larga.

304	***Interrumpido	Ocurre si detiene un	No es recuperable.
			programa con Ctrl+C.

305	Fichero no	El bit "e" (ejecutable)	Lo mismo que el error 121.
	ejecutable	del fichero está
			desactivado.

@endnode

@NODE MoreDirs "DIRECTORIOS ADICIONALES DEL AMIGA"

				   Apéndice B
				   ==========


		        DIRECTORIOS ADICIONALES DEL AMIGA
			=================================


Además de los comandos del AmigaDOS, hay otros ficheros y directorios en su
disco Workbench. Este capítulo incluye lo siguiente:

                                     @{"DEVS:" link DirDevs}

                                      @{"S:" link DirS}

                                      @{"L:" link DirL}

                                    @{"FONTS:" link DirFonts}

                                     @{"LIBS:" link DirLibs}

                                     @{"REXX:" link DirRexx}

                                    @{"LOCALE:" link DirLocale}

                                    @{"ENVARC:" link DirEnvarc}

                                     @{"ENV:" link DirEnv}

                                    @{"CLIPS:" link DirClips}

                                      @{"T:" link DirT}

                                   @{"Classes:" link DirClasses}

                                      @{"C:" link DirC}

Los cajones contenidos en DEVS: se describen en la "Guía del Usuario del
Workbench".

No necesita comprender totalmente el contenido de los directorios listados
aquí. A menos que se diga lo contrario, puede ignorarlos completamente. Sin
embargo, debería saber para qué sirven y dónde se encuentran por si acaso
en alguna ocasión borra sin querer o cambia el nombre de un fichero o de un
directorio o necesita copiar algo al directorio apropiado.

La figura siguiente ilustra la estructura estándar de directorios de un
sistema Amiga basado en disco duro. Los directorios cuyos iconos (de cajón)
son visibles en el Workbench se muestran a la izquierda; los demás se
indican a la derecha. El contenido y la estructura estándar de estos
directorios puede cambiar a medida que Commodore añade, cambia o elimina
ciertos recursos.


 --------------------------------------------------------------  ----------
 |                       SYS:                                 |  |  RAM:  |
 --------------------------------------------------------------  ----------
 _________|                         _______|                     ______|
|                                  |                            |
---Prefs -----------Presets        ----C:       ---_bullet      -Clipboards
|               |                  |  (C:)     |                | (CLIPS:)
|               |                  |           |                |
---System        ---ENV-Archive    |-- S:      |bullet_outlines |--- T:
|                    (ENVARC:)     |(S:, REXX:)|                |   (T:)
|                        |         |           |                |
|--Utilities            Sys        |-- L:      |----Topaz        -- Env
|                                  |  (L:)     |                   (ENV:)
|                                  |           |                     |
|--Tools         -- DOSDrivers     |--Libs     |----Courier         Sys
|               |                  | (LIBS:)   |
|               |-- DataTypes      |           |-- (y más fuentes)
|--Devs --------|                  |--Fonts ---
| (DEVS:)       |-- Monitors       | (FONTS:)
|               |                  |
|               |-- Printers       |--Rexxc
|--Expansion    |                  |
|                -- Keymaps        |
|                  (KEYMAPS:)      |--Classes ---- DataTypes
|--WBStartup                       |  (LIBS:)  |
|                                  |           |-- Gadgets
|                -- DOSDrivers     |           |
|--Storage -----|                  |           |-- Images
|               |-- DataTypes      |
|               |                  |
 --Trashcan     |-- Monitors        --Locale ----- Help
                |                    (LOCALE:) |  (HELP:)
                |-- Printers                   |
                |                              |-- Catalogs
                 -- Keymaps                    |
                                               |-- Languages
                                               |
                                                -- Countries

NOTA: En la mayor parte de los sistemas basados en disco flexible, los
      directorios LOCALE:, FONTS: y Storage se encuentran en volúmenes
      (discos) separados.

La mayor parte de estos directorios se asignan al volumen SYS: o al disco
RAM. Estos directorios, así como SYS:, pueden ser asignados a volúmenes
diferentes si es necesario.

Por ejemplo, puede asignar FONTS: a un disco en particular, como Fuentes:.
La mayor parte de las aplicaciones buscan automáticamente las fuentes de
texto que necesitan en el directorio FONTS:, sin importar dónde se encuentra
este directorio. Cambiando la asignación de FONTS:. puede hacer que las
aplicaciones utilicen las fuentes del disco Fuentes:.

@endnode

@NODE DirDevs "DEVS:"

DEVS:
-----

Además de los cajones DOSDrivers, Keymaps, Printers, Monitors y DataTypes
descritos en la "Guía del Usuario del Workbench", el cajón DEVS: contiene
ficheros y subdirectorios que pertenecen a los dispositivos que pueden
usarse con el Amiga.

Fíjese en que puede aludir a los cajones DEVS:Keymaps y a DEVS:Printers
con los nombres que tienen asignados, KEYMAPS: y PRINTERS: respectivamente.

@endnode

@NODE FicherosPuntoDevice "Ficheros de tipo '.device'"

FICHEROS DE TIPO .DEVICE

Ésta es una lista de los ficheros de tipo .device que se encuentran en DEVS:
y sus funciones:

  clipboard.device		Controla el acceso a CLIPS:

  parallel.device		Controla el acceso al puerto paralelo.

  printer.device		Controla el acceso al dispositivo de
				impresión.

  serial.device			Controla el acceso al puerto serie.

  mfm.device			Controla el acceso a los discos MS-DOS
				mediante CrossDOS.

Para ver más información sobre los ficheros de tipo ".device", mire los
manuales "@{I}Amiga ROM Kernel Reference Manuals@{UI}" publicados por Addison-Wesley.
@endnode

@NODE MásFicherosDevs "Otros ficheros"

OTROS FICHEROS

También hay los siguientes ficheros en DEVS:

  system-configuration		Guarda cierta información sobre la
                                configuración de las preferencias que
				se necesita durante el arranque.

  postscript_init.ps		Guarda información necesaria para
				inicializar una impresora PostScript
				cuando se usa el editor @{"PrinterPS" link EditorPrinterPS}.

@endnode

@NODE UsoDeMountList "Uso de ficheros de montaje o MountList"

USO DE FICHEROS DE MONTAJE O DE FICHEROS "MOUNTLIST"

Para acceder a nuevos dispositivos, el Amiga debe ser informado cuando los
añade al sistema. Pueden ser dispositivos físicos, como un dispositivo de
cinta, o dispositivos de software (lógicos), como un disco RAM recuperable.
Hay varias formas de hacer esto:

  - Colocando un driver en el cajón Expansion.

  - Colocando un fichero de montaje en el cajón DOSDrivers.

  - Haciendo una entrada para el dispositivo en un fichero "MountList" y
    usando el comando @{"MOUNT" link mount}.

Un fichero de montaje representa a un dispositivo, a un manejador o a un
sistema de ficheros. Los dispositivos estándar tienen sus propios ficheros
de montaje con sus iconos en el cajón DOSDrivers de DEVS:. Estos
dispositivos se montan automáticamente durante la ejecución del fichero
Startup-sequence estándar. Alternativamente, los dispositivos pueden usar
el comando @{"MOUNT" link mount} para leer una entrada de MountList que determine las
características de esos dispositivos.

La necesidad de usar un fichero MountList y el comando @{"MOUNT" link mount} se ha
eliminado gracias al método de los ficheros de montaje utilizados por la
versión 2.1 y posterior del sistema operativo. En lugar de necesitar un
fichero MountList que incluya las entradas para cada dispositivo que se
vaya a montar, ahora DEVS: contiene el cajón DOSDrivers, que guarda un
fichero de montaje o driver DOS por separado para cada dispositivo. El
contenido de un fichero de montaje es esencialmente el mismo que el de
una entrada individual en un fichero MountList.

Puede, no obstante, seguir usando el fichero MountList para montar
dispositivos. En este caso copie el MountList a DEVS: y elimine los drivers
del DOS que haya en los cajones DOSDrivers que tengan el mismo nombre que
sus entradas en MountList, ya que los ficheros de montaje tienen prioridad
sobre las entradas de un fichero MountList en caso de que haya una
coincidencia de nombres.

@endnode

@NODE MásMountList "Creación de un fichero de montaje o entrada para MountList"

CREACIÓN DE UN FICHERO DE MONTAJE O ENTRADA PARA MOUNTLIST

La siguiente información sobre los ficheros de montaje también se aplica a
los ficheros MountList salvo que se diga lo contrario.

Los ficheros de montaje contienen palabras clave que describen el
dispositivo, el manejador o el sistema de ficheros, así como los valores
que acompañan a dichas palabras clave. Algunas de estas palabras clave se
aplican solamente a un sistema de ficheros o a un manejador. Si se omite
una palabra clave, se usará un valor por defecto. Asegúrese de que las
palabras clave que indique son las adecuadas para el dispositivo.

Éstas son las reglas que debe seguir al crear un fichero de montaje o
MountList:

  - El fichero debe ser un fichero de texto ASCII normal.

  - El nombre del fichero de montaje debe ser el mismo que el del
    dispositivo, mientras que el nombre de un fichero MountList debe ser
    ése precisamente: MountList.

  - Cada entrada de un fichero MountList debe comenzar con el nombre del
    dispositivo. Omita esto si se trata de un fichero de montaje.

  - Las palabras clave deben ir seguidas de un signo de igualdad (=).

  - Las palabras clave deben ir separadas por un signo de punto y coma o
    bien deben colocarse en líneas separadas.

  - Se permite incluir comentarios siguiendo el estilo C estándar (esto es,
    los comentarios deben comenzar por /* y terminar con */).

  - Cada entrada de MountList debe terminar en un símbolo #. Omita esto si
    está trabajando en un fichero de montaje.

Cuando esté creando un nuevo fichero de montaje o una entrada en MountList,
tenga a mano la documentación que acompaña al dispositivo o bien tome como
modelo una entrada para un dispositivo similar. Cambie o añada solamente las
palabras clave necesarias.

La siguiente tabla es un listado de las palabras clave y sus valores por
defecto soportados en los ficheros de montaje y MountLists, incluyendo la
función de cada una. Los valores por defecto se muestran entre corchetes
angulados (< >).

-----------------------------------------------------------------------------
Palabra clave			Función
----------