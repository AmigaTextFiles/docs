@node Programming
@chapter Programming
This chapter handles problems arising for programmers and
compiler-users only.

@menu
* Manuals:: What documentation do I need as an Amiga programmer?
* CATS:: What is CATS?
* Includes::  Where do I get the Amiga include files?
* Developer:: How do I become a developer?
* Compilers:: What compilers (assemblers) are there?
* Printer control:: Those never-working Esc sequences!
* AmigaBasic:: Is it possible, to use AmigaBasic on the A1200?
* Localizing:: How do I localize my program?
* WindowPtr:: How to obtain a pointer to a console's window
* Pragmas:: What are pragmas?
* Missing functions:: My Compiler/Linker is complaining about missing symbols.
* Which functions:: How can I find out which functions are available?
* The GNU C compiler:: The GNU C compiler: general information and installation
@end menu


@node Manuals
@section What documentation do I need as an Amiga programmer?
@cindex RKMs
@cindex Rom Kernel manuals
The best information available are the RKMs (ROM Kernel Manuals), 3rd
edition, by Commodore, published by Addison-Wesley:
@example
The Amiga ROM Kernel Manual:  Libraries, ISBN 0-201-56774-1
The Amiga ROM Kernel Manual:  Devices, ISBN 0-201-56775-X
The Amiga ROM Kernel Manual:  Includes and Autodocs, ISBN
                                                     0-201-56773-3
The Amiga Hardware Manual, ISBN 0-201-56776-8
The Amiga User Interface Style Guide, ISBN 0-201-57757-7
@end example
@noindent
Especially the RKM: Libraries is a must. The RKM: Includes and Autodocs isn't
that much worth: Better get the same stuff on disk instead to have it online.
@xref{Includes}.

AmigaDOS isn't included in these books. The Autodocs give much information,
but to go deeper you probably need
@example
The AmigaDOS Manual, 3rd Edition, ISBN 0-553-35403-5
@end example
published by Bantam Books.

A better choice for developers is
@example
The Amiga Guru Book
@end example
@noindent
by Ralph Babel. The book
starts with a survey on different aspects of programming the Amiga. (About 250
pages) Useful for beginners are the sections on the Amiga's data types
(not to be confused with the 3.x DataTypes used by MultiView, for example),
the Includes and the amiga.lib. But even experienced
programmers will find useful things here that are missing in the RKMs.
But the largest part are about 500 pages on AmigaDOS and, as I think, the
most important, because AmigaDOS is the worst officially documented part
of the OS. The book is rather concise and hence not as easy to read as the
RKMs, but I recommend it as an addition and instead of the AmigaDOS manual.
(Not, however, a replacement for the Libraries and Devices, which aren't
covered here.) Unfortunately the book has no ISBN and is available in
special stores only. But there are some mail order companies which offer it
for about 50$ and which accept credit cards:

@example
                            Almathera Systems Limited
                            Southerton House
NBG USA, Inc.               Boundary Business Court
482 Holly Avenue            92-94 Church Road
St. Paul, MN 55102          Mitcham, Surrey CR4 3TD
USA                         England
Voice: +1 (612) 290 9447    Voice: +44 181 687 0040
Fax:   +1 (612) 290 9449    Fax:   +44 181 687 0490
                            E-Mail: <almathera@@cix.compulink.co.uk>

                            Stefan Ossowskis Schatztruhe
Hirsch & Wolf OHG           Gesellschaft für Software mbH
Mittelstraße 33             Veronikastraße 33
D-56564 Neuwied             D-45131 Essen
Germany                     Germany
Voice: +49 (2631) 8399-0    Voice: +49 (201) 788778
Fax:   +49 (2631) 8399-31   Fax:   +49 (201) 798447
                            E-Mail: <stefano@@tchest.e.eunet.de>

Someware
27 rue Gabriel Péri
59186 Anor
France
Voice: +33 27596000
Fax:   +33 27595206
E-Mail: <didierj@@swad.someware.com>
@end example
@xref{FAQs}.



@node CATS
@section What is CATS?
@cindex CATS
@cindex Commodore, West Chester
@cindex Hirsch & Wolf
This is a department at Commodore West Chester which was formerly named
@code{Commodore Amiga Technical Support} and was later renamed
@code{Commodore Application and Technical Support}. These are people that
work independently of Engineering, but close together with them, and try
to help developers outside of Commodore to create nice Amiga applications,
software or hardware. To achieve this, CATS has gathered a lot of informations
and tools, on floppy, CD, or paper. Much of this material is also available
to the general public. @footnote{Which means: For Non-Developers.} But don't
mix this up with some sort of Hotline for everyone!

For Americans the address to get this material is
@example
    CATS
    Commodore Electronics Limited
    950 Rittenhouse Road
    Norristown, PA 19403
@end example
@noindent
for all Europeans it's a company in Germany:
@example
    Fa. Hirsch & Wolf
    Mittelstr. 33
    56564 Neuwied
    Tel. 02631/83990
@end example

Dr. Peter Kittel, peterk@@cbmger.de.so.commodore.com


@node Includes
@section Where do I get the Amiga includes?
@cindex Includes
@cindex AutoDocs
@cindex NDUK
@cindex NDU
@cindex NDK
The only legal way to get the includes and autodocs (and you @emph{should}
get them, they are @emph{very} useful!) is to become a developer
(@pxref{Developer}) or to buy the @code{NDU} (Native developers update kit,
also known as @code{NDUK} or @code{NDK}), which is offered by CATS. They cost
about 30$ plus shipping and this seems to me to be a fair price. @xref{CATS}.
The current version is 3.1.

If you need only the includes, you could get them as well with a compiler
(commercial compilers only) or by getting the Fresh Fish CD. @xref{Fish CD}.


@node Developer
@section How do I become a developer?
@cindex Developer
@cindex Commodore, Frankfurt
@cindex NDA
You need the @code{ADSP} (Amiga Developer Support Program) documents. To get
this write a letter to your local Commodore branch asking for these documents.
Everything else should be explained there. The german address (for the
US address @pxref{CATS}) is
@example
    Commodore
    Lyoner Strasse 38
    60528 Frankfurt
@end example
There are three different developer versions:
@table @strong
@item Registered
developers get access to the CBMNET (kind of a Commodore-internal Usenet),
which makes it possible to discuss problems with other developers,
Commodore engineers included. Registered developers pay about US$80 per year,
plus initial US$30 initially.
@item Certified
developers seem to me the most interesting claass: They have the possibility
copy the most beta versions of the system software (Kickstart and Workbench)
and the respective Includes and AutoDocs. (Not all beta versions and
especially no beta hardware.) You pay about US$250 per year plus US$50 initially
for this.
@item Commercial
developers finally have in most details the same as certified developers,
but may expect to get more beta versions and sooner, included beta hardware
(This has @strong{not} always been so in the past.), hencethey pay about
US$400 plus US$50 initially.
@end table
@noindent
The above describes the prices and the situation in Germany and might be
different elsewhere. Especially not all Commodore branches offer the
registered status. A hint is to build a group of users and become a developer
group, so the costs are reduced.

All developers have to sign non-disclosure agreements (@code{NDA}) which specify
that we may not discuss information outside of authorized areas even
to other developers until given explicit permission by Commodore.


@node Compilers
@section What compilers (assemblers) are there?
@cindex Compilers
There is a lot of programming languages on the Amiga, commercial as well as
freely distributable. I will enumerate only those that I know or which seem
it worth to me otherwise.

@table @strong
@item Assembler
@cindex Assemblers
All C-compilers have an Assembler included. Freely distributable are
A68K and PhxAss (directory @file{dev/asm} on Aminet or Fish disks 521 and
906)

Commercial Assemblers are MaxonASM, OMA3.0 and DevPack3.14.

@item Basic
@cindex Basic

The following commercial Basic-compiler/interpreter are available:
BlitzBasic2, Amos and MaxonBasic3.

@item C
@itemx C++
@cindex C
@cindex C++
Freely distributable C-compilers are @code{gcc} (which has its own directory
@file{dev/gcc} on Aminet) and the evaluation version of
@code{Dice} (for example per FTP from @code{ftp.uni-paderborn.de}, directory
@file{/news/comp.binaries.amiga/volume91/languages} or on Fish disk 491).
The advantage of gcc is that you find gcc versions all over the
world and on all computer systems. Another advantage is that C++ is included
into gcc! But it is slow and needs 4Mb of RAM or more.
@xref{The GNU C compiler}.
@xref{Mailing lists}.

Commercial C compilers are @code{Aztec-C}, @code{Dice}, @code{SAS/C}
amd @code{MaxonC++}.
@code{Aztec-C} doesn't seem to get further development any more.
It should be remarked that the commercial compilers have especially wonderful
debugging utilities (Source level debuggers!) that the others are missing.

SAS has announced to drop support of the Amiga-Compiler, too, due to
the Amiga's bad situation. However,
the compiler is still available and up-to-date and has a crosscompiler
included, which translates C++ to C and supports the source level
debugger too. Considering the price of just 99$ for students and
updates from recent versions or other compilers it is still
the most recommendable of the three. In europe the compiler is available
from
@example
    SAS Institute, Inc.           SAS Institute Gmbh
    Book Sales                    PO Box 10 53 40
    SAS Campus Drive              69043 Heidelberg
    Cary, NC 27513                Germany
    USA

    Phone: (919)677-8000          Phone: (49)6221-4160
    EMail: sasdsb@@vm.sas.com      EMail: eurdoc2@@vm.sas.com
@end example

Dice is the cheapest and fastest commercial compiler. The greatest
disadvantage of Dice (compared to the other commercial compilers) is
the so-called Source-Line-Debugger:
This means that you see the current line of source and can execute
the program step by step, like with the other debuggers. On the other
hand you can examine memory only, not the variables.
To get information about DICE, send email to
info@@oic.COM. An automatic system will return complete details,
including upgrade prices.

Comeau C++ is a crosscompiler like SAS/C++. That wouldn't be a problem, but
Comeau C++ doesn't have a C compiler included.
You need SAS/C, Aztec-C or Dice additionally. But it is AT&T cfront 3.0
compliant and supports exceptions. And like gcc it runs on many platforms.
Maxxon C++ is offered in Germany. I cannot say anything on it. Both
compilers are commercial. Comeau's address is:
@example
    Comeau computing
    91-34, 120th Street
    Richmond Hill, NY, 11418-3214
    USA

    EMail: Greg Comeau, comeau@@bix.com
@end example

Maxon C++ is both a C++ and a C compiler. There is a light version and a
developer version. The developer version matches the AT&T standard 3.0.
Maxon-light includes a compiler and a editor. Developer includes a
source level debugger, Amiga classes library and Hot Help with documentation
to the amiga libs.
It is a german product, and compiler and documentation are german.
The compiler has some little bugs, but you can work with it well, anyway.


@item Forth
@cindex Forth
JForth is said to be an excellent Amiga port of Forth. Among its advantages
are object oriented extensions, full Amiga interface and an application
generator. It is available from:
@example
    Delta Research
    P.O. Box 151051
    San Rafael, CA   94915-1051

    Phone: (415) 453-4320
    EMail: Phil Burk, phil@@ntg.com
           Mike Haas, haas@@starnine.com
@end example


@item Fortran
@cindex Fortran
(Sigh! Still people who need it :-<)
Freely distributable are BCF (Fish disk 470) and f2c, a Fortran to C
converter (Aminet, directory @file{/dev/lang}). A commercial compiler is
offered from ABSoft. All these are Fortran 77 compilers, I don't know
any Fortran 90 compiler on the Amiga.

@item Lisp
@cindex Lisp
Freely distributable Lisp interpreters are XLisp (Fish disk 181) and OakLisp
(Fish disks 519 and 520) and CLISP (@file{/pub/lisp/clisp/binaries/amiga}
at the server @file{ftp ma2s2.mathematik.uni-karlsruhe.de}). Lisp
compilers are Gambit
(Fish 764 and 765) and Scheme-to-C (Fish disks 556, 557 and 558).
@xref{Mailing lists}.
@item Prolog
@cindex Prolog
@file{/dev/lang/UNSWProlog.lha} and @file{dev/lang/sbp3_1e.lha} on Aminet
as well as @file{SBProlog} on Fish disk 141 and @file{SBProlog} on Fish disk
145 are freely distributable Prolog interpreters.

@item Modula-2
@cindex Modula-2
M2Amiga is offered in Europe, Benchmark Modula-2 in the U.S. Both are said
to be very good, have a powerful source-level-debugger, a large library.
Especially M2Amiga has great support by a german user-group (AMOK) which
for example offers own PD disks. @xref{Mailing lists}.

M2Amiga is offered by:
@example
    A+L AG
    Daderiz 61
    2540 Grenchen
    Schweiz

    Tel.: +41/65/52 03-11
    Fax:              -79
@end example

Benchmark Modula-2 is available from:
@example
    Armadillo Computing
    5225 Marymount Drive
    Austin, Texas 78723
    USA

    Phone/FAX: 512/926-0360.
    EMail: Jim Olinger, jolinger@@bix.com
@end example

@item Oberon
@itemx Oberon-2
@cindex Oberon
@cindex Oberon-A
Two compilers (both Oberon-2) are available: AmigaOberon (commercial)
is offered by the same company as M2Amiga. It is integrated
into a full developers environment and has a large library of modules.
Library linker and  source level debugger are available.

Oberon-A is a Freeware compiler. (Source: Aminet, @file{dev/obero}
directory) However, this is a beta release, especially the module
library is limited. @xref{Mailing lists}.

The AMOK user group supports AmiOberon as well as M2Amiga.

In addition to these two standalone compilers which are thought
mainly for creating AmigaOS applications, there is an Amiga port of
the Oberon Sytem V4, too. The Oberon System is implemented as an
AmigaOS-Task using a separate screen and includes an Oberon-2
compiler. You can use it to write software that will work on all
implementations of the Oberon System V4 (for example Macintosh,
Windows or Sparc) without any changes.

@item Pascal
@cindex Pascal
There is a PD-compiler called PCQ (Directory @file{dev/lang} on
Aminet or Fish disk 511). It doesn't support all of Pascal and major
features are missing. P2C, a pascal to C converter is on disk 341. (Aminet:
@file{/dev/misc/p2c120.lha})
Additionally there are two commercial compilers called
HiSoft Pascal and KickPascal. HiSoft Pascal and P2C claim to be compatible
to Turbo Pascal up to 5.0. HiSoft has a source level debugger included.
@end table


@node Printer control
@section Those never working Esc sequences!
@cindex Printer control
@cindex Esc sequences
Many printers come with a manual that explains which @key{Esc} sequence causes
which action on the printer. But there happen weird things when you try
to send these sequences to your printer, either it does nothing, or it
does something completely different. There is a reason, the Amiga
printer drivers. These drivers are made in a way that they only understand
a certain set of @code{ANSI Esc sequences}, not the special ones
defined (differently) by the various printer manufacturers. The purpose
is that every application on the Amiga just uses this one standard set
of control sequences and this way doesn't need to know which printer is
actually connected. The printer driver then translates these standard
sequences into the special sequences a certain printer understands.
A list of the available ANSI Esc sequences is found in the current
Workbench manuals (or older AmigaDOS manuals). Now if you want to issue
a control sequence to the printer that's not available as an ANSI
command, you have two possibilities to achieve this:
@enumerate
@item Bypass the printer driver (that would unsuccessfully try to interpret
the sequence) and send your output @strong{only} during this sequence to
@file{PAR:} (or @file{SER:}, respectively). For this you have to close and
open printer output channels very often which is rather tedious, and
you have to know where (@file{PAR:} or @file{SER:}) your printer is connected.
@item Use a special ANSI sequence, made exactly for this case:
@example
    @samp{Esc[<n>"<x>}
@end example
where @samp{<n>} is the decimally typed number of bytes in the string
@samp{<x>}, which actually contains your special printer sequence. This ANSI
sequence tells the printer driver to not interpret or translate
the next @samp{<n>} bytes.
@end enumerate
But both methods have one big disadvantage when used in an application
program: You lose the printer independency! If you stick to ANSI sequen-
ces, you can output to any printer on earth, as long as there is an
Amiga printer driver for it. If you start to use special control sequences,
your program will be tied to this single printer model and will not be
usefull for any other (or you would have to provide some dozen new
printer drivers for your application).

Dr. Peter Kittel, peterk@@cbmger.de.so.commodore.com


@node AmigaBasic
@section Is it possible to use AmigaBasic on the A1200?
@cindex AmigaBasic
AmigaBasic wurde (als einziges Amiga-Programm) von Microsoft
entwickelt und ist entsprechend fehlerhaft.

Man kann es auf dem A1200 trotzdem zum Laufen bringen, wenn man
folgendes beachtet:

@enumerate
@item run NoFastMem (or turn off FastMem).
@item Switch off sound output in the Sound prefs editor.
@item Better avoid SUBs and use GOSUBs instead, then the
compatibility with newer processors will be higher.
@item There is a patch you should run at the beginning of AmigaBasic:
@example
  ---------------------------------- CUT HERE -------------------------------
   `" AmigaBASIC patch to let AmigaBASIC work on A1200 and other newer machines.
   `" Start at the beginning of AmigaBASIC or invoke AmigaBASIC with this program

   OPEN "AMIGABasic" AS 1 LEN=1
   FIELD #1,1 AS d$
   i&=&HF3*256+&H87 : PRINT i&
   GET #1,i& : a$=HEX$(ASC(d$))
   PRINT a$
   IF a$="79" THEN
       LSET d$=CHR$(&H78)
       PUT #1,i&
   END IF
   CLOSE 1
  ---------------------------------- CUT HERE -------------------------------
@end example
@end enumerate

Andreas Mixich, humpty@@tomate.tng.oche.de


@node Localizing
@section How do I localize my program?
@cindex Localizing
@cindex locale.library
@cindex CatComp
@cindex KitCat
@cindex MakeCat
@cindex FlexCat
@cindex Catalog description
@cindex Catalog translation
@cindex Catalogs
Suggest, you want to write a @code{HelloLocalWorld.c}. Your final program
will look like this:

@example
    #include "HelloLocalWorld_Cat.h"
    #include <clib/exec_protos.h>

    struct Library *LocaleBase;

    void main(int argc, char *argv[])

    @{
        /* Open the locale.library. No kill, if not successfull.
           (Just use the builtin catalog strings instead.) Note, that
           we open locale.library here, even if our compiler supports
           AutoOpening.
        */
        LocaleBase = OpenLibrary("locale.library", 38);
        OpenHelloLocalWorldCatalogs(NULL, NULL);

        printf(GetString(MSG_Hello));

        CloseHelloLocalWorldCatalog();
        if (LocaleBase) CloseLibrary(LocaleBase);
    @}
@end example

The routine GetString checks, if the wished catalogs are available and
returns a pointer to either the builtin string or the catalog string. (In
my case the german string.)

You see, the main difference besides the minor opening and closing stuff
(OpenLibrary, OpenHelloLocalWorldCatalogs, ...) (which too can be
dropped, too, with FlexCat) is to replace strings with
a function call. Hence we need a file @file{HelloLocalWorld_Cat.c}, which
holds OpenHelloLocalWorld, GetString, CloseHelloLocalWorld and the builtin
strings (this could be an array, where
@example
        array[MSG_Hello] = "Hello, local world.\n";
@end example
@noindent
is defined) and an include file @file{HelloLocalWorld_Cat.h}, which defines
the message ID's like MSG_Hello. You don't need to know, how these files
work internally, especially you don't need to know @code{locale.library}!

There are some catalog generators (in what follows: CGs) available
(@file{CatComp}, for devlopers only, @code{KitCat}, german docs only,
@file{MakeCat}, which I don't know and @code{FlexCat}, which I  recommend,
because it is most flexible in the generated source and supports catalogs
on 2.0 and any language, even Amiga-E, Cluster, Pascal, ... and besides
that: I'm the author ;-) are tools, that create  HelloLocalWorld_Cat.h,
HelloLocalWorld_Cat.c and the real catalogs for you. (The above code might
differ slightly between the different CGs.) (See Aminet, directory
@file{dev/misc}.)

Of course they need to know how to use them. First create a so-called
@code{catalog-description} file. This could look like this:
@example
    ; Lines beginning with a semicolon are comment lines.
    # language english
    ; the language of the builtin strings
    # version 0
    ; the catalog version (0 = any)
    MSG_Hello (1/15/30)
    Hello, local world
@end example
@noindent
Any string is defined by a line like the last two lines above: MSG_Hello
is the message-ID, (1/15/30) says, that the value of MSG_Hello should be
1 (you may omit this, in which case just the next free number is used)
and the string must not be shorter than 15 characters or longer than 30
characters. (These may be omitted too.)

Now write your program. Once you are ready, use the CGs to create a
so-called catalog translation file. (One for any language different than
the builtin.) In my case (german) this could look
like this:
@example
    ; Lines beginning with a semicolon are comment lines.
    ## language deutsch
    ; the catalog language (german)
    ## version $VER: Deutsch.catalog 1.0 (22.12.93)
    ; the catalog files version string
    MSG_Hello

    ; Hello, local world
@end example
@noindent
Note the empty line after the message ID. (The arguments of ## language and
## version would be missing as well.) You have to fill in the german strings
here. Again using the CGs you create a catalog file from this. Additionally
note, that no informations on the strings ID or length are behind MSG_Hello.
They are taken from the catalog description file.

Once you change the program (adding strings, changing the string length)
you change the catalog description as well, use the CGs in the same way to
update the catalog translation and hence the catalogs.


@node WindowPtr
@section How to obtain a pointer to a console's window
@cindex Console window
The following function returns the window pointer of a CON
window. It can be executed safely under all versions of the
Amiga's OS.

@example
  struct Window *getConWindowPtr(BPTR fh)
  @{
    struct Window *w;
    struct FileHandle *cfh;
    struct StandardPacket *sp;
    struct InfoData *id;
    struct MsgPort *mp;

    w = NULL;

    if ((cfh = BADDR(fh))->fh_Type != NULL) @{
      if (sp = AllocMem(sizeof (struct StandardPacket),
                        MEMF_PUBLIC | MEMF_CLEAR)) @{
        if (id = AllocMem(sizeof (struct InfoData),
                          MEMF_PUBLIC | MEMF_CLEAR)) @{
          if (mp = CreatePort(NULL, 0)) @{
            sp->sp_Msg.mn_Node.ln_Name = (char *) &sp->sp_Pkt;
            sp->sp_Pkt.dp_Link         = &sp->sp_Msg;
            sp->sp_Pkt.dp_Port         = mp;
            sp->sp_Pkt.dp_Type         = ACTION_DISK_INFO;
            sp->sp_Pkt.dp_Arg1         = MKBADDR(id);

            PutMsg(cfh->fh_Type, &sp->sp_Msg);
            (void) WaitPort(mp);
            (void) GetMsg(mp);

            if (sp->sp_Pkt.dp_Res1)
              w = (struct Window *) id->id_VolumeNode;

            DeletePort(mp);
          @}
          FreeMem(id, sizeof (struct InfoData));
        @}
        FreeMem(sp, sizeof (struct StandardPacket));
      @}
    @}

    return w;
  @}
@end example

Notes:
@itemize
@item Accessing a console's window directly may interfere with operations
performed by the CON handler. Be careful!
@item To obtain the window pointer of a CLI's console, pass the FileHandle
returned by Open("*", MODE_OLDFILE) to the above function.
@item The result of the above function may well be NULL, e.g. in case of
an AUX handler or if an AUTO CON handler is unable to open its window.
@item Sending an ACTION_DISK_INFO packet to an AUTO CON handler (2.0+)
causes its window to lose its special AUTO properties (i.e. it can no
longer be closed at any time by clicking on its Close gadget), as the
window pointer returned in id_VolumeNode must remain valid from now on.
@item All in all: Don't use this function. :-)
@end itemize

For more information, please refer to pages 273, 276, 435,
463, 485, and 629 in "The Amiga Guru Book" (@pxref{Manuals}).

Ralph Babel, rbabel@@babylon.pfm-mainz.de


@node Pragmas
@section What are pragmas?
@cindex pragmas
@cindex FD-files
@cindex fd2pragma
Pragmas are special compiler commmands which control certain
features of a C-compiler. Two problems arise when using pragmas:
@enumerate
@item Pragmas are compiler specific. You cannot expect that one compiler
will understand pragmas of another compiler, even if both run on the
Amiga.
@item You are not guaranteed that a compiler ignores pragmas, that he
doesn't understand. Even more: It might not help, to use something like
this:
@example
    #ifndef MY_COMPILER
    #pragma DoAnything
    #endif
@end example
@end enumerate
@noindent
A workaround is to put pragmas in a special include file
(BTW, the same holds true for statements like #asm (Aztec-C) or
#extern (C++) and replace the
above with
@example
    #ifndef MY_COMPILER
    #include <mypragmas.h>
    #endif
@end example

But what do pragmas on the Amiga? The most common usage (not the only,
but most meant when talking about pragmas)
is to tell the compiler about how to call library functions: Simple C
functions expect their arguments on the stack, but library functions
want their arguments in special processor registers and additionally
the @code{library base} in register a6. Lets have a look at a pragma command
of the Aztec-Compiler.
@example
    #pragma amicall(SysBase,0xd2,FreeMem(a1,d0))
@end example
@noindent
This tells the compiler to put the first argument of FreeMem in register
a1, the second in register d0 and the value of the variable SysBase
in register a6. Maxons pragmas look the same, Dice pragmas and SAS pragmas
look a bit more complicated;
@example
    #pragma libcall SysBase FreeMem d2 0902
@end example
@noindent
Here d2 is (like 0xd2 above) the @code{library vector offset} (see below), the
digits 09 are codes for the argument register in reversed order (Register
codes are 0=d0, 1=d1, .., 8=a0, 9=a1, a=a2, ..), the following 0 is the
result's registerä(always d0))and the final digit 2 is the number of
arguments.

A command @samp{FreeMem(fib,sizeof(*fib);} could
produce the following code, if the compiler has seen a pragma statement
like above:
@example
    move.l  _fib,a1
    move.l  260,d1	    ; sizeof(struct FileInfoBlock)
    move.l  _SysBase,a6
    jsr     -0xd2(a6)       ; 0xd2 = _LVOFreeMem
@end example
@noindent
Calling FreeMem in that way is shorter and faster than pushing the
arguments on the stack, calling a function _FreeMem which would do
just the same like the above code by pulling the arguments from the
stack.

The best way to use pragmas is to include statements like the following
in your program:
@example
    /*  SAS/C, Dice and GNU-c (since version 2.6.1) make it	*/
    /*  very simple:						*/
    #if defined(__SASC)  ||  defined(_DCC)  ||  defined(__GNUC__)
      #include <proto/exec.h>
    #else

      /*  Get the prototype for the function; note, that this	*/
      /*  is compiler independent.				*/
      #include <clib/exec_protos.h>

      /*  Get the pragma; compiler dependent, but most pragmas	*/
      /*  are in files with the same name.			*/
      #ifdef AZTEC_C
        #include <pragmas/exec_lib.h>
      #elif defined(__MAXON__)
        #include <pragmas/exec_pragmas.h>
      #endif

      /*  Declare the SysBase variable				*/
      extern struct ExecBase *SysBase;
    #endif
@end example
@noindent
The above example can be compiled on all these compilers and produce the
best code. (Besides, the proto/*.h-files do nothing else than reading
clib/*_protos.h and pragmas/*_pragmas.h with #include and then declare
the SysBase variable.)

A final question arises: How to get the pragmas? Most compilers have them
included. However, sometimes you want to produce pragmas for yourself,
for example if you are using new libraries or new versions with additional
functions. In that case you can produce them from the so-called @code{FD}
files which should be a part of the developer docs of the library. (The NDU
has a directory FD which contains FD files for all libraries and devices
of the OS. @pxref{Includes}) Most compilers have a utility with the name
@samp{fd2pragma} or similar included which can do that for you. A freely
distributable version which can produce pragmas for Aztec, Dice, SAS and
Maxon as well as LVO files for assembler and stub routines for the tag
versions is available on Aminet (@file{dev/misc/fd2pragma2_0.lha} and on the
Fish CDs.

For pragmas under gcc see @ref{Inline Headers}.


@node Missing functions
@section My Compiler/Linker is complaining about missing symbol xxx.
@cindex DoMethod
@cindex HookEntry
@cindex LibAllocPooled
@cindex DoSuperMethod
@cindex Missing functions
First be sure, that the function is really missing: For example floating
point functions are in a special link library and you need a linker option
like @samp{-lm} to include it into your program. Another
possibility would be that you are using a library function and didn't
notice it. This might lead to a missing library base, @samp{IntuitionBase}
for example. In that case
just put something like
@example
    struct Library *IntuitionBase;
@end example
@noindent
somewhere in the global part of your program. (Don't forget to call
OpenLibrary() and CloseLibrary! :-)

However, you could as well use a function which really isn't present
in your library at all. If you have, for example, an amiga.lib from
2.0 you would hardly find the locale functions or the pool memory
functions. @footnote{This problem arises most frequently for owners
of Aztec which is no longer supported and owners of Dice, which has
sometimes rather incomplete libraries. I own both ...}
Best solution is to get the NDU (@pxref{Includes}), but you
probably don't want to wait for it. In that case you have to find
what kind of function you are missing.
@itemize
@item Simple library functions (Examples: @samp{exec/AllocPooled},
@samp{locale/OpenCatalogA}) can be called with pragmas. However, you
need informations on the name of the library base and where to put the
arguments. @xref{Pragmas}.
@item Tag functions are mostly just stub functions which call library
functions. If you have, for example, @samp{dos/AllocDosObject} which
expects a constant and a pointer to an array of tags, you have the
varargs version @samp{AllocDosObjectTags} which expects tags on the
stack as well! Just create the following function:
@example
    #include <clib/dos_protos.h>
    #include <pragmas/dos_pragmas.h>	/*  Probably wrong name */

    void *AllocDosObjectTags(ULONG objtype, Tag tag1, ...)
    @{ return(AllocDosObject(objtype, (struct TagItem *) &tag1);
    @}
@end example
@item Some functions still remain: Amiga.lib has some functions which
are really doing valuable things and not just call a library: The
BOOPSI functions (@samp{DoMethod}, @samp{DoSuperMethod}) the memory
pool functions (@samp{LibAllocPooled}, @samp{LibCreatePool}, which are
replacements of 3.0 functions). The only way to replace these is to get
equivalents. The AmigaFAQ archive contains some of them (DoMethod,
DoSuperMethod and HookEntry) in the
@file{programmer} directory as well as the most common pragma files and some
examples of varargs functions. @xref{Amiga-FAQ Archive}.
@end itemize




@node Which functions
@section Where do I find the function xxx?
If you are not sure about the name of the appropriate function for a
certain job or in which library to find it, you can search in these places:
@itemize
@item In the Autodocs for each library you find at the very beginning a
contents table listing all functions available in this library.
They are sorted alphabetically, just like in the rest of the Autodocs.
In the body part of the Autodocs you find complete explanations and
specifications for each library function. @xref{Includes}.
@item The .FD files also offer a very compact overview over all functions
of the diverse libraries, complete with a short information about the
function arguments. If you already know roughly what you search for
and e.g. only need the precise order of the arguments, you can find
all needed information here. @xref{Pragmas}.
@end itemize

Dr. Peter Kittel, peterk@@cbmger.de.so.commodore.com


@include prog-gcc-e.texinfo


