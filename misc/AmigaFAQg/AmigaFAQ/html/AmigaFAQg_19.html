<!-- This HTML file has been created by texi2html 1.29af
     from ../AmigaFAQg.texinfo on 24 October 1995 -->

<TITLE>Amiga-FAQ - Chunky vs. Planar</TITLE>

<PRE><I>
&lt;&lt; <A HREF="AmigaFAQg_18.html">Grafik</A>
&gt;&gt; <A HREF="AmigaFAQg_20.html">Doublebuffering</A>
<HR>
</I></PRE>

<A NAME="IDX28"></A>
<A NAME="IDX29"></A>
<H2><A NAME="SEC19" HREF="AmigaFAQg_toc.html#SEC19">Was hei&szlig;t Chunky- und Planar-Display?</A></H2>
Einfach gesagt stehen die Bezeichnungen <CODE>chunky</CODE> und <CODE>planar</CODE>
(K&uuml;rzel f&uuml;r <CODE>bitplanar</CODE>) f&uuml;r verschiedene Arten, graphische Daten im
RAM des Computers zu speichern. Sie sind einfach zu verstehen, aber
vielleicht etwas schwierig zu erkl&auml;ren.
<P>
Die Anzeige eines Computers besteht aus einem Netz von Pixeln. Jedes Pixel
kann man sich als eine Zahl denken, die f&uuml;r die Farbnummer des Pixels steht.
Hier ist zum Beispiel eine ganz einfache Anzeige mit 4 Farben:
<P>
<PRE>
   00302132
</PRE>
<P>
Der Amiga speichert dies im <CODE>bitplanaren</CODE> Modus, d.h. es werden
verschiedene sogenannte Bitplanes verwendet, in denen zu jedem Pixel genau
ein Bit geh&ouml;rt. F&uuml;r eine Zahl zwischen 0 und 3 brauchen wir 2 Bits, also
auch zwei Bitplanes, die dann so aussehen:
<P>
<PRE>
   00100110    Dies ist Bitplane 0
   00101011    Dies ist Bitplane 1
   --------    Nun addieren wir sie, wobei wir die zweite mit 2
   00302132    multiplizieren
</PRE>
<P>
Das ist also die gew&uuml;nschte Grafik. Nun g&auml;be es aber nat&uuml;rlich auch eine
andere M&ouml;glichkeit: Wir k&ouml;nnten die jeweils 2 Bits direkt hintereinander
anordnen in sogenannten Chunks:
<P>
<PRE>
   00 00 11 00 01 10 11 01 = 00302132
</PRE>
<P>
Dies ist das Prinzip des Chunky-Modus. Man kann im allgemeinen kaum sagen,
da&szlig; eine dieser beiden Methoden besser oder schlechter ist. Allerdings haben
nat&uuml;rlich beide ihre Vor- und Nachteile:
<P>
Zun&auml;chst hat vielleicht jeder schon einmal gesehen, da&szlig; auf dem Amiga beim
Scrollen von farbigem Text ein gewisses Flackern entsteht. Genauer gesagt
&auml;ndern sich kurz die Farben. Was dabei passiert, ist, da&szlig; der Computer
Bitplanes verschiebt, gleichzeitig aber dieselben Daten f&uuml;r die Anzeige
verwendet werden. Wenn etwa gerade Bitplane 0 verschoben wurde, aber Bitplane
1 noch nicht verschoben ist, so h&auml;tten wir kurzfristig im obigen Beispiel
die folgende Anzeige:
<PRE>
   01001100    Dies ist Bitplane 0 (nach links verschoben)
   00101011    Dies ist Bitplane 1
   --------    Nun addieren wir sie wieder
   01203122
</PRE>
Sobald die zweite Bitplane ebenfalls verschoben ist, stimmt wieder alles,
aber kurzfristig entsteht dabei eben jenes Flackern. Bei einer Chunky-Anzeige
dagegen w&auml;re eben nur ein Teil des Bildschirms schon verschoben und ein
anderer Teil noch nicht.
<P>
Umgekehrt ist es im Chunky-Modus schlecht m&ouml;glich, mit beliebiger Anzahl
von Farben zu arbeiten: Da ein Byte 8 Bits hat, geh&ouml;ren etwa bei 4 Farben zu
jedem Byte 4 Pixel. Man mu&szlig; also stets erst berechnen an welcher Stelle
des Bytes die Informationen zu einem bestimmten Pixel sitzen. Das ist
aufwendig. Noch schlimmer wird die Sache bei 8 Farben: Da beginnen die Pixel
noch nicht mal an der gleichen Stelle. Das ist sehr umst&auml;ndlich und
rechenzeitaufwendig. In der Praxis gibt es daher Chunky-Anzeigen nur im
8-Bit-Modus (256 Farben) und im 24-Bit-Modus (16 Millionen Farben). Es ist
allerdings m&ouml;glich, da&szlig; die Anwender da gar nicht so ungl&uuml;cklich dar&uuml;ber
sind...
<P>

<PRE><I>
<HR>
&lt;&lt; <A HREF="AmigaFAQg_18.html">Grafik</A>
&gt;&gt; <A HREF="AmigaFAQg_20.html">Doublebuffering</A>
</I></PRE>
