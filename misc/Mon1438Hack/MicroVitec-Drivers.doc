o	Author: António Manuel Tavares de Oliveira Santos

any comments, money, postcards, sweets, candys, pictures, programs, sources, books
 should be directed to:

	António Manuel Santos
	Rua do Zaire, 5 1ºdto
	1170 Lisbon, Portugal
	
or
	L38058@ALFA.IST.UTL.PT


António Manuel Santos | Electronic Computers and Systems Engineer Course - 4th year - IST
Rua do Zaire, 5 1ºdto | Email: L38058@ALFA.IST.UTL.PT, http://alfa.ist.utl.pt/~l38058/
1170 Lisbon, Portugal | Home Phone: +01 8145439
-----------------------------------------------------------------------------------------
C:> dir
dir : memory not found at address 0xDEADF00D
-----------------------------------------------------------------------------------------


o	What you need:
	An Hex File Editor - AZap from aminet for example.
	MonEd from Aminet.
	Some patience :)
	
o   ONLY DO THESE STEPS IF YOU ARE A FAMILIRIZED AMIGA USER. PLEASE DONT SEND FLAMES TO ME
	IF YOU BLOW UP YOUR MONITOR. I SHALL *NOT* BE RESPONSABLE BY SUCH. INFACT, DONT READ THIS
	FILE AT ALL. ALL THESE INSTRUCTIONS COULD BE TOTALLY CRAP !!! IT COULD LEAVE YOUR
	HARDWARE/MONITOR TO NUTS !!!!!!!!!!!!!!!!!!!!!!!!!!!!! THANKS ...

o	All works fine to me. I use DBLPAL:High Res No Flicker 720 x 540 all the time.

o	Sorry for some spagheeti text, but maybe some one can organize this :)	


o	What will you gain with this text file :

	On MicroVitec 1438 Monitors, I will get these nice screen modes:
							
									Visible Size				Refresh Rates
	¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
	DBLPAL:High Res					720 x  270					49Hz, 27.58KHz
	DBLPAL:High Res Laced			720 x 1080					49Hz, 27.58KHz
	DBLPAL:High Res No Flicker		720 x  540					49Hz, 27.58KHz
	DBLPAL:Low Res					360 x  270					49Hz, 27.58KHz
	DBLPAL:Low Res Laced			360 x 1080					49Hz, 27.58KHz
	DBLPAL:Low Res No Flicker		360 x  540					49Hz, 27.58KHz
	MULTISCAN:640 x 240				640 x  300					48Hz, 30.00KHz *
	MULTISCAN:Productivity			640 x  600					48Hz, 30.00KHz *
	MULTISCAN:Productivity Laced	640 x 1200					48Hz, 30.00KHz *
	SUPER72:400 x 150				456 x  153					71Hz, 23.21KHz *
	SUPER72:800 x 150				912 x  153					71Hz, 23.21KHz *
	SUPER72:High Res				456 x  306					71Hz, 23.21KHz *
	SUPER72:High Res Laced			456 x  612					71Hz, 23.21KHz *
	SUPER72:Super-High Res			912 x  306					71Hz, 23.21KHz *
	SUPER72:Super-high Res Laced	912 x  612					71Hz, 23.21KHz *
	
	* - You can improve the number of vertical lines (TOTROWS) at the expense of
	refresh rate. You can get as high as 912x700 (or so) in SUPER72. But it will
	flicker a lot.
	
	
	These tooltypes were written by the MonEd package from aminet. What I just simple
	did was to edit the prefs file EnvArc:Sys/Overscan.prefs to reflect the maximum
	overscan possible that the AGA chips and monitor could cope.
	So, change the tooltypes acording:
	
		- Tooltypes for Sys:Devs/Monitors/Multiscan -
	
		TOTROWS=0x271
		TOTCLKS=0x77
		HBSTRT=0x02
		HBSTOP=0x2a
		VBSTRT=0x02
		VBSTOP=0xcaf
	
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
	
		- Tooltypes for Sys:Devs/Monitors/Super72 -
	
		TOTROWS=0x147
		TOTCLKS=0x99
		HBSTRT=0x02
		HBSTOP=0x21
		VBSTRT=0x00
		VBSTOP=0x71e
	
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
	
		- Tooltypes for Sys:Devs/Monitors/DblPAL -
	
		TOTROWS=0x233
		TOTCLKS=0x81
		HBSTRT=0x01
		HBSTOP=0x29
		VBSTRT=0x00
		VBSTOP=0x00
	
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
	Or edit them using MonEd. Don't forget to change the HBSTRT, HBSTOP, VBSTRT,
	VBSTOP to let the blackborder less visible (so that you gain more space to display
	image). And change the TOTCLKS as you like and lower the refresh rate by changing
	TOTROWS. My DblPAL is 49Hz vertically and 27.5870 KHz horizontaly. I note no flickering.
	If you think that your ScreenMode flickers, but a CRT Filter for your monitor. That will
	great enhance the Screen and protect your eyes. And the flicker will be a lot less.
	
	And now for the EnvArc:Sys/Overscan.prefs (uuencoded)
	
-----8<-------------------CUT HERE--------------------8<-----	
begin 677 EnvArc:Sys/Overscan.prefs
M1D]230```,)04D5&4%)(1`````8```````!/4T-.````)`````#^W+J)`!``
M&@"!`X$`"I`$`%$`%P+0`AP``````L\")4]30TX````D`````/[<NHD`%0`?
M`\@'D``#D"0`4P`9`H`"6``````"?P)73U-#3@```"0`````_MRZB0``````
M``````*0``!^`"`"@`$```````)_`/]/4T-.````)`````#^W+J)``P`&@"9
6`88`")`D`%$`%0.0`F0``````X\"8_]/
`
end
-----8<-------------------CUT HERE--------------------8<-----	

	How did I made this Overscan.prefs file :
	
	First you need the Includes from Commodore. You can get the includes from a 
	mounted MeatingPerls CDROM on internet by FTP. Just ask some one in the net
	cause I don't got the address here. I am writing this text at home on my
	cool Amiga :)
	
	But here is a part from the includes that you need to make the changes:
	
	- some structure definitions that helped -

include:graphics/gfx.h line 39 defines "tPoint" (struct)

struct tPoint
{
   WORD x;                              0000
   WORD y;                              0002
};


include:graphics/gfx.h line 41 defines "Point" (typedef)

typedef struct tPoint Point;


include:graphics/gfx.h line 27 defines "Rectangle" (struct)

struct Rectangle
{
   WORD MinX;                           0000
   WORD MinY;                           0002
   WORD MaxX;                           0004
   WORD MaxY;                           0006
};

#define ID_OSCN MAKE_ID('O','S','C','N')

#define OSCAN_MAGIC  0xFEDCBA89


struct OverscanPrefs
{
    ULONG	     os_Reserved;
    ULONG	     os_Magic;
    UWORD	     os_HStart;
    UWORD	     os_HStop;
    UWORD	     os_VStart;
    UWORD	     os_VStop;
    ULONG	     os_DisplayID;
    Point	     os_ViewPos;
    Point	     os_Text;
    struct Rectangle os_Standard;
};
	
	¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
	
	Ok, what I did was: using my program called ModeID I noted down the mode that I wanted
	change. Then I loaded Env:Sys/Overscan.prefs into a HexEditor (AZap is a good one ) and
	searched in the file the structure OverscanPrefs with a mode ID that I wanted to change.
	This is done by searching for the sequence 'OSCN' in ascii. This sequence belongs to
	the os_Reserved field in the referenced structure. Now, the mode id that I wanna change
	shall be in os_DisplayID. You need to note that: ULONG are 4 bytes, UWORD are 2 bytes etc,
	etc. Then I search for the corresponding values os_Text.x os_Text.y and set those to
	a greater value. For example the DblPAL mode is normaly 640x512, now its 720x540. I edit
	with AZap and set x to 2d0 and y to 21c (cause AZap works in hex mode). Then you must
	edit the os_Standard.MaxX os_Standard.MaxY to 2cf and 21b (i.e the values that you set
	before minus 1). Then I saved the edited block. The «IPrefs» Task gets notified that
	Env:Sys/Overscan.prefs has changed and it sets the new preferences. So, in order to
	set your Overscan, just experiment with these values on the desired screen mode.
	Now, after doing this, if you are happy with the new screen mode, just do a copy to the
	envarc: assign:

	$ copy Env:Sys/Overscan.prefs EnvArc:Sys/
	

	Hope this explanation help's anyone. It's a bit difficult to say how to do.
	
	The ModeID.c source is here :
	
-----8<-------------------CUT HERE--------------------8<-----	
/*
 * $Id: ModeID.c,v 1.2 1995/02/28 21:31:04 psys Exp psys $
 *
 * $Log: ModeID.c,v $
 * Revision 1.2  1995/02/28  21:31:04  psys
 * bug in main() corrected. Was using argv[2] as second argument!
 * In reality should be argv[1] !!! stupid error (arghhh!) :)
 *
 * Revision 1.1  1995/02/10  15:43:24  psys
 * Initial revision
 *
 * Compiled with SASC 6.55 without any problems.
 * Could not compile it with gcc 2.7.0 !!! :(
 *
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <errno.h>
#include <sys/types.h>
#include <string.h>
#include <time.h>
#ifdef __GNUC__
#include <sys/time.h>
#endif /* __GNUC__ */

#include <proto/exec.h>
#include <proto/graphics.h>

#include <graphics/gfx.h>
#include <graphics/monitor.h>
#include <graphics/displayinfo.h>

static UBYTE VersTag[] = "$VER: ModeID 1.2 (28.2.95)";
static char rcs_id[] = "$Id: ModeID.c,v 1.2 1995/02/28 21:31:04 psys Exp psys $";

extern struct GfxBase *GfxBase;

int FindAll(long mID,char *dummy,struct NameInfo *ni)
{
	/*printf("found mode : '%s'\t\t\twith id : '0x%lx'\n",ni->Name,mID);*/
	printf("ModeID : 0x%08lx ; ModeName : '%s'\n",mID,ni->Name);
	return 0;
}

int FindByName(long mID,char *name,struct NameInfo *ni)
{
	if (strcmp(name,ni->Name) == 0) {
		FindAll(mID,NULL,ni);
		return 1;
	}
	else {
		return 0;
	}
}

long ModeName2ID(char *mode,int (*checkfunc)(long,char *,struct NameInfo *))
{
	long	modeID;
	long	queryr;
	struct	NameInfo buff;
	long	buff_size = sizeof(buff);
	
	modeID = INVALID_ID;
	do {
		modeID = NextDisplayInfo(modeID);
		if (modeID != INVALID_ID) {
			queryr = GetDisplayInfoData(NULL,(char *)&buff,buff_size,DTAG_NAME,modeID);
			if (queryr == 0) {
				/*fprintf(stderr,"could not get display info data.\n");*/
			}
			else {
				if ( (*checkfunc)(modeID,mode,&buff) != 0) {
					break;
				}
			}
		}
	} while ( modeID != INVALID_ID );
	return modeID;
}

int main(int argc,char **argv)
{
	if ( GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",36L) ) {
		if (argc == 0 || argc == 1) {
			ModeName2ID(NULL,FindAll);
		}
		else if (argc == 2) {
			ModeName2ID(argv[1],FindByName);
		}
		else {
			fprintf(stderr,"usage: ModeID [ModeName].\nYou should enclose quotes in ModeName if needed.\n");
		}
		
		CloseLibrary((struct Library *)GfxBase);
	}
	exit(0);
}
-----8<-------------------CUT HERE--------------------8<-----	


António Manuel Santos | Electronic Computers and Systems Engineer Course - 4th year - IST
Rua do Zaire, 5 1ºdto | Email: L38058@ALFA.IST.UTL.PT, http://alfa.ist.utl.pt/~l38058/
1170 Lisbon, Portugal | Home Phone: +01 8145439
-----------------------------------------------------------------------------------------
C:> dir
dir : memory not found at address 0xDEADF00D
-----------------------------------------------------------------------------------------
