Abstract
---------

This archive contains documentation for the extended DOS Handler
interface that will become active with AmigaOS 3.1.4 and that
controls how to access devices >4GB, and how to support
variably sized removable media.

Its main purpose is to serve as a reference for authors of file
systems.


Introduction
-------------

Starting with AmigaOS 3.1.4., the Mount command includes three
additional keywords. This documentation explains these keywords,
how they are signalled to file systems, and how to support them.
Source code is included for the convenience of file system authors.

The first set of keywords enables access to media larger than 4GB, the
last one helps to support resizable external media such as ZIP disks,
and one additional flag prevents the file system from testing the
device for NSD style commands.

At the time of writing, four file systems already support this
extended protocol, namely the built-in FastFileSystem of the OS,
CrossDos, the CD File System (CDFS) and PFS.


Additional mount keywords
--------------------------

Starting from V45 on, the Mount command supports in mount lists the
following three additional keywords:

SCSIDIRECT
ENABLENSD
SUPERFLOPPY

All three keywords take a 1/0 argument, i.e. are boolean flags that
can be either enabled or disabled. By default, the first and the last
are disabled, whereas the middle is enabled.

This document describes their purpose, and how they are communicated
to device drivers.

The aim of the first two keywords, and the corresponding flags is to
enable seamless booting from large devices without requiring a boot
partition, and hence to overcome a limitation of OS 3.9.

The aim of the third is to enable support for removable external
devices that take media of variable size, such as ZIP drives that take
both 100MB and 250MB disks. Support of such devices caused quite some
hassle that included "dead drive icons" on the workbench.

The "SCSIDirect" flag can also be controlled from HDToolBox.


Communication to the file system
--------------------------------

The three flags above are encoded in the "environment vector"
that is documented in <dos/filehandler.h>, as "struct DosEnvec".

In particular, the flags can be found as part of

DosEnvec->de_Interleave

This flag used to control the factor by which the file system
interleaves consecutive blocks, as an attempt to speed up disk access
by ensuring that a subsequent sector of a file is located directly
under the drive head after the previous sector has been read. The
idea is to compute sector interleave such that the delay in sector
processing by the file access corresponds to the number of sectors
the drive head flies over while processing the data.

However, today's drives include caches, the sectoring of the disks
remain opaque behind the device interface, making this a questionable
improvement. In fact, support for interleave factors different from
zero has been dropped from the FastFileSystem since Kickstart V37 (OS
2.0) and this field became deserted and meaningless.

A review of the operating system internal file systems (namely, FFS,
CDFS and CrossDos) showed, indeed, its availability for extensions.

The 3 flags documented above are encoded as follows:

/*
** Starting with release 3.1.4, the upper 16 bits of the
** DE_INTERLEAVE entry contain the following additional flags:
*/
#define ENVF_SCSIDIRECT  (1L << 16)   /* Use HD_SCSICMD instead of TD_READ/TD_READ64 */
#define ENVF_SUPERFLOPPY (1L << 17)   /* Request device geometry by TD_GETGEOMETRY or
                                         HD_SCSICMD, DE_LOWCYL must be 0 */
#define ENVF_DISABLENSD  (1L << 18)   /* Do not query for NSD */

which is also found in the (updated) version of <dos/filehandler.h>.

Note that the "Mount" command inverts the logic of the NSD probing
flag, i.e. EnableNSD=0 in the mount list sets bit 18 of de_Interleave.
The purpose of this inversion is to have NSD probing on unless
explicitly disabled by the user.

More information on their use is given in subsequent sections.



Large device support
---------------------

Communication between a file system such as FFS and the hardware
device driver such as the scsi.device goes through a structure named
"IOStdReq", documented in <exec/io.h>. Unfortunately, this structure
uses a byte-offset to address a position on the disk, and hence is
limited to 4GB. Two competing solutions exist to overcome this
limitatation. First, the TD64 command set, defined by a loose
consortium around Ralph Babel, Ralph Schmidt, Dan Babcock, Randell
Jesup, Bernhard Möllemannand, Bill Coldwell and Oliver Kastl, and
second the NSD64 command set introduced by Heinz Wrobel. Last but not
least, devices communicating over the SCSI bus, or device drivers
implementing an emulation of the SCSI command set such as the
scsi.device in the ROM of the system can also use SCSI commands
directly instead of their AmigaOS abstractions to address data on a
medium.

While NSDPatch added NSD64 command set support for many hardware
device drivers once installed, NSD64 compliant access to such hardware
was only possible once NSDPatch was loaded, and hence booting from
such devices was not possible.

Starting with OS3.1.4, it is recommended for all file systems to
support all three access mechanisms, namely NSD64, TD64 and SCSI
access. Which command set to use, and how to select the command
set is controlled by the ENVF_SCSIDIRECT and ENVF_DISABLENSD
keywords in DosEnvec.

The following algorithm is suggested for a file system to select
the command set to use:

If DirectSCSI is enabled, use SCSI commands directly and do not
ask any further questions about the command set:

if (DirectSCSI == TRUE) {
   UseSCSI = TRUE;
}

It is then suggested to test whether the last sector of the medium is
within the 4GB limit, and if so, disable both TD64 and NSD, and switch
to the classical set.  SCSI, however, should remain enabled in this
case. Here, we assume that the sector size in bytes is a power of two,
and that this power is contained in sect_shift. For example, for 512
byte sectors (typical), sect_shift would be 9, because 2^9 = 512:

if ((lastsector >> (32 - sect_shift)) == 0) {
   UseTD64 = FALSE;
   UseNSD  = FALSE;
} else {
  Otherwise, at least one extended command set need to be used:
  if (DirectSCSI == FALSE && DisableNSD == FALSE) {
    Issue an NSCMD_DEVICEQUERY (see <devices/newstyle.h>),
    then test whether the device is of proper type:
    if(query.nsdqr_DeviceType == NSDEVTYPE_TRACKDISK) {
       Then test whether device supports NSCMD_TD_READ64:
       UWORD *cmds = query.nsdqr_SupportedCommands;
       while(*cmds) {
           if (*cmds == NSCMD_TD_READ64) {
	      If NSCMD_TD_READ64 is present, select
	      the NSD64 command set.
	      UseNSD = TRUE;
	   }
	   cmds++;
       }
    }
  }
  If neither DirectSCSI is select, and we neither have a positive
  identification for the NSD64 command set, switch to TD64:
  if (DirectSCSI == FALSE && UseNSD == FALSE) {
     UseTD64 = TRUE;
  }
}


The purpose of this switch is the following:
- DirectSCSI gets highest preference. If it is enabled by the user,
  just use it.
- If 4GB access is not needed, just leave the new command sets
  alone and go for the trackdisk commands, unless the user requested
  SCSI transport.
- If NSD is not disabled, query for it, and use it if it is found.
- Use TD64 as fallback if there is no positive detection for NSD and
  SCSI support is not requested.
- Querying for NSD can be disabled because issuing an unknown command
  such as NSCMD_DEVICEQUERY may also provoke a crash on legacy devices,
  it is therefore not necessarily 100% waterproof. This is (one of the)
  design mistake(s) of NSD.

Reading, writing and formatting disk sectors/tracks works then along
the command set selected, in the following way:

If SCSI is selected, use HD_SCSICMD with SCSI_READ(6), SCSI_READ(10)
or SCSI_READ(12) directly, and do not use anything else (note that
this is incomplete pseudo-code!). Depending on the connected hardware,
only a subset of all three commands may be available, even though
SCSI_READ(10) seems to be the most popular command set as it became
mandatory with SCSI-2.

Note further that you need to select the LUN from the
tenth digit of the device unit number when creating a SCSI command:

if (UseSCSI) {
  io->io_Command         = HD_SCSICMD;
  io->io_Data            = scsi;
  scsi->scsi_Command     = (UBYTE *)cmd;
  cmd->scsi10_cmd        = SCSI_READ;
  cmd->scsi10_Lun        = (DeviceUnit / 10) % 10;
  cmd->scsi10_Block      = sector;
  cmd->scsi10_BlockCntHi = sectcount >> 8;
  cmd->scsi10_BlockCntLo = sectcount;
} else {
  Otherwise, compute from the sector number the byte offset on the
  medium and select the access according to the selection made
  above:
  
  offslo = sector << sect_shift;
  offshi = sector >> (32 - sect_shift);

  In the above, the block size of the disk is assumed to be
  1 << sect_shift. Note that sect_shift may even change on
  a medium change, and - even though highly unlikely - your
  code should react properly (e.g. by an error) if it is not
  a power of two. Alternatively, the code has to depend on
  64 bit math. Note, however, that prior OS 3.1.4, the 64
  bit multiplication implementation of the utility.library
  is buggy on some processors, until fixed by SetPatch, and
  thus not reliable during bootstrap.
  
  io->io_Offset  = offslo;
  io->io_Actual  = offshi;
  
  if (UseNSD) {
    io->io_Command = NSCMD_TD_READ64;
  } else if (UseTD64) {
    io->io_Command = TD_READ64;
  } else {
    io->io_Command = CMD_READ;
  }
}

Some devices may hang if asked to read data in portions smaller than
the native block size. This may be obvious, but it may still be easily
overlooked. Note further that some device drivers do not respond
correctly to HD_SCSICMD. Software should be careful to check the
io_Error field, as well as scsi_Status fields when emulating a 64 bit
CMD_READ/CMD_WRITE command.

Users should be aware that the error codes returned by HD_SCSICMD
follow different conventions than those returned by the trackdisk
style commands. The error information is available in the extended
sense data in the form of the ASC/ASCQ pair. It is good practice to
make a best effort to map the SCSI errors to corresponding trackdisk
errors. The attached source demonstrates a particular mapping.

Writing to disk needs to be dispatched similarly.

A plausible replacement for TD_FORMAT at the SCSI layer is to map it,
similar to TD_WRITE, to the WRITE(6), WRITE(10) or WRITE(12) as the
low-level SCSI format command cannot wipe out individual sectors and
has other side conditions that are probably not intended.

The operating system Format tool does never attempt to low-level
format large partitions, and only re-writes the file system structure.

CMD_UPDATE and CMD_CLEAR are not required for DirectSCSI communication
as there is no Amiga-side buffer to keep the data.

It is suggested not to replace TD_MOTOR by its SCSI equivalent, even
if DirectSCSI is enabled. The reason for this is that TD_MOTOR may
also interact in some other way with the exec level device driver that
is unknown to the file system, such as turning off the LED on the
front-panel of the system.



Removable media support
-----------------------

Devices operating on removable media may face the situation that the
drive hardware supports media of variable size. A typical example is
the trackdisk.device, which supports both DD and HD disks, and the
carddisk.device, which also operates on PCMCIA cards of multiple
sizes.

The FastFileSystem, even prior 3.1.4, established a convention that
upon a medium change on the above devices for partitions that spawn
the entire disk the disk-geometry is queried from the device, and the
DosEnvec structure (see <dos/filehandler.h>) is updated
accordingly. The necessary modifications are detailed below. This
update mechanism ensures that other programs using the environment
vector for direct disk access (e.g. DiskDoctor) retrieve information
that is aligned to the configuration of the file system.

Starting with OS 3.1.4, this process is extended to those partitions
whose ENVF_SUPERFLOPPY flag is set in de_Interleave and whose de_LowCyl
value is 0, regardless of the device name. In particular, the
de_HighCyl, de_SizeBlock, de_Surfaces, de_BlocksPerTrack and
de_BufMemType values of the DosEnvec structure become irrelevant and
are instead retrieved from the device or medium itself. Details on how
to obtain geometry information are listed below.

If any of the values look sane and appear to be different from the
corresponding disk environment information (de_SizeBlock, de_HighCyl,
de_Surfaces and de_BlocksPerTrack, respectively), the file system
shall adopt them, update the disk environment vector and reinitialize
itself (allocating new buffers, re-read the root block, etc.). The
de_LowCyl value shall never change and shall remain 0.

Note in particular that this does not require spawning a new file
system process, nor creating a new DosList structure. The currently
running file system rather modifies its Environment vector itself, and
continues to operate from the updated values.

Sources of geometry information may be as follows:

*) If the file system structure allows it, use information on the
medium itself. For example, FAT file systems contain such information
in the boot block, and geometry information may be obtained from
there.

This is the mechanism used by CrossDos.

Since there is no equivalent information for the FastFileSystem, it
implements the following algorithm that should be adopted in the
absense of meta-information:

*) The disk layout ("geometry") information shall then be retrieved
from either TD_GETGEOMETRY or multiple SCSI commands. Selecting
between TD_GETGEOMETRY and SCSI access shall be based on the DirectSCSI
flag.

Note, however, that the information returned by TD_GETGEOMETRY is
specific to the exec device driver, and may not necessarily carry over
if the same (external) drive is connected to another system.

The following pseudo-code demonstrates the mechanism. The
DriveGeometry structure is documented in <devices/trackdisk.h>:

if (SuperFloppy && env->de_LowCyl == 0) {
   If there is something like a boot block for
   this device driver, try to get the information
   from there:
   if (HaveBootBlockOrSimilar) {
      ReadDataFromBootBlock();
   } else if (!UseSCSI) {
      struct DriveGeometry dg;
      io->io_Command = TD_GETGEOMETRY;
      io->io_Data    = &dg;
      Erase the DriveGeometry structure:
      memset(&dg,0,sizeof(dg));
      DoIO(io);
      if (dg.dg_SectorSize) {
         Update the environment vector from the
	 disk geometry.
      	 env->de_SizeBlock      = dg.dg_SectorSize >> 2;
      	 env->de_LowCyl         = 0;
	 env->de_HighCyl        = dg.dg_Cylinders - 1;
	 env->de_Surfaces       = dg.dg_Heads;
	 env->de_BlocksPerTrack = dg.dg_TrackSectors;
	 env->de_BufMemType     = dg.dg_BufMemType;
      }
   } else {
      Accessing the information from SCSI is more complicated.
      A suggested mechanism is demonstrated in the next section.
      GetSCSIGeometry();
   }
   At this point, the file system requires an internal
   restart, i.e. it needs to re-read its file system
   structures from the new disk.
   Restart();
}


Creating geometry information with SCSI commands
------------------------------------------------

If TD_GETGEOMETRY is not available, or its usage has been disabled by
the DirectSCSI flag in the mount list, the following algorithm tries
to generate comparable information from a set of SCSI commands.  Note
that this is again pseudo-code that leaves out a lot of house-keeping
work:

GetSCSIGeometry()
{

   First, issue a TEST_UNIT_READY to see whether there is any
   SCSI device to talk to:
   
   scsi6cmd->scsi6_Cmd             = SCSI_TEST_UNIT_READY;

   if (DoIO(diskreq))
      return 0;
   if (scsicmd->scsi_Status != SSTS_GOOD && scsicmd->scsi_Status != SSTS_INTERMEDIATE)
      return 0;

   Then inquiry the device to get the device class:

   scsi6cmd->scsi6_Cmd             = SCSI_INQUIRY;

   if (DoIO(diskreq))
      return 0;

   Sufficient information need to be available, and the status should be ok:
   
   if (scsicmd->scsi_Actual < 2)
      return 0;

   if (scsiinquiry->sci_Status >> 5)
      return 0;

   Then check the device class, and filter devices that cannot
   carry file systems. 
   switch(scsiinquiry->sci_Status & 0x1f) {
    case 0: direct access
    case 1: sequential
    case 4: write-once
    case 5: CD/DVD
    case 7: optical
      break;
    default:
      Everything else we do not need.
      return 0; 
   }

   Then try a mode sense on all pages. In fact, any page would be good
   as the SCSI page header - common to all pages - contains the relevant
   information, namely the total number of blocks a medium has, and the
   size of the blocks in bytes:

   scsi6cmd->scsi6_Cmd             = SCSI_MODE_SENSE;
   scsi6cmd->scsi6_Block           = 0x3f00; /* all pages */
    
   if (DoIO(diskreq) == 0) {
     if (scsicmd->scsi_Status == SSTS_GOOD || scsicmd->scsi_Status == SSTS_INTERMEDIATE) {
       if (scsicmd->scsi_Actual >= sizeof(struct SCSIPageHeader) + sizeof(struct SCSIBlockDescriptor)) {
	 struct SCSIPageHeader *scph = (struct SCSIPageHeader *)scsisense;
	 if (scph->spch_BlockDescriptorLength >= sizeof(struct SCSIBlockDescriptor)) {
	   if (scph->spch_ModeDataLength >= sizeof(struct SCSIPageHeader)) {
	     struct SCSIBlockDescriptor *scbd = (struct SCSIBlockDescriptor *)(scph + 1);

	     totalblocks = scbd->scbd_NumberOfBlocks & 0xffffff;
	     if (totalblocks == 0xffffff)
	        totalblocks = 0;
	      blocksize   = scbd->scbd_BlockLength    & 0xffffff;
	   }
	 }
       }
     }
   }

   This may fail, so use a second source for the same information, namely
   READ_CAPACITY:
   
   scsicmdphase->scsi10_Cmd        = SCSI_READ_CAPACITY;

   if (DoIO(diskreq) == 0) {
     if (scsicmd->scsi_Status == SSTS_GOOD || scsicmd->scsi_Status == SSTS_INTERMEDIATE) {
       if (scsicmd->scsi_Actual >= sizeof(struct SCSICapacity)) {
         if (scsicapacity->scc_BlockLength) {
	   blocksize = scsicapacity->scc_BlockLength;
	 } else {
	   blocksize = 512;
	 }
	 if (scsicapacity->scc_Block && scsicapacity->scc_Block != 0xffffffff) {
	   totalblocks = scsicapacity->scc_Block + 1; /* This is actually the last block */
	 }
       }
     }
   }

   If there is no information on the block count or block size, give up now.
   
   if (totalblocks == 0 || blocksize == 0)
     return 0;

   Then, try to obtain more information on the disk geometry through the rigid
   disk page:
   scsi6cmd->scsi6_Cmd             = SCSI_MODE_SENSE;
   scsi6cmd->scsi6_Block           = 0x0400; /* the rigid disk page */
   
   if (DoIO(diskreq) == 0) {
     if (scsicmd->scsi_Status == SSTS_GOOD || scsicmd->scsi_Status == SSTS_INTERMEDIATE) {
       if (scsicmd->scsi_Actual >= sizeof(struct SCSIPageHeader)) {
	 struct SCSIPageHeader *scph = (struct SCSIPageHeader *)scsisense;
	 if (scph->spch_ModeDataLength >= 4 + sizeof(struct SCSIPageHeader) + sizeof(struct SCSIPage)) {
	   if (scph->spch_BlockDescriptorLength >= sizeof(struct SCSIBlockDescriptor)) {
	     struct SCSIBlockDescriptor *scbd = (struct SCSIBlockDescriptor *)(scph + 1);
	     struct SCSIPage *scpg = (struct SCSIPage *)((UBYTE *)(scbd) + scph->spch_BlockDescriptorLength);
	     if (scsicmd->scsi_Actual >= 4 + scph->spch_BlockDescriptorLength +
	        sizeof(struct SCSIPage) + sizeof(struct SCSIPageHeader) &&
		  (scpg->scp_PageCode & 0x3f) == 0x04 && (scpg->scp_PageLength >= 4)) {
	       struct RigitDiskPage *rdp = (struct RigitDiskPage *)(scpg + 1);
	       cylinders = (rdp->rgp_NumberOfCylinders[0] << 16) |
	       	  (rdp->rgp_NumberOfCylinders[1] << 8) | rdp->rgp_NumberOfCylinders[2];
	       heads     = rdp->rgp_NumberOfHeads;
	     }
	   }
	 }
       }
     }
   }

   If this failed, or returned invalid results, we need to make up some
   information ourselves. The following is a heuristic that tries to
   generate some "nice looking numbers" for the heads and cylinders count:
   
   if (heads == 0 || cylinders == 0) {
     for(i = 16;i > 0;i--) {
       if (totalblocks % i == 0) {
	 heads = i;
	 break;
       }
     }
     tracksecs = totalblocks / i;
      
     for(i = 256;i > 0;i--) {
      if (tracksecs % i == 0) {
	 cylinders = i;
	 break;
       }
     }
   }

   Finally, derive the number of cylinders:
   tracks = cylinders * heads;
   if (tracks == 0)
     tracks = 1;

   Then insert the data into the environment vector:
   env->de_LowCyl         = 0;
   env->de_HighCyl        = cylinders - 1;
   env->de_BlocksPerTrack = totalblocks / tracks;
   env->de_Surfaces       = heads;
   env->de_SizeBlock      = blocksize >> 2;

   return 1;
}

Conclusion
----------

Unfortunately, the need to support three command sets (TD64,NSD,SCSI)
to address all devices puts quite some burden on the file system
design. However, at present this is the best option to allow booting
from arbitrary, even legacy devices.

At the time of writing, a couple of tools already support the
switching mechanism laid out here, including the three OS supported
file systems (FFS,CDFS,CrossDos) and the operating system tools around
it (Mount,HDToolBox,DiskCopy and Format).

While a single unique access mechanism such as NSD would have been
nice, the necessity to install a patch to realize it was unsuitable
and rendered partitions that needed it unavailable for
bootstrapping. It is the hope of the author that off-loading this
complexity to the file system will overcome these limitations.
