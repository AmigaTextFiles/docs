
   Программирование под AmigaOS для начинающих, версия 2.1 beta

   (C) 1999 RDC


  0) Ряд замечаний

     Прежде всего, предполагается, что с программированием как таковым
Вы в общем уже знакомы - например, работали ранее на БК, Спектруме,
PC.  Приветствуется знание Си, опыт программирования на каком-либо из
ассемблеров, знание архитектур компьютеров.  Этот текст не рассчитан
на тот случай, если Вы решили начать полностью с нуля.  В таком случае
рекомендуется начать с чего-либо более простого - например, с изучения
того же Си.
     Кроме того, очень рекомендуется иметь общее представление об
архитектуре и особенностях Амиги в целом.  Для этого почитайте книгу
Д.Михайлова «AMIGA #1».  Впрочем, книга эта будет полезна всем - она
является великолепным справочником по командному языку DOS и ARexx.

     Здесь не будет рассматриваться программирование с использованием
библиотек ввода-вывода ANSI C и обычного для Си стартап-кода.  Речь
пойдёт исключительно о программировании под AmigaOS.


  1) Средства разработки

     Программы под Амигу, как правило, пишутся на Си и/или Ассемблере.
Разумеется, языков программирования доступно в десятки раз больше, но
поддержка в основном идёт для C/Asm, и вся документация и примеры
обычно рассчитываются именно на них.
     В настоящее время существует множество различных ассемблеров.
Они существуют как в виде отдельных трансляторов (например, PhxAss),
так и в виде программных пакетов типа Devpac - в комплекте текстовый
редактор-оболочка, собственно транслятор, и отладчик.  Разные
трансляторы различаются скоростью трансляции и корректностью.
Например, GenAm (из комплекта Devpac) не слишком быстр, а PhxAss при
достаточной скорости «не понимает» некоторые полезные приёмы.  В
общем, выбор транслятора - дело вкуса.  Редактор годится любой - к
примеру, я использую обычный CygnusED вместо «родного» редактора
Devpac.
     Наиболее популярный компилятор Си - SAS/C, он же даёт наиболее
оптимальный код под 680x0.  Существует также Hisoft C, уступающий ему
в качестве кода, но имеющий исключительно приятную и удобную среду
разработки.  Кроме того, существует ряд компиляторов типа gcc, vbcc,
egcs - портированных из-под UNIX.

     Работа со всем перечисленным будет описана отдельно.


  2) Какую литературу желательно иметь

     Во-первых, нужна книга по программированию серии 680x0 на
ассемблере.  Существуют документации по 68000, 68020 и 68030 на
русском языке в электронном виде.  Книги на английском языке по любым
имеющимся в ассортименте процессорам бесплатно высылает по почте фирма
Motorola, на её Web-сайте доступны pdf-версии книг.

     Во-вторых, полезны любые книги по Си.  В этом качестве имеет
смысл обратить внимание на книгу Аллена Голуба «C&C++: правила
программирования».  В электронном виде она, к сожалению, пока
недоступна.  Книга содержит множество полезных рекомендаций по стилю и
приёмам программирования на Си.
     Кроме того, существует в электронном виде классическая книга
авторов Си - Кернигана и Ричи, и ряд других документов.

     В-третьих, нужны книги по программированию AmigaOS.  В этой связи
необходимы два издания: ROM Kernel Reference Manual и Guru Book.  Оба
существуют в электронном виде.  Есть также ряд других книг.
     Необходимо иметь автодоки - документацию по различным библиотекам
системы, где описана каждая их функция.

     Ну и в-четвёртых, весьма полезна будет вообще всякая литература
по программированию, не привязанная к конкретной платформе.  К
примеру, стоит отметить «Искусство программирования» Дональда Кнута,
издававшееся в 70х годах на русском языке, но и с тех пор не
потерявшее своей актуальности.


  3) С чего начать

     С моей точки зрения, лучше всего найти какую-либо «нишу», не занятую
другими программами, и начать работать в этом направлении.  Сложность
программы зависит от того, какой опыт у Вас уже есть.  Если ранее Вы
работали с другими платформами на достаточно серьёзном уровне, можете
спокойно браться за проект любой сложности, если считаете, что Вы его
«потянете».  Если Амига для Вас - первый полигон для программирования,
лучше начать с чего-нибудь попроще - какой-нибудь мелкой утилитки,
например.  Тупое чтение всей подряд литературы вряд ли что-нибудь даст,
лучший метод научиться чему-либо - попробовать это сделать самостоятельно.
     Не стоит браться за относительно сложные проекты, не имея
достаточного опыта.  Вполне возможно, что вроде бы всё и получится, но Вам
же самим потом будет обидно, когда Вы узнаете, что всё ранее сделанное
можно было сделать во много раз быстрее и компактнее.


  4) Как нужно писать программы, и как их писать не следует

     Этот вопрос для Амиги очень важен.  Если Вы ранее работали на
различных машинах - БК, Спектрум, Агат и т.п., стоит заметить, что методы
работы программы не были особо критичны.  Каждая программа работала сама
по себе и могла быть полновластным хозяином машины.  Операционные системы
были фактически пустым звуком.
     На Амиге ОС - важнейшая часть машины.  AmigaOS выступает посредником
между программой и «железом» (и пользователем).  Поскольку AmigaOS может
выполнять программы одновременно, никакая корректно написанная программа
не имеет права брать контроль над машиной - это может помешать работе
других программ.  «Железа» для программы как бы не существует, и все
операции программа обязана производить, вызывая операционную систему.
AmigaOS предоставляет великолепную возможность сделать практически всё с
помощью своих вызовов.  За счёт этого можно писать программы, совершенно
независимые от железа - ярким примером является компьютер DraCo, который
имеет с Амигой только общий процессор, но за счёт полностью совместимой
«операционки» выполняет любые КОРРЕКТНО НАПИСАННЫЕ программы для Амиги.
Следование правилам работы с системой также гарантирует работоспособность
программы на будущих версиях ОС и новых машинах.
     В некоторых случаях работа с железом позволяет резко увеличить
производительность работы программы - например, прямая запись в
видеопамять.  Однако, такой подход может работать не во всех случаях, а
также нет никаких гарантий, что это будет работать в будущем.  В таких
случаях имеет смысл сделать опцию в настройках программы, устанавливаемую
вручную - работа напрямую (custom routines) или через ОС.  В любом случае
несовместимости пользователь должен иметь возможность запустить программу
в «корректном» режиме.
     Ещё один важный момент.  Делайте программы универсальными.  Никогда
не стоит делать предположений типа «вряд ли у пользователя будет винчестер
более 4 гигабайт» (подумайте сами: такой подход лет пять назад был бы
вполне нормальным!) или «вряд ли пользователь запустит параллельно ещё
один музыкальный плеер».  При реализации какого-либо алгоритма обязательно
«прокрутите» в уме любые, даже самые изощрённые, нереальные и невероятные
ситуации.  Помните - даже незаряжённое ружьё раз в год стреляет ;)


  5) AmigaOS с самого начала

     AmigaOS отличает от большинства других операционных систем её
модульность и разделяемые ресурсы.  AmigaOS состоит из «кирпичиков»,
каждый из которых выполняет определённую задачу, и для решения конкретной
задачи используются только те модули, которые реально нужны.  Если один и
тот же модуль нужен для выполнения нескольких задач, в памяти он
существует в виде одной копии, с так называемым реентерабельным
(разделяемым) кодом.
     Пользовательская программа взаимодействует с этими модулями, и имеет
возможность задействовать те или иные функции системы, вызывая их.
Внутреннее устройство AmigaOS можно представить в виде дерева,
разветвлённая структура которого соответствует различным «внутренностям»
системы.  AmigaOS никак не привязана к конкретным физическим адресам в
памяти, и единственным исключением из этого правила служит ячейка с
абсолютным адресом 4, называемая SysBase.


  6) Библиотеки

     Разделяемые библиотеки (shared libraries) - один из «кирпичиков»
AmigaOS.  Библиотеки имеют набор точек входа, с точки зрения
ассемблера вызываемых командой jsr процессора.  С точки зрения Си -
это обычные внешние функции.  Эти точки входа и есть API (Application
Program Interface) AmigaOS.  Каждая библиотека имеет так называемую
базу - указатель на служебную структуру данных библиотеки (struct
Library). Служебные данные хранятся по положительным смещениям от
базы, а точки входа находятся по отрицательным смещениям.  Физически
по адресам точек входа размещены команды jmp, переходящие на реальные
адреса этих функций.
     Разделяемыми эти библиотеки называются потому, что всегда имеют в
памяти всего одну копию своего кода.  Если библиотеку используют
несколько программ, они вызывают один и тот же код.  Библиотека всегда
присутствует в памяти, если она нужна хотя бы одной программе.  Даже
если в данный момент она уже не нужна, она будет присутствовать в
памяти до тех пор, пока есть достаточно свободной памяти.  Как только
памяти не будет хватать, неиспользуемые библиотеки автоматически
выгружаются из памяти.
     Библиотеки бывают двух типов - находящиеся в ПЗУ и дисковые.  В ПЗУ
«зашиты» основные функции системы - работа с ресурсами машины, диском и
графикой, а так же некоторые служебные функции.  Все остальные библиотеки
при первой потребности в них загружаются с диска.
     Каждая библиотека имеет номер версии.  Механизм версий позволяет
постепенно наращивать возможности библиотек, сохраняя совместимость со
старыми версиями, и не допускать ситуаций доступа более новых программ
к функциям, отсутствующим у старых библиотек.

     Перед тем, как вызвать библиотеку первый раз, её необходимо
открыть.  Единственная библиотека, которая этого не требует - это
Exec, она открыта всегда и находится в ПЗУ.  Открывается библиотека
вызовом функции OpenLibrary(), аргументами которой служат указатель на
имя библиотеки и минимально необходимый номер версии.  Если библиотека
доступна, и её номер версии равен или больше требуемого - функция
вернёт указатель на базу библиотеки, иначе будет возвращён нуль.
     Exec всегда открыт, и указатель на его базу находится в ячейке
памяти с абсолютным адресом 4.
     После использования библиотеки её необходимо закрыть - это
делается вызовом CloseLibrary().  То же самое относится и к окнам, и к
экранам, и к файлам, и много к чему ещё.  Библиотека имеет счётчик
открытий, и гарантированно хранится в памяти только в том случае, если
этот счётчик больше нуля.


  7) Соглашения о вызове для Asm и C

     Для вызова функций библиотек принято передавать аргументы в
регистрах процессора.  Указатели обычно передаются в регистрах адреса,
значения обычно передаются в регистрах данных.  При этом обычно
используются регистры адреса начиная с A0 и данных начиная с D0.
Возможны и исключения из этого правила - так, например, в dos.library
практически всё передаётся в регистрах данных, начиная с D1.
     Что и куда конкретно кладётся - смотрите в автодоках.  Под каждым
аргументом там приписан регистр, в который нужно положить аргумент.
     Результат, если он есть, всегда возвращается в регистре D0 - даже
в том случае, если это указатель.  Если нужно вернуть значения
нескольких переменных, обычно передают функции ряд указателей на них.

     Базу библиотеки принято хранить в переменной с определённым
именем.  Для Си это будет имя типа DOSBase, IntuitionBase и т.п., а
для Asm это будет _DOSBase, _IntuitionBase - к имени любой переменной
на Си с точки зрения ассемблера прибавляется знак подчёркивания в
начале.  После открытия указатель на базу библиотеки кладётся в эту
переменную.
     Если вызов функций библиотек на Си ничем не отличается от вызова
любых прочих функций, то в случае ассемблера имеются следующие
соглашения:

     - при вызове любых функций, если не оговорено иное, в регистре A6
       должен лежать указатель на базу библиотеки.  Это сделано для
       того, чтобы код библиотеки мог иметь доступ к базе.

     - вызов функции записывается в виде jsr _LVOимя_функции(a6).
       Существуют также макросы типа CALLEXEC, CALLGFX, CALLINT etc,
       которые сами инициализируют A6 и добавляют _LVO к имени.

     В языке Си существуют функции с переменным числом аргументов.
Поскольку процессора с переменным числом регистров для этой цели никто
придумывать не будет, поступают проще - передают в регистре указатель
на массив переменных.  С точки зрения программиста на асме существует
лишь одна функция, получающая указатель на массив.  А с точки зрения
программиста на Си есть две функции - упомянутая ранее и так
называемый varargs stub.  Это «заглушка», представляющая собой
маленькую функцию, получающую массив аргументов классическим для Си
способом - на стеке, и передающая указатель на этот участок стека
вызываемой функции системы.

     В ряде случаев необходимо передать функции некое подмножество
аргументов из некоторого, достаточно большого множества.  Например,
когда мы открываем экран, можно не заботиться о глубине цвета и
видеорежиме, передавая аргументы Width, Height и Depth, а просто
скопировать режим экрана Workbench.  Для этого реализован механизм
ТЭГОВ (tags).  Tag представляет собой пару 32-битных чисел, первое из
которых является типом, а второе значением.  Taglist, то есть список
тэгов, представляет собой массив таких пар, заканчивающийся нулевым
типом (TAG_END).  Taglist обычно передаётся в виде набора чисел
функциям с переменным числом аргументов - фактически при этом будет
передан указатель на сформированный заранее (в случае ассемблера) или
сформированный «на лету» на стеке (в случае Си) массив.
     К примеру, если мы хотим открыть экран такого же разрешения и
видеорежима, как у Workbench, но глубиной в 4 цвета, пишем:

     OpenScreenTags(NULL, // структура не передаётся
       SA_LikeWorkbench, TRUE, // логическое значение
       SA_Depth, 2, // четыре цвета - два битплана
     TAG_END);

     На ассемблере то же самое представляется в следующем виде:
     ...
     sub.l  a0,a0
     lea    tags,a1
     move.l _IntuitionBase,a6
     jsr    _LVOOpenScreenTagList(a6)
     ...
tags dc.l   SA_LikeWorkbench, TRUE,
     dc.l   SA_Depth, 2,
     dc.l   TAG_END

     Текстовые строки в AmigaOS следуют соглашениям Си - являясь
последовательностью ненулевых байтов, заканчивающейся нулём.

     Несколько слов о результатах выполнения функций.  Как правило,
индикацией ошибки является нуль в результате выполнения.  Результат
нужно обязательно проверять «на вшивость», если выполнять программу
безотносительно результатов, то в некоторых случаях она может «упасть»
при попытке использования недоступных в данный момент или на данной
конфигурации ресурсов!


  8) Includes

     Includes - файлы типа #?.h (для Си) и #?.i (для ассемблера)
содержат все необходимые определения констант, структур и функций для
работы с AmigaOS.  Обычно принято хранить их на «include:».  Для
подключения любого из них используется директива include ассемблера
или #include препроцессора Си.

     Ассемблер:

     Для получения всех смещений функций библиотек предназначены файлы
ИмяБиблиотеки_lib.i - именно там определены все _LVO (Library Vector
Offsets).  Хранятся они в отдельных директориях для библиотек (типа
include:intuition/) или в специальной директории include:lvo/.

     Си:

     Здесь чуть сложнее, поскольку реализация зависит от компилятора.
Для SAS/C определения функций находятся в include:pragmas/ и
называются ИмяБиблиотеки_pragmas.h.  Для Hisoft C они лежат в
include:pragma/ и называются ИмяБиблиотеки_lib.h.  Кроме того, для
SAS/C требуются определения прототипов функций из include:clib/.
     Если Вам хочется, чтобы программа компилировалась как под SAS/C,
так и под Hisoft C, можно использовать условную компиляцию - как это
сделать, будет рассказано дальше.

     Остальные, кроме перечисленного, специфичного для языка, файлы
являются общими по смыслу, различаясь лишь именем #?.h и #?.i.


  9) Работа с памятью

     В отличие от БК, Спектрума, PC и других однозадачных машин на
Амиге не используются абсолютные адреса.  Программа может оказаться
при старте с любого адреса в пределах доступных процессору четырёх
гигабайт.  Единственный абсолютный адрес - ячейка 4.
     Когда для выполнения какой-либо задачи требуется память, её нужно
зарезервировать.  Это делается вызовами Exec.  Когда работа с участком
памяти закончена, его нужно освободить.  Память, в которой находится
сама программа при старте, уже зарезервирована системой и будет
автоматически освобождена при выходе из программы.
     Память на Амиге может быть разных типов.  При старте системы
происходит составление списка доступных участков памяти, каждый из
которых имеет свой приоритет.  При резервировании памяти происходит
просмотр всех участков в порядке уменьшения приоритета, и память
выделяется из того участка, в котором первым был найден требуемый
участок заданного размера.  Chip и Fast память представляют собой
пример таких участков.  Можно явно указать тип требуемой памяти.
     Для резервирования памяти у AmigaOS есть несколько средств.
Вызов Exec'а AllocVec() резервирует заданное количество байтов памяти
заданного типа.  Аргументы этой функции - требуемый объём памяти в
байтах (D0) и требуемый тип памяти (D1).  В результате возвращается
начальный адрес захваченной памяти, или же нуль в случае ошибки.
Обязательно проверяйте ошибку - попытка использовать память с нуля
приведёт к краху системы!  Для того, чтобы освободить захваченную
память, используйте FreeVec(), единственным аргументом которой
является указатель на участок памяти (A1).  Exec самостоятельно
запоминает объём захваченной памяти, и освобождает ровно столько же.
     Атрибуты определяют тип требуемой памяти и некоторые опции.  Они
подробно описаны в автодоках (exec.library/AllocMem() - устаревшая
функция захвата участка памяти, не запоминающая его размер).  Отметим
лишь две из них:  MEMF_CHIP должен быть ОБЯЗАТЕЛЬНО установлен, если к
захваченной памяти будет идти обращение чипсета (например, там будет
картинка, пересылаемая блиттером на экран), и MEMF_CLEAR означает, что
вся зарезервированная память будет обнулена (в противном случае там
будут случайные значения, оставшиеся от предыдущего «хозяина» этой
памяти).  Нуль (MEMF_ANY) означает отстутствие требований к памяти.

     Есть более простой способ работы с памятью.  Если программе всё
время её работы нужен участок памяти заданного размера, и динамически
захватывать и освобождать память не нужно, можно просто указать
следующее:

      section xxxx,bss
label ds.b ...

     Секция данных такого вида означает, что при старте программы эта
память будет автоматически зарезервирована системой, а при завершении
программы - автоматически освобождена.  В исполняемом файле она не
будет занимать места, резервирование мегабайта вовсе не означает, что
исполняемый файл увеличится на мегабайт.  Если указать тип секции как
bss_c, это аналогично AllocVec с атрибутом MEMF_CHIP.
     Размещать данные в секции типа bss нельзя, здесь применимы только
команды резервирования памяти ds.b, ds.w и ds.l.

     На Си для той же цели используются static-массивы.  В случае
SAS/C стоит указать ключевое слово __far, иначе в некоторых случаях
исполняемый код программы разбухнет от некоторого количества нулей.

     Для получения информации об объёме свободной памяти используется
функция AvailMem(). Её аргумент (D1) - атрибуты памяти. Таким образом
можно получить объём свободной chip-памяти (MEMF_CHIP), fast-памяти,
памяти вообще (MEMF_ANY), наибольшего непрерывного свободного куска
(MEMF_LARGEST).  Поскольку у нас многозадачная ОС, сведения об объёме
памяти к моменту их использования могут устареть :-)

     Для получения информации о типе памяти, указатель на которую
имеется, используется функция TypeOfMem().  Ей передаётся указатель
(A1), а результатом являются искомые атрибуты.  Если функция получила
указатель, не попадающий в пределы доступных областей памяти, она
вернёт нуль.


 10) Фрагментация памяти

     Фрагментация памяти неизбежно возникает, поскольку резервируемые
участки памяти могут быть только непрерывными.  Рано или поздно может
обнаружится такая ситуация, что вроде бы памяти и достаточно, а
непрерывный участок требуемого размера найти не удаётся.  С этим
явлением можно и нужно бороться следующими средствами:
     1. Если требуется определённый объём памяти для работы
программы, лучше вместо одного большого участка памяти захватить
несколько маленьких.
     2. По возможности избегайте динамической работы с памятью.  Если
объём требуемой памяти невелик, лучше работать с bss секциями.
Динамическая работа с памятью оправдана только в том случае, если
требуемые объёмы памяти достаточно велики, и большой объём памяти
может значительно увеличить производительность работы.  Если же
требуется 100-200 байт, то даже такой участок, оказавшись волей случая
посреди 16-мегабайтного пространства, может осложнить жизнь другим
программам...
     3. Начиная с версии 39 операционной системы (kickstart 3.0) есть
новый метод работы с памятью - Memory Pools.  Использование этого
метода позволит избежать сильной фрагментации памяти, если
использование динамической работы с памятью необходимо.  Фрагментации
практически не будет даже при использовании больших объёмов памяти из
множества маленьких блоков.  Суть метода в том, что система
автоматически по необходимости резервирует блоки памяти одинакового
заданного объёма, а требуемые блоки любого размера выделяются уже как
бы «внутри» этих блоков.  Когда память внутри одного из блоков
фиксированного объёма кончается, система автоматически захватывает
новый.  Соответственно, если внутри блока освобождается последний из
блоков произвольного размера, он автоматически освобождается.  Набор
блоков заданного размера образует Memory Pool.
     Для создания Memory Pool используется функция Exec CreatePool.
Её аргументы - атрибуты памяти, которая будет резервироваться у
системы (D0 - такие же, как и у AllocVec), размер фиксированного блока
памяти, из которых и будет составляться Pool (D1) и минимальный объём
памяти, при превышении которого захватываемые участки памяти будут
размещаться не в блоках заданного размера вместе с остальными
участками, а в своих собственных блоках (D2).  Этот объём должен быть
МЕНЬШЕ ИЛИ РАВЕН объёму блока фиксированного размера.
     CreatePool возвращает  указатель на заголовог Pool'а, либо
нуль в случае ошибки.  Для того, чтобы захватить участок памяти
произвольного размера, нужно воспользоваться функцией AllocPooled.
Ей передаётся заголовок Pool'а (A0) и объём требуемой памяти (D0).
Эта функция не запоминает объём затребованной памяти, как AllocVec,
поэтому его нужно запоминать самостоятельно (в autodocs приведён
исходный текст функции AllocVecPooled, работающей аналогично
AllocVec).
     Освободить занимаемую память можно тоже «по кусочкам» с помощью
FreePooled.  Она получает указатель на заголовок Pool'а (A0), адрес
освобождаемого участка (A1) и его длину в байтах (D0).  Так же как и в
случае FreeVec, можно воспользоваться собственной функцией
FreeVecPooled, исходник которой приведён в autodocs.
     Функция DeletePool уничтожает Memory Pool, адрес заголовка
которого ей передан (A0).  Зарезервированные в этом Pool'е участки
памяти освобождать не нужно - это будет сделано автоматически.


 11) Списки

     Списки используются в ОС повсеместно как механизм хранения набора
каких-либо объектов.  Например, в списки организуются участки
свободной памяти и библиотеки.  Элемент списка - структура данных Node
<exec/nodes.#?>, содержащая следующие поля:

     ln_Succ - указатель на следующий элемент списка
     ln_Pred - указатель на предыдущий элемент
     ln_Type - тип элемента
     ln_Pri - приоритет (для сортировки)
     ln_Name - указатель на имя элемента
 
     Если такие навороты не требуются, используется структура MinNode,
содержащая только первые два описанных поля.  Таким образом, это
двусвязные списки - т.е., по списку можно «двигаться» в обе стороны.
     Сам список описывается структурами List/MinList <exec/lists.#?>.

     Для работы со списками в Exec есть набор полезных функций:

     AddHead() - добавление элемента в начало списка
     RemHead() - удаление элемента из начала списка
     AddTail() - добавление в конец списка
     RemTail() - удаление из конца списка
     Remove()  - удаление заданного элемента из списка

     Enqueue() предназначена для добавления элемента в очередь, и
всегда сохраняет элементы списка в порядке приоритетов. FindName()
проводит поиск именованного элемента списка.
Разумеется, эти функции не будут работать с MinNode/MinList.

     Все перечисленные функции предполагают, что арбитраж доступа со
стороны разных задач к спискам ведётся задачей самостоятельно (см.
ниже о семафорах).



 12) Задачи

     Задачи (Tasks) являются основной программной единицей AmigaOS.
Любая запущенная в данный момент программа является задачей.  Кроме
того, задачи могут создавать новые задачи для реализации своих
собственных целей.
     У каждой задачи может быть три состояния - выполняемая (RUN),
готовая к выполнению (READY) и состояние ожидания (WAIT).  Очевидно,
процессор может в данный момент физически выполнять только один код,
поэтому в каждый конкретный момент только одна задача имеет статус
выполняемой.  У каждой задачи есть свой приоритет - байт со знаком.
Для определения порядка выполнения задач операционная система
сортирует их список по приоритетам, и задача с наивысшим приоритетом,
готовая к выполнению, выполняется первой.  Управление может быть
передано другой задаче в трёх случаях: если выполняющаяся задача
перешла в состояние ожидания, если задача с большим приоритетом
перешла в состояние готовности, и если при наличии готовой к
выполнению задачи с таким же приоритетом у рассматриваемой задачи
кончилось время.  Если готовых к выполнению задач с одинаковым
приоритетом несколько, процессор будет «обегать» их по очереди - так
реализуется разделение времени, позволяющее одновременно работать
нескольким задачам вычислительного характера.

     Каждая задача имеет структуту Task <exec/tasks.#?>, в
которой хранятся её свойства - приоритет, имя и прочее.  Указатель на
Task можно получить с помощью функции FindTask(), передав ей указатель
(A1) на имя задачи.  Если задаче нужен указатель на собственную
структуру, исполняется FindTask() с нулевым аргументом.  Знание адреса
структуры Task необходимо для межзадачных коммуникаций.

     Когда это необходимо, задача может создать любое количество
нужных ей подзадач.  Функция CreateNewProc() из dos.library создаёт
новую задачу, выполняя код Вашей же задачи.  Ей передаётся taglist,
содержащий тэг NP_Entry - указатель на выполняемую функцию.  Задача
начинает выполняться немедленно, а функция возвращает указатель на
структуру Task (если быть предельно точным, возвращается структура
Process, содержащая первым элементом структуру Task - но об этом
позже).  Задача завершается возвратом из функции (rts) и автоматически
уничтожается.
     Имейте в виду, что к моменту выхода из Вашей программы все
подзадачи должны быть завершены!  В противном случае последующая
работоспособность системы не гарантируется.


 13) Сигналы

     Как упоминалось ранее, задача может находиться в состоянии
ожидания.  В это состояние задачи входят для ожидания каких-либо
внешних (для этой задачи) событий, которые могут быть инициированы как
другими задачами, так и периферией комьютера.  Сигналы используются
для взаимодействия задач, это простейший тип их взаимодействия, на
котором построены все остальные.  В частности, сигналы используются
для того, чтобы вывести задачу из состояния ожидания.
     Любая задача может послать любой сигнал любой задаче.  Для этого
используется функция Exec'а Signal(), аргументами которой служат
указатель на структуру Task задачи-«приёмника», которой посылается
сигнал (A1) и маска сигналов (D0).  При этом не имеет значения, в
каком состоянии находится принимающая сигнал задача.  Если задача
находится в состоянии ожидания этого сигнала, она переходит в
состояние готовности к выполнению.  Если сигнал подан задаче,
находящейся в состоянии готовности, он будет запомнен, и при переходе
в состояние ожидания задача останется в состоянии готовности.
     Сигнал представляет собой один из битов 32-битного слова.
Одновременно можно послать как один, так и несколько сигналов -
установив соответствующие биты.  Точно так же любая задача может
ожидать как один, так и несколько сигналов.  Переход из состояния
ожидания в состояние готовности происходит только лишь в том случае,
когда приходит хотя бы один из ожидаемых сигналов - если ни один из
битов ожидаемых не соответствует пришедшему, задача не перейдёт в
состояние готовности (однако, сигнал будет запомнен!).  Когда задача
перешла в состояние готовности, она может проанализировать, какие
именно сигналы ей получены, и на основании этого сделать выводы, кто
конкретно и что от нее хочет.  Для того, чтобы выяснить, приходил ли
за время работы задачи сигнал, ей не обязательно переходить в
состояние ожидания - система даёт возможность прочитать текущее
состояние сигналов.  Для этого используется функция dos.library
CheckSignal(), аргументом которой (D1) служит маска проверяемых
сигналов, а результатом - сигналы, установленные на данный момент.
Все указанные функции сигналы будут сброшены.
     Сигналы используются, например, для обработки нажатия клавиш
CTRL/C - если во время работы программы в Shell нажать CTRL/C, задаче
будет послан соответствующий сигнал.  Обрабатывать его или нет - это
уже дело самой задачи.  Поскольку количество сигналов ограничено,
некоторые из них имеют специальное служебное назначение.  Сигналы 12,
13, 14, 15 (то есть биты по маске f000) соответствуют нажатию
комбинаций клавиш CTRL+C,D,E,F.  Остальные (0-11) используются
системой для внутренних нужд.  Для своих целей задачи могут
использовать сигналы начиная с 16-го.
     Поскольку задача может работать как бы в рамках другой задачи
(это называется «работать в контексте вызывающей задачи» - так,
например, shell запускает программы), некоторые сигналы к моменту
запуска задачи могут быть уже заняты.  Для того, чтобы использовать
только незанятые сигналы, Exec предоставляет возможность динамического
резервирования сигналов.  К примеру, если Ваша задача хочет получать
от кого-либо сигнал, она должна вызвать функцию Exec'а AllocSignal.  В
качестве аргумента (D0) передаётся байт -1, и в результате
возвращается номер сигнала, либо -1, если свободных сигналов нет.
Полученное число нужно запомнить.  Для получения битовой маски сигнала
используйте это число как аргумент сдвига единицы влево.
     Эта же функция используется системными функциями для работы с
сигналами, что позволяет избежать конфликтов с уже используемыми
задачей сигналами.
     Перед выходом из задачи зарезервированный сигнал необходимо
освободить!  Это делает FreeSignal(), получающей (D0) номер сигнала.
     Для перехода задачи в состояние ожидания вызывается функция
Wait() - аргументом которой (D0) является битовая маска ожидаемых
сигналов.  Задача перейдёт в состояние готовности после получения
сигналов, хотя бы один из которых совпадёт с ожидаемым (или сразу же,
если эти сигналы были уже посланы ранее).
     «Изнутри» сигналы устроены просто - у каждой задачи есть
служебная структура, в которой одно из слов служит для запоминания
сигналов.  Когда этой задаче посылается сигнал, соответствующий ему
бит устанавливается в этом слове.  Если установленные в результате
биты совпадают хотя бы с одним из ожидаемых задачей сигналов, она
переходит в состояние готовности к выполнению.  Если задача была
готова к выполнению, эти биты просто запоминаются.  Получение же
сигнала сбрасывает соответствующий ему бит, и делает задачу готовой к
повторному приёму сигнала.
     Если задача получает несколько сигналов подряд, она запоминает
только один.  Для того, чтобы запомнить серию обращений от задачи к
задаче, используются сообщения (messages).

     Существует возможность вызова пользовательской функции в
контексте задачи в случае получения заданного набора сигналов.
Функция SetExcept() позволяет определить условия возникновения этой
ситуации, а в поле tc_ExceptCode структуры Task задачи должен быть
прописан указатель на вызываемую функцию.  Более подробно читайте в
exec.doc.


 14) Сообщения

     Сообщения используются в тех случаях, когда задачу нужно не
просто проинформировать о факте события, но и передать какую-либо
информацию.  Кроме того, сообщения выстраиваются в очередь, и задача
получает ВСЕ сообщения, которые ей были переданы.  Сообщения «изнутри»
построены на служебных сигналах задачи.
     Для передачи сообщения должен существовать связной порт (message
port).  Если сигнал адресуется задаче, то сообщение адресуется порту.
Порт создаётся той задачей, которая собирается принимать сообщения.
Отправлять сообщения может любая задача.

     Для создания порта используется функция Exec CreateMsgPort().
Функция не имеет аргументов и возвращает указатель на созданный порт
либо нуль при ошибке.  Кроме того, эта функция захватывает сигнал.
Номер сигнала хранится в созданной структуре и может быть использован
для ожидания сообщений от нескольких портов одновременно (об этом
далее).  Когда надобности в связном порту больше нет, функция
DeleteMsgPort() (указатель на порт в A0) освободит сигнал и занятую
структурой память.

     Порты могут быть общедоступными (public).  Public-порты
отличаются тем, что имеют ИМЯ и находятся в системном списке
public-портов. Любая другая задача в этом случае может найти
нужный ей порт по имени и отправить сообщение.  Именно таким
образом работают REXX-порты программ.
     Для добавления порта в системный список используется функция Exec
AddPort(), аргументом (A1) получающая указатель на порт.  Перед
добавлением порта в список присвойте ему имя - положите в поле имени
элемента списка указатель на текстовую строку.
     Для удаления из системного списка используется RemPort().

     Сообщения представляют собой структуры данных передающей
программы.  Они имеют в начале обязательную структуру Message
<exec/ports.#?>, за которой следуют произвольные пользовательские
данные.  Размер сообщения вместе со структурой - до 65535 байт,
хранится перед самими данными (поле mn_Length).
     Сообщение передаётся функцией PutMsg(), получающей указатель на
порт (A0) и сообщение (A1).  Сообщение при этом ставится в очередь, и
вызвавшая функцию задача тут же получает управление.  Сообщение никуда
не копируется, поэтому изменять сообщение нельзя до тех пор, пока
адресат не получит это сообщение и не «распишется» в его получении
функцией ReplyMsg() - иначе он получит его изменённым (об этом ниже).
     Получатель принимает сообщения при помощи функции GetMsg(),
единственным аргументом которой является порт (A0).  Если в очереди
было несколько сообщений, то каждый вызов GetMsg() будет вытаскивать
очередное.  Когда сообщения кончатся, GetMsg() вернёт нуль.  Если
задаче нужно подождать прихода сообщения, то простейший способ это
сделать - функция WaitPort(), опять же получающая указатель на порт
(A0).  Пока сообщений нет, задача перейдёт в состояние ожидания.
Когда пришло хотя бы одно сообщение, WaitPort() возвращает указатель
на первое сообщение в очереди, НО НЕ ВЫНИМАЕТ СООБЩЕНИЯ!  То есть,
после её вызова следует выполнять GetMsg() до тех пор, пока сообщения
не кончатся.

     В простейшем случае сообщения могут не нести информативной
нагрузки, просто сообщая о фактах какого-то события.  Однако, очень
часто требуется передавать вполне конкретную информацию - аргументы,
массивы...  В этом случае программа-передатчик обычно захватывает
область памяти под сообщение, складывает туда необходимую информацию,
и должна каким-то образом выяснить момент, когда сообщение будет
получено, чтобы освободить эту память.  Для этого существует механизм
Reply-портов.
     Программа-передатчик в данном случае должна создать свой порт,
и занести указатель на него в поле mn_ReplyPort своего сообщения.
Программа-приёмник после приёма сообщения и использования данных из
него должна вызвать функцию ReplyMsg() с указателем на сообщение (A1).
С этого момента приёмнику уже нельзя использовать сообщение.
Передатчик же получит в свой ReplyPort своё сообщение обратно -
что и является той самой «распиской о получении».


 15) Ожидание сообщений от нескольких портов одновременно

     Как было упомянуто ранее, механизм сообщений построен на
сигналах.  В структуре, описывающей порт, есть поле mp_SigBit,
хранящее номер бита сигнала, который будет получен владельцем порта по
приходу сообщения - любое сообщение вызывает посылку этого сигнала.

     Поскольку WaitPort() позволяет ожидать прихода сообщения
только в один порт, для ожидания сообщений в нескольких портах разом
используется другой подход.  Из всех портов, сообщения из которых мы
ждём (ожидающая задача должна быть владельцем всех этих портов - то
есть именно она должна их создать!) выбираем mp_SigBit, разворачиваем
в маску сигнала и складываем все сигналы логической операцией ИЛИ в
одно 32-битное число.  Это число будет аргументом функции Wait().
     Теперь, стоит прийти хотя бы одному сообщению, задача сразу же
выйдет из состояния ожидания. Поскольку каждый порт обычно имеет свой
номер бита сигнала, по результату Wait() нетрудно догадаться, в какой
именно порт пришло сообщение.

     Поскольку количество пользовательских сигналов ограничено, при
работе с достаточно большим количеством портов придётся создавать
порты самому, расшаривая один сигнал на несколько портов разом.  При
таком раскладе уже придётся последовательно опрашивать группу портов,
чтобы выяснить, куда пришло сообщение.

     Поскольку вся коммуникация в AmigaOS построена на сигналах и
сообщениях, этот же подход можно использовать для ожидания любой
группы событий.


 16) Семафоры

     Семафоры являются средством разграничения доступа к разделяемым
ресурсам со стороны нескольких задач.
     Предположим, что у нас есть некая область памяти, куда задача Икс
складывает текстовую строку, а задача Игрек её оттуда считывает.
Поскольку Амига - машина многозадачная, вполне может сложиться такая
ситуация, что программа Игрек залезла в строку именно в тот самый
момент, когда Икс успел выложить только половину очередной строки.
Таким образом, то, что считает Игрек, будет представлять собой
половину новой строки и половину старой.

     Функция InitSemaphore(), получающая указатель на структуру
SignalSemaphore (A0), инициализирует семафор.  Функция ничего не
захватывает, выполняя только инициализацию.  С этого момента семафор
готов к работе.
     Когда задача хочет получить доступ к разделяемому ресурсу
(например, упомянутому участку памяти), она должна вызвать функцию
ObtainSemaphore(), получающую указатель на упомянутую выше структуру
(A0).  Если никто более в данный момент не использует структуру,
задача продолжит выполнение.  Когда операция с ресурсом завершена,
задача должна выполнить ReleaseSemaphore() с тем же аргументом.
     Если в момент между ObtainSemaphore() и ReleaseSemaphore(),
выполняемыми какой-либо задачей, какая-то ещё задача выполнит ту же
процедуру, передав указатель на тот же семафор - она будет переведена
в состояние ожидания до тех пор, пока «владелец» семафора не выполнит
ReleaseSemaphore().  С этого момента задача получит управление.  Если
в такую ситуацию попадёт несколько задач, они будут поставлены в
очередь и будут получать управление поочерёдно.

     Если задача хочет всего лишь узнать, свободен ли ресурс в данный
момент, не переходя в состояние ожидания - для этого существует
функция AttemptSemaphore().  Результат её - TRUE (не нуль), если
ресурс свободен.  В этом случае вызов AttemptSemaphore() идентичен
вызову ObtainSemaphore() - то есть, задача становится владельцем
ресурса, и должна выполнить ReleaseSemaphore() по завершении работы с
ним.  Если результат был FALSE (0) - значит, ресурс уже кем-то занят.

     Существуют более сложные случаи, не вписывающиеся в этот
механизм.  Например, может быть список, у которого есть один
«писатель» и множество «читателей».  Очевидно, что «читатели» друг
другу не мешают никоим образом, и поэтому нет смысла разграничивать
доступ между ними.  А с другой стороны, должна быть возможность разом
отсечь всех «читателей», когда активизируется «писатель».  Упомянутый
ранее механизм предназначен для «писателей», которые должны обладать
исключительным доступом к ресурсу, защищаемому семафором.  Для
«читателей» же есть ещё две функции - ObtainSemaphoreShared() и
AttemptSemaphoreShared(), которые позволяют применяющим их «уживаться»
на ресурсе одновременно.  Эти функции, кроме того, допускают пары
вложенных вызовов.  Для освобождения ресурса применяется всё тот же
ReleaseSemaphore().

     Если задача хочет получить доступ к группе ресурсов разом, может
быть полезно объединение семафоров в список.  ObtainSemaphoreList(),
получающая в качестве аргумента список семафоров (A0), выполняет
Obtain для них всех одновременно.  Этот вариант предпочительнее
последовательного выполнения Obtain, поскольку не может привести к
взаимной блокировке задач (deadlock), если другая задача захочет
провести то же самое в другом порядке.

     Так же, как и порты, семафоры могут быть общесистемно доступны.
Для этого вместо InitSemaphore() выполняется AddSemaphore().  Перед
этим необходимо инициализировать поле имени (ss_Link.ln_Name).
Обратная операция - RemSemaphore().

     Параллельно с описанным синхронным механизмом семафоров, в
AmigaOS реализован также и асинхронный механизм, построенный на
сообщениях.  Для этого применяется пара функций Procure()/Vacate().
     Задача, которой требуется работа с ресурсом, должна иметь готовый
ReplyPort и сообщение (структура SemaphoreMessage, описание смотрите в
<exec/semaphores.#?>, которое передаётся вторым аргументом (A1)
функции Procure().  Поле ssm_Message.ln_Name должна содержать 1 для
обычного (exclusive) доступа и 0 для разделяемого (shared).  Остальные
значения недопустимы.  Когда ресурс станет свободен, он сразу станет
автоматически захвачен, и задача получит сообщение на свой ReplyPort.
Этот механизм позволяет, в частности, ожидать освобождения даже
нескольких семафоров разом.
     Функция Vacate() используется как пара к Procure() для
освобождения занятого ресурса.  Аргументы у неё те же.  Функция может
быть выполнена в любой момент, в том числе и раньше, чем придёт
сообщение об освобождении - тем самым прерывая выполнение Procure().
Поле ssm_Semaphore будет очищено, придёт ответ, если он ещё не был
получен.


 17) Ресурсы

     Ресурсы (resources) представляют собой ещё один «кирпичик»
AmigaOS.  Они выполняют функцию, похожую на функцию семафоров.
Ресурсы предназначены для разграничения доступа к различным аппаратным
компонентам Амиги.  Приведём список имеющихся ресурсов:

     potgo.resource     - порт аналогового джойстика
     ciaa.resource      - 8520-a
     ciab.resource      - 8520-b
     battclock.resource - энергонезависимые часы/календарь
     misc.resource      - параллельный и последовательный порты
     disk.resource      - дисковод
     battmem.resource   - энергонезависимая память
     card.resource      - PCMCIA-порт

     Работа с ресурсами по сути похожа на работу с библиотеками:
каждый ресурс предоставляет некоторый набор функций, разграничивающих
доступ к «железу» со стороны нескольких задач, а также предоставляющих
интерфейс к этому «железу» (наиболее «наворочен» в этом плане PCMCIA).
Отличие от библиотек заключается в том, что ресурс не требует закрытия
и не имеет счётчика пользователей. Пользователь ресурса может быть
только один. Ресурс всегда присутствует в памяти. Вызов OpenResource()
с именем ресурса (A1) возвращает указатель на ресурс, если он найден.
Впоследствии этот указатель используется как база библиотеки.
     После открытия можно вызывать функции ресурса.  Так, для доступа
к «железу» дисковода (например, для написания замены имеющегося
trackdisk.device) нужно выполнить AllocUnit(), передав ему номер
нужного дисковода от 0 до 3 (D0), в результате захватив один из
доступных четырёх дисководов (вернулся не нуль) или убедиться, что
этот дисковод уже кем-то занят (вернулся нуль).  Если дисковод был
успешно захвачен, по завершении работы с ним нужно выполнить
FreeUnit() c тем же аргументом.
     Работа с остальными ресурсами по сути аналогична.

     Ресурсы не обязательно оперируют «железом».  Так, patchcontrol
в составе пакета MCP добавляет в систему ресурс patch.resource,
позволяющий разного рода патчам, поддерживающим этот интерфейс,
уживаться вместе без конфликтов и позволять убирать патчи, которые
были не последними.
     Любая задача может добавить свой ресурс к списку системных
ресурсов функцией Exec AddResource().  Обратная операция выполняется
соответственно функцией RemResource().


 18) Девайсы

     Девайс (device) - ещё один «кирпичик».  Девайсы обычно выполняют
функцию драйверов различных устройств, а также поддержки ввода-вывода
в любом виде.  В отличие от библиотек, интерфейс девайсов, выполняющих
сходную задачу, стандартизован, и в результате в программе можно
сделать выбор, какой из девайсов открывать - а набор операций в каждом
из них идентичен.
     Таким образом, в терминальной программе можно выбирать не только
serial.device, но и любой другой девайс обслуживания любого
последовательного порта (и даже необязательно последовательного - есть
девайс для обслуживания модема, воткнутого в PCMCIA порт).  Для
доступа к диску можно выбрать как scsi.device, так и trackdisk.device,
atapi.device...

     Вызов девайсов выполняется совершенно иным образом, нежели
библиотек (правда, из этого правила есть и исключения).  Вызов девайса
на низком уровне представляет собой обмен сообщениями.  На более
высоком уровне - это выполнение функций Exec SendIO(), WaitIO(),
DoIO(), AbortIO(), CheckIO().
     Так же, как и библиотеку, девайс перед работой с ним необходимо
открыть, а по завершении работы - закрыть.  В отличие от библиотеки,
девайсу требуется передача номера устройства - UNIT.  Это позволяет
работать с любым из устройств, подключенных на один и тот же порт.
Номер версии девайсу не требуется.
     Поскольку работа с девайсом основана на сообщениях, для неё нужен
ReplyPort.  Он должен быть создан заранее (ReplyPort()).  Кроме того,
нужна структура IORequest, которая будет далее передаваться всякий раз
любой операции с девайсом - эта структура представляет собой сообщение
с пользовательскими данными.  Размер сообщения, передаваемого девайсу,
не ограничивается размером этой структуры.  В зависимости от задачи
после неё указываются пользовательские данные различного размера.

     Перед открытием девайса IORequest уже должен существовать.
Создаёт её функция Exec CreateIORequest(), получающая указатель на
ReplyPort (A0) и размер IORequest для данного случая (D0). Когда
IORequest уже создан, можно открывать девайс - это делается функцией
OpenDevice(), получающей указатель на IORequest.  Аргументами служат
имя девайса (A0), номер устройства (D0), IORequest (A1) и флаги (D1).
Флаги задают различные режимы работы девайса и зависят от конкретного
девайса, по умолчанию - нуль.
     В отличие от библиотеки, нуль в результате OpenDevice() означает
успешное открытие девайса, а ненулевое значение - ошибку.

     Различные операции с девайсами выполняются функциями Exec.  Перед
тем, как выполнить очередную операцию, нужно заполнить соответствующие
поля структуры IORequest.  Поле io_Command содержит код операции (об
этом ниже), а io_Error будет содержать код ошибки по завершении.

     SendIO() запускает операцию, получая указатель на IORequest (A1).
Управление вызвавшей функцию задаче будет возвращено немедленно, а
операция будет выполняться асинхронно.
     WaitIO() позволяет подождать до завершения операции, переводя
задачу в режим ожидания, если операция ещё не завершена.
     DoIO() представляет собой SendIO() и WaitIO() «в одном флаконе»,
выполняя операцию и отдавая управление только по её завершении.
     CheckIO() позволяет проверить, завершилось ли выполнение
операции, возвращая FALSE, если операция пока продолжается.
     AbortIO() предназначена для прерывания выполняющейся операции.
AbortIO() не убирает сообщение из очереди, Вы по-прежнему должны
выполнить WaitIO(). Назначение этой функции - аварийное завершение
операции. Она может выполниться немедленно, а может не выполниться
вообще - это зависит от девайса и типа обслуживаемого устройства.
Если операция уже завершена, AbortIO() не делает ничего.

     По завершении работы с девайсом его необходимо закрыть, выполнив
CloseDevice() с единственным аргументом - IORequest (A1).  Затем
необходимо выполнить DeleteIORequest() (A0) и DeleteMsgPort().
К моменту закрытия девайса все операции с ним должны быть завершены!


 19) Основные операции по работе с девайсами

     Для любых существующих девайсов стандартизирован общий набор
выполняемых ими операций.  Каждая операция имеет код, представляющий
собой константу.  Конкретный девайс может как реализовать весь этот
набор, так и часть набора.  Этими общими для всех девайсов операциями
являются:

     CMD_INVALID
     CMD_RESET
     CMD_READ
     CMD_WRITE
     CMD_UPDATE
     CMD_CLEAR
     CMD_STOP
     CMD_START
     CMD_FLUSH

     Кроме того, общей для всех девайсов является структура IORequest,
в поле io_Command которой кладётся код операции.
     Действие каждой из этих операций зависит от конкретного девайса.
CMD_WRITE для scsi.device выполняет запись на диск, для serial.device
отправляет данные в порт, а для cd.device недействительна вообще.
     У каждого девайса, кроме перечисленных операций, могут быть ещё и
специфичные для этого девайса операции. Они тоже являются константами.
Каждый девайс также может иметь расширение структуры IORequest -
именно для этого фунции CreateIORequest() передаётся размер структуры.
В частности, timer.device использует структуру timerequest, содержащую
помимо IORequest специфичную для работы со временем информацию.
     Вызов не существующей у девайса операции не фатален и приводит к
возврату девайсом ошибки IOERR_NOCMD.

     Для девайсов, осуществляющих ввод-вывод, обычно используется
структура IOStdReq, содержащая (кроме полей, имеющихся в IORequest)
указатель на информационный массив (io_Data), объём передаваемой
информации в байтах (io_Length), смещение от начала блочного
устройства в байтах (io_Offset) и реально переданный объём по
завершении операции (io_Actual) - смотрите exec/io.#?.


 20) Работа с блочными устройствами

     Устройства блочного доступа (block-oriented) - винчестеры,
дисководы, CD-ROM, магнитооптика, флэш-карты - отличаются от потоковых
(stream) устройств тем, что при работе с ними адресуется требуемый
выполняемой операции участок носителя.

     Устройства блочного доступа могут иметь обычную для дисков
организацию - деление на сектора, поверхности и цилиндры.  Могут иметь
разный размер сектора (к примеру, для винчестера обычный размер
сектора - 512 байт, а для CD-ROM - 2048 байт).  Могут иметь разную
геометрию - например, у винчестеров обычно тысячи цилиндров, а CD-ROM
представляется одним-единственным треком, разбитым на сектора.
Флэш-карты могут вообще не иметь блочной структуры.  Для унификации
доступа к любому блочному устройству оно адресуется линейным смещением
в байтах (поле io_Offset). Смещение должно быть кратным размеру блока!
     Классическим блочным устройством является дисковод, обслуживаемый
trackdisk.device.  Этот девайс и подобные ему девайсы обслуживают
следующий набор команд:

     CMD_CLEAR       - сброс кэша по чтению
                       В случае дисковода при любом обращении к
                       дискете трек считывается целиком, и повторное
                       обращение к треку выдаёт имеющиеся в памяти
                       данные.  Эта команда делает их
                       недействительными, и повторное обращение по
                       чтению вызовет перечитывание трека.
     CMD_READ        - чтение
     CMD_UPDATE      - сброс кэша по записи
                       Запись данных на трек не вызывает немедленного
                       сброса на диск.  Трек записывается целиком
                       только при необходимости перехода на другой
                       трек.  Эта команда вызывает запись «насильно».
     CMD_WRITE       - запись
     TD_ADDCHANGEINT - регистрация обработчика смены диска
                       Позволяет определить код, который будет
                       выполняться в случае смены диска.
     TD_CHANGENUM    - считывание счётчика смен диска
     TD_CHANGESTATE  - проверка наличия диска в приводе
     TD_EJECT        - выброс диска. На встроенном дисководе не
                       поддерживается.  Предназначена для CD-ROM etc.
     TD_FORMAT       - форматирование трека
     TD_GETDRIVETYPE - определение типа привода
                       Типы описаны в <devices/trackdisk.#?>
     TD_GETGEOMETRY  - считывание геометрии диска
                       Формат описан в <devices/trackdisk.#?>
     TD_GETNUMTRACKS - считывание количества цилиндров
     TD_MOTOR        - управление мотором
     TD_PROTSTATUS   - проверка наличия защиты записи
     TD_RAWREAD      - низкоуровневое чтение
     TD_RAWWRITE     - низкоуровневая запись
                       Последние две команды позволяют работать с
                       «чужими» форматами - например, с дискетами IBM
                       PC.  В этом случае trackdisk.device возвращает
                       дорожку вместе со всеми маркерами, синхробитами
                       и т.п. в «сыром» MFM-формате.
     TD_REMCHANGEINT - отмена регистрации TD_ADDCHANGEINT
     TD_SEEK         - позиционирование.  Используется для служебных
                       целей (чистящие диски, диагностика и т.д.)

     Как упоминалось выше, конкретный девайс не обязан обслуживать
все перечисленные команды.  Если какая-то команда не обслуживается,
возвращается ошибка.  Более подробно смотрите trackdisk.doc.
     Поскольку смещение задаётся 32-битным числом, вполне очевидным
становится ограничение на объём устройства в четыре гигабайта.  Для
преодоления этого ограничения вместо стандартных команд используются
их 64-битные эквиваленты:

     NSCMD_TD_READ64
     NSCMD_TD_WRITE64
     NSCMD_TD_SEEK64
     NSCMD_TD_FORMAT64

     При этом старшая половинка 64-битного слова перед операцией
кладётся в поле io_Actual.  Эти команды поддерживаются только новыми
версиями девайсов (к примеру, scsi.device v43 и старше).  Проверяйте
результат их использования - если девайс возвратил ошибку, значит
следует использовать 32-битные команды, и объём носителя заведомо
меньше 4 гигабайт.


 21) Работа с потоковыми устройствами

     Потоковые устройства - например, последовательный порт, в
основном управляются стандартным набором CMD-команд.  К ним
добавляются несколько команд и полей управляющей структуры,
специфичных для устройства.  Так, для serial.device используется
расширенная структура IOExtSer и доступны команды:

     SDCMD_BREAK     - посылка сигнала BREAK
     SDCMD_QUERY     - считывание состояния порта
                       Позволяет определить состояние сигналов
                       RTS/CTS, DTR/DSR, CD, RI, сигнал BREAK,
                       переполнение буфера.
     SDCMD_SETPARAMS - установка состояния порта
                       Устанавливается размер буфера, скорость порта,
                       длительность сигнала BREAK, формат посылки,
                       xON/xOFF режим и прочее.

     Прочие девайсы, работающие с последовательными портами, могут как
поддерживать, так и не поддерживать эти команды и режимы.  Так,
например, 8n1.device имеет единственный формат посылки (что следует из
названия) и не позволяет его менять.

     parallel.device использует структуру IOExtPar и свой набор команд
- смотрите parallel.doc и <devices/parallel.#?>

     Остальные типы девайсов рассматриваться не будут - читайте
документацию самостоятельно.


 22) Работа с девайсами посредством вызова функций

     Посылка команд не является единственным средством работы с
девайсами.  Для осуществления быстрого выполнения операций, без
расхода времени на пересылку сообщений, применяются функции,
аналогичные функциям библиотек.  Набор этих функций специфичен
для каждого девайса.

     Поскольку OpenDevice() не возвращает «базу» девайса, после
открытия девайса базу нужно прочитать из структуры IORequest.
Находится она в поле io_Device этой структуры.  Когда девайс успешно
открыт, база копируется в переменную, специфичную для девайса -
например, для timer.device это будет переменная TimerBase.

     После этого можно выполнять функции девайса.  Какие функции какой
девайс предоставляет, описано в документации по девайсам.


 23) Quick IO

     Кроме стандартных операций ввода-вывода, существует также быстрый
ввод-вывод, при котором не выполняется пересылок сообщений и сразу
напрямую вызывается код девайса.  К примеру, такой подход полезен для
serial.device, когда принимаемая информация уже лежит в буфере, и её
нужно только передать задаче.
     Механизм быстрого асинхронного ввода-вывода реализуется следующим
образом:  в поле io_Flags структуры IORequest нужно установить флаг
IO_QUICK.  Затем вместо стандартного SendIO() (очищающего это поле)
нужно вызвать функцию BeginIO() девайса.  После вызова нужно проверить
флаг IO_QUICK: если флаг остался установленным, значит операция уже
завершена, и WaitIO() выполнять не нужно.  Если IO_QUICK сброшен,
значит, операция не может быть завершена сразу, и нужно ожидать её
завершения с помощью WaitIO().
     С точки зрения программиста на ассемблере, BeginIO() - это вызов
jsr -36(a0) - как обычно, в A6 должна лежать база.  Поскольку эта
операция в принципе может выполняться с любыми девайсами, имя базы не
определено.  Чтобы обойти этот момент при программировании на Си,
применяется функция BeginIO() линкуемой библиотеки amiga.lib,
вызывающаяся аналогично функции SendIO() - которая не может быть
применена для быстрого ввода-вывода.
     Быстрый синхронный ввод-вывод делается с помощью уже известной
нам DoIO(), с предварительной установкой флага IO_QUICK.


 24) Работа с таймером

     Несколько особняком среди девайсов стоит timer.device - он не
является средством ввода-вывода.  Таймер оперирует свой структурой
timerequest, имеет свои команды, а также набор функций.  Отличается от
общепринятого и применение UNITов - это не «номер устройства», а
режим, в котором мы будем использовать таймер.

     Таймер умеет считать время в двух разных системах единиц.  Первая
система общепринята - это секунды и микросекунды.  Они хранятся в
структуре timeval и представляют собой два лонга.  Представление
времени всегда нормализовано - т.е., количество микросекунд никогда не
превышает миллиона.
     Вторая система - так называемые EClock. Это внутренняя единица
времени Амиги. Частота EClock зависит от модели компьютера и обычно
составляет порядка 7 мегагерц. EClock хранятся в структуре EClockVal,
состоящей из двух лонгов - 64-битного представления числа.

     Таймер имеет два эталона времени - собственно EClock (точность
определяется частотой EClock) и кадровую частоту дисплея (точность
зависит от частоты, обычно в пределах 50-100Hz).  Второй вариант
используется тогда, когда точность не играет особой роли - например,
для мигания курсора. Эталон времени не имеет отношения к системе
единиц - можно определять время в микросекундах, используя EClock.

     И наконец, таймер имеет два разных режима работы.  Он умеет как
оперировать интервалами времени, так и позволяет ожидать наступления
определённого времени.

     Для того, чтобы использовать предоставляемые возможности, при
открытии timer.device нужно указать Unit:

     UNIT_MICROHZ    - работа с интервалами времени в микросекундах,
                       используя в качестве эталона EClock.
     UNIT_ECLOCK     - работа с интервалами времени в единицах EClock
                       (эталон - разумеется, EClock)
     UNIT_VBLANK     - интервалы времени в микросекундах, эталон -
                       кадровая частота
     UNIT_WAITUNTIL  - ожидание наступления заданного времени в
                       микросекундах, эталон - кадровая частота
     UNIT_WAITECLOCK - ожидание наступления времени в EClock,
                       эталон - EClock

     Работа с timer.device осуществляется операцией TR_ADDREQUEST.
Если требуется только ожидание в течение некоторого интервала времени
с малой точностью, вместо возни с таймером можно использовать функцию
dos.library Delay(), аргументом (D1) имеющую интервал в «тиках» (1/50
секунды).  Необходимую работу с таймером эта функция выполнит сама.

     Таймер имеет ряд вспомогательных функций для работы с временем.
AddTime(), SubTime() и CmpTime() получают указатели на исходную (A1) и
конечную (A0) структуру timeval и позволяют складывать, вычитать и
сравнивать время, попутно осуществляя нормализацию.
     Функция GetSysTime() возвращает в структуре timeval, указатель на
которую был ей передан (A0), текущее системное время.  Функция
ReadEClock() аналогичным образом заполняет структуру EClockVal (A0) в
формате EClock, и возвращает (D0) системную частоту EClock в герцах.

     Кроме того, доступны команды TR_GETSYSTIME и TR_SETSYSTIME для
считывания и установки системного времени соответственно.


 25) Некоторые особенности использования девайсов

     Как и всё прочее, работа с девайсами организована на сигналах и
сообщениях.  Это позволяет ожидать завершения нескольких запросов.
Очевидно, ничто не мешает и ожидать одновременно как завершения
ввода-вывода, так и любых других сообщений и сигналов.  Для этого
применяйте тот же способ, что был описан ранее для портов, используя
ReplyPort.

     Существование асинхронной работы с девайсом наталкивает на мысль
о возможности посылки сразу нескольких запросов единожды открытому
девайсу.  Однако, использовать один и тот же IORequest для этого
нельзя - структура должна быть неизменной до тех пор, пока девайс не
завершит операцию.  Чтобы не открывать для этого девайс несколько раз,
используется следующий «трюк»: создаются новые структуры IORequest
путём копирования в них старой.  Как уже упоминалось, перед закрытием
девайса все запросы должны быть завершены.


 26) New Style Devices

     Поскольку существует несколько разных типов девайсов, совместимых
с собой только на уровне стандартных CMD-команд, была бы полезной
возможность определить тип девайса после открытия - например, чтобы
терминальная программа не вздумала вместо serial.device использовать
scsi.device.  Такая возможность появилась благодаря спецификации NSD,
принятой в 1996 году Amiga International.

     New Style Devices при выполнении команды NSCMD_DEVICEQUERY
возвращают спецификацию девайса в структуре NSDeviceQueryResult.
Указатель на эту структуру и её размер должны быть предварительно
указаны в io_Data и io_Length.

     Структура содержит следующие поля:

     DevQueryFormat    - перед операцей нужно обнулить
     SizeAvailable     - перед операцей нужно обнулить
     DeviceType        - тип девайса
     DeviceSubType     - подтип, в зависимости от типа
                         Зарезервирован для будущего использования,
                         в данный момент всегда нулевой
     SupportedCommands - указатель на массив 16-битных слов,
                         оканчивающихся нулём - список всех команд,
                         не вызывающих ошибку IOERR_NOCMD.

     Последнее поле избавляет программиста от необходимости методом
тыка выяснять, работает ли та или иная команда, или нет.
     В настоящий момент определён следующий набор типов девайсов:
     <devices/newstyle.#?>

     NSDEVTYPE_GAMEPORT
     NSDEVTYPE_TIMER
     NSDEVTYPE_KEYBOARD
     NSDEVTYPE_INPUT
     NSDEVTYPE_TRACKDISK
     NSDEVTYPE_CONSOLE
     NSDEVTYPE_SANA2
     NSDEVTYPE_AUDIO
     NSDEVTYPE_CLIPBOARD
     NSDEVTYPE_PRINTER
     NSDEVTYPE_SERIAL
     NSDEVTYPE_PARALLEL
     NSDEVTYPE_UNKNOWN

     Категория девайса понятна из названия типа.  NSDEVTYPE_UNKNOWN
означает девайс, не подпадающий ни под одну из этих категорий.

     Очевидно, описанное расширение поддерживается только девайсами,
созданными после выхода этой спецификации.  Если какой-то конкретный
девайс слишком стар или по какой-то ещё причине не поддерживает её,
следует пользоваться только имеющимися возможностями, возложив
ответственность за правильность выбора типа девайса на пользователя.


 27) Работа с датами

     Системное время представляет собой количество времени, прошедшее
с даты 1 января 1978 года.  Поскольку для человека это время ничего не
скажет, существуют функции, оперирующие с более привычным для всех нас
представлением времени.

     Функция DateStamp() dos.library заполняет структуру DateStamp
<dos/dos.#?>, указатель на которую ей передан (D1).  Структура
содержит целое количество дней, прошедших с упомянутой даты (ds_Days),
количество минут, прошедших с полуночи (ds_Minute), и количество
«тиков» последней минуты (ds_Tick).
     Функция CompareDates() позволяет сравнить две даты (D1,D2),
представленные структурами DateStamp.

     Функции DateToStr() и StrToDate() переводят дату из DateStamp в
привычное человеческое представление и обратно.  Для этого
используется структура <dos/datetime.#?> DateTime
(D1), содержащая в начале структуру DateStamp и дополнительно имеющая
ряд полей, управляющих форматом, подстановкой слов (названия дней
недели) и имеющая указатели на результирующие строки, которые нужно
заполнить заранее перед вызовом функции.  Подробнее смотрите dos.doc.

     Другое средство - Date2Amiga() и Amiga2Date() в utility.library
позволяет оперировать не текстовыми строками, а цифровым
представлением даты.  Функции преобразуют количество секунд (D0) в
структуру (A0) ClockData <utility/date.#?> и обратно.  Структура
содержит следующие поля:

     sec   - секунды
     min   - минуты
     hour  - часы
     mday  - день месяца
     month - месяц
     year  - год
     wday  - день недели


 28) DOS

     Далее пойдёт подробное описание работы с dos.library (далее
просто DOS).  Эта библиотека занимается вводом-выводом на более
высоком уровне, работой с файлами, файловыми системами и прочим.

     DOS вводит новое понятие ПРОЦЕСС.  Процесс - это задача (task),
имеющая расширенные служебные поля.  Процесс описывается структурой
Process, которая первым элементом содержит структуру Task.  Новые поля
структуры необходимы для работы с DOS.  Только процессы имеют право
вызывать большинство функций dos.library.  Впрочем, большинство задач,
которые «крутятся» в системе, представляют собой именно процессы.
Описанной ранее функцией CreateNewProc() создаётся именно процесс.

     По историческим причинам DOS имеет следующую особенность:
аргументы большинства функций передаются в регистрах данных.  Так
получилось в результате того, что первые версии DOS были написаны не
на Asm/C, а на языке BCPL.  По той же причине в DOS достаточно часто
встречаются так называемые BCPL-указатели, которые представляют собой
номер лонга (то есть, для преобразования в обычный указатель нужно
сдвинуть его влево на два разряда).


 29) Устройства и пути

     DOS адресует устройства по их именам.  Имя - текстовая строка с
двоеточием в конце.  Устройством может быть всё что угодно - дискета,
последовательный порт, консольное окно.
     Частным случаем устройства может быть иерархическая древовидная
структура, содержащая множество файлов.   Для выяснения, является ли
данное устройство файловым, существует функция IsFileSystem(), которой
передаётся имя устройства (D1).  Результат - TRUE для файловой системы
или FALSE в противном случае.

     Для адресации файла в пределах иерархической файловой системы
существуют пути.  Путь может быть относительным или абсолютным.
Подробно об этом читайте в книге Д.Михайлова.

     Для удобства работы с путями DOS предоставляет ряд функций:

     AddPart() добавляет имя файла или путь, заданный вторым
аргументом (D2), к пути в буфере (D1) определённого размера (D3).
Если добавляемый путь является абсолютным, он полностью замещает
исходный.  Подробнее читайте dos.doc.
     FilePart() ищет последний компонент пути.
     PathPart() находит конец предпоследнего компонента пути, обычно -
имени директории.


 30) Механизм запуска программ в DOS

     В AmigaOS существует общепринятый формат загружаемого файла.
Он используется не только для исполняемых файлов - в этом же формате
хранятся и библиотеки, и девайсы, и шрифты, и иконки.  Файл состоит из
ХАНКОВ (HUNKS), представляющих собой отдельные участки.  Ханки могут
содержать код, данные, отладочную информацию, и таблицы перемещения.
Механизм таблиц перемещения позволяет загружать неперемещаемые
программы в любые адреса памяти, модифицируя в них ячейки, зависящие
от адресов - таблицы перемещения содержат список этих ячеек.

     Размещение загружаемого файла в памяти выполняется функцией
LoadSeg().  Ей передаётся указатель на строку - имя файла (D1).
Результат LoadSeg() - BCPL-указатель на так называемый seglist.
Seglist (список сегментов-ханков) содержит в первом лонге каждого
сегмента BCPL-указатель на следующий сегмент.  Конец списка - нуль.
LoadSeg() автоматически выполняет перемещение, после её успешного
выполнения загружаемый файл готов к выполнению.
     Когда загруженный файл в памяти более не нужен, выполняется
UnLoadSeg(), освобождающий занятую им память.

     Запуск программы DOS-ом производится операцией jsr.  При этом в
A0 программе передаётся указатель на командную строку, а в D0 длина.
Строка оканчивается символом LF.  Строка НЕ СОДЕРЖИТ имя программы,
то есть начинается с первого же её аргумента (или содержит только LF,
если аргументов нет).
     Результат работы (returncode) программа возвращает в D0.  Нуль
означает успешное (без ошибок) завершение программы.

     ВАЖНОЕ ЗАМЕЧАНИЕ.  Workbench использует другой механизм передачи
аргументов!  Признаком запуска программы из DOS является ненулевое
поле указателя на структуру CommandLineInterface в структуре Process.
     Проверить это поле можно как «напрямую», выполнив FindTask() с
нулевым аргументом, так и по результату Cli(), если DOS открыт.


 31) Запуск и останов программы

     Чтобы запустить из вашей программы какую-то ещё, очевидно, можно
самостоятельно выполнить LoadSeg() и передать ей управление.
     Но существует и более простой способ запуска другой программы -
SystemTags().  Аргумент - командная строка (D1) и taglist (D2).  При
выполнении этой функции запускается требуемая программа, а по выходу
из неё функция возвращает returncode.
     Тэги, передаваемые функции, позволяют перенаправить её ввод и
вывод, установить имя задачи, её приоритет.  Используются те же тэги,
что и у CreateNewProc().

     DOS предоставляет возможность доступа к списку запущенных из DOS
программ.  Каждая такая программа имеет уникальный номер, который
позволяет идентифицировать даже процессы с одинаковыми именами.
Нумеруются они с ЕДИНИЦЫ.
     Для доступа к списку сначала нужно выполнить функцию MaxCli(),
которая вернёт максимальный номер процесса, запущенного из DOS.  Это
не количество процессов, ряд номеров может быть незанятым по причине
завершения программ.  После этого в цикле от единицы до результата
MacCli() выполняется FindCliProc(), с аргументом - счётчиком цикла
(D1).  Результатом каждого вызова будет указатель на очередной процесс
или нуль, если таковой отсутствует.

     Для останова какой-либо программы необходимо послать ей сигнал
SIGBREAKF_CTRL_C <dos/dos.#?>.  Останов в этом случае не
гарантируется, однако многие программы поддерживают это соглашение.


 32) Аргументы командной строки

     Как описано выше, программа не получает своё имя в командной
строке.  Выяснить его можно с помощью функции GetProgramName(),
получающей указатель на буфер (D1) и его размер (D2).

     Есть несколько способов работы с командной строкой:

   - A0/D0.  В программе на Си головная функция задаётся в виде:

     __asm main(register __a0 char *string, register __d0 int len)

     Первое слово указываются только для SAS/C.  Если программа
     компилируется как A4-relative, то для SAS/C перед __asm нужно
     указать __saveds, а для Hisoft C первой операцией в main() будет
     GetBaseReg() - подробнее читайте в описании средств разработки.

   - GetArgStr() возвращает (D0) то же, что и передаётся в A0 при
     старте программы.  В этом случае возня с аргументами main() не
     требуется.

   - ReadArgs().  Это самое мощное и удобное средство работы с
     аргументами.  ReadArgs() полностью разбирает командную строку,
     превращая её в массив строк, чисел и флагов, соответствующих
     назначению ключевых слов.


 33) ReadArgs()

     ReadArgs() разбирает командную строку в соответствии с переданным
ему шаблоном.  Шаблон задаёт различные ключи командной строки и их
типы.  Шаблон состоит из списка ключей.  Ключи называются «полными»
именами, где это возможно (например, «Quick» вместо «Q»).  Также могут
быть заданы сокращения, путём использования «сокращение=ключ»
(например, «Q=Quick»).
     Ключи в шаблоне разделяются запятыми.  Для получения результата
ReadArgs(), Вы проверяете массив лонгов, переданный ему (каждый
элемент массива соответствует ключу в шаблоне).  Массив должен быть
очищен (либо инициализирован значениями по умолчанию) до передачи его
ReadArgs().  Что именно будет помещено в конкретный элемент массива,
определяется типом ключа.  По умолчанию это будет текстовая строка
(последовательность символов, не содержащая пробелов, либо заключённая
в кавычки) - в этом случае элемент массива будет содержать указатель
на строку.
     После каждого ключа может быть указан суффикс, указывающий его
тип.  Суффиксы состоят из «/» и одиночного символа.  У ключа может
быть несколько суффиксов.  Допустимы следующие суффиксы:

     /S - Переключатель (Switch).  Наличие рассматривается как
          логическое значение, устанавливающееся при появлении в
          командной строке.  Элемент массива имеет логический тип
          (0 - не установлен, ненулевое значение - установлен).
     /K - Строка (Keyword).  Элемент массива не будет заполнен, если
          ключ не указан.  К примеру, если в шаблоне указано «Name/K»,
          то при отсутствии «Name=<string>» или «Name <string>» в
          командной строке элемент массива не будет заполнен
     /N - Число (Number).  Параметр рассматривается как десятичное
          число, которое будет преобразовано вызовом ReadArgs.  Если
          указано неверное значение, возвращается ошибка.  Элемент
          массива будет содержать указатель на полученное число
          (таким образом Вы узнаете, было ли оно указано).
     /T - Переключатель (Toggle).  Похож на Switch, но при наличии
          не заполняет элемент массива, а «переключает» его на
          противоположное значение.
     /A - Требуемый (Required).  Этот ключ должен быть указан в
          командной строке, при его отсутствии возвращается ошибка.
     /F - Остаток строки.  Если указан, остаток строки после ключа
          будет передан как параметр, даже если в нём встречаются
          какие-либо ещё ключевые слова.
     /M - Множество строк (Multiple strings).  Параметром является
          любое количество строк, возвращаемое в виде указателя на
          массив строк, заканчивающийся нулевым указателем.  Любой
          аргумент, не являющийся частью другого аргумента, будет
          добавлен в этот массив.  Только один /M может быть указан
          в шаблоне.  Пример: для шаблона «Dir/M,All/S» командная
          строка «foo bar all qwe» установит логический элемент «all»,
          и вернёт массив строк, содержащий «foo», «bar», and «qwe».

     Существует взаимодействие между параметрами /M и /A.  Если после
разбора остаются незаполненные параметры /A, они будут заполнены
строками с конца списка предыдущего параметра /M.  Это используется
для случаев типа Copy («From/A/M,To/A»).

     Аргументы ReadArgs() - указатель на шаблон (D1), указатель на
заполняемый массив (D2) и указатель на структуру RDargs (D3).  Обычно
третьим аргументом передают 0.  Функция подробно описана в dos.doc.

     Каждый вызов ReadArgs() должен завершаться вызовом FreeArgs(),
который освободит занятую ReadArgs() память.


 34) Переменные окружения

     Переменные - ещё один способ как передачи программе аргументов,
так и получения от неё результата.  Кроме того, это основное средство
хранения данных в shell-скриптах, а также механизм хранения alias-ов
команд.

     Переменные могут быть ЛОКАЛЬНЫМИ и ГЛОБАЛЬНЫМИ.  Локальные
переменные в данный момент доступны только одной задаче.  Они
сохраняются всё время работы shell-скрипта и доступны всем программам,
запускаемым из этого скрипта.  Несколько разных задач одновременно
могут иметь разные переменные с одинаковыми именами, поскольку
работают в разных shell-процессах.
     Глобальные переменные (они же переменные окружения - environment)
глобальны для всей системы. Переменная, установленная из одной задачи,
будет видна другой задаче.
     Переменные содержат произвольную информацию. Рекомендуется, чтобы
это был ASCII текст - но это не является обязательным требованием.
     Переменные идентифицируются именем, которое соответствует формату
имён файловой системы.

     SetVar() присваивает переменной определённое значение.  Если
переменная ещё не существует, она создаётся.  Аргументы - имя
переменной (D1), буфер данных и его размер (D2, D3), и флаги (D4).
Флаги содержат тип переменной LV_VAR (переменная) или LV_ALIAS (alias
shell-команд), и область действия GVF_LOCAL_ONLY или GVF_GLOBAL_ONLY
<dos/var.#?>.

     GetVar() возвращает значение переменной по имени. Аргументы - имя
(D1), заполняемый буфер (D2) и его размер (D3), и флаги (D4).  Флаги
позволяют считывать не-ASCII переменную, чтобы буфер не оканчивался
кодом LF (GVF_BINARY_VAR) и нулём (GVF_DONT_NULL_TERM), а также
задаваить область видимости (GVF_LOCAL_ONLY или GVF_GLOBAL_ONLY).  По
умолчанию сначала ищется локальная переменная, и только если она не
найдена, ищется глобальная.
     Результат - длина переменной или -1, если она не найдена.

     DeleteVar() удаляет заданную именем (D1) переменную.  Флаги (D2)
позволяют указать область действия (GVF_LOCAL_ONLY, GVF_GLOBAL_ONLY).
LV_VAR - единственный тип, который может быть глобальным.

     FindVar() по имени (D1) и типу (D2) возвращает указатель на
структуру LocalVar, описывающую локальную переменную.


 35) Работа с файлами

     Работа с файлами осуществляется функциями dos.library:

     Open()  - открытие файла
     Close() - закрытие файла
     Read()  - чтение из файла
     Write() - запись в файл

     Аргументами Open() являются имя (D1) и режим доступа (D2).  Имя
может содержать путь к файлу, путь может быть как абсолютным, так и
относительным - относительно текущей директории.  Функции работают как
с файлами на дисках, так и с любыми устройствами - которыми могут быть
«SER:» (последовательный порт), «PAR:» (параллельный порт) и т.д.
Таким образом, Read() и Write() оперируют произвольными потоками
данных.  Режим доступа - константа, определяющая режим работы:
MODE_OLDFILE открывает существующий файл (и возвращает ошибку, если
файл не найден), MODE_NEWFILE создаёт новый файл (и удаляет старый с
таким же именем при его наличии), MODE_READWRITE создаёт новый при
отсутствии и открывает имеющийся при наличии.  Константы описаны в
<dos/dos.#?>.
     Функцией Open() возвращается filehandle - уникальное 32-битное
число, идентифицирующее открытый файл.  С этого момента любым
операциям над этим файлом передаётся имеющийся filehandle. Завершается
работа с файлом функцией Close(), также получающей filehandle (D1).
После этого значение filehandle недействительно, и всякие попытки
работать с ним могут вызвать сбой системы.
     Чтение осуществляется функцией Read().  Её аргументами служат
filehandle (D1), указатель на буфер в памяти (D2) и требуемый объём
(D3).  Если операция выполнена успешно, Read() возвращает объём
реально прочитанных данных.  Этот объём может быть меньше
запрошенного.  Это не является ошибкой - например, при попытке чтения
100 байт из 50-байтного файла результатом будет реальная длина файла.
Если операция завершилась с ошибкой, в результате возвращается -1.
     Запись осуществляется функцией Write(), по формату вызова и
результатам аналогичной функции Read().

     Несколько последовательных запросов чтения читают следующие друг
за другом участки файла.  DOS запоминает текущую позицию в файле и
после каждого запроса сдвигает её вперёд на прочитанное количество
байт.  Существует возможность передвинуть её «вручную», например для
повторного чтения того же участка файла - для этого служит функция
Seek(), аргументы которой - filehandle (D1), новая позиция в файле
(D2) и режим (D3).  Режим - одна из констант <dos/dos.#?>:

     OFFSET_BEGINNING
     OFFSET_CURRENT
     OFFSET_END

     что позволяет адресоваться от начала файла, от текущей позиции в
нём или от конца файла.  Поскольку filehandle может соответствовать
произвольному по своей сути потоку, Seek() работает не во всех случаях
- например, при попытке вызова его на «SER:» вернётся ошибка.

     Позицию в файле нельзя сдвигать за его пределы.  Если необходимо
создать на диске файл заданной длины без затрат времени на запись,
используется функция SetFileSize(), которой передаётся filehandle
(D1), позиция конца файла (D2) и режим (D3), аналогичный режимам
Seek(). Эта же функция позволяет и «обкусывать» существующие файлы.

     ОЧЕНЬ ВАЖНОЕ ЗАМЕЧАНИЕ.  Не следует путать средства работы с
файлами DOS и ANSI C.  То, что возвращают функции типа fopen(), не
имеет отношения к filehandle, хотя и предназначены для того же!


 36) Буферизованный ввод-вывод

     Всякая операция с функциями Read() и Write() может вызвать
обращение к диску.  Таким образом, например, запись порциями по 10
байт вызовет для каждого обращение считывание текущего блока,
модификацию этих 10 байт и запись блока.  В итоге, для ряда операций
описанный выше подход (называемый небуферизованным вводом-выводом)
чрезвычайно неэффективен.
     Для повышения эффективности таких операций применяется
буферизованный ввод-вывод.  В этом случае данные считываются поблочно
в буфер, а порции небольшого размера выдаются уже из буфера, не требуя
лишних обращений к диску.  Так, и при записи, содержимое буфера
сбрасывается на диск только при его заполнении.

     Функции FRead() и FWrite() являются буферизованными аналогами
Read() и Write(), с той лишь разницей, что ещё одним их аргументом
является количество блоков (D4), длина которых задана третьим.
Результат в случае успешного завершения - количество блоков.
     Функция FGetC() считывает единственный символ, получая на входе
filehandle (D1), а функция FPutC() записывает символ, указанный вторым
аргументом (D2).  Функции FGets() и FPuts() выполняют то же самое для
строк, второй аргумент - указатель на строку (D2), у FGets() третьим
аргументом (D3) идёт объём буфера, выделенного под строку.

     Функция Flush() сбрасывает не заполненный до конца буфер в
выходной поток.  Если этого не сделать, поток будет не сброшен, и, к
примеру, окончание текста в консольное окно будет выведено только
после закрытия файла, а не непосредственно после его вывода.

     Буферизованный и небуферизованный ввод-вывод можно чередовать на
одном и том же файле.  Главное - помнить, что перед каждым переходом
на небуферизованный вывод следует ОБЯЗАТЕЛЬНО выполнить Flush()!

     SetVBuf() управляет работой буферизации.  Аргументы - filehandle
(D1), указатель на буфер (D2), режим буферизации (D3) и размер буфера
(D4).  Если указатель на буфер нулевой, DOS сам будет захватывать
память под буфер, предварительно освобождая предыдущий.  Если указан
размер -1, будет изменён только режим буферизации.
     Доступны следующие режимы буферизации <dos/stdio.#?>:

     BUF_LINE - буфер сбрасывается после каждой строки
     BUF_FULL - буфер сбрасывается только по заполнению или Flush()
     BUF_NONE - буферизация отключена

     Следует отметить, что описанный буферизованный ввод-вывод также
неэффективен для операций с большими массивами, поскольку фактически
требует двойного копирования - в буфер и в память задачи.


 37) Работа с консолью

     Shell-окно, из которого запускается программа, фактически тоже
представляет собой файл.  Точнее, это два файла, на ввод и на вывод
(в стандарте ANSI C им соответствуют потоки stdin и stdout).  Эти два
файла всегда (пока работает программа) открыты.  Соответствующие
им filehandles можно получить функциями dos.library Input() и Output()
соответственно.  С ними работают все описанные выше средства DOS.  По
завершению работы с ними, в отличие от открытых Вами файлов, эти
filehandles закрывать НЕЛЬЗЯ!

     Для вывода в консоль обычно применяют механизм форматных строк.
Форматная строка - это выводимый текст, который «разбавлен» различными
управляющими последовательностями. Они начинаются с символа «процент»
и при выводе заменяются подстроками, числами в разных системах
счисления и т.п. Более подробно об этом можно прочитать в любой книге
по языку Си.
     Обработка форматных строк на низком уровне в AmigaOS выполняется
функцией Exec RawDoFmt().  Её аргументы - форматная строка (A0),
указатель на массив аргументов (A1), указатель на функцию вывода (A2)
и передаваемый ей указатель (A3).  RawDoFmt() может работать с
форматной строкой, выводя результат форматирования куда угодно - в
файл, в память и т.п., позволяя отследить такие явления, как
переполнение буфера.  Вывод результата ведётся посимвольно, для этого
вызываемая по указателю в третьем аргументе функция получает очередной
символ в регистре D0.  Классический вид этой функции:

     move.l d0,(a3)+
     rts

     В таком случае результирующая строка будет размещена в памяти по
адресу, указанному четвёртым агрументом RawDoFmt().  При написании
программы на Си эту функцию можно написать отдельно на ассемблере.
То, что получится в результате, является неким подобием функции
sprintf() ANSI C, но при этом не требует линковки с программой
килобайт ненужного кода.
     Спецификация форматных строк, используемых функцией RawDoFmt(),
по сравнению с описанной в стандарте Си несколько упрощена - в
частности, не поддерживаются числа с плавающей точкой (впрочем, на
практике применяемые исключительно редко).  Более подробно этот вопрос
освещён в exec.doc.

     Более высокоуровневой функцией DOS является Printf(), по сути -
аналог сишного printf().  Аргументы его те же - форматная строка (D1)
и набор аргументов (D2 - для незнакомых с этой функцией имеет смысл
изучить сишную документацию).  Также доступен FPrintf(), первым
аргументом которого указывается filehandle.

     ОЧЕНЬ ВАЖНЫЙ МОМЕНТ.  Размер целого типа для RawDoFmt() и всех
использующих его функций - 16 бит!  Таким образом, для работы с
32-битными числами необходимо применять флаг «l».  Пример:

     Printf("Печатаем 32-битное десятичное число: %ld\n",number);

     PutStr() - печать обычной (неформатной) строки (D1).
     WriteChars() - печать строки (D1) определённой длины (D2).

     Аналогов scanf() в DOS нет.  Впрочем, по причине графической сути
AmigaOS подобные средства тоже требуются исключительно редко.
Программы с консольным интерфейсом ограничиваются анализом командной
строки и выводом служебной информации, взаимодействие с пользователем
принято делать с помощью GUI.

     Программа не ограничена своим консольным окном, она имеет
возможность открыть ещё несколько подобных окон.  Для этого на запись
открывается файл вида «CON:» или «RAW:».  Первое от второго отличается
тем, что в случае CON весь клавиатурный ввод буферизуется, и программа
получает готовую строку по нажатию ENTER (что позволяет организовать
редактор строки и history-буфер), а в случае RAW любой введённый
символ тут же поступает во входной поток.  Кроме того, введённые
в CON символы тут же отображаются в окне, а в случае RAW этого не
происходит.  Shell-окно, в котором работает программа, имеет тип CON.
     После имени устройства можно через слэш указывать параметры.  Это
подробно расписано в книге Д.Михайлова «AMIGA #1».

     Существует способ открытия нового файла, чтобы ввод-вывод был
направлен на текущее окно.  Для этого используется имя «CONSOLE:».
Данный способ удобен для программ, которые выводят информацию только
в файл, а не в Output().


 38) Обработка ошибок

     Поскольку признаком ошибки обычно является нуль или минус
единица, а причин ошибок может быть множество, в DOS существует
механизм «вторичных» кодов ошибок.
     Если произошла ошибка, её код можно выяснить функцией IoErr() без
аргументов.  Коды ошибок DOS описаны в <dos/dos.#?>.  Этот же
механизм используется во многих других системных библиотеках.  Для
хранения кода ошибки используется специально выделенное для этой цели
поле структуры Process - pr_Result2.

     Чтобы не выводить пользователю невразумительные номера, с каждой
ошибкой связана текстовая строка на языке, установленном в системе.
Эта строка возвращается функцией Fault(), аргументы которой - код
ошибки (D1), заголовок (D2), буфер, куда будет скопирована строка (D3)
и его размер (D4).
     Заголовок - строка, которая будет размещена перед текстом, и
отделена от описания ошибки двоеточием.  В результате, можно получать
строки типа «Can't create archive: object not found».

     PrintfFault() выводит то же в Output() - в этом случае буфер и
его длина не указываются.


 39) Операции с объектами

     В данном контексте «объект» (object) - это произвольный элемент
директории, будь то файл или поддиректория.

     DeleteFile(), несмотря на название, удаляет как заданный файл
(D1), так и директорию.  Перед удалением директории должно быть
удалено всё её содержимое.

     Rename() переименовывает объект, заданный первым аргументом (D1),
во второй (D2).  Этим же способом объект можно перемещать в другую
директорию - но только на том же диске!

     SetComment() устанавливает комментарий (D2) объекту (D1).

     SetFileDate() устанавливает произвольную дату/время последней
модификации объекта (D1), заданную структурой DateStamp (D2).

     SetProtection() устанавливает HSPARWED флаги (D2) файлу (D1).


 40) Что такое Lock

     Функция Lock() позволяет ограничить доступ к объекту.  Доступ
можно ограничить либо только по записи (shared lock), либо как по
записи, так и по чтению (exclusive lock).  В любом случае будет
запрещена всякая модификация содержимого объекта, включая его
удаление.  Аргументы - имя объекта (D1) и тип Lock (D2), принимающий
значения ACCESS_READ (shared) или ACCESS_WRITE (exclusive).
     Результат этой функции - уникальное 32-битное число, по сути
немного похожее на filehandle.  Lock существует до тех пор, пока не
будет выполнена функция UnLock() (D1), результатом которой является
освобождение объекта, а lock становится недействительным.

     При открытии файла функцией Open() предварительно выполнять
Lock() НЕ НУЖНО - это делается системой как бы автоматически.

     Имея lock на файл (не на директорию!), можно «переделать» его в
filehandle (обратное невозможно).  Для этого существует функция
OpenFromLock(), аргументом которой служит lock (D1).  Если функция
выполнена успешно (не нулевой результат), lock с этого момента
недействителен, и UnLock() делать НЕ НУЖНО (судя по всему, достаточно
распространённая программерская ошибка) - и вместо него по завершению
работы нужно выполнить Close().

     При необходимости можно получить дубликат Lock-а - для этого
существует функция DupLock(), которой передаётся имеющийся lock (D1).
Это позволяет получить копию lock-а, например, для другой задачи.
Простое копирование lock-а с этой целью недопустимо!

     DupLockFromFH() позволяет получить Lock по filehandle (D1).
В отличие от OpenFromLock(), filehandle остаётся действительным.

     SameLock(), получающая два lock-а (D1, D2), позволяет выяснить,
принадлежат ли эти lock-и одному объекту.  Результатом может быть:

     LOCK_SAME        - один и тот же объект
     LOCK_SAME_VOLUME - разные объекты в пределах одного диска
     LOCK_DIFFERENT   - разные объекты на разных дисках

     Похожая функция SameDevice() позволяет определить, находятся ли
объекты в пределах одного физического устройства (возможно, на разных
разделах).


 41) Текущая директория

     Текущую директорию можно изменить функцией CurrentDir(),
аргументом которой является lock на новую текущую директорию (D1).
Результат её - lock на старую.
     Существует два правила, которые нужно обязательно соблюдать:

   - lock на текущую директорию должен быть валидным ВСЁ время, пока
     она остаётся текущей.  Если над ним выполнен UnLock(), попытка
     обращения по пути относительно текущей директории приведёт к сбою
     системы!

   - программа ОБЯЗАНА при выходе сделать текущей ту директорию,
     которую она получила при старте.  Единственное исключение из
     этого правила - команда cd.

     Lock на текущую директорию может быть нулём - это означает
корневую директорию системного диска.


 42) Директория, откуда запущена программа

     Разумеется, эта директория защищена lock-ом.  Этот lock можно
получить функцией GetProgramDir() без аргументов.  Выполнять UnLock()
на нём НЕЛЬЗЯ!

     Существует ещё один способ доступа к этой директории - указание
«PROGDIR:» в пути к ней.


 43) Линки

     Линки представляют собой средство создания нескольких объектов,
физически ссылающихся на один и тот же объект на диске. Существует два
типа линков - hard и soft.

     Hard-линки представляют собой несколько записей в каталоге диска,
физически ссылающихся на один и тот же объект.  Все они должны
находиться в пределах одного диска.  Эти записи равноценны, и объект
существует до тех пор, пока существует хотя бы одна запись о нём.

     Soft-линки представляют собой путь, фактически в виде текстовой
строки.  Они могут ссылаться на любой объект, любого типа, на любом
диске.  Наличие объекта не проверяется.

     Для создания линка используется функция MakeLink(), которой
передаётся имя линка (D1), объект, на который создаётся линк (D2) и
тип линка (D3) - нуль для hard-линков, не нуль для soft-линков.
     В случае создания soft-линка вторым аргументом передаётся
текстовая строка, в случае же hard-линка это должен быть lock на
объект.

     Несмотря на то, что физически soft-линк содержит путь, при
доступе к нему (Open() или Lock()), разумеется, мы получаем тот
объект, на который он ссылается.  Чтобы считать ссылку, применяется
ReadLink() - описанный в dos.doc.


 44) Работа с директориями

     Программы типа Directory Opus должны иметь средство считывания
различных параметров файлов и директорий - комментариев, дат создания,
имён, размеров...

     Для считывания информации об одиночном объекте используется
функция Examine(), которой передаётся lock на объект (D1) и указатель
на структуру FileInfoBlock (D2), которую заполнит эта функция.
Похожая функция ExamineFH() отличается тем, что вместо lock получает в
качестве первого аргумента filehandle.
     Структура FileInfoBlock <dos/dos.#?> обязательно должна
иметь адрес, кратный четырём (в SAS/С это делается ключом __aligned
перед описанием структуры, на ассемблере перед структурой нужно
написать cnop 0,4).  Назначение её полей таково:

     fib_DiskKey      - для OFS/FFS - номер блока на диске,
                        большинством остальных FS не используется
     fib_DirEntryType - тип объекта <dos/dosextens.#?>:
                         ST_ROOT     - корневая директория
                         ST_USERDIR  - обычная директория
                         ST_SOFTLINK - soft-link
                         ST_LINKDIR  - hard-link на директорию
                         ST_FILE     - файл
                         ST_LINKFILE - hard-link на файл
                         ST_PIPEFILE - «pipe:»
                        В общем случае, положительное значение
                        означает директорию, а отрицательное - файл.
     fib_FileName     - имя (не указатель, а 108 байт имени)
     fib_Protection   - флаги HSPARWED
     fib_EntryType    - недокументировано, не вздумайте использовать
     fib_Size         - длина файла
     fib_NumBlocks    - сколько блоков диска занимает объект, в т.ч.
                        директория.  Использовать не рекомендуется
     fib_Date         - структура DateStamp - дата/время последней
                        модификации объекта
     fib_Comment      - комментарий (не указатель, а 79 байт)
     fib_OwnerUID     - используются только для multiuser,
     fib_OwnerGID       на обычных файловых системах недействительны

     Для того, чтобы получить информацию обо всей директории, делается
следующее:  сначала выполняется Examine(), возвращающая информацию об
этой директории, а потом последовательно выполняется функция ExNext()
с теми же аргументами, каждый вызов которой возвратит сведения об
очередном объекте директории.  Очевидно, что FileInfoBlock в течение
всего процесса должен быть одним и тем же.
     ExNext() следует выполнять до тех пор, пока он не вернёт FALSE.
После этого нужно убедиться, что код ошибки (IoErr()) соответствует
ERROR_NO_MORE_ENTRIES - в противном случае это действительно ошибка
обращения к диску.

     Существует ещё один способ считывания директории - целиком.  Для
этого существуют функции ExAll() и ExAllEnd().  Интересующиеся могут
ознакомиться с ними в dos.doc.

     Функция CreateDir() позволяет создать новую директорию.  Ей
передаётся имя директории (D1).  Результат - exclusive lock на неё или
нуль в случае ошибки.
     ParentDir() позволяет найти родительскую директорию по lock-у на
любой объект в ней (D1).  Похожая функция ParentOfFH() делает то же
самое по filehandle.


 45) Шаблоны

     Шаблоны (они же «маски» и «регулярные выражения») - механизм для
идентификации строк, удовлетворяющих определённым правилам.  Подробно
описаны в книге Д.Михайлова.  Шаблоны можно использовать не только для
имён файлов, но и вообще для произвольных целей.

     Функция ParsePattern() переводит шаблон во внутренний формат, в
котором он используется для идентификации строки. Шаблон во внутреннем
формате может занимать более чем в два раза больше, чем исходная
строка. Аргументы функции - исходная строка (D1), буфер для шаблона
(D2) и его размер (D3).
     Результат функции: нуль - строка не является шаблоном,
                           1 - строка обработана успешно,
                          -1 - переполнение буфера или другая ошибка.

     Результат работы ParsePattern() используется в MatchPattern().
Аргументы - шаблон во внутреннем формате (D1) и проверяемая строка
(D2).  Функция является рекурсивной и весьма требовательна к стеку!

     Описанные функции - case-sensitive (то есть заглавные и строчные
буквы для них различны).  Если требуется, чтобы заглавные и строчные
не различались, нужно использовать другую пару: MatchPatternNoCase()
и ParsePatternNoCase()

     Существует механизм работы с объектами директории по шаблонам.
Для этого существуют функции MatchFirst(), MatchNext() и MatchEnd().
Более подробно - читайте dos.doc.


 46) Нотификация

     Нотификация представляет собой механизм информирования Вашей
задачи об изменениях, произошедших с файловой системой.  Обычно она
используется в программах типа Directory Opus.
     Не все типы файловых систем поддерживают эту возможность -
например, для сетей она может быть нереализуема.  Программа не должна
требовать наличия нотификации, и должна уметь обходиться без неё.

     StartNotify() получает аргументом указатель (D1) на структуру
NotifyRequest.  Структура заполняется до вызова функции, и должна быть
неизменной до выполнения EndNotify().  nr_Name <dos/notify.#?>
указывает на строку - имя объекта, за которым мы собираемся следить.
Для файла отслеживается факт его закрытия.  В случае изменения могут
быть два варианта реакции - посылка сообщения либо посылка сигнала.
Вариант реакции зависит от содержания поля nr_Flags (NRF_SEND_MESSAGE
или NRF_SEND_SIGNAL).  В зависимости от варианта нужно заполнить поля
nr_Msg или nr_Signal.

     EndNotify() с тем же аргументом завершает нотификацию.  Его можно
вызывать даже в случае, если StartNotify() вернул ошибку.  В случае
NRF_SEND_MESSAGE функция очищает порт от всех накопившихся сообщений.


 47) Операции с файловыми системами в целом

     Для устройств, представляющих собой файловые системы, DOS
предоставляет набор «глобальных» операций.  Как уже упоминалось,
функция IsFileSystem() позволяет определить тип устройства.

     Info() по lock-у на любой объект на диске (D1) заполняет
структуру InfoData (D2) информацией о диске.  Эта структура
<dos/dos.#?> должна иметь адрес, кратный четырём, и содержит
следующие поля:

     id_NumSoftErrors - количество ошибок в файловой системе
     id_UnitNumber    - номер устройства
     id_DiskState     - состояние диска, принимает следующие значения:
                        ID_WRITE_PROTECTED - защита от записи
                        ID_VALIDATING      - идёт валидация (OFS/FFS)
                        ID_VALIDATED       - всё ok
     id_NumBlocks     - объём диска в блоках
     id_NumBlocksUsed - сколько блоков занято
     id_BytesPerBlock - размер блока
     id_DiskType      - тип файловой системы:
                        ID_NO_DISK_PRESENT  - диск не вставлен
                        ID_UNREADABLE_DISK  - диск не читается
                        ID_DOS_DISK         - OFS
                        ID_FFS_DISK         - FFS
                        ID_INTER_DOS_DISK   - OFS intl
                        ID_INTER_FFS_DISK   - FFS intl
                        ID_FASTDIR_DOS_DISK - OFS DC
                        ID_FASTDIR_FFS_DISK - FFS DC
                        ID_NOT_REALLY_DOS   - NDOS
                        ID_KICKSTART_DISK   - A1000 ROM
                        ID_MSDOS_DISK       - MS-DOS
                        Возможны и другие значения, например в случае
                        AFS, PFS, SFS, Macintosh HFS...

     Inhibit() - «выключение» файловой системы.  Используется для
того, чтобы получить доступ к диску напрямую без риска конфликтов с
файловой системой.  Эту возможность, например, используют DMS и
DiskSalv.  Аргументы - имя устройства (D1) и флаг TRUE/FALSE (D2).
TRUE «выключает» файловую систему, FALSE «включает» её обратно.

     Format() - инициализация файловой структуры, именно эта функция
выполняется для QuickFormat.  Аргументы - физическое имя устройства
(D1 - например, «DF0:»), имя диска БЕЗ ДВОЕТОЧИЯ (D2 - например,
«System»), и тип файловой системы, если она поддерживает несколько
типов.  Перед выполнением Format() следует выполнить Inhibit(), иначе
будет ошибка.

     Relabel() позволяет сменить логическое имя диска, получая имя
устройства (D1) и новое имя диска БЕЗ ДВОЕТОЧИЯ (D2).

     AddBuffers() позволяет управлять размером кэша файловой системы.
Аргументы - имя устройства (D1) и значение, на которое увеличивается
размер кэша в блоках (D2).  Для уменьшения указывается отрицательным.
Размер блока зависит от файловой системы.


 48) DOS-Packets

     DOS-Packets - механизм низкоуровневой работы с DOS.  Большинство
перечисленных ранее функций DOS реально представляет собой
высокоуровневую оболочку к DOS-пакетам, реализующую, например,
реквесторы при ошибках (Retry/Cancel) и буферизацию.  Фактически
DOS-пакеты представляют собой сообщения Exec.

     Использование DOS-пакетов имеет смысл для следующих задач:

   - асинхронный ввод-вывод
   - отключение реквесторов при ошибке
   - операции с файловыми системами, не ограниченные возможностями DOS

     DOS-пакет представлен структурой StandardPacket, содержащей
структуры Message (поле sp_Msg) и DosPacket (sp_Pkt).  Структура
DosPacket содержит следующие поля:

     dp_Link - указатель на sp_Msg <dos/dosextens.#?>
     dp_Port - ReplyPort для пакета.  Для выполнения высокоуровневых
               функций DOS использует pr_MsgPort процесса.  При
               асинхронной работе с DOS порт нужно создать самому.
     dp_Type - код операции
               Коды операций перечислены в <dos/dosextens.#?>
     dp_Res1 - результат (то, что возвращают функции DOS)
     dp_Res2 - вторичный код ошибки (IoErr())
     dp_Arg1
     dp_Arg2
     dp_Arg3
     dp_Arg4
     dp_Arg5
     dp_Arg6
     dp_Arg7 - аргументы.  Специфичны для выполняемой операции.

     Использование DOS-пакетов по сути похоже на работу с девайсами.
DOS предоставляет аналогичный работе с девайсами набор функций:

     DoPkt()
     SendPkt()
     WaitPkt()
     ReplyPkt()
     AbortPkt()

     Функции описаны в dos.doc.  Порт, в который отправляется
сообщение, берётся из filehandle (поле fh_Arg1) - не забудьте, что
filehandle представляет собой BCPL-указатель!  Это порт хэндлера
(или файловой системы), которая обслуживает нужное нам устройство.
     Перед выполнением операции структура заполняется аргументами и
кодом операции, затем с помощью перечисленных функций либо PutMsg()
посылается сообщение.  По завершении операции на сообщение приходит
ответ, который можно ожидать как с помощью WaitPkt(), так и с помощью
средств Exec.

     Очень подробное описание работы с DOS Packets, а также ряд
примеров приведены в Guru Book.

     [to be continued]
