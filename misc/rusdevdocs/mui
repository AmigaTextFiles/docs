
    Программирование MUI для начинающих, версия 2.1 beta

    (C) 1999 RDC


1) Чем отличается MUI от всех прочих интерфейсных систем,
   или почему нет смысла делать софт не под MUI ;-)

   Есть два типа интерфейсных систем. К первому относится
низкоуровневый Intuition, более высокоуровневый Gadtools,
а также интерфейсы MacOS и Windows.  Программирование этих интерфейсов
сводится к крайне трудоёмкой задаче подбора координат и размеров
каждого элемента.  Большинство программ, написанных под подобные
интерфейсы, имеют набор констант, определяющих координаты и размеры.
Такие программы могут работать только со шрифтом определённого размера
и с определённым языком.  Попытки изменить шрифт или локализовать
программу приводят к тому, что надписи начинают вылезать за пределы
элементов.  Некоторые программы умеют масштабировать интерфейс целиком
в зависимости от размера шрифта - но опять же, не учитывают то, что
ширина надписи пропорциональным шрифтом зависит не столько от размера
шрифта, сколько от содержания надписи.  Особо умные программы
учитывают и это - в результате, стоит надписи на всего лишь одной
кнопке в горизонтальном ряду увеличиться раза в два, как расширяется в
два раза всё окно (наблюдал самолично в русифицированном TERM).
   Теперь посмотрим с позиции программиста.  Он вынужден вручную
подбирать эти пресловутые координаты.  Раньше это делалось вообще чуть
ли не на листе бумаги в клетку.  Позже появились программы типа
GadToolsBox, позволяющие расставлять элементы мышкой - но и это работа
не для слабонервных.  Полная перегруппировка интерфейса из-за
добавления пары кнопок равнозначна переделыванию его заново.  Всё
время приходится прикидывать, насколько эстетично смотрится интерфейс.
Не получилось ли, что интервал между этими двумя кнопками чуть меньше,
чем между теми?
   Кроме того, управляющими элементами интерфейса собственно интерфейс
не ограничивается. Кроме них, есть ещё и элементы оформления - всякие
надписи, рамочки, картиночки. Их уже нужно рисовать в окне вручную.
Причём - каждый раз, когда приходит IDCMP-сообщение с просьбой
перерисовать окно... Приличная программа должна обеспечивать юзеру
возможность поменять размер окна - а для этого придётся при получении
сообщения о новом размере пересчитывать положение и размер ряда
элементов. И наконец, нужно обязательно определять размеры рамки окна,
чтобы при разных размерах элементы не «наползали» на неё.

   Второй тип интерфейсных систем - системы с автоматической
компоновкой (automatic layout).  К этому классу относятся MUI,
ClassAct, BGUI, GTLayout, а также Motif/Lesstif под UNIX.
   В этом случае понятия «координаты и размеры» нет вообще.
Программист группирует элементы интерфейса, связывая их между собой и
определяя взаимосвязи, а интерфейсная библиотека уже самостоятельно
(при каждом изменении пользователем размера окна!) вычисляет, какие
координаты и размеры будут у того или иного элемента.  При этом в
зависимости от размеров картинок и надписей интерфейс может быть
значительно перегруппирован.  Для такого подхода более не требуются
конструкторы интерфейсов и мучительный подбор координат.
   Перечисленные интерфейсы тоже не равнозначны (Motif в данном
контексте рассматриваться не будет, хотя по возможностям он во многом
похож на MUI).  MUI отличается рядом свойств, позволяющих значительно
упростить программу, увеличивая её возможности.  Программисту под MUI
не нужно задумываться о всякого рода подложках - достаточно указать
флаг типа «здесь будет подложка, предназначенная для кнопки».  А уже
какая подложка должна быть у кнопки, решает юзер в MUI prefs.  Для
реализации drag'n'drop достаточно указать, какие объекты можно таскать
и на какие объекты их можно кидать - и совсем не нужно вручную
изображать процесс dnd, как это сделано в тех же SnoopDOS или DOpus5.
Можно даже перетаскивать элементы интерфейса, динамически меняя их
расстановку в окне - и приложение не должно заботиться об этом -
хорошим примером является IBrowse.  MUI позволяет динамически убрать
или восстановить тот или иной элемент или группу элементов - и окно
будет тут же перерисовано, а при необходимости даже изменит размер.  И
наконец, самое интересное свойство - MUI позволяет устанавливать связи
между элементами.  Например, интерфейс вида - галочка, установка
которой означает открытие окна, а убирание её или нажатие на кнопку
закрытия вызывает автоматическое закрытие этого окна - делается
средствами самого MUI.  Нужно всего лишь указать связи, и с этого
момента MUI будет сам обрабатывать данную ситуацию, а программа даже
не будет получать управления по поводу этого события - разумеется,
если она этого не захочет.
   Элементы интерфейса MUI не исчерпываются набором имеющихся.  Их
можно делать самому - так называемые custom classes.  Например,
существует элемент интерфейса HTMLview, фактически представляющий
собой Web-браузер.  Укажешь ему веб-страницу - он её тут же покажет
вместе со всеми картинками и анимациями, и позволит прокручивать
туда-сюда, копировать текст в clipboard.


2) Общая концепция MUI.

   MUI построен на BOOPSI - Basic Object-Oriented Programming System
for Intuition.  Интерфейс BOOPSI появился ещё в OS 2.0.  Вспомните
Palette Prefs - круг выбора цвета и слайдер с градиентом представляют
собой BOOPSI-объекты.  Если Вы имеете понятие о BOOPSI и вообще об
объектно-ориентированном подходе - следующий пункт можете не читать.


3) Объектно-ориентированный подход.

   ОО подход к программированию был разработан пару десятков лет
назад, проявившись в таких языках программирования, как Simula,
SmallTalk и C++.  Рассмотрим основные понятия ООП в контексте BOOPSI:

   1) Класс.  Фактически это библиотека, представляющая собой
      определённый машинный код.  В нашем случае она реализует тот или
      иной элемент интерфейса.
   2) Объект.  Собственно элемент интерфейса.  Представляет собой
      нечто, идентифицируемое уникальным 32-битным числом (фактически,
      представляющим собой указатель на структуру данных).
   3) Метод.  Функция библиотеки, позволяющая сделать то или иное
      действие с объектом - к примеру, вытащить окно на передний план.
   4) Атрибут.  Свойство объекта - например, надпись на кнопке.
      Это свойство можно как считывать, так и менять.  Делается это с
      помощью методов «считать» и «установить».

   Каждый объект является объектом определённого класса.  Класс
предоставляет набор атрибутов и методов, имеющих отношение к данному
объекту.  К примеру, у любого окна есть атрибут «заголовок окна» и
метод «убрать окно на задний план».
   Объекты можно динамически создавать и уничтожать. Пока объект
существует, над ним можно выполнять методы, присущие классу этого
объекта, и считывать/менять атрибуты, присущие классу. Ряд атрибутов
можно инициализировать нужными значениями сразу при создании объекта.
Создание и уничтожение объекта тоже являются выполнением методов.
   Классы организованы в дерево, похожее на дерево директорий
иерархической файловой системы.  Тем самым реализуется ещё один момент
ОО-подхода - наследование.  Субклассы («субдиректории») наследуют все
методы и атрибуты «родительских» классов (называемых суперклассами),
что позволяет не реализовывать в субклассе заново уже существующие
вещи.  Фактически, субклассы являются как бы частными случаями
суперклассов.  К примеру, субкласс «картинка» наследует у класса
«прямоугольная область» атрибут «размер по горизонтали».  Класс
«картинка» не будет отрабатывать считывание этого атрибута - он просто
передаст неизвестную ему операцию классу «прямоугольная область».

   Как всё это «соотносится с реальностью»? В первую очередь, ОО
подход позволяет значительно упростить и упорядочить программный
интерфейс.  Посмотрите на интерфейс Exec, Intuition и Graphics - сотни
вызовов для самых разных целей.  Для работы с MUI достаточно не более
десятка.  Упорядочение сводится, к примеру, к тому, что для
уничтожения объекта есть один единственный вызов.  А вовсе не десяток
- закрыть окно, закрыть экран, закрыть файл, закрыть девайс, закрыть
библиотеку, освободить семафор, освободить базу библиотеки...

   Существуют два подхода к ООП, условно назовём их «статическим» и
«динамическим».  Первый, присущий C++, представляет собой ООП на этапе
компиляции.  ОО-программа, содержащая работу с объектами,
компилируется в объектный код, уже не содержащий никаких объектов.
Для всего внешнего мира это такая же программа, как и написанная на
бейсике или ассемблере - разве что более монстровая и тормознутая.
Классы C++ нельзя представить в виде разделяемых библиотек.  Они
обязательно линкуются к программе, увеличивая её объём на сотни
килобайт и мегабайты.  Собственно, последствия этого подхода можно
наблюдать сейчас на PC.
   Динамический подход, присущий SmallTalk и BOOPSI, сводится к тому,
что объекты действительно существуют и предоставляются окружением.
Программа оперирует функциями окружения для доступа к ним.  В этом
случае программа уже не содержит лишнего кода и получается
исключительно компактной (вспомните MUI Prefs - всего 7 килобайт!).


4) Документация по MUI

   Описания MUI похожи на обычные autodocs, но они описывают не
функции библиотеки, а набор атрибутов и методов, присущий классу.
Каждый класс имеет своё описание.

   Атрибуты - это константы, начинающиеся с «MUIA_».
   Методы - константы, начинающиеся с «MUIM_».

   При описании атрибутов можно встретить что-то типа [ISG].
Это сочетание символов определяет, может ли данный атрибут применяться
при инициализации объекта (Init), может ли изменяться программой в
процессе работы (Set), и может ли значение атрибута быть считанным
(Get).  Если какой-либо возможности у атрибута нет, она заменяется
точкой.  Например, атрибут, который может быть установлен только при
создании объекта, обозначается как [I..].


5) Функции, которые нам потребуются для начала.

 - Функции muimaster.library:

   MUI_NewObject()     - создание объекта. Имеет два аргумента - имя
                         класса (строка) и taglist.  Последний
                         представляет собой набор пар лонгов, первый
                         из которых - атрибут, а второй - его
                         значение.  Это позволяет инициализировать ряд
                         атрибутов нужными значениями сразу при
                         создании объекта.  Функция возвращает
                         указатель на объект.

                         Важное замечание: при создании множества
                         объектов набором функций MUI_NewObject()
                         в исполняемом файле появится множество
                         одинаковых строк.  В компиляторе SAS/C 6.x
                         есть опция StringMerge (Compiler options в
                         scopts), преобразующая указатели на все
                         одинаковые строки в указатель на одну.

   MUI_DisposeObject() - уничтожение объекта.

 - функция amiga.lib (линкуемой библиотеки):

   DoMethod()          - выполнение метода над объектом. Аргументы -
                         указатель на объект, код (номер) метода и
                         список аргументов метода.

 - макросы:

   MAKE_ID()           - макрос для преобразования четырёх символов в
                         один лонг, состоящий из этих четырёх байт.
                         В компиляторе HisoftC 4.x вместо этого можно
                         использовать символьную константу - эти же
                         четыре символа в апострофах.

   set()               - макрос для установки атрибута. Аргументы -
                         объект, атрибут и его значение.
   get()               - макрос для считывания атрибута. Аргументы -
                         объект, атрибут и указатель на переменную,
                         куда положить результат.

   Макросы развёртываются в SetAttrs() и GetAttr() соответственно.


6) Создание простейшего интерфейса.

   Интерфейс представляет собой дерево объектов.  Не путайте его с
упомянутым ранее деревом классов.  Каждый объект создаётся вызовом
функции MUI_NewObject().  Чтобы у объекта были дочерние объекты, в
списке тэгов указывается тэг Child, аргументом которого является
указатель на уже созданный дочерний объект.  Таким образом, создание
интерфейса ведётся от самых «мелких» объектов к самым крупным.
Крупные объекты содержат в себе (территориально) более мелкие и так
далее.  Окно содержит в себе группы объектов, те содержат в себе
кнопки, ещё группы и т.д. В общем случае дерево объектов типичного
приложения выглядит так:
                                  ­ЎЎЎЎЎЎЎЎЎЎЎЎЇ
                                  ў Приложение ў
                                  їЎЎЎЎЎѕЎЎЎЎЎЎґ
                                        ў
              ----ЎЎЎЎЎЎѕЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎµЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ
                        ў               ў                ў
                    ­ЎЎЎ¶ЎЎЇ        ­ЎЎЎ¶ЎЎЇ         ­ЎЎЎ¶ЎЎЇ
                    ў Окно ў        ў Окно ў         ў Окно ў
                    їЎЎЎѕЎЎґ        їЎЎЎѕЎЎґ         їЎЎЎѕЎЎґ
                        ў               ў                ў
                   ­ЎЎЎЎ¶ЎЎЎЇ           :                :
                   ў Группа ў
                   їЎЎЎЎѕЎЎЎґ  к вопросу о пользе псевдографики ;)
                        ў
         ­ЎЎЎЎЎЎЎЎЎЎЎЎѕЎ¶ЎЎЎЎЎЎЎЎѕЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ
         ў            ў          ў                 ў
  ­ЎЎЎЎЎЎ¶ЎЎЎЎЎЇ  ­ЎЎЎ¶ЎЎЎЎЇ ­ЎЎЎ¶ЎЎЎЇ         ­ЎЎЎ¶ЎЎЎЎЇ
  ў Поле ввода ў  ў Группа ў ў Текст ў         ў Группа ў
  їЎЎЎЎЎЎЎЎЎЎЎЎґ  їЎЎЎѕЎЎЎЎґ їЎЎЎЎЎЎЎґ         їЎЎЎѕЎЎЎЎґ
                      ў                            ў
       ----ЎЎЎЎЎѕЎЎЎЎЎ¶ЎЎЎЎЎЇ          ­ЎЎЎЎЎЎЎЎЎЎЎµЎЎЎЎЎЎЎ-----
                ў           ў          ў           ў
           ­ЎЎЎЎ¶ЎЎЎЇ   ­ЎЎЎ¶ЎЎЇ  ­ЎЎЎЎ¶ЎЎЎЇ   ­ЎЎЎ¶ЎЎЎЎЇ
           ў Список ў   ў Цикл ў  ў Список ў   ў Группа ў
           їЎЎЎЎЎЎЎЎґ   їЎЎЎЎЎЎґ  їЎЎЎЎЎЎЎЎґ   їЎЎЎѕЎЎЎЎґ
                                                   ў
                                             ­ЎЎЎЎЎ¶ЎЎЎЎЎЇ
                                             ў           ў
                                         ­ЎЎЎ¶ЎЎЎЎЇ  ­ЎЎЎ¶ЎЎЎЎЇ
                                         ў Кнопка ў  ў Кнопка ў
                                         їЎЎЎЎЎЎЎЎґ  їЎЎЎЎЎЎЎЎґ

   Для упрощения этого процесса применяется следующий подход (далее
примеры будут приводится на Си - но это не значит, что MUI может
программиться только на Си и не на чём больше).  Пишется функция,
создающая самый крупный объект - в случае MUI это объект Application.
В аргументах указывается набор её атрибутов, а также тэг SubWindow.
После него очередным аргументов MUI_NewObject() указывается ещё один
MUI_NewObject(), создающий окно.  В его аргументах ставится Child и
ещё вложенные MUI_NewObject(), создающие всё остальное.  Уровень
вложения в принципе не ограничен.  В итоге Си скомпилирует всё это в
последовательный вызов функций от «самых вложенных» до корневой
функции, подставляя результаты как аргументы функциям-«родителям».
   Очевидно, что при создании очередного объекта может случиться
ошибка - недоступен класс с таким именем, нехватка памяти, да мало ли
что ещё.  В таком случае MUI_NewObject() вернёт нуль.  Для этого в MUI
предусмотрен механизм следующего вида - если MUI_NewObject() получил в
качестве хотя бы одного из Child нуль, он выполняет
MUI_DisposeObject() над ненулевыми Child и возвращает нуль сам. В
итоге, ошибка всегда отслеживается.

   Разумеется, при первом взгляде на этот механизм может возникнуть
впечатление, что исходный текст в результате будет содержать множество
маловразумительных функций с кучей непонятных чисел в качестве
аргументов.  Для того, чтобы это не случилось, MUI комплектуется
набором макросов и констант, реализующий достаточно удобный «язык
описания интерфейса».

   Object *app, *window1, *button1;
   app = ApplicationObject,
     MUIA_Application_Title      , "Программа",
     MUIA_Application_Version    , "$VER: Программа 1.0 (дата)",
     MUIA_Application_Copyright  , "(C) 1999 Программинг Компэни",
     MUIA_Application_Author     , "Программист",
     MUIA_Application_Description, "Краткое описание программы",
     MUIA_Application_Base       , "РЕКС.ПОРТ.ПРОГРАММЫ",
     SubWindow, window1 = WindowObject,
       MUIA_Window_Title, "Программа",
       MUIA_Window_ID   , MAKE_ID('M','A','I','N'),
       WindowContents, button1 = SimpleButton("Нажми меня");
     End,
   End;

   Как видно в приведённом примере, вызовы функции MUI_NewObject() с
различными вариантами имён классов свёрнуты в макросы вида xxxObject,
а завершающие вызов функции TAG_END и скобка оформлены как макрос End.
Между началом и завершением функции размещаются тэги, представляющие
собой инициализацию атрибутов и указание дочерних объектов.  В итоге
описание интерфейса ведётся «лесенкой» - обычный для Си стиль
программирования.
   Часть из макросов содержат всю функцию сразу - например,
приведённый выше SimpleButton().  В этом случае End не требуется.

   Использовать этот интерфейс можно только в том случае, если в
результате его создания переменная app содержит не нуль.  А по
окончании работы с ним выполняем MUI_DisposeObject(app) - в этом
случае все дочерние объекты будут удалены автоматически.
   Удалять можно ТОЛЬКО объекты, которые не являются дочерними по
отношению к каким бы то ни было ещё объектам.

   В программе может быть и несколько объектов класса Application.
Например, это позволит открывать разные Application на разных экранах.


7) Компоновка объектов

   Если требуется что-то более сложное, чем рассмотренная ранее кнопка
в окне, нам потребуется использовать группы.

   Группа - это прямоугольный объект, который содержит другие объекты.
Группы могут быть трёх видов - горизонтальные, вертикальные, и
содержащие определённое количество колонок.  Объекты размещаются в
группе так же, как ячейки в таблице.  В ячейке группы может быть
размещена ещё одна группа - количество уровней вложения опять же не
ограничено.

   Рассмотрим в качестве примера создание файлового реквестора:

   ­ЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ
   ў                                       ў
   ў  ­ЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЇ ­ЎЎЎЎЎЎЇ  ў
   ў  ў C                (dir) ў ў dh0: ў  ў
   ў  ў Classes          (dir) ў ў dh1: ў  ў и ещё раз
   ў  ў Devs             (dir) ў ў dh2: ў  ў к вопросу
   ў  ў Expansion        (dir) ў ў df0: ў  ў о пользе
   ў  ў ...                    ў ў df1: ў  ў псевдографики
   ў  ў Trashcan.info    1.172 ў ў df2: ў  ў
   ў  ў Utilities.info     632 ў ў ram: ў  ў ;-)
   ў  ў WBStartup.info     632 ў ў rad: ў  ў
   ў  їЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎґ їЎЎЎЎЎЎґ  ў
   ў                                       ў
   ў  Путь: _____________________________  ў
   ў                                       ў
   ў  Файл: _____________________________  ў
   ў                                       ў
   ў  ­ЎЎЎЎЎЎЎЎЇ               ­ЎЎЎЎЎЎЎЎЇ  ў
   ў  ў Готово ў               ў Отмена ў  ў
   ў  їЎЎЎЎЎЎЎЎґ               їЎЎЎЎЎЎЎЎґ  ў
   ў                                       ў
   їЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎЎґ

   В этом случае мы имеем следующие объекты:  списки сверху справа и
слева, два поля ввода строки, и две кнопки снизу.  Нужно как-то
связать между собой все перечисленные объекты, чтобы они разместились
в окне в указанном виде.  Для этого два списка сверху и две кнопки
снизу объединяются в ГОРИЗОНТАЛЬНЫЕ ГРУППЫ.  Всё описанное
группируется в ВЕРТИКАЛЬНУЮ ГРУППУ.

   VGroup,
     Child, HGroup,
       Child, FileListview(), // Каталог
       Child, DeviceListview(), // Устройства
     End,
     Child, PathGadget(), // Путь
     Child, FileGadget(), // Файл
     Child, HGroup,
       Child, OkayButton(), // Готов
       Child, CancelButton(), // Отмена
     End,
   End;

   Группы с указанным количеством колонок (вертикальные группы - их
частный случай) записываются как ColGroup(количество_колонок) и имеют
следующее свойство: количество объектов должно быть обязательно равно
произведению количества столбцов и количества строк.

   Рассмотренный механизм в некоторой мере является аналогом таблиц
в HTML.  Кто знаком с HTML, может ознакомиться с Custom-классом
MCC_TableGroup, в котором сложные группы формируются более удобным
способом, практически идентичным механизму HTML-таблиц.


8) Компоновка объектов более подробно

   Объекты, размещаемые в группе, могут иметь ВЕС (MUIA_Weight).  Вес
- это число, характеризующее, какую часть общего пространства следует
выделить объекту.  Если вес объекта не указан, по умолчанию он
принимается равным 100.  Вес может быть указан раздельно по
горизонтали (MUIA_HorizWeight) и по вертикали (MUIA_VertWeight).
   Таким образом, если мы хотим иметь кнопку «Отмена» вдвое более
широкую, чем кнопка «Готово», нужно указать ей вес 200.

   Существует также способ расставлять объекты «вручную» - например,
для написания Web-браузеров, где расположение кнопок определяется
содержанием Web-страницы.  Для этого применяется атрибут
MUIA_LayoutHook класса Group.  При этом MUI будет вызывать указанную
функцию каждый раз перед размещением очередного объекта.

   Интервалы между объектами (spacing) определяются в настройках
интерфейса.  Если для конкретной задачи нужно установить определённый
интервал (например, для размещения ряда кнопок вплотную друг к другу),
группе с этими объектами указывается атрибут MUIA_Group_Spacing с
требуемым значением (в нашем примере - нуль).

   Есть возможность автоматического «исчезания» объекта, если он не
умещается в интерфейс (пример - надпись справа внизу в MCP Prefs).
Для этого указываются атрибуты MUIA_HorizDisappear (исчезание, если
объект не умещается по горизонтали) и MUIA_VertDisappear (по
вертикали).  Значение атрибута - «степень важности» объекта,
объекты с наибольшим значением исчезают в последнюю очередь.


9) Связывание объектов и обработка событий

   Корневым классом дерева классов MUI является класс Notify.  Именно
он предоставляет эту возможность.

   После создания дерева интерфейса над рядом объектов следует
выполнить метод Notify.  Для этого делается вызов следующего вида:

   DoMethod(объект1,MUIM_Notify,атрибут,значение,
            объект2,количество_аргументов,метод,...)

   объект1 - тот объект, изменение состояния которого мы собираемся
ослеживать.  После MUIM_Notify указывается отслеживаемый атрибут, и то
значение, при установке атрибута в которое срабатывает устанавливаемая
нами связь.

   объект2 - объект, над которым мы будем производить действие в
случае срабатывания связи.  Количество аргументов - константа,
указывающая, сколько ещё аргументов идёт после этой константы.  При
срабатывании связи может быть выполнен любой метод, в том числе метод
MUIM_Set, устанавливающий атрибут.

   К примеру, мы хотим, чтобы при всяком нажатии кнопки worst,
radio-button clock был установлен на первую позицию.  Для этого после
создания интерфейса выполняем:

   DoMethod(worst,MUIM_Notify,MUIA_Pressed,FALSE,
            clock,3,MUIM_Set,MUIA_Radio_Active,0);

   Обработка событий делается ровно так же. Есть несколько способов
получить информацию о событии. Приведём три из них - ReturnIDs,
Callback hook и Write Long.

   ReturnID представляет собой число, возвращаемое DoMethod() в
главном цикле MUI-программы.  Можно запрограммировать несколько таких
чисел на разные события, и в зависимости от числа выполнять разные
действия.  MUI уже предоставляет MUIV_Application_ReturnID_Quit,
который возвращается, в частности, при выполнении Remove из программы
Exchange (любое MUI приложение, если не указано иного, по умолчанию
является Commodity).  Если мы хотим получать тот же ReturnID при
нажатии на кнопку закрытия окна mainwin, пишем следующее:

   DoMethod(mainwin,MUIM_Notify,MUIA_Window_CloseRequest,TRUE,app,2,
     MUIM_Application_ReturnID,MUIV_Application_ReturnID_Quit);

     где app - объект Application.

   Callback hook представляет собой механизм вызова пользовательских
функций в случае возникновения событий.  Для этого выполняется
MUIM_CallHook с аргументом - указателем на структуру Hook.

   MUIM_WriteLong позволяет записать число по указанному адресу в
памяти.  Это позволяет отказаться от обслуживания событий от
элементов, задающих режимы работы, и только в нужный момент
проанализировать состояние указанных ячеек памяти.

   MUIM_WriteString  - то же самое для строк, а не лонгов.


10) Динамическая компоновка объектов

   В любой момент в процессе работы приложения есть возможность
динамически добавить или отобрать у какого-либо объекта его дочерние
объекты. Для этого существуют методы OM_ADDMEMBER и OM_REMMEMBER.
   Например, для добавления объекта - кнопки Delete к файловому
реквестору нужно выполнить

   DoMethod(group,OM_ADDMEMBER,SimpleButton("Удалить"));

   над группой, которая будет содержать эту кнопку.

   В процессе выполнения метода, если окно было открыто, интерфейс
перерисуется в реальном времени и к имеющимся кнопкам добавится новая.


11) Общий обзор реализации интерфейса

   Рассмотрим порядок действий, необходимых для построения минимальной
программы под MUI.

   а) открываем muimaster.library и intuition.library
      Intuition потребуется нам для get() и set().
   б) создаём объект Application.
   в) выполняем ряд вызовов DoMethod()
      Здесь нужно выполнить как минимум следующие действия:
      - установить связи
      - открыть окно (окна).
   г) выполняем метод MUIM_Application_NewInput над объектом
      Application, передав ему указатель на переменную sigs.
   д) проверяем результат, который возвратил DoMethod() - это нужный
      нам ReturnID.  Если это Quit - переходим на и)
   е) анализируем переменную sigs. Если она равна нулю - переходим
      обратно на пункт г)
   ж) если переменная sigs не равна нулю - sigs = Wait(sigs);
   з) возвращаемся на г)
   и) уничтожаем объект Application. Окна закрываются автоматически.
   к) закрываем библиотеки.


12) Доступные классы и их назначение

aboutmui.mui

   Представляет собой окошко, которое обычно выводится приложениями по
пункту меню «About MUI».

application.mui

   Приложение - корневой объект дерева, рассмотренного ранее.

area.mui

   Прямоугольная область. Это суперкласс практически всех классов MUI.
Имеет набор атрибутов типа размеров, координат и т.п., наследуемых
большинством остальных классов.

balance.mui

   Управляющий элемент для balancing groups.  Размещается в любом
месте интерфейса и позволяет, «хватаясь» за него мышкой, передвигать
его, меняя пропорции расположенных по сторонам от него объектов.

bitmap.mui

   Позволяет использовать картинку, описанную структурой Bitmap.

bodychunk.mui

   Позволяет использовать картинку в IFF ILBM формате.

boopsi.mui

   Интерфейс для использования любых BOOPSI классов в MUI интерфейсе,
в частности, ColorWheel, используемого при настройке цвета.

coloradjust.mui

   Элемент настройки цвета (на kickstart 3.0 использует ColorWheel).
Позволяет выбрать RGB и яркость.

colorfield.mui

   Индикатор цвета.  По мере возможности отображает в прямоугольнике
цвет, заданный компонентами RGB.  На ks 2.x будет чёрным.

cycle.mui

   Cycle gadget (кнопка с выбором варианта)

dataspace.mui

   Контейнер произвольной информации.  В частности, используется MUI
для хранения настроек.

dirlist.mui

   Список файлов.  Самостоятельно считывает директорию, показывает её
содержимое, позволяет выбирать строку.

family.mui

   Суперкласс для классов, оперирующих списком субклассов.
Используется для меню.

floattext.mui

   Субкласс класса list с возможностью форматирования абзацев по
правому краю.

gauge.mui

   Используется для progress-bar'ов.  Могут быть как горизонтальными,
так и вертикальными, и содержать строку.

group.mui

   Группа (описана ранее)

image.mui

   Произвольная картинка, в том числе из файла по заданному пути.
К сожалению, требует указывать жёстко заданное разрешение.

knob.mui

   Элемент типа регулятора громкости, вращаемого мышкой

levelmeter.mui

   Стрелочный индикатор

list.mui

   Список.  Обычно используется как дочерний объект у listview.

listview.mui

   Добавляет к списку управляющий скроллбар и обработку ввода.

menu.mui

   Объект представляет собой одно выпадающее меню (к примеру, меню
Project).

menuitem.mui

   Пункт выпадающего меню.

menustrip.mui

   Меню в целом (можно устанавливать enable/disable глобально).

notify.mui

   Суперкласс всех классов MUI. Обеспечивает связывание объектов,
обработку событий, а также ряд других полезных моментов.

numeric.mui

   Суперкласс для любых элементов, обеспечивающих работу с целыми
числами - например, для knob.mui.  Сам по себе не предоставляет
никаких средств GUI.

numericbutton.mui

   Кнопка выбора числа. Представляет собой slider, «свёрнутый» в
кнопку для экономии места.

palette.mui

   Полный набор элементов для настройки палитры.

popasl.mui

   Субкласс класса popstring, самостоятельно вызывающий asl.library
для реквесторов разного рода.  Создаёт дочерний процесс, благодаря
чему выполнение задачи при вызове реквестора не блокируется.

poplist.mui

   Выпадающий список произвольных объектов.

popobject.mui

   Позволяет создавать любые, выпадающие по нажатию кнопки объекты.

popstring.mui

   Суперкласс для выпадающих объектов.  Позволяет создавать список
строк и выбирать строку.

prop.mui

   Аналог propgadgets в intuition - движок, управляемый мышью.  Может
быть как горизонтальным, так и вертикальным.  Также может использовать
бордюры окон (как в Workbench).

radio.mui

   Radiobutton для выбора нескольких вариантов.

rectangle.mui

   «Пустое место» для дизайна интерфейса.  Может содержать
горизонтальную или вертикальную полосу-разделитель и надпись.

register.mui

   Умещает несколько объектов в одно и то же пространство с
возможностью выбора, какой из них показывать, с помощью «закладок».

scale.mui

   Процентная шкала (от 0 до 100%). Обычно используется для Gauge.

scrollbar.mui

   Набор из propgadget-а и двух кнопок со стрелками.

scrollgroup.mui

   Класс для поддержки горизонтальной и вертикальной прокрутки
«виртуальной» группы.  Пример - скроллинг окна в IBrowse.

semaphore.mui

   Семафор для разграничения доступа к dataspace от разных задач.

slider.mui

   Элемент для выбора числа с помощью «движка», управляемого мышью.

string.mui

   Поле ввода строки.

text.mui

   Надпись с различными возможностями оформления.

virtgroup.mui

   «Виртуальная» группа, которая может быть большего размера, чем
выделен для неё в интерфейсе.

volumelist.mui

   Список устройств.

window.mui

   Класс окна.


13) Язык описания интерфейса более подробно

   Для того, чтобы не писать каждый раз вручную вызов функции
MUI_NewObject() и имя класса, в mui.h определён набор макросов для
доступа ко всем имеющимся классам. Таким образом, строка типа

   классObject

   преобразуется в строку

   MUI_NewObject(класс

   Далее через запятые пишется taglist.  Для его завершения, как
упоминалось, используется макрос End, разворачивающийся в TAG_END).

   Разумеется, приведённым выше списком разнообразие элементов
интерфейса не ограничивается.  Например, MUI не имеет специального
класса «кнопка» - для этого обычно используется объект любого
субкласса (например, text.mui) класса Area, у которого устанавливается
атрибут MUIA_InputMode.  Таким образом кнопки могут содержать не
только надписи, но и любой практически произвольный набор объектов.

   Часто используемые элементы интерфейса имеют уже определённые
макросы с набором параметров, сразу задающие необходимые атрибуты.
К примеру, кнопка описывается как SimpleButton("надпись").
Все определённые элементы с описанием можно найти в файле mui.h.
   Там же определено множество других макросов, в частности, заранее
определённые атрибуты. Например, для указания типа рамки для кнопки
вместо MUIA_Frame, MUIV_Frame_Button достаточно написать ButtonFrame.


14) Пример простейшей программы

   Самый простой способ сделать первую программу под MUI - скомпилить
приведённый ниже исходник, «вьехать», как он работает, поменять и
сделать что-то своё.  Исходник по возможности прокомментирован.  Как
только этого варианта станет мало - изучайте исходники MUI Demos,
прилагаемых к архиву с документацией по MUI.
   Программа проверена под SAS/C 6.58 и Hisoft C 4.0.  В установках
необходимо выключить линковку со стартап-кодом.  Для Hisoft C нужно
добавить к проекту muistubs.lib.  Программа запускается из CLI.

#include <clib/exec_protos.h>
#include <clib/muimaster_protos.h>
#include <clib/dos_protos.h>
#include <clib/alib_protos.h>

#ifdef __SASC
#define VERDATE __AMIGADATE__
#include <pragmas/exec_sysbase_pragmas.h>
#include <pragmas/muimaster_pragmas.h>
#include <pragmas/dos_pragmas.h>
#define GetBaseReg()
#else
#define VERDATE "("__DATE2__")"
#include <pragma/exec_lib.h>
#include <pragma/muimaster_lib.h>
#include <pragma/dos_lib.h>
#include <linkerfunc.h>
#define __saveds
#endif

#include <libraries/mui.h>
#include <dos/dos.h>
#ifndef MAKE_ID
#define MAKE_ID(a,b,c,d) ((ULONG) (a)<<24 | (ULONG) (b)<<16\
                          | (ULONG) (c)<<8 | (ULONG) (d))
#endif

enum {
ReturnID_ButtonPressed = 1,
ReturnID_ButtonReleased,
ReturnID_StringEntered
};

struct Library *MUIMasterBase, *IntuitionBase, *DOSBase, *SysBase;

__saveds main()
{
 GetBaseReg(); // это для Hisoft C
 SysBase = *((struct Library **)4L); // SysBase в переменную
 if(DOSBase = OpenLibrary("dos.library",36))
 {
  if(IntuitionBase = OpenLibrary("intuition.library",39))
  {
   if(MUIMasterBase = OpenLibrary("muimaster.library",0))
   {
    Object *app, *win, *button, *string;
    if(app = ApplicationObject,
     MUIA_Application_Title, "Программа",
     MUIA_Application_Version, "$VER: Программа 1.0 "VERDATE,
     MUIA_Application_Copyright, "(C) 1999 Программинг Компэни",
     MUIA_Application_Author, "Программист",
     MUIA_Application_Description, "Просто какая-то программа",
     MUIA_Application_Base,"PROGRAM",
     SubWindow, win = WindowObject,
      MUIA_Window_Title, "Программа",
      MUIA_Window_ID, MAKE_ID('M','A','I','N'),
      WindowContents, VGroup,
       Child, button = SimpleButton("Нажми меня"),
       Child, string = String("Введите текст",40),
      End,
     End,
    End)
    {
     unsigned long id, sigs = 0;
     // Открываем окно
     set(win,MUIA_Window_Open,TRUE);
     // устанавливаем связь между нажатием на кнопку закрывания
     // окна и выходом из программы
     DoMethod(win,MUIM_Notify,MUIA_Window_CloseRequest,TRUE,app,2,
      MUIM_Application_ReturnID,MUIV_Application_ReturnID_Quit);
     // связь между нажатием кнопки и возвратом результата
     DoMethod(button,MUIM_Notify,MUIA_Pressed,TRUE,
      app,2,MUIM_Application_ReturnID,ReturnID_ButtonPressed);
     // связь между отпусканием кнопки и возвратом результата
     DoMethod(button,MUIM_Notify,MUIA_Pressed,FALSE,
      app,2,MUIM_Application_ReturnID,ReturnID_ButtonReleased);
     // связь между вводом строки и возвратом результата
     DoMethod(string,MUIM_Notify,MUIA_String_Acknowledge,
      MUIV_EveryTime, // при всяком изменении состояния атрибута
      app,2,MUIM_Application_ReturnID,ReturnID_StringEntered);
     // ожидаем события
     while((id = DoMethod(app,MUIM_Application_NewInput,&sigs))
     != MUIV_Application_ReturnID_Quit)
     {
      switch(id) // проверяем возвращённый нам ReturnID
      {
       case ReturnID_ButtonPressed:
        Printf("Вы нажали кнопку\n"); break;
       case ReturnID_ButtonReleased:
        Printf("Вы отпустили кнопку\n"); break;
       case ReturnID_StringEntered:
       {
        STRPTR res;
        // считываем указатель на строку в переменную
        get(string,MUIA_String_Contents,&res);
        Printf("Вы ввели что-то типа <<%s>>\n",res);
        break;
       }
      }
      if (sigs)
      {
       // ожидаем сигнала
       sigs = Wait(sigs | SIGBREAKF_CTRL_C);
       // если нажали CTRL+C - выходим
       if (sigs & SIGBREAKF_CTRL_C) break;
      }
     }
     MUI_DisposeObject(app);
    }
    CloseLibrary(MUIMasterBase);
   }
   CloseLibrary(IntuitionBase);
  }
  CloseLibrary(DOSBase);
 }
}


15) Некоторые важные моменты

   Важное замечание относительно выше приведённого примера.  Принято
делать реакцию на ОТПУСКАНИЕ, а не на НАЖАТИЕ кнопки - для того, чтобы
пользователь в последний момент смог отказаться от нажатия, и чтобы
нажатие не произошло случайно.  Обработка нажатия приведена лишь для
того, чтобы проиллюстрировать такую возможность.

   MUI работает в контексте вызывающей задачи.  Это означает, что
программа обязана за минимальное время отреагировать на любое
случившиеся событие.  Если программа отвлекается на отработку
какого-либо действия (например, читает в память очень большой файл),
то интерфейс «умирает», на время превращаясь в статическую картинку
(что можно наблюдать, например, в YAM при ожидании ответа сервера).
   Есть два способа, как это обойти.  Первый способ сводится к тому,
что во время длительного действия (к примеру, архивации) время от
времени проверять, не поступили ли какие-либо сигналы).  Второй способ
- создать дочерний процесс и поручить работу ему, обмениваясь с ним
сообщениями.

   После создания интерфейса ОБЯЗАТЕЛЬНО необходимо проверить, будут
ли окна программы умещаться на экран 640x200 при фонтах 8x8 - это
общее правило для всех программ, и MUI тут не исключение.  Если окно
не влезает в экран, MUI попытается заменить шрифты на Helvetica/9, а
если и это не поможет, то окно попросту не откроется.  Работа с не
открытым окном не является ошибкой, все операции при этом валидны -
но, очевидно, никакого взаимодействия с пользователем при этом не
будет.  Чтобы избежать этой ситуации, проверяйте MUIA_Window_Open.


16) Custom classes и зачем они нужны

   Custom-классы применяются в тех случаях, когда стандартного набора
классов MUI начинает не хватать.  Например, если нужен элемент
интерфейса с хитрым векторным изображением.
   Custom-классы бывают двух видов - public и private.

   Public custom class представляет собой библиотеку, которая обычно
кладётся в mui:libs.  Они имеют имена, оканчивающиеся не на «.mui», а
на «.mcc» (MuiCustomClass).  Работа с ними по сути не отличается от
работы со стандартным набором классов.  Многие классы имеют свои
собственные настройки, которые добавляются в список настроек MUI Prefs
- эти настройки тоже представляют собой библиотеку, которая кладётся в
mui:libs и оканчиваются на «.mcp» (не путайте с программой MCP).

   Private custom class существует только в пределах Вашей программы.
Фактически это всего лишь одна функция - так называемый диспетчер
класса.  Эта функция получает управление всякий раз, когда выполняется
какой-либо метод, и получает в качестве аргумента кроме всего прочего
указатели на объект и на выполняемый метод.  Часть методов и атрибутов
класс обрабатывает сам, всё остальное, про что он не знает, он просто
передаёт «вышестоящему» классу функцией DoSuperMethod().
   Поскольку у private-класса нет имени, объекты этого класса
создаются вызовом не MUI_NewObject(), а NewObject() из Intuition.

   В качестве примера смотрите исходники MUI Demos (Class#?.c).


17) Не рассмотренные ранее функции muimaster.library

MUI_SetError()
MUI_Error()

   Устаревшие функции, вместо них рекомендуется применять SetIOErr() и
IOErr() dos.library.

MUI_AllocAslRequest()
MUI_AslRequest()
MUI_FreeAslRequest()

   Интерфейс к asl.library.  В MUI-программах необходимо использовать
именно эти функции вместо функций asl.library, reqtools.library etc -
поскольку в данном случае MUI имеет возможность обрабатывать,
например, сворачивание программы в иконку, закрывая все окна.

MUI_CreateCustomClass()
MUI_DeleteCustomClass()

   Регистрация и удаление custom-классов - как private, так и public
(в последнем случае вызываются из служебных функций библиотеки).
При создании класса передаётся указатель на функцию-диспетчер, базу
библиотеки для public классов, суперкласс, и размер data-структуры.

MUI_FreeClass()
MUI_GetClass()

   Устаревшие функции, вместо них применяйте вышеупомянутые.

MUI_MakeObjectA()

   Аналог MUI_NewObject().  Отличается более компактным вызовом -
функции передаётся КОД создаваемого объекта (не строка!) и набор
параметров (не taglist!), специфичный для объекта.  Создаёт ряд
заранее определённых объектов, в основном используется в макросах,
определённых в mui.h.
   Любой вызов данной функции можно заменть аналогичным вызовом
MUI_NewObject(), но не наоборот.

MUI_ObtainPen()
MUI_ReleasePen()

   Аналоги функций graphics.library (доступных только на v39+), но
работают и на v36.

MUI_Redraw()

   Функция вызывается ТОЛЬКО из custom classes.  Назначение следующее:
если в какой-то момент времени объект нужно перерисовать (например,
изменились атрибуты), вместо рисования его класс должен вызвать эту
функцию.  MUI произведёт расчёт всех необходимых координат и областей
отсечения (для virtual-групп), после чего выполнит метод MUIM_Draw.
   Рисование в окно можно выполнять ТОЛЬКО при получении MUIM_Draw!

MUI_Request()

   MUI-реквестер, аналог EasyRequest().  Вызов MUI_Request() блокирует
обработку интерфейса.

MUI_RejectIDCMP()
MUI_RequestIDCMP()

   Функции для custom-классов.  Используются классами, обрабатывающими
ввод - события от клавиатуры и мыши.  Поскольку далеко не всем
объектам требуется обработка ввода, для уменьшения накладных расходов
на «широковещательную» рассылку событий эти события рассылаются только
запросившим их классам.
   Запрашивать весьма критичные по времени события (IDCMP_INTUITICKS,
IDCMP_MOUSEMOVE) имеет смысл только на то время, пока они требуются.


18) Более подробно о custom-классах

   MUI работает с объектами различных классов путём выполнения
специфичного набора методов.  Часть из методов обязательно должна быть
реализована в любом custom-классе, остальные же необязательны.
   Как любой BOOPSI объект, MUI-объект создаётся выполнением метода
OM_NEW.  Поскольку объекты в MUI создаются от более мелких к более
крупным, к моменту создания объект ещё ничего не «знает» о свойствах
дисплея.
   Когда все объекты созданы, MUI выполняет метод MUIM_Setup, рассылая
объектам информацию о экране, шрифтах и т.п.  Окон на этот момент ещё
не существует.
   Следующий метод, рассылаемый MUI - MUIM_AskMinMax.  Это запрос
объекта о его размерах - максимальном, минимальном и по умолчанию.
Выполнение этого метода обязательно, если Вы не хотите получить
прямоугольник нулевого размера ;)
   После расчёта всех положений и координат MUI готов к открытию окна.
Как только окно открыто, MUI рассылает метод MUIM_Show, говорящий о
существовании окна.  MUIM_Show - это ещё не команда нарисовать что-то
в окне.  Обычно он используется для добавления Intuition gadgets к
окну.
   И наконец, метод MUIM_Draw говорит о том, что нужно приступить к
рисованию.  Всякое получение MUIM_Draw должно запустить перерисовку
объекта - она требуется не только при открытии окна, но и при рефреше,
а также при необходимости отобразить следующую фазу у ряда элементов
интерфейса (к примеру, следующий кадр видео в окне).
   Когда изменяется размер окна, MUI последовательно выполняет
MUIM_Hide, MUIM_Show и MUIM_Draw.

   При завершении работы всё производится в обратном порядке.  Перед
закрытием окна выполняются MUIM_Hide.  Если нужно выйти из программы,
или просто перенести её на другой экран - выполняется MUIM_Cleanup.
   Последнее, что получит объект - OM_DISPOSE.

   Всю последовательность действий можно представить следующим
образом.  Заключённые в фигурные скобки фрагменты являются циклами -
могут выполняться один раз и более, а могут и не выполниться вообще

   OM_NEW; // здесь Вы ещё ничего не знаете о дисплейном окружении
   {
     MUIM_Setup; // информация о дисплее
     MUIM_AskMinMax; // опрос размеров
     // здесь открывается окно
     {
       MUIM_Show; // добавить к окну, ещё не рисовать
       {
          MUIM_Draw; // нарисовать
       }
       MUIM_Hide; // удалить из окна
     }
     // здесь окно закрывается
     MUIM_Cleanup; // освобождаем все дисплейно-зависимые данные
   }
   OM_DISPOSE; // уничтожаем объект


   [to be continued]

