@database "8052 AH-BASIC.guide"
@$VER: "8052 AH-BASIC.guide (31.05.96)"
@author "Andreas Heinrich"
@(c) "© 1996 by Andreas Heinrich"
@font topaz.font 8
##

##
##      INHALT
##
@node Main "8052 AH-BASIC Entwicklungs-Paket"

                    @{b}8052 AH-BASIC Entwicklungs-Paket@{ub}

                          von Andreas Heinrich

                     Erstveröffentlicht am  1. August 1994
                     2. Update          am 31. Mai    1996

                     @{" Was ist Neu ? " link Neu}

        @{b}Inhaltsverzeichnis@{ub}

        @{" Copyright und Vertrieb " link Copyright}  @{" Warnung ! Bitte lesen. " link Warn}

           @{" Einleitung " link Einleitung}  und  @{" Was ist 8052 AH-BASIC ? " link Wasist}

           @{" Die Hardware / Prozessorboard " link HardwarePro}
           @{" Die Hardware / IN_OUT-Board " link HardwareIO}
           @{" Die Hardware / Meßwertgeber " link HardwareMeß}
           @{" Bauanleitung " link Bauanleitung}

           @{" 8052 AH-Basic-Terminal 2.2 " link Terminal}

           @{" Das I2C-Interface und die Software " link I2C}

           @{" BASIC - Befehle " link BASIC}
           @{" Demoprogramme " link Demos}
           @{" Tips zur EPROMprogrammierung " link Tips}

           @{" Adresse des Autors " link Kontakt}
@endnode

##
##      Neu
##
@node Neu "Was ist Neu ?"

   Zum Terminal-Programm:

1. Das Terminal-Programm > 8052 AH-Basic-Terminal 2.2 < wurde von
   einigen Fehlern befreit, die sich bei Systemen mit 68000er
   Standard-Prozessor ( A500&A600 ) und nur vorhandenen Chip-Ram
   bemerkbar machten.
   Dieses war folgendermaßen:
   Beim holen von Listings konnte es vorkommen, daß das Programm in 
   einer Endlosschleife hängen blieb. Durch umschreiben der betreffenden
   Routinen konnte das Timer.device anders angesprochen werden.
   
2. Außerdem werden nun ASL-Filerequester verwendet, die aber WB 2.+
   voraussetzen. (Unter Kick 1.3 läuft das Terminal-Programm nicht mehr.) 
   Kick 1.3 Anwender müssen auf den "Old-Stuff" zurückgreifen und 
   Amos-Basic bzw. die anderen älteren Versionen verwenden.

3. Beim holen von Listings wird nun die aktuell geholte Zeile angezeigt.
   Bisher wurde nur "Hole das Listing. Bitte warten..." ausgegeben.
   Dadurch kann die Übertragung besser überwacht werden.

4. Nach wochenlangen ( monatelangen ? ) herumprobieren auf einer
   XT-Karte(!) unter MS-Dos 6.0 und unter Zuhilfenahme von drei 
   verschiedenen Assemblern ist es mir gelungen, I2C-Treibersoftware 
   für das 8052 AH-Basic zu schreiben. 
   Diese Treibersoftware lief in einem mehrwöchigen Dauertest, wobei
   die verschiedensten Zusammenstellungen der Module getestet wurden.
       
   Zum I2C-Bus und der Treibersoftware:
   
   Hier handelt es sich um Maschinenspracheprogramme die in einen 
   geschützten oberen Bereich des Rams geladen werden und die die
   einfache Steuerung von I2C-Modulen ermöglicht.
   
5. Diese Module sind zur Zeit ein A/D-D/A-Wandler, eine batteriegestützte
   Echtzeituhr mit 256 Byte Ram, ein 8 Bit I/O-Baustein und eine
   4 Digit LED-Anzeige. 
   Diese ganzen Module lassen sich ganz einfach aus dem Basic ansprechen.

   Um die Zahlungsmoral etwas anzuheben ist in dieser Veröffentlichung
   nur der I2C-Ausgabe-Treiber verfügbar.
   
   Bereits registrierte Anwender können die Software für 15.- DM bekommen
   und evtl. zusätzliche Platinen mit dem Registrierungsformular bestellen.  

   Weiteres zum @{" I2C-Interface und der Software " link I2C}.
   
@endnode

##
##      COPYRIGHT
##
@node Copyright "Copyright und Vertrieb"

   Dieses 8052 AH-Basic Entwicklungspaket mit 8052 AH-Basic-Terminal 2.2
     (das ausführbare Programm, Anleitung), der I2C-Treiberssoftware: 
     I2C_Treiber_IO.bas Version 1.0 bzw. I2C_Treiber_O.bas Version 1.0, 
       sowie die Platinenlayouts mit dazugehörigen Bauanleitungen &
                Bauteillisten & Basiclistings & Texten sind
                
          Copyright © 1993, 1994, 1995, 1996 von Andreas Heinrich.

                         Alle Rechte Vorbehalten.


   Die Bauanleitungen, Schaltpläne, Platinenlayouts und Bauteillisten
   wurden aus Standardaplikationen zusammengetragen, verbessert,
   optimiert und erweitert.
   Soweit mir bekannt ist lagen für die Standardaplikationen keine
   Copyrights vor.

   Die Firma Intel hat das Copyright auf den MCS-52-Basic-Interpreter.

   Deshalb müssen die Copyrightbestimmungen beim kopieren des Interpreters
   in ein EPROM beachtet werden.

   Dieses Entwicklungspaket ist Shareware und kann frei kopiert und
   weitergegeben werden. Sollte das Paket in einer FD-Serie aufgenommen
   werden, darf der Preis pro Einzeldisk nicht höher als 10.- DM sein.

   Bei Gefallen und Benutzung des Pakets ist allerdings eine Shareware-
   gebühr von 35.- DM an mich zu zahlen. Registrierte Anwender bekommen
   dann von mir die Platinenlayouts und die Bestückungspläne zugesandt.
   Außerdem können diese registrierten Anwendern die fertig geätzten
   Platinen über mich beziehen.
   ( Alle Platinen müssen allerdings noch gebohrt werden.)
   
   Die aktuellen Preise sind auf dem Registrierungsformular zu finden.
 
   Die vollständige I2C-Treibersoftware gehört selbstverständlich auch dazu.
   
   Durch die Zahlung der Shareware ist allerdings nur der Gebrauch im
   privaten Bereich erlaubt.
   Die kommerzielle Nutzung des Pakets und der Software bedarf einer
   gesonderten Vereinbarung mit dem Autor. 


Siehe auch: @{" Adresse des Autors " link Kontakt}.
@endnode

##
##      EINLEITUNG
##
@node Einleitung "Einleitung"

Was beim C 64 der Userport war, ist beim Amiga der .?.?.?...

Der Amiga hat zwar verschiedene Schnittstellen zur Außenwelt, die sich vom
Rechnertyp mehr oder weniger unterscheiden, aber meistens lassen sich diese
nur schwer programmieren und / oder der Hardwareaufwand wird zu aufwendig.

Wie die Steuerung über den Parallelport geht, veröffentlichte ich mit dem
Schaltungsaufbau des @{" IN-OUT-BOARDS " link Bildergalerie/IN-OUT_Layout.ilbm/main} . Leider hat der Amiga (meistens) nur
einen Parallelport und dieser ist dann auch noch mit dem Drucker belegt.
Es bleibt einem dann also nichts anderes übrig, als ewig hinten am Rechner
die Stecker umzutauschen oder einen Dataswitch zu benutzen.

Bei dieser anderen Lösung mit dem 8052 AH-BASIC-Prozessor wird nun der
Seriellport benutzt. Sofern man kein Modem oder etwas anderes am Serialport
hat, kann nun die Verbindung "dauerhaft" hergestellt werden. Da der Serial-
port auch weniger empfindlich ist, lassen sich nun Verbindungen von
etlichen Metern in zweiadrigen abgeschirmten Kabel herstellen.
Mit RS 232 Treiber sind sogar mehrere hundert Meter möglich.
Auch ist die Hardware mit anderen Rechnern zu betreiben. Nur ein serieller
Port ( RS 232 ) und eine Terminalsoftware muß vorhanden sein.

Da mit dieser Hardware ein intelligentes System zum Regeln und Steuern
zu realisieren ist, sind bestimmt auch die abenteuerlichsten Sachen zu
verwirklichen. Zwar wird nun der Hardwareaufwand ein wenig aufwendiger,
aber dafür hat man ein eigenständiges System, wobei der Amiga nicht ständig
eingeschaltet sein braucht.
Die @{" Demoprogramme " link Demos} verdeutlichen diesen Vorteil.

Hier nun ein Beispiel anhand einer Wetterstation:

Das externe System sammelt zu verschiedenen Tageszeiten die Meßdaten von
Gebern, die die Temperatur und Helligkeit messen. Einmal am Tag oder in der
Woche (kommt auf die Größe der Daten an) holt man sich über die serielle
Schnittstelle die gesammelten Daten und wertet diese aus. Oder das externe
System schaltet selbst den Amiga an und das Programm, das in der User-
Startup eingefügt wurde wird ausgeführt.

Oder noch ein Beispiel:

Steuerung der Vorlauftemperatur bei einem Heizkessel. Aus der Außentemper-
atur wird die optimale Vorlauftemperatur ausgerechnet. Die Temperatur wird
durch Ein und Ausschalten mit Relais des elektrischen Magnetventils
geregelt. Zuerst wird die optimale Temperaturkurve auf dem Amiga
ausgerechnet und in ein Programm an das externe System übertragen. Hier
kann nun die Software über einen längeren Zeitraum getestet werden und
wenn alles zur Zufriedenheit läuft in das EPROM gebrannt werden. Danach
kann die serielle Verbindung unterbrochen werden und das System arbeitet
völlig selbstständig.

Diese beiden Beispiele sollen eigentlich nur Denkanstöße für eigene
Entwicklungen geben und die Möglichkeiten aufzeigen.

Siehe auch: @{" Was ist 8052 AH-BASIC ? " link Wasist}
@endnode


##
##      WAS IST 8052 AH-BASIC
##
@node Wasist "Was ist 8052 AH-BASIC ?"

Der 8052 AH-BASIC ist ein Basicprogrammierbarer Mikrokontroller der dem
Mikrokontroller des 8052 von Intel ähnlich ist. Der Unterschied liegt
darin, daß dieser in einem 8 KB großen ROM einen Basicinterpreter
integriert hat. Mußten vorher Mikrokontroller mühsam mit Hilfe aufwendiger
und kostspieliger Entwicklungssysteme in Maschinensprache programmiert
werden, kann man nun dieses in einem speziellen Dialekt der Hochsprache
Basic tun. Das Basic-Programm wird in einem externen RAM oder EPROM
gespeichert und startet auf Wunsch automatisch beim Einschalten der
Betriebsspannung bzw. eines Resets. Auch ist es möglich den Interpreter
auszulesen und diesen in das EPROM zu brennen. So kann statt des
8052 AH-BASIC der wesentlich billigere 80C32 verwendet werden, der strom-
sparender und höher taktbar ist (max. 32 MHZ).
Wie schon erwähnt, wird der Kontroller in einer speziell für diesen Zweck
zugeschnittenen Variante der Sprache Basic programmiert; der Anwender
braucht sich nicht in die Abgründe der Maschinensprache zu begeben, um ihn
als programmierbare elektronische Steuerung einzusetzen.
Ich kann in dieser Anleitung eigentlich nur das Wichtigste vermitteln.
Wer mehr über dieses Basic erfahren möchte und mehr aus dem Prozessor
herausholen will, empfehle ich das Buch 8052 AH-BASIC aus dem Elektor-
Verlag. ( ISBN 3-921608-72-4 ) Preis zur Zeit 48.- DM.
( Es gibt eine erweiterte Neuauflage des Buches zum Preis von 58.-DM )

Siehe auch: @{" Basic-Befehle " link BASIC}

@endnode

##
##      WARNUNG
##
@node Warn "Warnung"

   Achtung!!!Achtung!!!Achtung!!!Achtung!!!Achtung!!!Achtung!!!Achtung


   Obwohl der Aufbau der Hardware eigentlich keine Schwierigkeiten
   bereiten sollte, muß ich allerdings noch dieses schreiben:


   Der Aufbau und die Inbetriebnahme der Hard und Software erfolgt auf
   eigene Gefahr und für etwaige Schäden wird keine Haftung übernommen.


               ( Das soll aber keine Abschreckung sein.)

@endnode

##
##      DIE HARDWARE / Prozessorboard
##
@node HardwarePro "Die Hardware / Prozessorboard"

Um den einfachen Nachbau zu verwirklichen, wird das @{" Prozessorboard " link Bildergalerie/Prozessorboard.ilbm/main} auf
einer einseitigen Europakarte 100*160 mm aufgebaut. Der Prozessor läßt
sich, wie schon erwähnt in Basic programmieren. Aber auch Assembler oder
beides ist möglich.
Das System ist mit 32 KB-EPROM und 32 KB-RAM aufgebaut.
Der RAM-Bereich erstreckt sich von Adresse 0000 Hex - 7FFF Hex.
Der Speicherinhalt des RAM's kann durch eine Back-Up-Batterie gesichert
werden. Allerdings ist dann eine Programmieranweisung im EPROM notwendig.
Denn bei einem Neueinschalten bzw. Reset macht der Interpreter einen
Selbsttest, wobei im RAM stehende Programme überschrieben werden.
Siehe auch unter Basicbefehle >@{" PROG4 " link PROG4}<.
Der ROM (EPROM) - Bereich ist in zwei 16 KB große Blöcke geteilt.
Im oberen Bereich von 8000 Hex - BFFF Hex können eigene Basicprogramme
gebrannt werden. Im unteren Bereich von 0000 Hex - 1FFF Hex kann der
Interpreter kopiert werden. Allerdings ist aufgrund des Hardwareaufbaus
zum programmieren ein Adaptersockel notwendig.
Siehe auch unter:@{" Tips zur EPROMprogrammierung " link Tips}
Die EPROM-Programmierhardware ist auf der Platine integriert.
Die Schaltung braucht eine Versorgungsspannung von mindestens 16 Volt,
damit eine Programmierspannung von 12,5 Volt erzeugt werden kann.
Wird der EPROMer nicht benötigt kann die Spannung zwischen 8 - 12 Volt
liegen. Die Stromaufnahme mit dem Original-Prozessor ist ca. 400 mA.
Mit der CMOS-Version 80C32 ungefähr die Hälfte. Der Original-Prozessor
kann bis ca. 15 MHZ getaktet werden. Aus Sicherheitsgründen (Überhitzung)
sollten nur 12 MHZ Quarze verwendet werden. Anders sieht es bei der CMOS
Variante aus; hier sind 24 MHZ und mehr möglich. Allerdings schaffen nur
einige Exemplare 32 MHZ. Um Schwingungen zu vermeiden, muß ab 20 MHZ eine
Festinduktivität von 1,5 µH an den Quarz gelötet werden.
Diese Festinduktivität sollte allerdings nur beim 80C32 verwendet werden.
( Beim Original-Prozessor schwingt sonst der Quarz nicht an. )
Der Prozessor hat einen bidirektionalen Port -> Anschlüsse P1.0-P1.7.
Die Ausgänge davon sind mit Schutzwiderständen von 2,7 K bestückt. Diese
begrenzen bei Programmierfehlern den Strom und der Prozessor ist somit
geschützt. Über diesen Port kann die Ein und Ausgabe erfolgen z.B. Relais,
Leuchtdioden angesteuert oder eine Tastatur / Schalter abgefragt werden.
Außerdem kann mit den Anschlüssen P1.6 & P1.7 an diesen Port ein I2C-Bus-
Interface realisiert werden. Siehe auch @{" Prozessorboard ändern " link Änd} .
Mit diesen einem Ein-Ausgabeport läßt sich schon viel anfangen. Wenn das
aber nicht ausreicht, kann mit 18 pol.IC-Steckverbindern und Flachbandkabel
die Verbindung zur IN_OUT-Platine hergestellt werden.

Siehe auch: @{" Hardware / IN_OUT-Board " link HardwareIO}

@endnode

##
##      Die Hardware / IN_OUT-Board
##
@node HardwareIO "Die Hardware / IN_OUT-Board"
Auch hier wurde um den einfachen Nachbau zu verwirklichen, das 
@{" IN_OUT-Board " link Bildergalerie/In_Out-Platine.ilbm/main} auf einer einseitigen Europakarte 100*160 mm aufgebaut.
Auf dieser befinden sich zusätzlich 4 8-Bit-Ausgabe-Ports, 2 8-Bit-Eingabe-
Ports, ein achtfacher Multiplex - Frequenzeingang und eine Hilfsschaltung
für ein @{" LCD-Display " link Bildergalerie/LCD-Display.ilbm/main}. Theoretisch läßt sich das LCD-Display auch direkt
über den Datenbus ansteuern.  Leider gab es manchmal Timing-Probleme,
so daß ich für die Ansteuerung zwei Ausgabe-Ports heranziehe.
Das kommt auch der Betriebssicherheit zu gute.
Mit einem anderen Ausgabe-Port wird ein 8-Fach Multiplexer angesteuert.
An diesen können Meßwertgeber für Temperatur / Lichtmessung usw.
angeschlossen werden.

Weiteres dazu bei den @{" Demoprogrammen " link Demos}
und unter @{" Die Hardware / Meßwertgeber " link HardwareMeß}

Werden nicht alle Ports gebraucht, oder kann z.B. auf das LCD-Display ect.
verzichtet werden, kann das entsprechende IC / Bauteil entfallen.
Der IN / OUT Bereich erstreckt sich von Adresse C000 Hex - FFFF Hex.
In Anspruch genommen durch das IN_OUT-Board werden nur die Adressen
C000 Hex - C005 Hex. Also bleibt für eigene Erweiterungen genügend freier
Adressraum.

Neues:

Auf der Platine wurde noch der @{" WatchDog " link WatchDog} und eine Zusatzschaltung für ein
@{" 625 Hertz " link Bildergalerie/625_Hertz.ilbm/main} Rechtecksignal integriert. Dieses 625 Hertz Signal ist zum
decodieren des @{" DCF " link DCF} - Funkuhr-Signals notwendig. Das DCF-Funkuhr-Empfangs-
modul gibt ein Signal mit den Impulslängen von 100 ms bzw. 200 ms ab, das
an den Interrupt Eingang INT1 gelegt wird. Entweder auf der Prozessor-
oder der IN_OUT-Platine. Das 625 Hertz Signal kommt an den Frequenzein-
gang 8 oder direkt an T1, wenn gar keine IN_OUT-Platine angeschlossen ist.
Geeicht auf 625 Hertz wird mit einem Frequenzzähler oder dem Programm
Multiplex. Hier dauert allerdings ein kompletter Durchlauf 8 Sekunden,
so daß man immer eine kleine Pause zwischen einem Abgleich machen muß.

Ein passendes Empfangsmodul kostet ca. 30 DM und ist zum Beispiel bei
Conrad electronic oder Westfalia Technica erhältlich.


@endnode

##
##      WatchDog
##
@node WatchDog "WatchDog - Schaltung"

Die WatchDog - Schaltung:

Die Resetschaltung, im Fachjargon auch @{" WatchDog " link Bildergalerie/WatchDog.ilbm/main} genannt, wirkt auf den
Resetanschluß des Prozessors. Solange am Resetanschluß 0 Volt anliegt,
ist die CPU inaktiv und führt keine Programmbefehle aus. Wechselt das
Potential von 0 auf 5 Volt, so startet der Prozessor den Programmablauf
ab der Adresse 0000H. Durch kurze (oder auch längere) negative Impulse
kann man somit hardwaremäßig den Prozessor zwingen, an der Adresse
0000H die Programmausführung neu zu beginnen.
Die Resetschaltung dient als Einschalt - Reset bei Spannungs-
einbrüchen oder -ausfällen, wozu auch das Ein- und Ausschalten des
Gerätes zählt. Sobald die Versorgungsspannung einen kritischen Wert
unterschreitet (oder beim Einschalten die notwendige Spannung noch
nicht erreicht ist), wird die Resetleitung auf 0 Volt gelegt.
Zum zweiten wird der Prozessor durch die Resetschaltung auf einwand-
freie Programmbearbeitung überwacht. Mittels regelmäßiger Impulse,
die - gleichgerichtet - einen Kondensator aufladen, muß der Prozessor
anzeigen, das er normal arbeitet. Bei fehlenden Impulsen entlädt sich
der Kondensator und die Resetschaltung gibt einen negativen Impuls ab,
worauf der Prozessor zur Adresse 0000H springt und das Programm an
definierter Stelle neu anläuft. Diese zweite Funktion ist der eigent-
liche "Watch-Dog", wogegen das Erste ein Einschalt-Reset ist.
Besonders einfach und elegant läßt sich diese Resetschaltung mit dem
IC TL 7705 verwirklichen. Die entsprechende Schaltung ist in der
"Bildergalerie" zu sehen. Das IC hat intern bereits eine Spannungs-
überwachung die unterhalb 4,55 Volt den Reset-Ausgang nullt. Der
Resin-Eingang hat seine Umschaltschwelle bei 0,8 Volt, unterhalb dieser
Spannung wird ein Reset ausgegeben. Durch die Rückkopplung mittels dem
100 K-Widerstand von Resin + nach Resin - wird erreicht, daß sich die
Schaltung kurzfristig selbst zurücksetzt und somit dem Prozessor Zeit
gibt, das Programm zu starten, denn bei einem Reset wird Reset +
positiv und lädt damit den 4,7 µF-Kondensator auf, welcher wiederum
bewirkt, daß die Resetleitung auf "High" schaltet. Somit kann der
Prozessor sein Programm starten und gibt in regelmäßigen Abständen
eine Rechteckspannung an den 0,1 µF-Kondensator. Diese wechselnde
Spannung wird mittels der Diode gleichgerichtet und lädt so den
Kondensator am Resin - auf. Dabei werden ca. 2 Volt erreicht. Der 750 k
Widerstand, sowie das Trimmpoti 2,5 M sorgen für eine stetige Entladung
so daß der Prozessor darauf achten muß, daß der Kondensator stets auf-
geladen ist. Zur Ansteuerung eignet sich z.B. D7 (Adresse 0C001H) auf
der IN_OUT-Platine. Mit diesem Bit wird dann das LCD-Display und der
WatchDog gleichzeitig bedient.

Programmierbeispiel:
Man @{" verschaltet " link Bildergalerie/WatchDog_Schalter.ilbm/main} den WatchDog wie in der Bidergalerie angegeben auf der
IN_OUT-Platine und lädt das Programm Uhrzeit_3.bas in den Interpreter.
Der Kippschalter sollte natürlich geöffnet sein, sonst gibt es dauernd
einen Reset. Danach startet man das Programm und dreht an dem Trimmpoti
bis die LED nicht mehr blinkt. Jetzt kann der Kippschalter geschlossen
werden und der WatchDog ist hiermit scharf. Das kann durch Programmab-
bruch gleich ausprobiert werden. Also Ctrl-C hält das laufende Programm
an, der Impuls bleibt aus und der erwartete Reset wird ausgeführt.
Natürlich ist nun das gerade unterbrochene Programm aus dem RAM
verschwunden und demzufolge wird es in regelmäßigen Abständen einen
Reset geben. Somit ist der erste Test schon bestanden.
Der nächste Schritt wäre es, sein Programm ins Eprom zu brennen mit "PROG"
und dann mit "PROG2" eine Kennung ins Eprom zu legen, daß das erste im
Eprom stehende Programm gestartet werden soll. Gleichzeitig wird mit
dieser Kennung die Baudrateninformation abgelegt, so daß beim Neustart
kein Leerzeichen gesendet werden muß. Wird nun mit scharfen WatchDog
ein Reset erzwungen (Programmabbruch = Ctrl-C), startet das ins Eprom
gebrannte Programm. Eventuell muß das Trimmpoti noch etwas nachregu-
liert werden, da der Selbsttest des Interpreters ca. 2 - 3 Sekunden
dauert.


Zurück zur @{" Hardware / IN_OUT-Board " link HardwareIO}

@endnode

##
##      DCF - Signal und Codierung
##
@node DCF "Die DCF77-Codierung"

In der Physikalischen-Technischen Bundesanstalt (PTB) in Braunschweig
wird unsere Gesetzliche Zeit "hergestellt". Die dort erzeugte Zeitskala
wird codiert und vom Langwellensender DCF77 per Funksignal ausgestrahlt.
Dieser Sender gehört der Deutschen Bundespost und wird von der PTB nur
gemietet. Der zentrale Standort in Mainflingen bei Frankfurt am Main
und die gewählte Frequenz von 77,5 KHZ im Längstwellenbereich garan-
tieren eine Reichweite von gut 1500 km.
Das Schema der codierten Zeitübertragung ist ganz simpel:
Die Trägerfrequenz von 77,5 KHZ wird kontinuierlich im Dauerstrich
ausgestrahlt und in jeder Sekunde wird die Amplitude kurzzeitig auf
25 % des Normalwertes abgesenkt. Die dadurch entstehenden Sekunden-
marken können entweder kurz (0,1 Sek.) oder lang sein (0,2 Sek.); die
kurzen entsprechen dem digitalen LOW-, die langen einem HIGH-Bit.
Durch "Einsammeln" der Bits und geeignetes Decodieren kommt man an die
verschlüsselte Datum- und Zeitinformation wieder heran.
Um in den endlosen Strom der ankommenden Bits Ordnung zu bringen,
braucht man einen Bezugspunkt zur Synchronisation. Bei DCF77 erhält
man den dadurch, daß pro Minute eine Sekundenmarke ausbleibt, dort
also keine Trägerabsenkung erfolgt.
Mit der auf diese Lücke folgenden Marke beginnt jeweils eine neue
Minute. In diesem Augenblick setzt die Auswertesoftware ihren Sekunden-
zähler auf Null. Bei jeder folgenden Sekundenmarke wird dieser Zähler
um Eins erhöht. Der Zählerstand läßt also jederzeit erkennen, um
welchen Sekundenpuls es sich gerade handelt.
Auf diese Weise hat man pro Minute 59 Sekundenmarken zur Informations-
übertragung zur Verfügung. Diese Bitfolge von 59 zusammengehörenden
Bits nennt man auch Telegramm, in diesem Fall das Zeittelegramm, weil
darin Uhrzeit, Datum und Wochentag übermittelt werden.
Folgende Informationen sind darin enthalten:
Minuten (Einer und Zehner)
Stunden (Einer und Zehner)
Kalendertage (Einer und Zehner)
Monat (Einer und Zehner)
Jahr (Einer und Zehner)
Wochentag als Zahl (Montag=1)
Übertragen wird immer die Uhrzeit der nächstfolgenden Minute, bei
deren Beginn (Sekundenmarke Null) sie in eine Anzeige überschrieben
wird. Sekunden brauchen nicht mit im Telegramm übertragen zu werden;
sie ergeben sich stets aus dem Stand des Sekundenzählers.
Jede der elf Ziffern des Telegramms (Minuten-Einer bis Jahres-Zehner)
wird im BCD-Format dargestellt. Das ist ein Vier-Bit-Binärcode, bei
dem jedes aufsteigende Bit die doppelte Wertigkeit des vorhergehenden
hat (8-4-2-1-Code). Um damit beispielsweise die Ziffer 9 darzustellen,
müssen das erste Bit (mit der Wertigkeit 1) und das vierte (mit der
Wertigkeit 8) gesetzt sein (auf HIGH).
Es sind aber nicht für jede Stelle vier Bits erforderlich. Der Tages-
Zehner z.B. kann maximal eine 3 sein, so daß man für dessen Darstel-
lung nur zwei Bits braucht (mit den Wertigkeiten 1 und 2).

Hier nun eine Tabelle des Codierungsschemas:

Nr.  Bedeutung   Wert
 0   Anfang      X
 1   ....
14   nicht belegt
Sonderbits:
15   R           X
16   A1          X
17   Z1          X
18   Z2          X
19   A2          X
20   Start       X
Minuten:
21   Einer       1
22               2
23               4
24               8
25   Zehner      1
26               2
27               4
28   Prüfbit 1   X
Stunden:
29   Einer       1
30               2
31               4
32               8
33   Zehner      1
34               2
35   Prüfbit 2   X
Kalendertag:
36   Einer       1
37               2
38               4
39               8
40   Zehner      1
41               2
Wochentag:
42   Nummer      1
43               2
44               4
Monat:
45   Einer       1
46               2
47               4
48               8
49   Zehner      1
Jahr:
50   Einer       1
51               2
52               4
53               8
54   Zehner      1
55               2
56               4
57               8
58   Prüfbit 3   X
59   fehlt

Der "richtige" Informationsgehalt beginnt bei Sekunde Nr.21 mit dem
Minuten-Einer. Davor liegen 14 Bits ohne Informationsinhalt (Nr.1 bis
14) sowie weitere sechs Sonderbits (Nr.15 bis 20;s.u.). Die drei Prüf-
bits dienen einer Auswerte-Software zur Kontrolle. Sie ergänzen die
davor übertragenen Datenbits auf gerade Parität, d.h. einschließlich
Prüfbit muß im jeweiligen Abschnitt des Telegramms eine gerade Anzahl
von Einsen (HIGH-Bits) vorhanden sein.
Auch die Sonderbits dienen u.a. dazu, die Auswerte-Software zu unter-
stützen und vor Fehlschlüssen zu bewahren. Bit 15 (R) ist HIGH, wenn
die Reserve-Antenne des Senders aktiv ist.
Die Ankündigungsbits (Nr.16 und 19) leiten die Zeitumstellung ein (A1)
bzw. kündigen das Einfügen einer Schaltsekunde an (A2). Mit den Zeit-
zonen-Bits (Nr.17 und 18) wird die Sommerzeit gekennzeichnet (Z1=HIGH
während MESZ). Bit Nr.20 ist immer ein "langes", das den Beginn der
eigentlichen Zeitcodierung markiert.
Wie lange braucht nun die Software, bis sie nach dem Start die DCF77-
Zeit anzeigt ?
Mindestens eine volle Minute und zwar von der 59. Sekunde der einen
bis zur 59. Sekunde der nächsten Minute. Wegen der fehlenden Synchro-
nisation zählt eine beim Start gerade laufende "angebrochene" Minute
nicht.
Die Auswertesoftware wertet aber zwei aufeinanderfolgende Zeittele-
gramme aus, die sich nur um eine Minute Differenz unterscheiden
dürfen. Erst dann wird der korrekte Empfang der Zeitinformation be-
stätigt. Also nach spätestens 3 Minuten sollte die Uhr synchron
laufen, vorausgesetzt der Empfang ist einwandfrei.


Zurück zur @{" Hardware / IN_OUT-Board " link HardwareIO}
@endnode
##
##      Die Hardware / Meßwertgeber
##
@node HardwareMeß "Die Hardware / Meßwertgeber"

Um nicht teure AD-Wandler verwenden zu müssen, werden die @{" Meßwertgeber " link Bildergalerie/Messwertgeber.ilbm/main}
mit den Standard-Timer-IC's 555 in CMOS-Ausführung aufgebaut.
Diese Meßwertgeber arbeiten genügend präzise und sind kaum störanfällig.
Kabellängen von 20 Metern oder mehr sind möglich, so daß Fehlmessungen
eigentlich nicht zu erwarten sind.

Zur Schaltung:

Die Schaltung setzt die von einem NTC-Widerstand gemessene Temperatur in
ein digitales Signal um. Der Widerstandswert des NTC fällt mit steigender
Umgebungstemperatur. Er steuert die Frequenz eines Oszillators, der mit
der CMOS-Version des Timers 555 aufgebaut ist. Die Schaltung ist so
dimensioniert, daß die Oszillatorfrequenz bei 20 °C Umgebungstemperatur
etwa 2000 Hertz beträgt und sich bei steigender Temperatur erhöht.
Der nichtlineare Zusammenhang zwischen Temperatur und Oszillatorfrequenz
ist kein Problem, da der 8052er-Mikrokontroller mit Hilfe einer einfachen
Tabelle eine rechnerische Linearisierung vornehmen kann. Ausgehend von
drei gemessenen Temperaturpunkten mit zugehöriger Oszillatorfrequenz
können die Zwischenwerte gefunden werden. Also die ganze Eichung der
Meßwertgeber wird per Software erledigt.
Statt des NTC-Widerstand kann auch ein Fotowiderstand genommen werden
und dann die Helligkeit gemessen werden. Aber auch Fühler für Luftfeuchtig-
keit oder Luftdruck sind bestimmt möglich. Diese Sensoren allerdings
teuer und die Eichung wird auch nicht einfach sein.

Angeschlossen wird der Meßwertgeber an den externen Timereingang T1 bzw.
die Meßwertgeber auf der IN_OUT-Platine am Multiplexereingang.
Das Multiplex-IC wird durch den Ausgangsport 4 angesteuert und es können
dann die einzelnen Eingänge abgefragt werden. Der 8052er-Mikrokontroller
fungiert mit Hilfe der Software als Frequenzzähler und die gewonnenen
Daten können entweder gleich verwertet oder diese von der Amiga-Software
mit benutzt werden.

Siehe auch bei den @{" Demoprogrammen " link Demos}.


@endnode

##
##      Bauanleitung
##
@node Bauanleitung "Bauanleitung"

In der Bildergalerie sind die Platinenlayouts des Prozessorboards, der
IN_OUT-Platine und der Meßwertgeber als IFF-Bilder abgelegt. Aus Platz-
gründen sind die Leiterbahnen, Bauteile und Bauteilbezeichnungen überein-
ander gelegt. Die Schaltpläne des @{" WatchDogs " link Bildergalerie/WatchDog.ilbm/main} und des @{" 625 Hertz " link Bildergalerie/625_Hertz.ilbm/main} Rechteck-
Signals sind für die registrierten Anwender gedacht, damit sie diese bei
Bedarf optional auf einer Punktrasterplatine aufbauen können.
Auch sind bei dieser Veröffentlichung die Bauteillisten mit dabei.
Es gab nämlich Unklarheiten mit der Erhältlichkeit der Bauteilen und deren
Kosten. So kann sich jeder überzeugen, daß nur Standardbauteile verwendet
werden.

Aber nun zum Aufbau des Prozessorboards:

Wichtig ist, daß die Drahtbrücken zuerst eingelötet werden, da einige
unter IC-Fassungen liegen. Br.1 und Br.2 sollten allerdings ganz zum
Schluß mit isolierten Schaltdraht gesetzt werden. Danach können die IC-
Fassungen, Widerstände, Kondensatoren, Elkos, Dioden und Transistoren
eingelötet werden. IC 4 ( LM 317 ) wird auf den passenden Kühlkörper
geschraubt und dieser auf der Platine mit Schrauben befestigt.
Erst dann wird das IC verlötet. Nachdem man noch einmal den Aufbau
kontrolliert hat und auch die Leiterbahnseite auf evtl. Kurzschlüsse
untersucht hat, kann man Spannung auf die Platine geben. Mit einem
Meßgerät wird kontrolliert, ob der Spannungsregler korrekt funktioniert
und an den IC-Fassungen 5 Volt Versorgungsspannung anliegt. Ist dieser
erste Test erfolgreich verlaufen, wird die Versorgungsspannung unter-
brochen und die IC's können eingesetzt werden. Das EPROM braucht noch
nicht eingesetzt werden. Vom seriellen Anschluß der Platine ( TxD, RxD,
Minus ) kann nun die Verbindung zum Rechner hergestellt werden.
Achtung: TxD und RxD werden gekreuzt = @{" Nullmodemschaltung " link Bildergalerie/Nullmodem.ilbm/main}.
Nun kann das Terminal-Programm gestartet und die Platine unter Spannung
gesetzt werden. Nachdem man die Leertaste betätigt hat, sollte sich der
Prozessor melden.

Das müßte so aussehen:

*MCS-51(tm)BASIC V1.1*
READY
>

Das Prozessorboard ist damit betriebsbereit.



Der Aufbau der IN_OUT-Platine ist im Prinzip gleich:

Zuerst sollten die Drahtbrücken eingesetzt und verlötet werden. Da auf
der IN_OUT-Platine die Drahtbrücken teilweise sehr eng beieinander liegen,
sollte auf Kurzschlüsse geachtet werden. Dann können die Fassungen, die
passiven und dann die aktiven Bauteile eingesetzt werden. Die Verbindung
mit dem Prozessorboard erfolgt durch zwei @{" Flachbandkabel " link Bildergalerie/Verbindungen.ilbm/main} die 18 polige
IC-Stecker haben.
Zum Testen der Ports können die @{" Hilfsmittel " link Bildergalerie/Hilfsmittel.ilbm/main} und die Demosoftware benutzt
werden.



Zum Aufbau der Meßwertgeber ist nicht viel zu sagen:

Wem der Aufbau in SMD-Technik nicht liegt, kann die "größere"
konventionelle Variante nehmen.
Angeschlossen wird der Geber an T1 auf dem Prozessorboard, bzw. die Geber
auf der IN_OUT-Platine.

@endnode


##
##      8052 AH-BASIC TERMINAL 2.2
##
@node Terminal "8052 AH-BASIC Terminal 2.2"

         8052 AH-Basic-Terminal Version 2.2 vom 31.Mai 1996

    Achtung! Dieses Programm ist Shareware und darf nur komplett mit dem
                Entwicklungspaket weitergegeben werden.

Verbunden wird das Prozessorboard über die serielle Schnittstelle mit
einer sogenannten Nullmodem-Schaltung. Über die integrierte serielle
Schnittstelle kann der Mikrokontroller vollduplex (d.h. gleichzeitig
sendend und empfangend) Daten mit dem Rechner austauschen. Nach dem
Systemstart oder Reset arbeitet die serielle Schnittstelle im asynchronen
Modus mit folgenden Datenformat: 1 Startbit, 8 Datenbit, 1 Stopbit, kein
Paritätsbit. Außerdem erwartet der Mikrokontroller ein Leerzeichen
(Spacetaste). Eingestellter Defaultwert des Terminalprogramms ist 9600
Baud. In der Praxis hat sich dieser Wert als ausreichend erwiesen.

Zum Programm selbst:

Im 8052 AH-Basic ist ein einfacher Zeileneditor integriert, mit dem die
Basic-Programme eingegeben werden können.
Gibt man z.B. ein verkehrtes Zeichen ein, ist dieses mit der Del-Taste
zu löschen.
Wurde hingegen schon die Eingabetaste betätigt, ist das Löschen der
Zeile nur noch mit Eingabe der Zeilennummer möglich.
(Der Interpreter ist zeilenorientiert, wie in guten alten Zeiten).

Hier ein immer wieder beliebtes Programmbeispiel:

10 REM  Ein Super-Beispiel
20 FOR X=1 TO 10
30 PRINT "HELLO WORLD"
40 NEXT X

Wird dieses schöne Programm durch die Eingabe von RUN gestartet,
erscheint der allzeit beliebte Text 10 mal.

Möchte man nun die 1. Zeile löschen, reicht es aus, 10 einzugeben und
die Eingabetaste zu drücken.

Gestartet wird das Programm wie bereits erwähnt durch RUN.

Unterbrechen lassen sich die Programme mit Ctrl-C.

Das Terminalprogramm hat Defaultwerte mit dem der Serialport geöffnet
wird, sowie eine Funktionstastenbelegung die wie folgt aussieht:

F 1  LIST     0 - 99
F 2  LIST   100 - 999
F 3  LIST  1000 - 9999
F 4  LIST 10000 - 49000
F 5  LIST     0 - 65535
F 6  RUN
F 7  CONT
F 8  RAM
F 9  ROM
F10  XFER

Die LIST-Befehle auf den Funktionstasten F1 - F5 bedürfen eigentlich
keiner Erklärung. Nur das F5 das gesamte Programm listet (0-65535) und
das 65535 die maximale Zeilenzahl ist, die der Interpreter verwalten kann.

Taste F 6 startet das Programm.

Taste F 7 führt das Programm an der Stelle fort, wo es mit Ctrl-C abge-
          brochen wurde.

Taste F 8 schaltet ins RAM.

Taste F 9 schaltet ins ROM.

Taste F10 kopiert dem ROM-Inhalt ins RAM.

Natürlich lassen sich alle diese Funktionstasten auch anders belegen.

Über die Menüleiste Einstellungen/F-Tasten oder der Tastenkombination
Rechts-Amiga-F kommt man in das Konfigurationsfenster der F-Tasten.
Hier können bis zu 64 Zeichen lange Befehlszeilen eingegeben werden.

Nach verlassen des Konfigurationsfensters und wählen des Menüpunktes
Einstellungen/Konf. sichern bzw. Rechts-Amiga-S werden die Einstellungen
dauerhaft im Konfigurationsfile 8052AH-BASIC.config festgehalten.
Dieses File sollte im Verzeichnis SYS:S/ stehen, da die eigenen
Einstellungen jedesmal beim Start des Terminalprogramms hieraus geholt
werden. Ist allerdings das File nicht vorhanden, werden die Defaultwerte
gesetzt. Hat man nun einige Einstellungen verändert und möchte das
Terminalprogramm zurücksetzten, kann durch den Menüpunkt Einstellungen/
Konf. laden (bzw. Rechts-Amiga-L) das vorher abgespeicherte Konfig.-File
geladen werden. Aber auch mehrere verschiedene Konfigurationsfiles
lassen sich anlegen. Nur sollte ein abgewandelter Name für das File
verwendet werden. Wie z.B. 8052AH-BASIC2.config oder Meine.config.

Hat man nun alles verstellt und möchte die Grundeinstellung wiederhaben,
hilft der Menüpunkt Einstellungen/Defaultwerte (bzw. Rechts-Amiga-D)
weiter.

Weitere Einstellungen können mit Menüpunkt Einstellungen/Terminal bzw.
Rechts-Amiga-T gemacht werden.

Hier die Defaultwerte für die serielle Schnittstelle:

Baud          9600
Buffer       16384
Delay           15
Device      serial.device
Unit             0
Timeout        250
Taskpriorität   -1

Baud:
Hier lassen sich vier verschiedene Baudraten ( 2400, 4800, 9600 oder
19200 ) einstellen.

Buffer:
Hier kann die Buffergröße geändert werden. ( 4096, 8192, 16384, 32768 )

Delay:
Hier läßt sich die Verzögerungszeit zu den verschiedenen Baudraten
einstellen. ( 0-63 )
Dazu folgendes:
Die Übertragung des Listings an den Mikrokontroller muß in einem
bestimmten Format ablaufen. Jedesmal wenn die Eingabe einer Programmzeile
in das 8052-AH-Basic-System mit einem Carriage Return (0D Hex)
abgeschlossen wird, benötigt der Interpreter gewisse Zeit, um die Zeile
intern in Kurzzeichen ( Token ) umzusetzen und zu speichern. Erst danach
darf die nächste Programmzeile eingegeben werden; andernfalls gehen die
ersten Zeichen der nächsten Zeile verloren. Um dem Interpreter die not-
wendige Zeit zu lassen, wird das Basic-Prompt ">" ausgewertet. (Software-
Handshake). Danach muß noch ein gewisser Zeitraum gewartet werden, damit
der Eingabepuffer wirklich leer ist und die nächste Zeile gesendet werden
kann. Die Defaultwerte sind meine Erfahrungswerte auf einem A 4000/030.
Eventuell müssen diese auf einem Rechner mit höheren Prozessor höher bzw.
einen Standard-Amiga niedriger gesetzt werden.

Device & Unit:
Hier ist das serial.device mit dem Unit 0 vorgegeben.
Hat man nun eine Multiseriell-Karte im Amiga, kann das Terminalprogramm
darauf umgeleitet werden.

Timeout:
Tritt bei der Übertragung ein Fehler auf, erscheint ein Info-Requester
und  die Übertragung wird beendet. Defaultwert ist 250 = 5 Sekunden.

Taskpriorität:
Voreingestellt ist -1. Eventuell ist hier überhaupt keine Änderung not-
wendig. Sollte allerdings das Multitasking gestört werden, kann ein
Wert zwischen -5 bis 5 gesetzt werden. Der Filetransfer erfolgt sicher-
heitshalber immer mit der Priorität 3.

Eine noch nicht erwähnte Funktion im Menüpunkt Einstellungen ist
Umlaute (Tastenkombination Rechts-Amiga-U).
Der Basic-Interpreter schluckt nämlich keine Umlaute wie ö ä ü oder das ß.
Ist die Funktion aktiviert und wird z.B. ä eingegeben, erfolgt eine Aus-
gabe als ae. Damit auch Leute die kein deutsches Keyboard haben nicht
durcheinander kommen ist die Wandlung abschaltbar.

Alle diese Einstellungen werden auch im vorher erwähnten Konfigurations-
file abgespeichert, so daß man seine einmal eingestellte Konfiguration
gleich beim Start des Terminalprogramms geladen hat.

Noch nicht erwähnte Menüpunkte:

Info/Ende:

Info (bzw. Rechts-Amiga-I) bringt ein Infofenster auf den Screen mit den
aktuellen Daten von:
Datum, Uhrzeit, Uhrzeit beim Start des Programms, Prozessor, Execversion,
AGA oder kein AGA, PAL oder NTSC, freies Chip-Mem, freies Fast-Mem, größ-
ter freier Speicherblock und Taskpriorität.

Quit (bzw. Rechts-Amiga-Q) beendet das Programm.

Filetransfer:

File übertragen (bzw. Rechts-Amiga-Ü) überträgt das Basiclisting in den
Interpreter.

Listing holen (bzw. Rechts-Amiga-H) holt das Listing und sichert es.

Sonstiges:

CLS (bzw. Rechts-Amiga-C) löscht das Ausgabefenster (CLS).
F-Taste 1 - 10 = Funktionstasten.


Zum Terminalprogramm noch folgendes:

Das Carriage Return an Texten im Amiga-Format muß noch angehängt, bzw.
beim Sichern von Listings herausgefiltert werden.
Das übernimmt alles dieses Terminal-Programm.
Das Schreiben von längeren Programmen ist einfacher, wenn man dieses in
einem Textprogramm macht, einschließlich Zeilennummern und dieses ASCII-
Textfile anschließend in das 8052-System lädt. Auch ist es möglich, im
Hintergrund das Textprogramm laufen zu lassen und mit der Tasten-
kombination Links-Amiga-M hin und herzuschalten.


************************************************************************


Hier noch einmal die Funktionsübersicht der Tasten:

F1      LIST     0 - 99
F2      LIST   100 - 999
F3      LIST  1000 - 9999
F4      LIST 10000 - 49000
F5      LIST     0 - 65535
F6      RUN
F7      CONT
F8      RAM
F9      ROM
F10     XFER

Del     Zeichen löschen
Ctrl-C  Programmabbruch

Rechts-Amiga-I    Infofenster
Rechts-Amiga-Q    Programm beenden
Rechts-Amiga-Ü    File übertragen
Rechts-Amiga-H    Listing holen
Rechts-Amiga-T    Terminal
Rechts-Amiga-F    Funktionstasten
Rechts-Amiga-U    Umlaute
Rechts-Amiga-S    Konfiguration sichern
Rechts-Amiga-L    Konfiguration laden
Rechts-Amiga-D    Defaults nehmen
Rechts-Amiga-C    CLS (ClearScreen)

Links-Amiga-M Zur Workbench


************************************************************************


Und die Menüleiste:

Info/Ende       File-Transfer       Einstellungen       Sonstiges

Info            File übertragen     Terminal            CLS
Quit            Listing holen       F-Tasten            F-Taste  1
                                    Umlaute             F-Taste  2
                                    Konfig. sichern     F-Taste  3
                                    Konfig. laden       F-Taste  4
                                    Defaultwerte        F-Taste  5
                                                        F-Taste  6
                                                        F-Taste  7
                                                        F-Taste  8
                                                        F-Taste  9
                                                        F-Taste 10


************************************************************************


Achtung:

Das Serial.Device sollte im Verzeichnis Devs stehen.
Gerade bei Rechner die mit Diskette gebootet werden, wird oftmals das
Serial.Device aus Platzgründen weggelassen.


Und noch das übliche zum Schluß:

Für etwaige Schäden, die wohl nicht vorkommen dürften bzw. Datenverlust
durch Bedienungsfehler wird keine Haftung übernommen.
Die Benutzung geschieht auf eigene Gefahr.


@endnode

##
##      I2C
##
@node I2C "Das I2C-Interface und die Software"

   Das I2C-Interface und die Software:

   @{" Allgemeines         " link Allg} zum I2C-Bus.
   @{" Prozessorboard      " link Änd} - Änderungen.
   @{" Vor- und Nachteile  " link Nacht} des I2C-Bus und des In_Out-Board.
   @{" I2C-Treibersoftware " link I2CSoft}
   @{" Ansteuerung         " link Anst} des I2C-Bus und dessen Adressen.
   @{" I/O Praxisbeispiel  " link IO} am Baustein PCF8574.
   
   Hinweise zu den @{" I2C-Modulen " link I2C-Mod}
   
   Das I/O-Modul    @{" PCF8574    " link 8574}
   Bauanleitung des @{" I/O-Moduls " link Bau8574} 
   
   Die RTC-Uhr      @{" PCF8583      " link 8583}
   Bauanleitung des @{" Uhren-Moduls " link Bau8583}
   
   Der A/D-D/A-Wandler @{" PCF8591                " link 8591}
   Bauanleitung des    @{" A/D-D/A-Wandler-Moduls " link Bau8591}
   
   Die 4 Digit LED-Anzeige @{" SAA1064                    " link 1064}
   Bauanleitung des        @{" 4 Digit-LED-Anzeige-Moduls " link Bau1064}


   Zu den I2C-Demolistings:
   
   Da in dieser Veröffentlichung nur der Ausgabetreiber zur Verfügung
   steht, sind die Demoprogramme nur hier für ausgelegt.
   
   @{" DA-Wandler.bas       " link DA-Wandler}
   @{" I2C_Treiber_O.bas    " link I2C_Treiber_O}
   @{" IO_Out.bas           " link IO_Out}
   @{" LED-Anzeige-Test.bas " link LED-Anzeige-Test}
   @{" LED-Zähler.bas       " link LED-Zähler}
   @{" Scan_Test.bas        " link Scan_Test}
   
   Weitere Demos in der registrierten Version sind:
   
   AD&LED.bas =         Kanal 1 des AD-Wandlers wird eingelesen und auf die
                        4 Digit-LED-Anzeige gebracht.
   AD-Wandler.bas =     Alle 4 Kanäle des AD-Wandlers werden eingelesen und
                        die Werte auf dem Monitor angezeigt.
   I2C_Treiber_IO.bas = Der komplette I2C-Treiber für Ein- und Ausgabe             
   IO_In.bas =          Das anliegende Datenwort am IO-Modul-Eingang, kann 
                        eingelesen werden.
   Uhr&LED&Mon.bas =    Die Echtzeituhr wird ausgelesen und die Stunden,
                        Minuten auf die LED-Anzeige gebracht. Zusätzliche
                        Ausgabe auf den Monitor mit Sekunden und Tagen.
   Uhr_Lesen.bas =      Die Echtzeituhr wird ausgelesen und die Anzeige 
                        erfolgt nur auf dem Monitor
   Uhr_Stellen.bas =    Stellen der Echtzeituhr                                                            
                     
   
                     
   Weitere @{" I2C-IC's " link I2C-IC's}.
                     
                      
@endnode

##
##      ALLG
##
@node Allg "Allgemeines"

   Das I2C-Interface wurde ursprünglich von der Firma Philips entwickelt,
   um mehrere IC's mit einem einfachen bidirektionalen seriellen Bus zu
   verbinden. Dieser Inter-Integrated Circuit-Bus, abgekürzt I2C, soll 
   die Kommunikation zwischen integrierten Schaltungen ermöglichen.
   Die IC's sitzen dabei üblicherweise auf einer Platine oder einem Gerät,
   wodurch die Länge der Busverbindung auf ca. 30-40 cm beschränkt bleibt.
   In unseren Fall reicht das allemal aus und somit können über eine
   einfache Zweidrahtverbindung alle möglichen IC's angesprochen werden.
   Natürlich muß auch noch eine Stromversorgung mit 5 Volt bzw. Masse
   erfolgen, so daß vier Leitungen an das IC anliegen müssen.   
   
   Aber hier das @{" Schema " link Bildergalerie/I2C_Schema.ilbm/main} vom I2C-Bus.
  
   Durch die Vergabe von verschiedenen Adressen, die mittels Jumper ein-
   gestellt werden, können z.B. 8 I/O-IC's (PCF8574) am Bus hängen.
   ( Wem das noch nicht reicht, kann zusätzlich den PCF8574A nehmen und 
   nochmals 8 I/O-IC's in einen anderen Adreßbereich verwenden. )
   
   Also, in jedem I2C-Chip ist ein Adreßbereich fest eingestellt, der 
   mittels 1,2 oder 3 Jumper verändert werden kann. Im Falle von
   3 Jumpern sind dieses 8 Adressen oder 8 gleiche Bausteine im I2C-Bus.
   
           
@endnode

##
##      Änd
##
@node Änd "Änderungen am Prozessorboard"
 
   Um auf den richtigen Pegel zu kommen, müssen die Widerstände R17 und
   R18 auf 330 Ohm verringert und zusätzlich 2 Widerstände von 3,3 K
   unter die Platine gelötet werden.
   
   Siehe @{" Prozessorboard ändern " link Bildergalerie/Prozessorboard_än.ilbm/main}.

   Die Stromversorgung kann von den Pin's 1-2 (Masse) und 3-7 (5 Volt)
   am oberen Verbindungssockel ( IC7 ) geholt werden. 
   
   Siehe @{" Prozessorboard " link Bildergalerie/Prozessorboard.ilbm/main}.    
   
   Zu beachten ist, daß der Spannungsregler auf der Prozessorboard-Platine
   z.B. nicht 8 * 4 Digit LED-Anzeigen und zusätzliche Module, Relais usw.
   versorgen kann und somit ein zusätzliches Netzteil nötig ist.
   ( Maximal zulässige Stromentnahme des Spannungsreglers LM 317 T mit
     richtig dimensionierten Kühlkörper = 1,5 Ampere. )
           
      
@endnode
   
##
## Nacht
##
@node Nacht "Vor- und Nacht des I2C-Bus und In_Out-Board"
   
   Im Prinzip könnte die In_Out-Board-Platine ganz entfallen und die ganze
   Kommunikation über den I2C-Bus gehen. Der Nachteil beim I2C-Bus ist, daß
   die Übertragung von Daten seriell erfolgt, dementsprechend langsamer
   ist und das der Preis von den I2C-Chips höher liegt als TTL-Bausteine.
   
   Vorteil des I2C-Bus ist seine einfache Erweiterbarkeit mit den 
   verschiedensten Modulen und kein großes Verdrahtungschaos.
       
   
@endnode   
   
##
##      I2CSoft
##
@node I2CSoft "Die I2C-Treiber-Software"

   Die I2C-Treiber-Software ist ein reines Maschinensprache-Programm,
   daß über den Basic-Befehl >Call< aufgerufen wird.
   
   Diese Treiber-Software wird im oberen Adreßbereich des Ram's
   kopiert und ist, da MTOP heruntergesetzt, gegen überschreiben oder 
   dem Befehl >New< geschützt. Resetfest wird das ganze allerdings
   erst durch die Programmierung ins EPROM mit dem entsprechenden
   >PROG< Befehl.
   
   Achtung: 
   Das Basic-Programm "I2C_Treiber_O.bas" ist nur die gekürzte
   Version der Treibersoftware und kann nur Daten ausgeben.
   (Registrierte Anwender bekommen natürlich die komplette Version
    bzw. bereits Registrierte Anwender gegen Zahlung von 15 DM. )
    
   Also jetzt die Praxis:
   
   Mit dem Terminal-Programm wird das Basic-Programm "I2C_Treiber_O.bas"
   in den Rechner übertragen und anschließend gestartet.
   Nach dem heruntersetzen von MTOP (oberere Speicherplatzvariable)
   und kopieren der Daten ins obere RAM, muß der Befehl >New<
   eingegeben werden. Nun kann ein I2C-Demoprogramm geladen und 
   angetestet werden. 
   Die I2C-Treiber-Software kann natürlich auch in eigene Basic-
   Programme eingebunden werden, so daß der "I2C_Treiber_O" nicht
   jedesmal vorher geladen werden braucht. 
            
       
@endnode

##
##      Anst
##
@node Anst "Die Ansteuerung des I2C-Bus und dessen Adressen"


  Die Ansteuerung des I2C-Bus und dessen Adressen.
   
  
  Eingangstreiber:       
  
  Diese beiden Adressen mit den gewünschten Werten beschreiben. 
  
  Adresse vom Chip in Adresse 68H  z.B. DBY(68H)=40H
  Wieviele Bytes ? in Adresse 69H  z.B. DBY(69H)=1
  
  Dann Aufruf mit CALL 7C00H
  
  Der Übertragungs-Check erfolgt mit PRINT DBY(6AH).
  OK wenn der Ausgabewert = 0.
  
  Eingangsbuffer maximal 8 Bytes.
  
                 1.Byte  70H
                 2.Byte  71H
                 3.Byte  72H
                 4.Byte  73H
                 5.Byte  74H
                 6.Byte  75H
                 7.Byte  76H
                 8.Byte  77H
                 
  Aus dem Eingangsbuffer kann nun der 1.Wert mit PRINT DBY(70H)
  ausgelesen werden. 
  
  
  Ausgangstreiber:
  
  Diese beiden Adressen mit den gewünschten Werten beschreiben. 
  
  Adresse vom Chip in Adresse 6CH  z.B. DBY(6CH)=40H  
  Wieviele Bytes ? in Adresse 6DH  z.B. DBY(6DH)=1
  
  Ausgangsbuffer maximal 8 Bytes.
  
                 1.Byte  78H
                 2.Byte  79H
                 3.Byte  7AH
                 4.Byte  7BH
                 5.Byte  7CH
                 6.Byte  7DH
                 7.Byte  7EH
                 8.Byte  7FH
                 
  Die zu übertragenen Daten in den Buffer schreiben mit z.B. DBY(78H)=5
  und dann Aufruf des Ausgangstreibers mit CALL 7E00H.
  
  Der Übertragungs-Check kann mit PRINT DBY(6EH) kontrolliert werden.
  Also, ist der Wert in Adresse 6EH=0 war die Übertragung OK.
     

@endnode

##
##      IO
##
@node IO "Der I/O-Baustein PCF8574"

  Wir möchten daß das Datenwort "127" am Ausgang des PCF8574 anliegt:
  
  1. Schreiben der Adresse des PCF8574 = "4EH" nach "6CH" mit:
  
     DBY(6CH)=4EH
     
  2. Schreiben in die Adresse "6DH" wieviele Bytes übertragen werden mit:
  
     DBY(6DH)=1
     
  3. Aufruf des I2C-Ausgangs-Treibers mit:
  
     CALL 7E00H
     
  4. Konnte das IC angesprochen werden, ist in Adresse "6EH" der Wert 0.
  
     Print DBY(6EH) oder CHECK=DBY(6EH) : Print CHECK 


  Anmerkung zu 2. :
  
  Beim PCF8574 braucht nur ein Datenwort geschrieben werden. Deshalb
  ist hier die 1 gesetzt. Bei anderen IC's können zusätzlich Kontroll-
  und Steuerbytes in deren internen Register gesetzt werden.
  Aber dazu mehr bei den I2C-Demoprogrammen.
   
     

@endnode

##
##      I2C-Mod
##
@node I2C-Mod

  Alle später aufgeführten I2C-Module sind mit einem abgewinkelten
  9 poligen Sub-D-Stecker versehen, der wie folgt beschaltet ist:
  
  Pin 1 = SCL
  Pin 2 = SDA
  Pin 3 = Int
  Pin 4 = ---
  Pin 5 = ---
  Pin 6 = ---
  Pin 7 = 5 Volt
  Pin 8 = ---
  Pin 9 = Masse
  
  
  Anmerkung zum Pin 3:
  
  Der I/O-Baustein und die Echtzeituhr haben einen Interrupt-Ausgang.
  Dieser wird auf Pin 3 herausgeführt und kann evtl. eine Interrupt-
  Routine im Basic-Programm ausführen. Ich habe allerdings noch 
  keine Versuche damit gemacht.


  Mit diesen Modulen kann man sich z.B. so etwas wie ein Mainboard mit
  9 poligen Sub-D-Buchsen auf einer Lochrasterplatine aufbauen, wo
  die einzelnen Baugruppen einfach aufgesteckt werden und einfach
  austauschbar sind.
    
 

@endnode

##
##      8574
##
@node 8574 "Der I/O-Baustein mit dem PCF8574"

  Das Bild @{" I2C_PCF8574 " link Bildergalerie/I2C_PCF8574.ilbm/main} zeigt das I/O-Modul,daß über den 
  I2C-Bus angesteuert wird.
  Der 8-Bit-I/O-Port ist besonders einfach aufgebaut:
  Der abgewinkelte 9 polige Sub-D-Stecker stellt die Verbindung zur 
  digitalen Außenwelt her. Drei Adreßleitungen (A0, A1 und A2) sind
  über einen Pull-Up-Widerstand mit der Versorgungsspannung verbunden.
  Ist nun kein Jumper gesteckt, kann das IC unter der Adresse 4EH
  angesprochen werden (Demoprogramme). Dank dieser drei Jumper können
  8 verschiedene Exemplare des IC's PCF8574 gleichzeitig auf dem selben
  I2C-Bus installiert werden. Da es noch eine andere Version gibt,
  nämlich den PCF8574A der in einen anderen Adreßbereich liegt, kann 
  die I/O auf 16 Module erweitert werden.
  Der quasi-bidirektionale I/O-Port des PCF8574 hat ein Lese- und ein
  Schreibregister. Je nach Anwendung kann ein Eingang auch als Ausgang
  verwendet werden. Als Senke kann jeder Ausgang einen Strom von 25 mA
  aufnehmen, als Stromquelle liefert jeder Ausgang einen Ausgangsstrom
  von etwa 0,4 mA. Wird ein Anschluß als Eingang verwendet, so muß er 
  zuerst eine 1 erhalten. Liest man nun den Wert des betreffenden
  Anschlusses zurück, so kann man erkennen, ob an dem als Eingang
  verwendeten Ausgang der Pegel 0 oder 1 anliegt. Eine 0 bedeutet:
  Der Anschluß wurde von außen auf 0 gesetzt. Durch die interne
  Struktur des IC's (open drain-Ausgang) kann durch dieses auch bei
  Mikrokontrollern häufig angewendete Verfahren kein Schaden angerichtet
  werden. Durch die Verwendung eines Widerstands-Arrays, kann der 
  Eingang bei Bedarf entweder nach Masse oder auf 5 Volt gezogen
  werden. Wird das I/O-Modul als reiner Ausgang verwendet, kann das
  Widerstands-Array entfallen. 
   

@endnode

##
##      Bau8574
##
@node Bau8574 "Bauanleitung des I/O-Moduls"

  Mit einem 0,8 mm Bohrer wird die Platine gebohrt und es kann dann
  mit der Bestückung begonnen werden. Also die fünf Widerstände, der
  Kondensator die IC-Fassung, der abgewinkelte Sub-D-Stecker und die
  Stiftleiste für die Jumper. Nach dem Einstecken des PCF8574 ist das
  Modul Betriebsbereit. Bei Bedarf kann ein Widerstands-Array einge-
  setzt und der Eingang entweder nach Masse oder 5 Volt gezogen 
  werden. 

  Das Modul @{" I2C_PCF8574 " link Bildergalerie/I2C_PCF8574.ilbm/main}. 
  

@endnode

##
##      8583
##
@node 8583 "Die batteriegepufferte Echtzeituhr mit dem PCF8583"

  Das Bild @{" I2C_PCF8583 " link Bildergalerie/I2C_PCF8583.ilbm/main} zeigt die Echtzeituhr,die über den 
  I2C-Bus angesteuert wird.
  Der abgewinkelte 9 polige Sub-D-Stecker stellt die Verbindung zur 
  digitalen Außenwelt her. Eine Adreßleitungen (A0) ist über einen 
  Pull-Up-Widerstand mit der Versorgungsspannung verbunden.
  Ist nun kein Jumper gesteckt, kann das IC unter der Adresse A2H
  angesprochen werden (Demoprogramme). In den Basic-Listings ist diese
  Adresse mit einer vorangestellten 0 einzugeben. Also 0A2H. Denn
  bei den Hex-"Buchstaben" A-F würde der Interpreter annehmen, daß
  es sich um eine Variable handelt und dieser eine Fehlermeldung
  ausgeben.
  Das IC enthält ein 256*8-bit RAM mit sich automatisch erhöhenden
  Adreßregister, einen 32768-kHz-Oszillator, einen Frequenzteiler,
  einen Power-on-reset-Block und das I2C-Interface. Die ersten acht
  Byte des RAM's (00...07) sind als adressierbare parallele 8-bit-
  Register ausgeführt.
  Damit die Uhr auch bei Ab- oder Ausfall der Versorgungsspannung
  weiterläuft, ist eine Back-Up-Batterie vorhanden.
  Natürlich sind die evtl. ins RAM geladenen Daten auch gesichert.    
  

@endnode

##
##      Bau8583
##
@node Bau8583 "Bauanleitung des Uhren-Moduls"

  Das Modul @{" I2C_PCF8583 " link Bildergalerie/I2C_PCF8583.ilbm/main}.

  Wieder muß die Platine zuerst mit einem 0,8 mm Bohrer bearbeitet
  werden. Dann können die passiven bzw. aktiven Bauteile eingesetzt
  und verlötet werden. Da es zig- verschiedene Bauformen von Batterien
  und deren Halterungen gibt, müssen die Löcher zum befestigen des 
  Batteriehalters entsprechend gebohrt sein. Im oberen Bereich der 
  Platine sind genügend Lötpins angebracht. 
  Am Trimmkondensator C2 kann später die Ganggenauigkeit der Uhr
  korrigiert werden.

  
@endnode  

##
##      8591
##
@node 8591 "Der A/D-D/A-Wandler mit dem PCF8591"

  Das Bild @{" I2C_PCF8591 " link Bildergalerie/I2C_PCF8591.ilbm/main} zeigt das A/D-D/A-Modul,daß über den 
  I2C-Bus angesteuert wird.
  Der abgewinkelte 9 polige Sub-D-Stecker stellt die Verbindung zur 
  digitalen Außenwelt her. Drei Adreßleitungen (A0, A1 und A2) sind
  über einen Pull-Up-Widerstand mit der Versorgungsspannung verbunden.
  Ist nun kein Jumper gesteckt, kann das IC unter der Adresse 9EH
  angesprochen werden (Demoprogramme). Dank dieser drei Jumper können
  8 A/D-D/A-Module gleichzeitig auf dem I2C-Bus betrieben werden.
  Durch die große Anzahl von Möglichkeiten wird das Senden von Daten
  zum PCF8591 etwas komplizierter, als dies beim PCF8584 der Fall ist.
  Neben den Datenbytes gibt es hier noch ein sogenanntes Kontroll-Byte,
  das für eine Reihe von Einstellungen sorgt. So ist es möglich, daß
  das Modul als 4 Kanal 8-Bit A/D-Wandler (Eingang), oder als 1 Kanal 
  8 Bit D/A-Wandler (Ausgang) programmiert werden kann. 
  Mit dem Trimmpoti R13 läßt sich die Referenzspannung zwischen 2,8V
  und 4,1V einstellen. Diese eingestellte Referenzspannung wird im
  IC in 256 Zwischenwerte geteilt, so daß z.B. die Ausgabe von 0 =
  0 Volt Spannung bzw. die Ausgabe von 255 die eingestellte Referenz-
  spannung am Ausgang zur Folge hat. Die Ausgabe von 127 hätte also
  die 1/2 Referenzspannung. Bei der Analog-Digital-Wandlung verhält
  es sich anders herum. Die Demoprogramme sind aber ausreichend
  dokumentiert, so daß der Programmablauf und die richtige 
  Programmierung ersichtlich wird. 
  

@endnode

##
##      Bau8591
##
@node Bau8591 "Bauanleitung des A/D-D/A-Wandler-Moduls"

  Wieder muß die Platine zuerst mit einem 0,8 mm Bohrer bearbeitet
  werden. Dann können die passiven bzw. aktiven Bauteile eingesetzt
  und verlötet werden. Achtung: Die beiden Drahtbrücken nicht 
  vergessen. Am Trimmpoti R13 kann die Referenzspannung, gemessen an
  Pin 14 des PCF8591 gegen Masse eingestellt werden. Der eingestellte
  Wert muß dann später im Demoprogramm eingetragen werden. 
  Im Demoprogramm ist dieses 3,8 Volt.
  Zu beachten ist, daß die Eingangsspannung nicht den Wert der 
  Referenzspannung übersteigt. Eventuell ist ein Spannungsteiler im
  Eingang zu setzen, damit man auch höhere Spannungen messen kann. 

  Das Modul @{" I2C_PCF8591 " link Bildergalerie/I2C_PCF8591.ilbm/main}.

  
@endnode  

##
##      1064
##
@node 1064 "Die 4 Digit-LED-Anzeige mit dem SAA1064"

  Das Bild @{" I2C_SAA1064 " link Bildergalerie/I2C_SAA1064.ilbm/main} zeigt die 4 Digit-LED-Anzeige,die über den 
  I2C-Bus angesteuert wird.
  Der abgewinkelte 9 polige Sub-D-Stecker stellt die Verbindung zur 
  digitalen Außenwelt her. Drei Adreßleitungen (A0, A1 und A2) sind
  über einen Pull-Up-Widerstand mit der Versorgungsspannung verbunden.
  Ist nun kein Jumper gesteckt, kann das IC unter der Adresse 76H
  angesprochen werden (Demoprogramme). Dank dieser drei Jumper können
  8 LED-Anzeige-Module gleichzeitig auf dem I2C-Bus betrieben werden.
  Auch hier gibt es neben den Datenbytes noch ein sogenanntes Kontroll-
  Byte, das für eine Reihe von Einstellungen sorgt.
  So lassen sich die Digits 1&3 und 2&4 einzeln aktivieren, es kann
  ein Segment-Test durchgeführt und die Helligkeit eingestellt werden. 
  Aber wie zuvor schon beim A/D-Wandler erwähnt, die Demoprogramme 
  zeigen in der Praxis, wie die Programmierung erfolgen muß.


@endnode

##
##      Bau1064
##
@node Bau1064 "Bauanleitung des 4 Digit-LED-Anzeige-Moduls"

  Wieder muß die Platine zuerst mit einem 0,8 mm Bohrer bearbeitet
  werden. Weil einige von den 13 Drahtbrücken versteckt liegen, sollten
  diese zuerst gesetzt und dann die passiven bzw. aktiven Bauteile 
  eingelötet werden.
  Da die Platine verhältnismäßig groß ist und diese in einer Gehäusefront
  Platz haben sollte, kann diese an der gestrichelten Linie getrennt
  werden. Entweder man winkelt die Anzeige ab, oder man macht eine
  Verbindung mit Flachbandkabel zu den Digits.
  
  Da es verschiedene 7 Segment-Anzeigen gibt,
  hier die richtigen @{" Anschlüsse " link Bildergalerie/LED.ilbm/main}.
  

  Das Modul @{" I2C_SAA1064 " link Bildergalerie/I2C_SAA1064.ilbm/main}. 

  
@endnode  

##
##      DA-Wandler
##
@node DA-Wandler "Demoprogramm DA-Wandler.bas"

1      REM **************************************************************
2      REM *
3      REM *            Programm DA-Wandler
4      REM *   Der angeschlossene A/D-D/A I2C-Chip PCF 8591 P
5      REM *   auf Adresse 9EH wird auf Analog-Ausgabe eingestellt.
6      REM *   Der Binaerwert z.B. von 255 hat eine Spannung von
7      REM *   Uref*255/256 am Ausgang zur Folge.
8      REM *
9      REM **************************************************************
10    DBY(6CH)=9EH :  REM Adresse des I2C-Chip
20    DBY(6DH)=2 :  REM   Uebertragung von 2 Bytes
30    DBY(78H)=64 :  REM  I2C-Chip auf Analog-Ausgabe einstellen
40     PRINT "Gebe einen Wert zwischen 0-255 ein:",
50     INPUT V :  REM     Wert in V uebernehmen
60    DBY(79H)=V :  REM   und den Wert nach 79H schreiben
70     CALL 7E00H :  REM  Aufruf des I2C-Ausgabe-Treibers
80    VOLT=3.8/256*V :  PRINT "Ausgabe =", :  PRINT VOLT, :  PRINT "Volt"
85     PRINT 
90     GOTO 10 :  REM     Und noch einmal von vorne...


@endnode

##
##      I2C_Treiber_O
##
@node I2C_Treiber_O "Demoprogramm I2C_Treiber_O.bas"

1      REM *****************************************************************
2      REM *
3      REM *              Programm I2C_Treiber_O Version 1.0
4      REM *         ( gekuerzte Nur-Ausgabe-Version zum testen )
5      REM *      <c> 1996 Andreas Heinrich / Alle Rechte vorbehalten
6      REM *     Dieser Treiber ist nur fuer registrierte Anwender des 
7      REM *          8052 AH-Basic-Entwicklungspaketes gedacht.
8      REM *        Die Weitergabe an Dritte und das unberechtigte
9      REM *                 kopieren ist nicht erlaubt.
10     REM *
11     REM ***************************************************************** 
20    MTOP=31743
25     PRINT "Setze MTOP auf 31743 = 7BFFH"
30    A=7C00H
40    CHECK=0
50    C=34+23903
60     PRINT "Kopiere die Treiber ins RAM..."
100    FOR I=1 TO 220
110    READ B
120   XBY(A)=B
130   A=A+1
135    IF A=7C00H+2 THEN A=7E00H
140    NEXT I
145    PRINT "Fertig! Errechne nun die Checksumme..."
150   A=7C00H
160    FOR I=1 TO 220
170   B=XBY(A)
180   CHECK=CHECK+B
190   A=A+1
195    IF A=7C00H+2 THEN A=7E00H
200    NEXT I
210    IF CHECK=C THEN  PRINT "Checksumme OK" ELSE  PRINT "Checksummenfehler!"
220    PRINT "Bitte das Kopier-Programm aus dem Speicher mit >NEW< entfernen!"
999    END 
1000   REM Hier wuerde der Eingabe-Treiber stehen
1010   REM Ruecksprung aus der Routine mit 22H  
1230   DATA 00H,22H
1240   REM Bytes = 2
1250   REM Checksumme = 34
1260   REM
2000   DATA 0C0H,0E0H,0C0H,0F0H,0C0H,81H,0C0H,0D0H
2010   DATA 0C0H,82H,0C0H,83H,78H,78H,0D1H,80H
2020   DATA 85H,27H,6EH,0D0H,83H,0D0H,82H,0D0H
2030   DATA 0D0H,0D0H,81H,0D0H,0F0H,0D0H,0E0H,22H
2040   DATA 00H,22H,0D2H,96H,30H,96H,0FDH,22H
2050   DATA 0C2H,97H,12H,7EH,22H,12H,7EH,20H
2060   DATA 0D2H,97H,12H,7EH,20H,0C2H,3AH,22H
2070   DATA 75H,6FH,08H,33H,92H,97H,12H,7EH
2080   DATA 22H,12H,7EH,20H,0C2H,96H,12H,7EH
2090   DATA 20H,0D5H,6FH,0EFH,0D2H,97H,12H,7EH
2100   DATA 22H,12H,7EH,20H,30H,97H,02H,0D2H
2110   DATA 38H,0C2H,96H,12H,7EH,20H,22H,0D2H
2120   DATA 3AH,0C2H,38H,0C2H,39H,30H,96H,13H
2130   DATA 30H,97H,10H,0C2H,97H,12H,7EH,20H
2140   DATA 0C2H,96H,12H,7EH,20H,0E5H,6CH,12H
2150   DATA 7EH,38H,22H,0D2H,39H,0D2H,38H,22H
2160   DATA 12H,7EH,5FH,20H,38H,0BH,0E6H,12H
2170   DATA 7EH,38H,08H,20H,38H,03H,0D5H,6DH
2180   DATA 0F5H,12H,7EH,28H,22H,75H,6FH,08H
2190   DATA 12H,7EH,22H,12H,7EH,20H,0A2H,97H
2200   DATA 33H,0C2H,96H,12H,7EH,20H,0D5H,6FH
2210   DATA 0EFH,0C0H,0E0H,0E5H,6DH,0B4H,01H,04H
2220   DATA 0D2H,97H,80H,02H,0C2H,97H,12H,7EH
2230   DATA 22H,0D0H,0E0H,12H,7EH,20H,0C2H,96H
2240   DATA 0D2H,97H,12H,7EH,20H,22H,05H,6CH
2250   DATA 12H,7EH,5FH,20H,38H,08H,12H,7EH
2260   DATA 95H,0F6H,08H,0D5H,6DH,0F8H,12H,7EH
2270   DATA 28H,22H
2280   REM Bytes = 218
2290   REM Checksumme = 23903


@endnode

##
##      IO_Out
##
@node IO_Out "Demoprogramm IO_Out.bas"

1      REM ******************************************************************
2      REM *
3      REM *               Programm IO_Out
4      REM * Der angeschlossene I/O-Chip PCF 8574 P unter der Adresse 4EH
5      REM * wird zur Ausgabe eines 8 Bit Datenwortes gebraucht.
6      REM * Es wird der Wert von 0-255 (0H=0FFH) ausgeben.
7      REM *
8      REM ******************************************************************
9      FOR I=0 TO 255 :  REM     For Next Schleife (0-255)
10    DBY(6CH)=4EH :  REM        Adresse des I/O-Chip
20    DBY(6DH)=1 :  REM          1 Byte schreiben
60    DBY(78H)=I :  REM          I=Wert der geschrieben wird
70     CALL 7E00H :  REM         Aufruf des I2C-Ausgabe-Treibers
75     PRINT I, :  PH0. I :  REM Ausgabe in Dez und Hex
80     NEXT I :  REM             Schleifenende
145    PRINT  :  REM             Leerzeile
500    END  :  REM               Und Tschuess...


@endnode

##
##      LED-Anzeige-Test
##
@node LED-Anzeige-Test "Demoprogramm LED-Anzeige-Test"

1      REM *************************************************************
2      REM *
3      REM *                 Programm LED-Anzeige-Test
4      REM * Das Programm schreibt 1 2 3 4 und einen Dezimalpunkt
5      REM * auf die Digits. Danach wird ein kompletter Segment-Test
6      REM * gemacht, wobei alles leuchten sollte. Zum Schluss wird 
7      REM * die Helligkeit erhoeht und das Programm beginnt von vorne.
8      REM *
9      REM *************************************************************
10    DBY(6CH)=76H :  REM    Adresse des SAA 1064
20    DBY(6DH)=6 :  REM      6 Bytes uebertragen
30    DBY(78H)=0 :  REM      1.Byte = 0 fuer das Kontrollregister
40    DBY(79H)=23 :  REM     2.Byte Aktiviere Digits 1&3, 2&4 mit 3mA
50    DBY(7AH)=6 :  REM      Steht fuer die 1
60    DBY(7BH)=91 :  REM     Steht fuer die 2
70    DBY(7CH)=79 :  REM     Steht fuer die 3
80    DBY(7DH)=102 :  REM    Steht fuer die 4
90     CALL 7E00H :  REM     Aufruf des I2C-Ausgabe-Treibers
100    PRINT "Schreibe 1 2 3 4 auf die Digits." :  PRINT 
110    FOR X=1 TO 1000 :  NEXT X
120    PRINT "Jetzt setze ich bei der 2 den Dezimalpunkt." :  PRINT 
130   DBY(6CH)=76H :  REM    Adresse des SAA 1064
140   DBY(6DH)=4 :  REM      4 Bytes uebertragen
150   DBY(78H)=0 :  REM      0 fuer das Kontrollregister
160   DBY(79H)=23 :  REM     Digits 1&3, 2&4 mit 3 mA
170   DBY(7AH)=6 :  REM      Steht fuer die 1
180   DBY(7BH)=91+128 :  REM 91("2")+128 werden dazu addiert fuer den .
190    CALL 7E00H :  REM     Aufruf des I2C-Ausgabe-Treibers
200    FOR X=1 TO 1000 :  NEXT X
210    PRINT "Kleiner Segmenttest:" :  PRINT 
220    PRINT "Brennen alle Segmente ?" :  PRINT 
230   DBY(6CH)=76H :  REM    Adresse
240   DBY(6DH)=2 :  REM      ? Bytes
250   DBY(78H)=0 :  REM      Kontrollregister
260   DBY(79H)=31 :  REM     Segmenttest mit 3 mA
270    CALL 7E00H
280    FOR X=1 TO 1000 :  NEXT X
290    PRINT "Ein bisschen heller ?"
300   DBY(6CH)=76H :  REM    Adresse 
310   DBY(6DH)=2 :  REM      ? Bytes
320   DBY(78H)=0 :  REM      Kontrollregister
330   DBY(79H)=63 :  REM     Segmenttest mit 6 mA
340    CALL 7E00H
350    FOR X=1 TO 1000 :  NEXT X
360    PRINT  :  PRINT "Noch heller ?"
370   DBY(6CH)=76H :  REM    Adresse 
380   DBY(6DH)=2 :  REM      ? Bytes
390   DBY(78H)=0 :  REM      Kontrollregister
400   DBY(79H)=127 :  REM    Segmenttest mit 12 mA
410    CALL 7E00H
420    FOR X=1 TO 1000 :  NEXT X
430    PRINT  :  PRINT "Und wieder von vorne..." :  PRINT 
440    GOTO 10 :  REM        Und wieder von vorne... Ab dafuer!
499    END 


@endnode

##
##      LED-Zähler
##
@node LED-Zähler "Demoprogramm LED-Zähler.bas"

1      REM *************************************************************
2      REM *
3      REM *                 Programm LED-Zaehler
4      REM * Das Programm gibt die Ziffern von 0000-9999 auf die Digits.
5      REM * Die Adresse des I2C-Modul mit dem SAA 1064 liegt auf 76H.
6      REM * Das Programm war eigentlich nur zum Geschwindigkeitstest 
7      REM * der Ausgabe gedacht. Die PRINT-Ausgabe bremst es aus.
8      REM *
9      REM *************************************************************
10    DBY(6CH)=76H :  REM Adresse des SAA 1064
20    DBY(6DH)=6 :  REM   6 Bytes uebertragen
30    DBY(78H)=0 :  REM   1.Byte Kontrollregister
40    DBY(79H)=55 :  REM  Registersteuerwort zum initialisieren der 4 Digits
45     REM                Display erstmal nullen
50    DBY(7AH)=63 :  REM  1.Digit = 0
60    DBY(7BH)=63 :  REM  2.Digit = 0
70    DBY(7CH)=63 :  REM  3.Digit = 0
80    DBY(7DH)=63 :  REM  4.Digit = 0
90     CALL 7E00H :  REM  Aufruf des I2C-Ausgabe-Treibers
95    A=0
96    B=0
97    C=0
98    D=0
100   X=X+1
110   A=X
120    GOSUB 500
130   DBY(7DH)=LED :  REM 4.Ziffer
140    IF X=10 THEN B=B+1 :  GOSUB 700
468   DBY(6DH)=6
469   DBY(6CH)=76H
470    CALL 7E00H
490    GOTO 100
499    END 
500    REM                Zahlentabelle
510    IF A=0 THEN LED=63
520    IF A=1 THEN LED=6
530    IF A=2 THEN LED=91
540    IF A=3 THEN LED=79
550    IF A=4 THEN LED=102
560    IF A=5 THEN LED=109
570    IF A=6 THEN LED=125
580    IF A=7 THEN LED=7
590    IF A=8 THEN LED=127
600    IF A=9 THEN LED=111

--------------------------------------------------------------------------

Anmerkung zur Zahlentabelle:

Die Zahlen werden aus den einzelnen Segmenten durch Addition der Segment-
werte gebildet. Die 1 z.B. aus Segment b=2 + Segment c=4 also 6.

Hier die Werte: a  =   1
                b  =   2
                c  =   4
                d  =   8
                e  =  16
                f  =  32
                g  =  64
                dp = 128 ( Dezimalpunkt )
                
Siehe auch @{" LED.ilbm " link Bildergalerie/LED.ilbm/main}

Auch lassen sich bestimmte Buchstaben oder eigene Zeichen in einer Tabelle
definieren, soweit diese mit den 7 Segmenten angezeigt werden können.
                 
--------------------------------------------------------------------------                 
                 
610   A=0
620    RETURN 
700   A=B
705    IF A=10 THEN A=0 : B=0 : C=C+1 :  GOSUB 800
710    GOSUB 500
720   DBY(7CH)=LED :  REM 3.Ziffer
730   X=0
740   DBY(7DH)=63
790    RETURN 
800   A=C
810    IF A=10 THEN A=0 : B=0 : C=0 : D=D+1 :  GOSUB 900
820    GOSUB 500
830   DBY(7BH)=LED :  REM 2.Ziffer
840   X=0
880    RETURN 
900   A=D
910    IF A=10 THEN A=0 : B=0 : C=0 : D=0
920    GOSUB 500
930   DBY(7AH)=LED :  REM 1.Ziffer
940   X=0
980    RETURN 


@endnode

##
##      Scan_Test
##
@node Scan_Test "Demoprogramm Scan_Test.bas"

1      REM *************************************************************
2      REM *
3      REM *                 Programm Scan_Test
4      REM * Das Programm versucht auf dem I2C-Bus ein Dummy-Byte
5      REM * an Adresse 0-255 (0H-FFH) zu schreiben.
6      REM * Ist auf der Adresse 6EH der Wert 00H konnte ein Chip mit 
7      REM * der Adresse die in 6CH geschrieben, angesprochen werden.
8      REM *
9      REM *************************************************************
10    DBY(6DH)=1 :  REM       1 Byte schreiben
20    DBY(78H)=0 :  REM       Dummy-Byte gleich 0
30     FOR I=0 TO 0FFH :  REM For Next Schleife (0-255)
40    DBY(6CH)=I :  REM       I = von 0 hochzaehlend
50     CALL 7E00H :  REM      Aufruf des I2C-Ausgabe-Treibers
60     IF DBY(6EH)=0 THEN  PH0. I :  REM Wenn auf Adr. 6EH=0
65     REM                    dann Ausgabe der Adresse I in Hex
70     NEXT I :  REM          Schleifenende
100    END  :  REM            Und Tschuess


@endnode

##
##      I2C-IC's
##
@node I2C-IC's "Weitere I2C-IC's"

   Type             Funktion
   
   PCD3311/12       DTMF/Modem/Tongenerator
   PCF8200          Sprachsynthesizer
   PCF8566          Universeller LCD-Treiber
   PCF8570/71       Statisches RAM (256*8/128*8)
   PCF8570C         Statisches RAM (256*8)
   PCF8572          EEPROM (128*8)
   PCF8573          Echtzeituhr/Kalender
   PCF8574          8-Bit-I/O-Erweiterung
   PCF8574A         8-Bit-I/O-Erweiterung
   PCF8576          Universeller LCD-Treiber
   PCF8577          LCD-Direkt/Dupplex-Treiber
   PCF8577A         LCD-Direkt/Dupplex-Treiber
   PCF8578          LCD-Treiber für Dot-Matrix
   PCF8579          LCD-Treiber für Dot-Matrix
   PCF8582A         EEPROM (256*8)
   PCF8583          Uhr/Kalender mit statischen RAM
   PCF8591          8-Digit A/D-D/A-Wandler
   SAA1064          4-Digit-LED-Treiber
   SAA1136          PCM-Audio-Interface
   SAA1300          Tuner-Schaltkreis
   SAA3038          IR-Transkoder (RC5)
   SAA4700          VPS-Datenzeilen-Prozessor
   SAA5243/45       Computergesteuertes Teletext-IC
   SAA9020          Speicher-Kontroller
   SAA9050/51       Digitaler Multistandard TV-Kontroller
   SAA9055P/8A      Digitaler SECAM-Dekoder
   SAA9055P/8E      Digitaler SECAM-Dekoder
   SAA9062/63/64    Digitaler Ablenkungs-Kontroller
   SAA9068          Bild-in-Bild-Kontroller
   SAB3035/36/37    Computer-Interface für Abstimmung
   SAF1135          Datenzeilen-Dekoder
   TDA8370          Sync-Prozessor für Fernsehgeräte
   TDA8400          Computer-Interface für Vorteiler-Synthesizer
   TDA8405          Stereo-Tonprozessor für TV
   TDA8420/8421     Stereo-Audio-Prozessor
   TDA8425          Stereo-Audio-Prozessor
   TDA8440          Video/Audio-Schalter
   TDA8442          Interface für Farbdekoder
   TDA8443A         YUV/RGB-Interface
   TDA8444          8-fach 6-bit-D/A-Wandler
   TDA8461          PAL/NTSC-Dekoder
   TDA8440          Schalter für Fernsehgeräte
   TEA6000/6100     FM/ZF-System für Mikroprozessor-Tuner
   TEA6300(T)/10T   Fader-Ton-IC
   TEA6330T         Regelverstärker
   TEA6360          Equalizer
   TSA5510(T)       1,3 GHz-Frequenz-Synthesizer
   TSA6057(T)       Radio-PLL-Frequenz-Synthesizer
   UMA1000T         Datenprozessor für drahtlose Telephonie
   UMA1010T         Universeller Synthesizer für Radiokommunikation
           

@endnode 

##
##      BASIC
##
@node BASIC "BASIC-Befehle"

Die folgende Übersicht über Kommandos, Anweisungen und Operatoren wurde
dem Original-Datenblatt von Intel entnommen.

Wer ausführlichere Angaben und die deutschen Erklärungen haben möchte,
verweise ich auf das in @{" Was ist 8052 AH-BASIC ? " link Wasist} aufgeführte Buch.


        @{" " link RUN} RUN         @{" " link DO} DO          @{" " link UI0} UI0         @{" " link RCAP2} RCAP2
        @{" " link CONT} CONT        @{" " link UNTIL} UNTIL       @{" " link UO1} UO1         @{" " link T2CON} T2CON
        @{" " link LIST} LIST        @{" " link WHILE} WHILE       @{" " link UO0} UO0         @{" " link TCON} TCON
        @{" " link LIST#} LIST#       @{" " link END} END         @{" " link ST@} ST@         @{" " link TMOD} TMOD
        @{" " link LIST@} LIST@       @{" " link FOR-TO} FOR-TO      @{" " link LD@} LD@         @{" " link TIME} TIME
        @{" " link NEW} NEW         @{" " link NEXT} NEXT        @{" " link IDLE} IDLE        @{" " link TIMER0} TIMER0
        @{" " link NULL} NULL        @{" " link GOSUB} GOSUB       @{" " link RROM} RROM        @{" " link TIMER1} TIMER1
        @{" " link RAM} RAM         @{" " link RETURN} RETURN      @{" " link +} +           @{" " link TIMER2} TIMER2
        @{" " link ROM} ROM         @{" " link GOTO} GOTO        @{" " link Schr} /           @{" " link PI} PI
        @{" " link XFER} XFER        @{" " link ONGOTO} ON GOTO     @{" " link **} **
        @{" " link PROG} PROG        @{" " link ONGOSUB} ON GOSUB    @{" " link *} *
        @{" " link PROG1} PROG1       @{" " link IF-THEN} IF-THEN     @{" " link -} -
        @{" " link PROG2} PROG2       @{" " link INPUT} INPUT       @{" " link .AND.} .AND.
        @{" " link PROG3} PROG3       @{" " link LET} LET         @{" " link .OR.} .OR.
        @{" " link PROG4} PROG4       @{" " link ONERR} ONERR       @{" " link .XOR.} .XOR.
        @{" " link PROG5} PROG5       @{" " link ONTIME} ONTIME      @{" " link ABS()} ABS()
        @{" " link PROG6} PROG6       @{" " link ONEX1} ONEX1       @{" " link NOT()} NOT()
        @{" " link FPROG} FPROG       @{" " link PRINT} PRINT       @{" " link INT()} INT()
        @{" " link FPROG1} FPROG1      @{" " link PRINT#} PRINT#      @{" " link SGN()} SGN()
        @{" " link FPROG2} FPROG2      @{" " link PH0.} PH0.        @{" " link SQR()} SQR()
        @{" " link FPROG3} FPROG3      @{" " link PH1.} PH1.        @{" " link RND} RND
        @{" " link FPROG4} FPROG4      @{" " link PH0.#} PH0.#       @{" " link LOG()} LOG()
        @{" " link FPROG5} FPROG5      @{" " link PH1.#} PH1.#       @{" " link EXP()} EXP()
        @{" " link FPROG6} FPROG6      @{" " link PRINT@} PRINT@      @{" " link SIN()} SIN()
        @{" " link BAUD} BAUD        @{" " link PH0.@} PH0.@       @{" " link COS()} COS()
        @{" " link CALL} CALL        @{" " link PH1.@} PH1.@       @{" " link TAN()} TAN()
        @{" " link CLEAR} CLEAR       @{" " link PGM} PGM         @{" " link ATN()} ATN()
        @{" " link CLEARS} CLEARS      @{" " link PUSH} PUSH        @{" " link CBY()} CBY()
        @{" " link CLEARI} CLEARI      @{" " link POP} POP         @{" " link DBY()} DBY()
        @{" " link CLOCK1} CLOCK1      @{" " link PWM} PWM         @{" " link XBY()} XBY()
        @{" " link CLOCK0} CLOCK0      @{" " link REM} REM         @{" " link GET} GET
        @{" " link DATA} DATA        @{" " link RETI} RETI        @{" " link IE} IE
        @{" " link READ} READ        @{" " link STOP} STOP        @{" " link IP} IP
        @{" " link RESTORE} RESTORE     @{" " link STRING} STRING      @{" " link PORT1} PORT1
        @{" " link DIM} DIM         @{" " link UI1} UI1         @{" " link PCON} PCON
@endnode

##
##      RUN
##
@node RUN "Basic-Befehl RUN"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RUN          Execute a program                      RUN




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CONT
##
@node CONT "Basic-Befehl CONT"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CONT         CONTinue after a STOP or Control-C     CONT




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      LIST
##
@node LIST "Basic-Befehl LIST"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LIST         LIST program to the console device     LIST
                                                          LIST 10-50




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      LIST#
##
@node LIST# "Basic-Befehl LIST#"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LIST#        LIST program to serial printer         LIST#
                                                          LIST# 50




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      LIST@
##
@node LIST@ "Basic-Befehl LIST@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LIST@        LIST program to user driver            LIST@
                                                          LIST@ 50




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      NEW
##
@node NEW "Basic-Befehl NEW"




      COMMAND      FUNCTION                               EXAMPLE(S)


      NEW          erase the program stored in RAM        NEW




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      NULL
##
@node NULL "Basic-Befehl NULL"




      COMMAND      FUNCTION                               EXAMPLE(S)


      NULL         set NULL count after carriage return-  NULL
                   line feed                              NULL 4




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RAM
##
@node RAM "Basic-Befehl RAM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RAM          evoke RAM mode, current program in     RAM
                   READ/WRITE memory




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ROM
##
@node ROM "Basic-Befehl ROM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ROM          evoke ROM mode, current program in     ROM
                   ROM/EPROM memory                       ROM 3




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      XFER
##
@node XFER "Basic-Befehl XFER"




      COMMAND      FUNCTION                               EXAMPLE(S)


      XFER         transfer a program from ROM/EPROM to   XFER
                   RAM




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG
##
@node PROG "Basic-Befehl PROG"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG         save the current program in EPROM      PROG




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG1
##
@node PROG1 "Basic-Befehl PROG1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG1         save baud rate information in EPROM   PROG1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG2
##
@node PROG2 "Basic-Befehl PROG2"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG2        save baud rate information in EPROM    PROG2
                   and execute program after RESET




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG3
##
@node PROG3 "Basic-Befehl PROG3"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG3        save baud rate and MTOP information    PROG3
                   in EPROM




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG4
##
@node PROG4 "Basic-Befehl PROG4"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG4        save baud rate and MTOP information    PROG4
                   in EPROM and execute program after
                   RESET




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG5
##
@node PROG5 "Basic-Befehl PROG5"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG5        same as PROG4 except that external     PROG5
                   RAM is not cleared on RESET or power
                   up if external RAM contains a 0A5H
                   in location 5EH




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PROG6
##
@node PROG6 "Basic-Befehl PROG6"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PROG6        same as PROG6 except that external     PROG6
                   code location 4039H is CALLED after
                   RESET




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG
##
@node FPROG "Basic-Befehl FPROG"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG        save the current program in EPROM      FPROG
                   using the INTELligent algorithm




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG1
##
@node FPROG1 "Basic-Befehl FPROG1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG1       save baud rate information in EPROM    FPROG1
                   using the INTELligent algorithm




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG2
##
@node FPROG2 "Basic-Befehl FPROG2"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG2       save baud rate information in EPROM    FPROG2
                   and execute program after RESET, use
                   INTELligent algorithm




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG3
##
@node FPROG3 "Basic-Befehl FPROG3"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG3       same as PROG3, except INTELligent      FPROG3
                   programming algorithm is used




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG4
##
@node FPROG4 "Basic-Befehl FPROG4"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG4       same as PROG4, except INTELligent      FPROG4
                   programming algorithm is used




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG5
##
@node FPROG5 "Basic-Befehl FPROG5"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG5       same as PROG5, except INTELligent      FPROG5
                   programming algorithm is used




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FPROG6
##
@node FPROG6 "Basic-Befehl FPROG6"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FPROG6       same as PROG6, except INTELligent      FPROG6
                   programming algorithm is used




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      BAUD
##
@node BAUD "Basic-Befehl BAUD"




      COMMAND      FUNCTION                               EXAMPLE(S)


      BAUD         set baud rate for line printer port    BAUD 1200




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CALL
##
@node CALL "Basic-Befehl CALL"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CALL         CALL assembly language program         CALL 9000H




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CLEAR
##
@node CLEAR "Basic-Befehl CLEAR"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CLEAR        CLEAR variables, interrupts and        CLEAR
                   Strings




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CLEARS
##
@node CLEARS "Basic-Befehl CLEARS"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CLEARS       CLEARS Stacks                          CLEARS




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CLEARI
##
@node CLEARI "Basic-Befehl CLEARI"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CLEARI       CLEAR interrupts                       CLEARI




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CLOCK1
##
@node CLOCK1 "Basic-Befehl CLOCK1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CLOCK1       enable REAL TIME CLOCK                 CLOCK1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CLOCK0
##
@node CLOCK0 "Basic-Befehl CLOCK0"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CLOCK0       disable REAL TIME CLOCK                CLOCK0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      DATA
##
@node DATA "Basic-Befehl DATA"




      COMMAND      FUNCTION                               EXAMPLE(S)


      DATA         DATA to be read by READ statement      DATA 100




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      READ
##
@node READ "Basic-Befehl READ"




      COMMAND      FUNCTION                               EXAMPLE(S)


      READ         READ data in DATA statement            READ A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RESTORE
##
@node RESTORE "Basic-Befehl RESTORE"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RESTORE      RESTORE READ pointer                   RESTORE




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      DIM
##
@node DIM "Basic-Befehl DIM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      DIM          allocate memory for arrayed variables  DIM A(20)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      DO
##
@node DO "Basic-Befehl DO"




      COMMAND      FUNCTION                               EXAMPLE(S)


      DO           set up loop for WHILE or UNTIL         DO




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      UNTIL
##
@node UNTIL "Basic-Befehl UNTIL"




      COMMAND      FUNCTION                               EXAMPLE(S)


      UNTIL        test DO loop condition                 UNTIL A=10
                   (loop if false)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      WHILE
##
@node WHILE "Basic-Befehl WHILE"




      COMMAND      FUNCTION                               EXAMPLE(S)


      WHILE        test DO loop condition                 WHILE A=B
                   (loop if true)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      END
##
@node END "Basic-Befehl END"




      COMMAND      FUNCTION                               EXAMPLE(S)


      END          terminate program execution            END




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      FOR-TO
##
@node FOR-TO "Basic-Befehl FOR-TO"




      COMMAND      FUNCTION                               EXAMPLE(S)


      FOR-TO       set up FOR-NEXT loop                   FOR A=1 TO 5




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      NEXT
##
@node NEXT "Basic-Befehl NEXT"




      COMMAND      FUNCTION                               EXAMPLE(S)


      NEXT         test FOR-NEXT loop condition           NEXT A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      GOSUB
##
@node GOSUB "Basic-Befehl GOSUB"




      COMMAND      FUNCTION                               EXAMPLE(S)


      GOSUB        execute subroutine                     GOSUB 1000




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RETURN
##
@node RETURN "Basic-Befehl RETURN"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RETURN       RETURN from subroutine                 RETURN




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      GOTO
##
@node GOTO "Basic-Befehl GOTO"




      COMMAND      FUNCTION                               EXAMPLE(S)


      GOTO         GOTO program line number               GOTO 500




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ON GOTO
##
@node ONGOTO "Basic-Befehl ON GOTO"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ON GOTO      conditional GOTO                       ON A GOTO 5,20




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ON GOSUB
##
@node ONGOSUB "Basic-Befehl ON GOSUB"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ON GOSUB     conditional GOSUB                      ON A GOSUB 2,6




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##    IF-THEN-ELSE
##
@node IF-THEN "Basic-Befehl IF-THEN-ELSE"




      COMMAND      FUNCTION                               EXAMPLE(S)


      IF-THEN      conditional test                       IF A<B THEN
         ELSE                                             A=0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##    INPUT
##
@node INPUT "Basic-Befehl INPUT"




      COMMAND      FUNCTION                               EXAMPLE(S)


      INPUT        INPUT a string or variable             INPUT A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##    LET
##
@node LET "Basic-Befehl LET"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LET          assign a variable or string a value    LET A=10
                   (LET is optional)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ONERR
##
@node ONERR "Basic-Befehl ONERR"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ONERR        ONERRor GOTO line number               ONERR 1000




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ONTIME
##
@node ONTIME "Basic-Befehl ONTIME"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ONTIME       generate an interrupt when TIME is     ONTIME 10,1000
                   equal to or greater than ONTIME
                   argument-line number is after comma




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ONEX1
##
@node ONEX1 "Basic-Befehl ONEX1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ONEX1        GOSUB to line number following ONEX1   ONEX1 1000
                   when INT1 pin is pulled low




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##    PRINT
##
@node PRINT "Basic-Befehl PRINT"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PRINT        PRINT variables, strings or literals   PRINT A
                   P. is shorthand for PRINT




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PRINT#
##
@node PRINT# "Basic-Befehl PRINT#"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PRINT#       PRINT to software serial port          PRINT# A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH0.
##
@node PH0. "Basic-Befehl PH0."




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH0.         PRINT HEX mode with zero suppression   PH0. A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH1.
##
@node PH1. "Basic-Befehl PH1."




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH1.         PRINT HEX mode with no zero            PH1. A
                   suppression




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH0.#
##
@node PH0.# "Basic-Befehl PH0.#"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH0.#        PH0. to line printer                   PH0.# A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH1.#
##
@node PH1.# "Basic-Befehl PH1.#"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH1.#        PH1.# to line printer                  PH1.# A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PRINT@
##
@node PRINT@ "Basic-Befehl PRINT@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PRINT@       PRINT to user defined driver           PRINT@ 5*5




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH0.@
##
@node PH0.@ "Basic-Befehl PH0.@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH0.@        PH0. to user defined driver            PH0.@
                                                          XBY(5EH)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PH1.@
##
@node PH1.@ "Basic-Befehl PH1.@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PH1.@        PH1. to user defined driver            PH1.@ A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PGM
##
@node PGM "Basic-Befehl PGM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PGM          Programm an EPROM                      PGM




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PUSH
##
@node PUSH "Basic-Befehl PUSH"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PUSH         PUSH expressions on argument stack     PUSH 10,A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      POP
##
@node POP "Basic-Befehl POP"




      COMMAND      FUNCTION                               EXAMPLE(S)


      POP          POP argument stack to variables        POP A,B,C




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PWM
##
@node PWM "Basic-Befehl PWM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PWM          PULSE WIDTH MODULATION                 PWM 50,50,100




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      REM
##
@node REM "Basic-Befehl REM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      REM          REMark                                 REM DONE




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RETI
##
@node RETI "Basic-Befehl RETI"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RETI         RETurn from interrupt                  RETI




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      STOP
##
@node STOP "Basic-Befehl STOP"




      COMMAND      FUNCTION                               EXAMPLE(S)


      STOP         break program execution                STOP




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      STRING
##
@node STRING "Basic-Befehl STRING"




      COMMAND      FUNCTION                               EXAMPLE(S)


      STRING       allocate memory for STRINGs            STRING 50,10




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      UI1
##
@node UI1 "Basic-Befehl UI1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      UI1          evoke User console Input routine       UI1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      UI0
##
@node UI0 "Basic-Befehl UI0"




      COMMAND      FUNCTION                               EXAMPLE(S)


      UI0          evoke BASIC console Input routine      UI0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      UO1
##
@node UO1 "Basic-Befehl UO1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      UO1          evoke User console Output routine      UO1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      UO0
##
@node UO0 "Basic-Befehl UO0"




      COMMAND      FUNCTION                               EXAMPLE(S)


      UO0          evoke BASIC console Output routine     UO0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ST@
##
@node ST@ "Basic-Befehl ST@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ST@          store top of stack at user specified   ST@ 1000H
                   location                               ST@ A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      LD@
##
@node LD@ "Basic-Befehl LD@"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LD@          load top of stack from user specified  LD@ 1000H
                   location                               LD@ A




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      IDLE
##
@node IDLE "Basic-Befehl IDLE"




      COMMAND      FUNCTION                               EXAMPLE(S)


      IDLE         wait for interrupt                     IDLE




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RROM
##
@node RROM "Basic-Befehl RROM"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RROM         run a program in EP(ROM)               RROM 3




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      +
##
@node + "Basic-Befehl +"




      COMMAND      FUNCTION                               EXAMPLE(S)


      +            ADDITION                               1+1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      SCHR
##
@node SCHR "Basic-Befehl /"




      COMMAND      FUNCTION                               EXAMPLE(S)


      /            DIVISION                               10/2




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      **
##
@node ** "Basic-Befehl **"




      COMMAND      FUNCTION                               EXAMPLE(S)


      **           EXPONENTATION                          2**4




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      *
##
@node * "Basic-Befehl *"




      COMMAND      FUNCTION                               EXAMPLE(S)


      *            MULTIPLICATION                         4*4




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      -
##
@node - "Basic-Befehl -"




      COMMAND      FUNCTION                               EXAMPLE(S)


      -            SUBTRACTION                            8-4




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      .AND.
##
@node .AND. "Basic-Befehl .AND."




      COMMAND      FUNCTION                               EXAMPLE(S)


      .AND.        LOGICAL AND                            10.AND.5




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      .OR.
##
@node .OR. "Basic-Befehl .OR."




      COMMAND      FUNCTION                               EXAMPLE(S)


      .OR.         LOGICAL OR                             2.OR.1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      .XOR.
##
@node .XOR. "Basic-Befehl .XOR."




      COMMAND      FUNCTION                               EXAMPLE(S)


      .XOR.        LOGICAL EXCLUSIVE OR                   3.XOR.2




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ABS()
##
@node ABS() "Basic-Befehl ABS()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ABS()        ABSOLUTE VALUE                         ABS(-3)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      NOT()
##
@node NOT() "Basic-Befehl NOT()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      NOT()        ONES COMPLEMENT                        NOT(0)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      INT()
##
@node INT() "Basic-Befehl INT()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      INT()        INTEGER                                INT(3.2)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      SGN()
##
@node SGN() "Basic-Befehl SGN()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      SGN()        SIGN                                   SGN(-5)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      SQR()
##
@node SQR() "Basic-Befehl SQR()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      SQR()        SQUARE ROOT                            SQR(100)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RND
##
@node RND "Basic-Befehl RND"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RND          RANDOM NUMBER                          RND




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      LOG()
##
@node LOG() "Basic-Befehl LOG()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      LOG()        NATURAL LOG                            LOG(10)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      EXP()
##
@node EXP() "Basic-Befehl EXP()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      EXP()        "e"(2.7182818) TO THE X                EXP(10)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      SIN()
##
@node SIN() "Basic-Befehl SIN()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      SIN()        RETURNS THE SINE OF ARGUMENT           SIN(3.14)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      COS()
##
@node COS() "Basic-Befehl COS()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      COS()        RETURNS THE COSINE OF ARGUMENT         COS(0)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TAN()
##
@node TAN() "Basic-Befehl TAN()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TAN()        RETURNS THE TANGENT OF ARGUMENT        TAN(.707)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      ATN()
##
@node ATN() "Basic-Befehl ATN()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      ATN()        RETURNS ARCTANGENT OF ARGUMENT         ATN(1)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      CBY()
##
@node CBY() "Basic-Befehl CBY()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      CBY()        READ PROGRAM MEMORY                    P.CBY(4000)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      DBY()
##
@node DBY() "Basic-Befehl DBY()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      DBY()        READ/ASSIGN INTERNAL DATA MEMORY       DBY(99)=10




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      XBY()
##
@node XBY() "Basic-Befehl XBY()"




      COMMAND      FUNCTION                               EXAMPLE(S)


      XBY()        READ/ASSIGN EXTERNAL DATA MEMORY       P.XBY(10)




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      GET
##
@node GET "Basic-Befehl GET"




      COMMAND      FUNCTION                               EXAMPLE(S)


      GET          READ CONSOLE                           P.GET




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      IE
##
@node IE "Basic-Befehl IE"




      COMMAND      FUNCTION                               EXAMPLE(S)


      IE           READ/ASSIGN IE REGISTER                IE=82H




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      IP
##
@node IP "Basic-Befehl IP"




      COMMAND      FUNCTION                               EXAMPLE(S)


      IP           READ/ASSIGN IP REGISTER                IP=0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PORT1
##
@node PORT1 "Basic-Befehl PORT1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PORT1        READ/ASSIGN I/O PORT 1 (P1)            PORT1=0FFH




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PCON
##
@node PCON "Basic-Befehl PCON"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PCON         READ/ASSIGN PCON REGISTER              PCON=0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      RCAP2
##
@node RCAP2 "Basic-Befehl RCAP2"




      COMMAND      FUNCTION                               EXAMPLE(S)


      RCAP2        READ/ASSIGN RCAP2 (RCAP2H:RCAP2L)      RCAP2=100




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      T2CON
##
@node T2CON "Basic-Befehl T2CON"




      COMMAND      FUNCTION                               EXAMPLE(S)


      T2CON        READ/ASSIGN T2CON REGISTER             P.T2CON




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TCON
##
@node TCON "Basic-Befehl TCON"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TCON         READ/ASSIGN TCON REGISTER              TCON=10H




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TMOD
##
@node TMOD "Basic-Befehl TMOD"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TMOD         READ/ASSIGN TMOD REGISTER              P.TMOD




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TIME
##
@node TIME "Basic-Befehl TIME"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TIME         READ/ASSIGN THE REAL TIME CLOCK        P.TIME




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TIMER0
##
@node TIMER0 "Basic-Befehl TIMER0"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TIMER0       READ/ASSIGN TIMER0 (TH0: TL0)          TIMER0=0




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TIMER1
##
@node TIMER1 "Basic-Befehl TIMER1"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TIMER1       READ/ASSIGN TIMER1 (TH1: TL)           P.TIMER1




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      TIMER2
##
@node TIMER2 "Basic-Befehl TIMER2"




      COMMAND      FUNCTION                               EXAMPLE(S)


      TIMER2       READ/ASSIGN TIMER2 (TH2: TL2)          TIMER2=0FFH




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode

##
##      PI
##
@node PI "Basic-Befehl PI"




      COMMAND      FUNCTION                               EXAMPLE(S)


      PI           PI=3.1415926                           PI




      Zurück zu den @{" Basic-Befehlen. " link BASIC}

@endnode


##
##      Demoprogramme
##
@node Demos "Demoprogramme"

Hier nun eine kleine Sammlung von 8052er Basic-Programmen.

Alle Programme könnten zwar eleganter geschrieben sein, aber um auch
Anwendern die wenig Basic-Kenntnisse haben den Einstieg zu ermöglichen
wurde auf die Optimierung verzichtet.

Programm   @{" Lese_Port " link Lese_Port}
Programm   @{" Multiplex " link Multiplex}
Programm   @{" Portausgangstest " link Portausgangstest}
Programm   @{" ROMkopie " link ROMkopie}
Programm   @{" Temperaturmessung " link Temperaturmessung}
Programm   @{" Test_Multiplex " link Test_Multiplex}
Programm   @{" Uhrzeit " link Uhrzeit}
Programm   @{" Uhrzeit_2 " link Uhrzeit_2}
Programm   @{" Meßwertgeberaufnahme " link Meßwertgeberaufnahme}
Programm   @{" DCF_Decoder " link DCF_Decoder}

@endnode

##
##      Lese_Port
##
@node Lese_Port "Programm Lese_Port"

Programm Lese_Port

Nach dem Start des Programms, kann der Wert der am Eingangsport Adresse
0C004 Hex anliegt gelesen und auf dem Monitor gebracht werden.

Die Hauptprogrammschleife erstreckt sich von Zeile 100 - 200. In Zeile
110 wird durch den GET-Befehl der serielle Eingang laufend abgefragt.
Kommt nun das Dollarzeichen "$" an, wird zum Unterprogramm Zeile 9000
verzweigt. Hier wird der Wert der aus Adresse 0C004 Hex gelesen wurde,
in die Variable MESS abgelegt und durch den PRINT-Befehl angezeigt.

Anmerkung zum Befehl XBY:

Dieser entspricht im Prinzip dem normalen Basic Peek oder Poke - Befehl.
Ob nun gelesen oder geschrieben werden soll hängt davon ab, wo XBY steht.
Ist dieser an zweiter Stelle wie z.B. MESS=XBY(Adresse) wird gelesen.
Schreiben an eine Adresse sieht demzufolge so aus: XBY(Adresse)=Wert


@endnode

##
##      Multiplex
##
@node Multiplex "Programm Multiplex"

Programm Multiplex

Die 8 Frequenzeingänge werden durchgescannt und der gelesene Wert kann
mit den Tasten 1-8 ausgelesen werden.

In Zeile 515 wird der Ausgangsport Adresse  0C003 Hex angesteuert und
die Datenbits D0, D1, D2 selektieren die Eingangsadressen des
Multiplex-IC. Um ein Inverter-IC auf der IN_OUT-Platine zu sparen, muß
die Ansteuerung wie in den Zeilen 1000 - 1070 aussehen. Soll z.B. der
erste Eingang ausgewählt werden, muß ein Wert zwischen 0-31 an Adresse
0C003 Hex geschrieben werden. Um die Sache nicht kompliziert zu machen,
wird in Zeile 510 einfach 32 dazu addiert und somit kann der
5. Eingang gelesen werden usw... usw. .


@endnode

##
##      Portausgangstest
##
@node Portausgangstest "Programm Portausgangstest"

Programm Portausgangstest

Nach dem Start des Programms können durch die Eingabe auf den
Tasten 1-10 die folgenden Ausgaben gemacht werden:
Taste 1=Bit 1 (D0) usw. / Taste 9 gibt die Werte binär hochzählend
von 0-255 aus. Taste 0=0

In Zeile 80 wird die Adresse des Ausgangsport festgelegt. (Hier Port 3.)
Ist die optische Ausgangskontrolle (Bildergalerie/Hilfsmittel)
angeschlossen kann die Ausgabe kontrolliert werden. Gleichzeitig erfolgt
auch die Ausgabe des entsprechenden Wertes auf dem Monitor.
Achtung: Die LED's zeigen den Wert invertiert an. Also beim Wert 0
         leuchten alle Leuchtdioden.


@endnode

##
##      ROMkopie
##
@node ROMkopie "Programm ROMkopie"

Programm ROMkopie

Benötigt wird der Adaptersockel wie in @{" Tips zur EPROMprogrammierung " link Tips}
beschrieben. Das Programm selbst hat eine Benutzerführung.


@endnode

##
## Temperaturmessung
##
@node Temperaturmessung "Programm Temperaturmessung"

Programm Temperaturmessung

Liest den Wert der an T1 bzw. Multiplexeingang anliegt und gibt diesen
auf das LCD und dem Monitor aus.
Zwischen den Zeilen 9000-9290 liegen die Unterprogramme für die Ansteuerung
des LCD-Displays. Nach dem Start folgt zuerst die Initialisierung des LCD,
wie in Zeile 20 (Gosub 9200). Danach können entweder Daten oder Kommandos
an das LCD gesendet werden.


@endnode

##
##      Test_Multiplex
##
@node Test_Multiplex "Programm Test_Multiplex"

Programm Test_Multiplex

Die 8 Frequenzeingänge werden durchgescannt und der gelesene Wert auf
dem Monitor ausgegeben.
Das Programm ist ähnlich wie das Programm @{" Multiplex. " link Multiplex}
Hier aber erfolgt die Ausgabe kontinuierlich auf dem Monitor im Format
" Auf Eingang Nr. X ist XXXX Hertz ".


@endnode

##
##      Uhrzeit
##
@node Uhrzeit "Programm Uhrzeit"

Programm Uhrzeit

Nach den Programmstart wird man aufgefordert das aktuelle Datum sowie die
Uhrzeit einzugeben. Die Ausgabe erfolgt dann auf das LCD und dem Monitor.
Ab Zeile 60000 fängt das Unterprogramm für die Berechnung der Uhrzeit und
des Datums an. Zwischen den Zeilen 9000-9290 liegen die Unterprogramme für
die Ansteuerung des LCD's. In Zeile 10 wird die Systemvariable XTAL mit der
entsprechenden Quarzfrequenz gesetzt. Indem man an dieser Systemvariablen
etwas herumdoktort kann die Softwareuhr geeicht werden. Geht die Uhr z.B.
1 Minute am Tag nach, kann der Wert entsprechend optimiert werden.


@endnode

##
##      Uhrzeit_2
##
@node Uhrzeit_2 "Programm Uhrzeit_2"

Programm Uhrzeit_2

Nach dem Start des Programms kann die Uhrzeit mit Shift/S gesetzt und mit
Shift/T geholt werden. Shift/4 ($) gibt den Wert der an T1 anliegt aus.
Uhrzeit, Datum und Meßwert werden auch auf dem LCD angezeigt.
Eigentlich ist dieses Programm nur eine Erweiterung des Programms Uhrzeit.


@endnode

##
##      Meßwertgeberaufnahme
##
@node Meßwertgeberaufnahme "Programm Meßwertgeberaufnahme"

Programm Meßwertgeberaufnahme

Meßwertgeberaufnahme ist nur ein kleines Demoprogramm, das in BlitzBasic 2
geschrieben wurde und das zeigen soll, wie die Software auf Amigaseite
aussehen könnte.
Zuerst ist es nötig, das Programm Multiplex zum 8052er System zu über-
tragen und zu starten. Danach muß das Terminalprogramm beendet werden.
Es ist nämlich nicht möglich, daß zwei Programme den Seriellport teilen.
Das Demoprogramm sendet die Tastaturcodes und gibt die empfangenen Werte
aus.


@endnode
##
##      DCF_Decoder
##
@node DCF_Decoder "Programm DCF_Decoder"

Programm DCF_Decoder

Das Listing "DCF77-Dekoder" aus dem 8052 AH-Basic Buch wurde hier als
Grundlage genommen und entsprechend der anderen Hardware angepaßt. Da
auch hier nur die wichtigsten Funktionen übernommen wurden, verkleinerte
sich das Programm wesentlich.
Die REM-Zeilen 1 bis 51 zeigen die gebrauchten Variablen und Strings an.
Bei Platzproblemen können diese entfernt werden.
Wichtig ist, daß der Gebereingang  8 an dem die 625 Hertz Rechteckspannung
anliegt auch eingestellt wird (Zeile 100 XBY(0C003H)=255).

Da im Prinzip die Uhr nur beim Neustart gestellt werden braucht und danach
evtl. einmal die Stunde (oder am Tag) synchron sein braucht (der Timer des
Prozessors ist verhältnismäßig genau), kann mit einer TMOD-Anweisung der
externe Interrupt abgeschaltet werden. So ist genügend Prozessorzeit für
andere Routinen übrig und es können keine Interrupts das Programm unter-
brechen.

Beim Start des Programms wird das LCD-Display zurückgesetzt und die Uhrzeit
mit 00:00:00 ausgegeben. Das Datum ist 1. Januar '00 und vor der Uhrzeit
erscheint ein "-" -Zeichen, das anzeigt das keine Synchronisation besteht.
Nach spätestens 3 Minuten (einwandfreier Empfang vorausgesetzt) sollte
die aktuelle Uhrzeit im Display erscheinen. Außerdem wechselt das
"-" -Zeichen zum "*", das einwandfreien Empfang signalisiert.
Durch Eingabe von "$" wird die aktuelle Uhrzeit, sowie das Datum seriell
ausgegeben.

Shift/T holt die Daten im Format:
Wochentag, Monatstag, Monat, Jahr, Stunde, Minuten, Sekunden, Synch. und
Sommerzeit.
Zum Beispiel steht 1 bei Wochentag für den Montag.
Bei Synch. steht 42, wenn einwandfreier Empfang war, bzw. 45 wenn dieser
gestört ist.
( 42 ist der Dezimale ASCII-Code des Zeichens "*", 45 das Zeichen "-" )
Bei Sommerzeit wird eine 2, Normalzeit eine 1 ausgegeben.

Shift/L gibt die Uhrzeit aus, wann die letzte Synchronisation bestand.

Mit Shift/S kann die Uhrzeit auch manuell über die Tastatur gesetzt werden
im Format: Wochentag, Tag, Monat, Jahr, Stunden, Minuten, Sekunden, jeweils
getrennt durch ein Komma.


@endnode
##
##      Tips
##
@node Tips "Tips zur EPROMprogrammierung"

Da zur EPROMprogrammierung die Portausgänge 1.3 und 1.4 benutzt werden,
sollte hier nichts angeschlossen sein, wie z.B. Relais oder LED's, da
der Pegel evtl. heruntergezogen werden kann und die EPROMprogrammierung
dann nicht funktioniert.
Also hier die beste Vorgehensweise:
Bei ausgeschalteter Prozessorplatine das EPROM einsetzen. Da das EPROM
ein CMOS-IC ist, sollte statische Aufladung vermieden bzw. abgeleitet
werden. Eine evtl. Verbindung von den Portausgängen 1.3 und 1.4 zu
externen Ein oder Ausgabebausteinen lösen. Da die Portausgänge 1.0 - 1.7
sowieso auf eine Stiftleiste geführt und normalerweise ein Stecker dafür
verwendet werden sollte, braucht dieser nur abgezogen werden.
Schalter S2 und S3 können geschlossen und das 8052er System eingeschaltet
werden. Nach dem Betätigen der Leertaste, müßte sich der Interpreter wie
gewohnt melden. Nun, nachdem man sein Programm übertragen hat, wird S1
geschlossen und die Programmierspannung steht dem EPROM zur Verfügung.
Durch die PROG-Anweisung wird das im Speicher stehende Programm ins
EPROM gebrannt. In der Programmierphase leuchtet die LED und auf dem
Terminal wird das PROG z.B. 1 angezeigt. Es ist nämlich möglich mehrere
Programme hintereinander ins EPROM zu brennen und der Interpreter
numeriert diese dann. Für die 8 KB große Interpreterkopie braucht
der Prozessor ca. 7 Minuten. Nachdem die LED ausgegangen ist, muß Schalter
S1 geöffnet werden und die EPROMprogrammierung ist damit beendet.
Schalter S2 und S3 können auch wieder geöffnet werden und es kann ein
kleiner Test erfolgen. Durch den Befehl @{" ROM  " link ROM} wird ins EPROM geschaltet
und mit @{" LIST " link LIST} kann das gerade gebrannte Programm auf's Terminal gebracht
werden.
Der Interpreter stellt auch einen INTELligenten Programmieralgorithmus zur
Verfügung, aber dieser wird bei diesem Hardwareaufbau nicht unterstützt.
Also die ganzen FPROG-Programmieranweisungen funktionieren nicht und
deshalb sollten nur die PROG(1-6)-Befehle verwendet werden.
Das Kopieren des Interpreters ins EPROM erfordert zusätzlich noch einen
Adaptersockel. Die Programme, die normalerweise durch PROG gebrannt werden,
liegen in der zweiten Hälfte des EPROMs. Beim Systemstart sollte der
Prozessor den Interpreter ab Adresse 0000 Hex im EPROM finden. Um nun
die erste Hälfte im EPROM anzusprechen und den Interpreter dorthin zu
kopieren, wird eine Adressleitung auf Masse gelegt.
Also man nehme:
Zwei 28 polige IC-Fassungen, biege von einer Fassung Pin 27 (A14) um und
löte einen kurzen Draht an. Dieser Draht wird mit Pin 14 (Masse) verbunden
und angelötet. Diese Fassung wird auf die andere gesteckt und zusammen-
gedrückt. Dabei ist zu beachten, daß der umgebogene Pin 27 (A14) keinen
Kontakt mit dem darunterliegenden hat (evtl. etwas Isolierband nehmen).
Der Massepin 14 bleibt natürlich durchgehend. Zweck der Sache ist, daß
die Adreßleitung A14 zum EPROM unterbrochen und der Anschlußpin am EPROM
an Masse gelegt wird. Dadurch wird die Adressierung "umgebogen". Auf die
gestapelten Fassungen wird das EPROM eingesetzt und dieses ganze Gebilde
in den EPROMsockel auf dem Prozessorboard gesteckt. Nach der Kopie des
Interpreters in das EPROM muß der Adaptersockel wieder entfernt werden.
Nach dem Austausch des 8052 AH-Basic-Prozessors gegen einen 80C32, muß
nur noch das interne ROM des 80C32 abgeschaltet werden. Dieses geschieht,
indem man eine Drahtbrücke neben dem Prozessor oberhalb C7 (wird mit Jumper
bezeichnet) einlötet.


@endnode


##
##      KONTAKT
##
@node Kontakt "Adresse des Autors"


Bitte schicken Sie das ausgefüllte Registrierungsformular an:




                    Andreas Heinrich
                    Ellerstraße 34
            D-33615 Bielefeld


       Email:  eraser@Suicide.Turboland.de
               AHeinrich@t-online.de       

Wenn Ihnen ein Fehler am Programm oder der Hardware auffallen sollte,
scheuen Sie sich bitte nicht, mir diesen mitzuteilen.


               Ich bedanke mich im voraus.

@endnode


