
                  Last Installment For the Event Detector.
                  ----------------------------------------

                                   Coding.
                                   -------

  Before anyone comments about my coding practice, I code so that young
  children can understand what is going on, NOT how professionals do it.
  I call my approach to this the 'baby' method(s). As all of my projects
  are mainly for youngsters then the code must suit youngsters also.

                  (Read my CRITERIA in magazine Issue 44.)

  Now read on... :)

  (SURPRISE, SURPRISE... :)

  Kickstart 1.3x and Workbench 1.3x.
  ----------------------------------

  +--------------------------------------------------------------------+
  | ******   NO, I HAVEN'T FORGOTTEN THE OLD A500 AND OS1.3x!   ****** |
  +--------------------------------------------------------------------+

  AmigaBASIC Interpreter.
  -----------------------

  AmigaBASIC was supplied as the standard BASIC interpreter for OS1.3x
  and so I have included a BASIC program in the OLD line number format
  to work on a STANDARD A500, complete with floppy disk swapping.
  DO YOU REMEMBER DOING ALL OF THAT RIGMAROLE THEN EH!!!. :)

  ~PARINPUT.B~ is the basic script for the AmigaBASIC Interpreter.

  Of course IF you have the 1/2MB memory upgrade and an extra floppy
  drive then this is a bonus and saves a lot of aggravation.

  As is part of my CRITERIA the mouse is NOT required but is optional.

  It is assumed that your A500 has the above upgrades to make life easier.

  Running From Floppy:-
  ---------------------

  1) Boot up into Workbench 1.3.
  2) From the ~Extras1.3~ disk startup the AmigaBASIC Interpreter.
  3) Load the program ~PARINPUT.B~ into the interpreter.
  4) From the interpreter command line type "RUN[RETURN/ENTER]" without
     the quotes.
  5) When an event takes place there will be a beep and a flash on the
     screen.
  6) Press the ~Esc~ key to quit.

  (The interpreter, ABasic, has NOT been included but there is no reason
  why this project shouldn't work using that interpreter, maybe someone
  might give it a try and write the code to suit, just for fun... :)

  You could generate a minimal boot floppy to auto-run AmigaBASIC and
  call this program from a cold start through AmigaBASIC if so desired;
  read further down inside this text to find out how to do it.

  When you view the code you will notice that each event is given its
  own subroutine, this is so that you can modify each event to suit
  your own requirements... I am giving this code ~PARINPUT.B~ as FULL
  Public Domain and you can do with it what you like. Read the ~Warning~
  file for other information.

  IMPORTANT NOTE!!!

  THIS PROGRAM HAS HAD VERY, VERY LIMITED TESTING SO BEWARE!!!!!


  AmigaBASIC Code:-
  -----------------

10 REM Using AmigaBASIC to access the parallel port for the Event Detector.
20 REM It uses PAR: as a VOLUME in READ mode. (C)2006, B.Walker, G0LCU.
30 REM This is Public Domain, and is ENTIRELY for Workbench 1.3x users.
40 REM An old style STANDARD A500 is all that is required.

60 REM Setup a simple screen.
70 CLS
80 CLEAR
90 PRINT "                   Event detector, (C)2006, B.Walker, G0LCU."
100 PRINT
110 PRINT "                         Use ~Esc~ to exit or quit."
120 PRINT
130 PRINT "                              No event detected."

140 REM Set up the required variables.
150 LET count=0
160 LET mybyte=0
170 LET mybyte$="(C)2006, B.Walker, G0LCU."
180 LET a$=""

200 REM Open a channel and import the byte from the parallel port.
210 OPEN "PAR:" FOR INPUT AS #3 LEN=1
220 LET mybyte$=INPUT$(1,#3)
230 CLOSE #3
240 REM Immediately close the channel after byte access.
240 LET a$=a$+mybyte$
250 IF a$="" THEN LET a$=CHR$(255)
260 LET mybyte=ASC(mybyte$)

270 REM Do a bit test to check for an arming of any channel.
280 GOSUB 500

290 REM After a period of time of NO activity...
300 REM RESET to the start of the program.
310 LET count=count+1
320 IF count>=100 THEN GOTO 10
330 LET a$=INKEY$
340 If a$=CHR$(27) THEN GOTO 400
350 GOTO 160

400 REM Quit the program.
410 SYSTEM

500 REM Test multiple bits to set up any alarms.
510 LET mybyte=255-mybyte
520 IF mybyte>=128 AND mybyte<=254 THEN GOSUB 8000
530 IF mybyte>=128 AND mybyte<=254 THEN LET mybyte=mybyte-128
540 IF mybyte>=64 AND mybyte<=127 THEN GOSUB 7000
550 IF mybyte>=64 AND mybyte<=127 THEN LET mybyte=mybyte-64
560 IF mybyte>=32 AND mybyte<=63 THEN GOSUB 6000
570 IF mybyte>=32 AND mybyte<=63 THEN LET mybyte=mybyte-32
580 IF mybyte>=16 AND mybyte<=31 THEN GOSUB 5000
590 IF mybyte>=16 AND mybyte<=31 THEN LET mybyte=mybyte-16
600 IF mybyte>=8 AND mybyte<=15 THEN GOSUB 4000
610 IF mybyte>=8 AND mybyte<=15 THEN LET mybyte=mybyte-8
620 IF mybyte>=4 AND mybyte<=7 THEN GOSUB 3000
630 IF mybyte>=4 AND mybyte<=7 THEN LET mybyte=mybyte-4
640 IF mybyte>=2 AND mybyte<=3 THEN GOSUB 2000
650 IF mybyte>=2 AND mybyte<=3 THEN LET mybyte=mybyte-2
660 IF mybyte=1 THEN GOSUB 1000
670 RETURN

1000 REM Test for Bit 0 set, channel 1.
1010 LET count=0
1020 CLS
1030 BEEP
1040 PRINT "ALARM!!! Channel 1 fired."
1999 RETURN

2000 REM Test for Bit 1 set, channel 2.
2010 LET count=0
2020 CLS
2030 BEEP
2040 PRINT "ALARM!!! Channel 2 fired."
2999 RETURN

3000 REM Test for Bit 2 set, channel 3.
3010 LET count=0
3020 CLS
3030 BEEP
3040 PRINT "ALARM!!! Channel 3 fired."
3999 RETURN

4000 REM Test for Bit 3 set, channel 4.
4010 LET count=0
4020 CLS
4030 BEEP
4040 PRINT "ALARM!!! Channel 4 fired."
4999 RETURN

5000 REM Test for Bit 4 set, channel 5.
5010 LET count=0
5020 CLS
5030 BEEP
5040 PRINT "ALARM!!! Channel 5 fired."
5999 RETURN

6000 REM Test for Bit 5 set, channel 6.
6010 LET count=0
6020 CLS
6030 BEEP
6040 PRINT "ALARM!!! Channel 6 fired."
6999 RETURN

7000 REM Test for Bit 6 set, channel 7
7010 LET count=0
7020 CLS
7030 BEEP
7040 PRINT "ALARM!!! Channel 7 fired."
7999 RETURN

8000 REM Test for Bit 7 set, channel 8.
8010 LET count=0
8020 CLS
8030 BEEP
8040 PRINT "ALARM!!! Channel 8 fired."
8999 RETURN

----------------------------------------------------------------------------

  bwBASIC BASIC Interpreter.
  --------------------------

  ~PARINPUT.BAS~ is purely a fun program to show that even the VERY
  limited and ~free~ bwBASIC, BASIC Interpreter can do this task and gain
  access to certain hardware under certain circumstances. As it has NO
  ~BEEP~ command or anything else useful then the command ~PRINT CHR$(7)~
  is used to generate this ~BEEP~. It is very limited for this role as
  an Event Detector but it DOES work. So I will not mention any more about
  this method of accessing PAR: for use as an Event Detector. There is a
  deliberate flaw in this code, can you find it?. Have fun in doing so... :)
  This flaw is NOT a bug and does NOT affect to overall operation of the
  software.

  Note this method of ~BEEP~ requires the sound and/or screen flash to be
  switched on from the ~PREFS:Sound~ under OS3.xx. Under OS2.xx ONLY the
  screen will flash.

  You WILL need, ~bwBASIC111.lha~ and ~ixemul.library~ from AMINET however
  if you wish to try it for fun... :)

  ~PARINPUT.BAS~ is also released as FULL Public Domain just like
  AmigaBASIC version ~PARINPUT.B~ above.

  IMPORTANT NOTE!!!

  THIS PROGRAM HAS HAD VERY, VERY LIMITED TESTING SO BEWARE!!!!!


  bwBASIC111 Code:-
  -----------------

10 REM Using bwBASIC to access the parallel port for the Event Detector.
20 REM It uses PAR: as a VOLUME in READ mode.
30 REM (C)2006, B.Walker, G0LCU.
40 REM This is Public Domain, and reminds me of Spectrum BASIC.
50 REM From AMINET 'bwbasic111.lha' is required. 

60 REM Setup a simple screen.
70 PRINT CHR$(12)
80 PRINT "                   Event detector, (C)2006, B.Walker, G0LCU."
90 PRINT
100 PRINT "                         Use Ctrl-C to exit or quit."
110 PRINT
120 PRINT "                              No event detected."

130 REM Set up the required variables.
140 CLEAR
150 LET count=0
160 LET mybyte=0
170 LET newbyte=0
180 LET mybyte$="(C)2006, B.Walker, G0LCU."

190 REM Open a channel and import the byte from the parallel port.
200 OPEN "I", #2, "PAR:", 1
210 LINE INPUT #2, mybyte$
220 CLOSE #2
230 REM Close the channel after byte access.

240 REM Correct the byte value as unsigned.
250 LET mybyte=ASC(mybyte$)
260 IF mybyte<=-1 THEN GOSUB 400

270 REM Do a bit test to check for an arming of any channel.
280 GOSUB 500

290 REM After a period of time of NO activity...
300 REM RESET to the start of the program.
310 LET count=count+1
320 IF count>=100 THEN GOTO 10
330 GOTO 160

400 REM Remove the negation of the byte value.
410 LET newbyte=129+mybyte
420 LET mybyte=127+newbyte
430 RETURN

500 REM Test multiple bits to set up any alarms.
510 LET mybyte=255-mybyte
520 IF mybyte>=128 AND mybyte<=254 THEN GOSUB 8000
530 IF mybyte>=128 AND mybyte<=254 THEN LET mybyte=mybyte-128
540 IF mybyte>=64 AND mybyte<=127 THEN GOSUB 7000
550 IF mybyte>=64 AND mybyte<=127 THEN LET mybyte=mybyte-64
560 IF mybyte>=32 AND mybyte<=63 THEN GOSUB 6000
570 IF mybyte>=32 AND mybyte<=63 THEN LET mybyte=mybyte-32
580 IF mybyte>=16 AND mybyte<=31 THEN GOSUB 5000
590 IF mybyte>=16 AND mybyte<=31 THEN LET mybyte=mybyte-16
600 IF mybyte>=8 AND mybyte<=15 THEN GOSUB 4000
610 IF mybyte>=8 AND mybyte<=15 THEN LET mybyte=mybyte-8
620 IF mybyte>=4 AND mybyte<=7 THEN GOSUB 3000
630 IF mybyte>=4 AND mybyte<=7 THEN LET mybyte=mybyte-4
640 IF mybyte>=2 AND mybyte<=3 THEN GOSUB 2000
650 IF mybyte>=2 AND mybyte<=3 THEN LET mybyte=mybyte-2
660 IF mybyte=1 THEN GOSUB 1000
670 RETURN

1000 REM Test for Bit 0 set, channel 1.
1010 LET count=0
1020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 1 fired."
1999 RETURN

2000 REM Test for Bit 1 set, channel 2.
2010 LET count=0
2020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 2 fired."
2999 RETURN

3000 REM Test for Bit 2 set, channel 3.
3010 LET count=0
3020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 3 fired."
3999 RETURN

4000 REM Test for Bit 3 set, channel 4.
4010 LET count=0
4020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 4 fired."
4999 RETURN

5000 REM Test for Bit 4 set, channel 5.
5010 LET count=0
5020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 5 fired."
5999 RETURN

6000 REM Test for Bit 5 set, channel 6.
6010 LET count=0
6020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 6 fired."
6999 RETURN

7000 REM Test for Bit 6 set, channel 7
7010 LET count=0
7020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 7 fired."
7999 RETURN

8000 REM Test for Bit 7 set, channel 8.
8010 LET count=0
8020 PRINT CHR$(7);CHR$(12);"ALARM!!! Channel 8 fired."
8999 RETURN

----------------------------------------------------------------------------

  RexxMast Interpreter And RX.
  ----------------------------

  ~PARINPUT.rexx~ is the DEFAULT code for this project as nothing but
  a FULL OS2.0x install is required to run it. This code is just a MINOR
  modification to the test software ~PAR.rexx~. BITTST, (Bit Test), is
  used to detect which line(s) has been triggered. Ensure the interpreter
  RexxMast is running before starting the code and RX is in the path.

  To run, open up a SHELL and go to the drawer where ~PARINPUT.rexx~ is.
  Type "RX PARINPUT.rexx[RETURN/ENTER]" without the quotes. Use ~Ctrl C~
  to quit the program.

  Rather than just using the simple command addressing to use the ~Say~
  command you could use ~CALL~ instead and call a subroutine and have many
  things happen of your choice per individual event. Of course there is a
  hideous computerised voice at the moment but this can be changed at will.

  ~PARINPUT.rexx~ is also released as FULL Public Domain just the same as
  the two differing BASIC programs above.

  NOTE!, this program has been THOROUGHLY tested on various machines for
  long periods and NOT ONE adverse effect occured.


  ARexx Code:-
  ------------

/* ----------------------------------------------- */
/* 8 channel input detector using the PAR: device. */
/*            (C)2005, B.Walker, G0LCU.            */
/* ----------------------------------------------- */
/* Use ECHO for printing to the screen and SAY for */
/*      printing any variables to the screen.      */
/* ----------------------------------------------- */
/*   IMPORTANT!!!, run ONLY from a SHELL or CLI.   */
/* From a SHELL, type:-   RX PARINPUT.rexx<RETURN> */
/* ----------------------------------------------- */


/* Show my version number and (C) for one line only. */
/* (Note these two lines can be omitted.) */
    ECHO 'c'x
    ECHO '$VER: PARINPUT.rexx_Version_0.80.00_(C)01-06-2006_B.Walker_G0LCU.'
    ECHO
    ECHO 'Press ~Ctrl C~ to quit the program...'


/* Set up any variables. */
    ParaByte = ''
    MyByte = ''


/* Set the signal for breaking the script, ~Ctrl C~. */
    SIGNAL ON BREAK_C


/* ------------------------------------------------------------------- */
/* This is the main working loop for accessing the parallel port. */
    DO FOREVER

/* Open up a channel for reading from the parallel port. */
    OPEN(ParaByte, 'PAR:', 'R')

/* Read a single binary character from the port. */
    MyByte = READCH(ParaByte, 1)

/* If MyByte is a NULL then this corresponds to the EOF, 0, so correct */
/* it by making sure ALL NULLs are given the value of 0. */
    IF MyByte = '' THEN MyByte = 0

/* All major data access done, NOW IMMEDIATELY close the channel. */
    CLOSE(ParaByte)

/* Test each data bit and IF SET to 0 then trigger the hideous voice. */
    IF BITTST(MyByte, 0) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel ONE armed."'
    IF BITTST(MyByte, 1) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel TWO armed."'
    IF BITTST(MyByte, 2) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel THREE armed."'
    IF BITTST(MyByte, 3) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel FOUR armed."'
    IF BITTST(MyByte, 4) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel FIVE armed."'
    IF BITTST(MyByte, 5) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel SIX armed."'
    IF BITTST(MyByte, 6) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel SEVEN armed."'
    IF BITTST(MyByte, 7) = 0 THEN ADDRESS COMMAND 'SYS:Utilities/Say "WARNING!!!, channel EIGHT armed."'
    END
/* ------------------------------------------------------------------- */


/* Cleanup and exit from the script. */
Break_C:
    ECHO 'c'x'7'x
    ECHO 'Ctrl C detected program closing down...'
    EXIT

----------------------------------------------------------------------------

  Python Interpreter.
  -------------------

  ~ParInput.py~ is a special version to see how easy it was/is to integrate
  the Python Interpreter to LIMITED hardware access. As you can see I was
  successful in my attempt... :)

  The version of Python is 1.4 and will work on a stock A1200(HD) without
  modification or extra files other than the Python archive:-

            http://main.aminet.net/dev/lang/Python_14.lha

  The 'PYTHON:' volume MUST be ASSIGN(ed) to the ~Drive:Drawer~ where you
  install the Python Interpreter and all of the required files.

  Copy ~ParInput.py~ to the ~PYTHON:Lib~ drawer and run it from the Python
  prompt ~>>> ~ as below:-

  >>> execfile('PYTHON:Lib/ParInput.py')[RETURN]

  and away you go... :)

  You may copy the Python variant and modify that copy at your leisure BUT
  the ORIGINAL (C) for the idea MUST show as a one line comment in your new
  Python script as shown below:-

  # ORIGINAL idea and copyright, (C)2006, B.Walker, G0LCU.

  It CANNOT be used for any commercial means AT ALL, nor for profit without
  express permission from myself:-

  B.Walker, G0LCU.

  Email:-

  wisecracker@tesco.net

  Thank you for your support... :)

  NOTE!, this program has had the greatest amount of testing on my STANDARD
  A1200(HD) and has proven totally stable for that machine. It has been left
  on running in the background for days and I manually trigger(ed) the board
  to test it.


  Python Code:-
  -------------

# An 8 channel event detector using standard Python, Version 1.4 minimum...
# This WILL run on a stock A1200(HD), NO FastRAM is needed, but it helps. :)
# This is (C)2006, B.Walker, G0LCU. PAR_READ.lha from AMINET IS required.
# BEST VIEWED IN 640x200 using standard TOPAZ 8 FONTS.
# Press Ctrl-C or (Ctrl-D) to __STOP__ the program.

# Import any necessary module components.
import sys
import os
import time

# Test for genuine classic AMIGA platform.
# If it doesn't exist then completely quit the program and Python.
if sys.platform != 'amiga':
	print '\f'
	print 'This program is AMIGA A1200(HD), (and greater), specific ONLY.'
	print
	print 'Closing down...'
	print
	time.sleep(3)
	# Shut down the program and Python.
	# Not really an error, so exit with ~RC~ of 0.
	sys.exit(0)

# If the correct platform print the version number.
if sys.platform == 'amiga':
	print '\f'
	print '$VER: Event_Detector_Version_0.90.34_(C)11-06-2006_B.Walker.'
	print
	# Ask for a check on the -ACK hardware.
	hw = raw_input('Is the board connected?, upper case ONLY, (Y/N):- ')
	# If NOT present don't allow program to run.
	# ONLY UPPERCASE ~Y~ IS ALLOWED!!!
	if hw != 'Y':
		print '\f'
		print 'The project MUST be connected or the system WILL hang.'
		print
		print 'Closing down...'
		print
		time.sleep(3)
		# Shut down the program and Python.
		# Not really an error, so exit with ~RC~ of 0.
		sys.exit(0)

# Established that the ~-ACK~ hardware from ~PAR_READ.lha~ IS connected.
# So now set up a working display that looks OK(ish :).
print '\f'
print '              8 Channel Event Detector, (C)2006, B.walker, G0LCU.'
print
print '                              No event detected.'

# This is the main working program. It is AMIGA compliant ONLY.
# Wake up the parallel port for use under this program.
pointer = open('PAR:', 'rb', 1)
mybyte = str(pointer.read(1))
# Put back to sleep again ready for general use.
pointer.close()

# This is the main coded segment.
def main():
	# Make ~mybyte~ and ~counter~ global.
	global mybyte
	global counter
	# Set both to 0.
	mybyte = 0
	counter = 0
	while 1:
		# Open a channel to the parallel port called ~pointer~.
		pointer = open('PAR:', 'rb', 1)
		# Read one byte, ~mybyte~, from that channel.
		mybyte = str(pointer.read(1))
		# Once read, immediately close that channel.
		pointer.close()
		# Set ~mybyte~ to decimal 0 to 255.
		mybyte = (ord(mybyte))
		# Subtract ~mybyte~ from 255 for easy coding! :)
		mybyte = 255-mybyte
		# Setup the main window again after any triggering.
		# The ~counter~ is used as a pseudo-time delay only.
		if mybyte == 0 and counter == 1000:
			counter = 0
			print '\f'
			print '              8 Channel Event Detector, (C)2006, B.Walker, G0LCU.'
			print
			print '                              No event detected.'
		# Now determine which line(s) has(have) been triggered.
		if mybyte >= 128 and mybyte <= 254:
			counter = 0
			print '\f'
			print 'Channel eight armed...'
			os.system('SYS:Utilities/Say "Channel EIGHT armed."')
			mybyte = mybyte - 128
		if mybyte >= 64 and mybyte <= 127:
			counter = 0
			print '\f'
			print 'Channel seven armed...'
			os.system('SYS:Utilities/Say "Channel SEVEN armed."')
			mybyte = mybyte - 64
		if mybyte >= 32 and mybyte <= 63:
			counter = 0
			print '\f'
			print 'Channel six armed...'
			os.system('SYS:Utilities/Say "Channel SIX armed."')
			mybyte = mybyte - 32
		if mybyte >= 16 and mybyte <= 31:
			counter = 0
			print '\f'
			print 'Channel five armed...'
			os.system('SYS:Utilities/Say "Channel FIVE armed."')
			mybyte = mybyte - 16
		if mybyte >= 8 and mybyte <= 15:
			counter = 0
			print '\f'
			print 'Channel four armed...'
			os.system('SYS:Utilities/Say "Channel FOUR armed."')
			mybyte = mybyte - 8
		if mybyte >= 4 and mybyte <= 7:
			counter = 0
			print '\f'
			print 'Channel three armed...'
			os.system('SYS:Utilities/Say "Channel THREE armed."')
			mybyte = mybyte - 4
		if mybyte >= 2 and mybyte <= 3:
			counter = 0
			print '\f'
			print 'Channel two armed...'
			os.system('SYS:Utilities/Say "Channel TWO armed."')
			mybyte = mybyte - 2
		if mybyte == 1:
			counter = 0
			print '\f'
			print 'Channel one armed...'
			os.system('SYS:Utilities/Say "Channel ONE armed."')
		# Add 1 to the pseudo-time delay.
		counter = counter + 1
		# When ~counter~ reaches 1001 set it to 0 again!!!.
		if counter >= 1001:
			counter = 0
main()
# Program End.
# DEAD SIMPLE EH!... :)

----------------------------------------------------------------------------

  Using An Old Style A500 And Floppy Workbench 1.3x Bootdisk.
  -----------------------------------------------------------

  As an A500 is difficult to use in absolute STANDARD form then the only
  way to get a successful means of running the AmigaBASIC program is to
  generate a bootable version.

  This is done as follows:-

  1) Have a blank floppy disk ready and label it ~Event_Detector~ with
     a stick on label of some sort.
  2) Cold boot into Workbench1.3 from a copy, (not the master), bootfloppy.
  3) From the Workbench screen pull down menu ~Workbench --> Duplicate~,
     launch the ~DiskCopy x.x~ program.
  4) Follow ALL on screen prompts.
  5) When finished the disk will have the wrong VOLUME NAME!!!
     It will read something like, ~Copy of Workbench1.3~.
  6) Again from the Workbench1.3 pull down menu ~Workbench --> Rename~,
     this new disk to ~Event_Detector~.     
  7) Delete ANY files that are NOT in this listing:-
     (All the ones showing ARE required.)

     c (dir)
       Ask                              Assign
       Binddrivers                      CD
       Copy                             Delete
       Dir                              Echo
       Ed                               Else
       EndCLI                           EndIf
       Execute                          Failat
       IconX                            If
       List                             LoadWB
       Makedir                          Mount
       NewCLI                           NewShell
       Path                             Prompt
       Relabel                          Rename
       Run                              SetClock
       SetEnv                           SetPatch
       Stack                            Type
     devs (dir)
          keymaps (dir)
            gb                               usa1
          clipboards (dir)
          printers (dir)
            generic                          
       clipboard.device                 narrator.device
       parallel.device                  printer.device
       ramdrive.device                  serial.device
       system-configuration             
     empty (dir)
     expansion (dir)
     FD1.3 (dir)
       BASIC FD files here!             BASIC FD files here!.info
       clist_lib.fd                     console_lib.fd
       diskfont_lib.fd                  dos_lib.fd
       exec_lib.fd                      expansion_lib.fd
       graphics_lib.fd                  icon_lib.fd
       intuition_lib.fd                 layers_lib.fd
       mathffp_lib.fd                   mathieeedoubbas_lib.fd
       mathieeedoubtrans_lib.fd         mathtrans_lib.fd
       potgo_lib.fd                     romboot_lib.fd
       timer_lib.fd                     translator_lib.fd
     fonts (dir)
          topaz (dir)
            11                               
       topaz.font                       
     l (dir)
       Aux-Handler                      Disk-Validator
       Newcon-Handler                   Pipe-Handler
       Port-Handler                     Ram-Handler
       Speak-Handler                    
     libs (dir)
       diskfont.library                 icon.library
       info.library                     mathieeedoubbas.library
       mathieeedoubtrans.library        mathtrans.library
       translator.library               version.library
     prefs (dir)
     s (dir)
       startup-sequence                 
     system (dir)
       CLI                              Diskcopy
       Format                           NoFastMem
       SetMap                           
     t (dir)
     tools (dir)
     trashcan (dir)
     utilities (dir)
       Calculator                       Clock
       More                             Say
  AmigaBASIC                       PARINPUT.B
  CLI                              CLI.info

  8) From the ~Extras1.3~ disk copy over the AmigaBASIC program to the new
     ~Event_Detector~ bootfloppy.
  9) Also from the ~Extras1.3~ disk copy over the FD1.3 drawer complete
     to the new ~Event_Detector~ bootfloppy.
 10) Finally copy over ~PARINPUT.B~ to the new bootfloppy.
 11) The ~startup-sequence~ should be edited as such:-

 sys:c/setpatch >NIL:
 sys:c/binddrivers
 sys:c/assign CLIPS: sys:devs/clipboards
 sys:c/assign ENV: sys:t
 sys:c/assign T: sys:t
 sys:c/assign AMIGABASIC: Event_Detector:
 sys:c/stack 16384
 sys:c/loadwb -debug
 sys:c/run >NIL: sys:AmigaBASIC PARINPUT.B
 sys:c/endcli >NIL:

 12) If you are unsure of how to do this then contact me on:-

                            wisecracker@tesco.net

     and I will do my best to help you out... ;-)

----------------------------------------------------------------------------

  Finale.
  -------

  The COMPLETE series of articles for this project including all and any
  code buried inside ANY of the text can be found on AMINET at:-

        http://main.aminet.net/hard/hack/AMIGA-Project1.lha

  The archive includes images in both IFF and NON-IFF formats to suit
  any image displaying software of your choice.

  As a final touch, ANY comments about this project, GOOD OR BAD, please
  contact me on the above Email address and they WILL be re-published in
  the online magazine for all to read along with any replies I repost back
  to you... :)

  Many thanks for joining in whether you constructed the project or not...

============================================================================

                                IMPORTANT:-
                                -----------

    The Legal Stuff:-
    -----------------

    These programs are Freeware and no profit will be made from them,
    also all of the files must remain unaltered and intact including this
    one. The author is not responsible for any damage to, or loss of, or
    failure of equipment or data caused in any way by the use of these
    programs. There is NO warranty with the use of these software releases
    and YOU USE THEM AT YOUR OWN RISK.

----------------------------------------------------------------------------

    Testing Evaluation:-
    --------------------

    An A1200(HD) in 2MB, 6MB and 10MB modes using trapdoor memory AND/OR
    PCMCIA memory expansions. Also tested on an A600(HD) in 2MB and 6MB
    modes. All test conditions were/are running STANDARD KS2.0x to 3.1x,
    and using standard ~topaz 8~ fonts throughout.

    I have no idea what a strange configuration setup will create so refer
    to the ~The Legal Stuff~ above.

----------------------------------------------------------------------------

                                 WARNING.
                                 --------

  1) DISCONNECT any faulty equipment under test from the MAINS supply.
  2) If a DC supply is used do NOT reverse polarity the connections.
  3) Do NOT power up any electronic item until it is safe to do so.
  4) CHECK and RECHECK all of your construction and repair work thoroughly.
  5) Handle ALL tools used with care.
  6) Beware of ALL types of solvents, glues and etching fluids.
  7) NEVER leave a soldering iron switched on unattended.
  8) KEEP everything OUT of the reach of small children.
  9) Switch OFF the AMIGA before disconnecting or connecting any hardware.
 10) And finally read 1) to 9) again.

----------------------------------------------------------------------------

   Contact:-
   ---------

   Mr Barry Walker, G0LCU.

   Email:-     wisecracker@tesco.net
   URL:-       http://homepages.tesco.net/wisecracker/G0LCU.HTM

   Author of the ~TestGear?~ projects in the ~hard/hack~ drawer of AMINET.

----------------------------------------------------------------------------

   A very useful HardWare related site, (C) Anthony Hoffman, for
   modifications, schematics, repairs and the like is:-

                          http://amiga.serveftp.net/

============================================================================

73...

Bazza... G0LCU.

Team AMIGA...
