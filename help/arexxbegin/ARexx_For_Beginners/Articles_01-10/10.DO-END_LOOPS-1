@DATABASE "ARB10"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 10 - DO-END Loops"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 10 - PROGRAMMING LOOPS WITH DO...END - PART 1

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" Read Me First!!                      " LINK "Read"}
@{" Repetitive Tasks                     " LINK "Repetitive"}
@{" What Are Loops?                      " LINK "What"}
@{" The DO and END Instructions          " LINK "Do"}
@{" To Loop Or Not To Loop?              " LINK "ToLoop"}
@{" How Many Times to Loop?              " LINK "HowMany"}
@{" The `Symbol = n1 TO n2 BY n3' Method " LINK "Symbol"}
@{" The FOR Method                       " LINK "For"}
@{" The WHILE Method                     " LINK "While"}
@{" The UNTIL Method                     " LINK "Until"}
@{" The FOREVER Method                   " LINK "Forever"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Read" "Article 10 - DO-END Loops - Read Me First"

@{B}@{U}@{JCENTER}READ ME FIRST!!@{UB}@{UU}
@{JLEFT}
I am going to discuss LOOPS in two parts.

This article will discuss what loops are and how to use the DO...END
instructions.

I will then go on to discuss:-

  Comparison Operators    -  @{"Article 11" LINK "ARB:Articles_11-20/11.Comparison_Operators/Main"}
  Conditional Statements  -  @{"Article 12" LINK "ARB:Articles_11-20/12.Conditional_Statements/Main"}
  Logical Operators       -  @{"Article 13" LINK "ARB:Articles_11-20/13.Logical_Operators/Main"}

before going on to do the second part of LOOPS (Article 14).

This is necessary as you really need to know the contents of Articles
11, 12 and 13 before being able to use LOOPS properly.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Repetitive" "Article 10 - DO-END Loops - Repetitive Tasks"

@{B}@{U}@{JCENTER}REPETITIVE TASKS@{UB}@{UU}
@{JLEFT}
There are very many occasions in programming where you need to do
the same, or a very similar thing, over and over again.

We have already seen an example of this in @{"Example6-1" LINK "ARB:Articles_01-10/06.Centring_Text/MAIN"54}.

As an example of how useful loops are, if you are going to do
something
like a display a multiplication table without some method of
handling
repetitive tasks, you would need programming code like this:-

  SAY 'Please enter a number from 1 to 12'
  PULL Number
  SAY
  SAY 'The' number 'times table....'
  SAY
  SAY Number 'x' 1 ' = ' Number * 1
  SAY Number 'x' 2 ' = ' Number * 2
  SAY Number 'x' 3 ' = ' Number * 3

  .... (lines for multipliers 4 to 11)

  SAY Number 'x' 12 ' = ' Number * 12

To display the full 12 lines of the times table, you would need 12
lines of very similar code. This is very inefficient as one single
line can replace all 12 lines.

One way is to cater for this situation is to use a loop with the
DO...END instructions (which we will look at in this article) and
another is to CALL or INVOKE a FUNCTION which we look start to look
at in @{"Article 16" LINK "ARB:Articles_11-20/16.Functions-Internal/MAIN"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "What" "Article 10 - DO-END Loops - What Are Loops?"

@{B}@{U}@{JCENTER}WHAT ARE LOOPS?@{UB}@{UU}
@{JLEFT}
All programming languages have methods of performing "loops" of
instruction code. A loop allows a block of instruction code to be
performed over and over again until some event occurs that tells it to
leave the loop and go on to the next bit of programming code.

Take a look at this example (which I will explain @{"later" LINK "Symbol"} in this article):-

  /* Example10-1 */

  1. SAY 'The 5 times table'

  2. DO x = 1 TO 10
  3. SAY 'Five times' x '=' x * 5
  4. END

The lines 2 to 4 are a "LOOP". The program will, in this case, loop
through lines 2, 3 and 4 then back to 2 a total of 10 times.

You can make loops as simple as this example or give them many lines
of complex coding between the DO and the END, or make them somewhere
in between these two alternatives. You can even put loops within loops but
that is jumping ahead a bit!


@{JCENTER}=== End of Text ===
@{JLEFT}




@ENDNODE

@NODE "Do" "Article 10 - DO-END Loops - The DO and END Instructions"

@{B}@{U}@{JCENTER}THE DO AND END INSTRUCTIONS@{UB}@{UU}
@{JLEFT}
The operation of loops is controlled by the DO and END instructions.
DO indicates the start of the programming code to be included in the loop
and END indicates the end of the code within the loop.

Note that these two instructions can also be used in non loop situations
in conjunction with the IF THEN statements which we will looked at in
@{"Article 12" LINK "ARB:Articles_11-20/12.Conditional_Statements/Making"32}.

@{B}DO and END are SEPARATE Instructions@{UB}

You should note carefully that the DO and its corresponding END are
@{B}separate@{UB} instructions and therefore @{B}must@{UB} be in separate instruction
clauses. This is achieved either by placing them on separate lines,
as in:-

  DO options
    program coding
  END

or on the same line separated by semicolons, as in:-

  DO (options) ; program coding ; END

The DO syntax can be one of:-

  @{" DO variable=expression TO expression               " LINK "Symbol"}
  @{" DO variable=expression TO expression BY expression " LINK "Symbol"}
  @{" DO FOR expression                                  " LINK "For"}
  @{" DO WHILE expression                                " LINK "While"}
  @{" DO UNTIL expression                                " LINK "Until"}
  @{" DO FOREVER                                         " LINK "Forever"}

The END syntax can be one of:-

  END
  END variable

The "Variable" can only be used with the @{"first two" LINK "Symbol"} of the above DO methods
and is optional. It is the variable in the "variable=expression" part of
the syntax.

It makes it easier to read a program if you indent the programming code
that comes between the DO and the END. It is not essential but very
helpful. Some programs are written with the END indented to the same degree
as the coding as in:

  DO options
    Instruction clause 1
    Instruction clause 2
    Instruction clause 3
    etc.
    END

(The @{B}options@{UB} after the DO are explained in each of the @{"above referenced" LINK "Do"26}
methods of using DO.)

However, I prefer to have the END indented to the same degree as
the corresponding DO as in:-

  DO options
    Instruction clause 1
    Instruction clause 2
    Instruction clause 3
    etc.
  END

I find that this makes it easier to find the corresponding END but
it is all a matter of personal preference.

It is absolutely essential that every DO has its corresponding END.
If loops are nested (one within another) then the @{B}innermost@{UB} END relates
to the @{B}innermost@{UB} DO and the @{B}outermost@{UB} END relates to the @{B}outermost@{UB}
DO. Intermediate DOs and ENDs are linked together in similar order.
For example:-

  DO options                    /* Start Loop 1 */
    coding for loop 1
    DO options                  /* Start Loop 2 */
      coding for loop 2
      DO options                /* Start Loop 3*/
        coding for loop 3
      END                       /* End Loop 3 */
      coding for loop 2
    END                         /* End Loop 2 */
  END                           /* End Loop 1 */

You may find it helpful, in cases of two or more nested loops, to
put in comments (as shown above) indicating the start and end of
each loop.

Note that all the coding for a loop need not be before the start
of the nested loop that follows it. In the above example, some of
loop 2's coding is before loop 3 and some is after loop 3. In fact,
loop 3 is really a part of the coding for loop 2 and both loop 2
and loop 3 are part of the coding for loop 1.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "ToLoop" "Article 10 - DO-END Loops - To Loop Or Not To Loop?"

@{B}@{U}@{JCENTER}TO LOOP OR NOT TO LOOP?@{UB}@{UU}
@{JLEFT}
The DO...END instructions can be used in non-looping situations, as in:-

  DO
    Instruction clause 1
    Instruction clause 2
    Instruction clause 3
    etc.
  END

In this case, the DO has no qualifying options to tell it how many times
to loop. The program coding in the "loop" is therefore only done @{B}once.@{UB}

This is a bit pointless @{B}unless@{UB} you are using it in @{B}conditional IF...THEN@{UB}
statements. I will cover this type of DO...END in @{"Article 12" LINK "ARB:Articles_11-20/12.Conditional_Statements/Making"32}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "HowMany" "Article 10 - DO-END Loops - How Many Times To Loop?"

@{B}@{U}@{JCENTER}HOW MANY TIMES TO LOOP?@{UB}@{UU}
@{JLEFT}
There are quite a few ways of telling ARexx how many times the DO block of
instructions is to be carried out.
@{JCENTER}
@{" The `Symbol = n1 TO n2 BY n3' Method " LINK "Symbol"}
@{" The FOR Method                       " LINK "For"}
@{" The WHILE Method                     " LINK "While"}
@{" The UNTIL Method                     " LINK "Until"}
@{" The FOREVER Method                   " LINK "Forever"}
@{JLEFT}
In some cases, a job could be done by any or all of the methods. However,
you will usually find that one method is better for a particular job than
another.

In order to illustrate the use of the various methods of using DO-END,
I will show how to program the 5 times table using each method. Even
though this will result in some clumsy programming, it will allow
you to have a constant comparison.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Symbol" "Article 10 - DO-END Loops - The `Symbol = n1 TO n2 BY n3' Method"

@{B}@{U}@{JCENTER}THE "SYMBOL = N1 TO N2 BY N3" METHOD@{UB}@{UU}
@{JLEFT}
This method uses a "counter" symbol to set the number of times a loop is
executed, control being as follows:-

  n1 = starting value of "symbol"
  n2 = finishing value of "symbol"
  n3 = value by which "symbol" is incremented for each loop

The following example demonstrates this:-

  /* Example10-2 */

  SAY 'The 5 times table'

  DO x = 1 TO 10 BY 1
    SAY 'Five times' x '=' x * 5
  END

In this example the symbol "x" has a starting value of 1. As the BY value
is 1, "x" increments by 1 for each of the loop operations. Thus the SAY
line will be executed for all values of "x" from 1 to 10 inclusive giving
us our 5 times table up to 10.

When the BY value is 1, as in this example, it can be left out altogether,
as in:-

  SAY 'The 5 times table'

  DO x = 1 to 10
    SAY 'Five times' x '=' x * 5
  END

and we will get exactly the same result. (In fact, this is exactly what
@{"Example10-1" LINK "What"10} was.)

To specify another BY value, you could use something like:-

  /* Example10-3 */

  SAY 'The 5 times table for odd numbers'

  DO x = 1 TO 10 BY 2
    SAY 'Five times' x '=' x * 5
  END

In this example we have asked the loop counter to increment BY 2 each time
the loop is executed. Now only 1, 3, 5, 7 and 9, i.e. the odd values of the
symbol "x" between 1 and 10, will be used. To get the even numbers, use:-

  DO x = 2 to 10 BY 2

You can have a negative value for BY provided that start value is higher
than the TO value. For example:-

  /* Example10-4 */

  SAY 'The 5 times table for descending even numbers'

  DO x = 10 TO 1 BY -2
    SAY 'Five times' x '=' x * 5
  END

The result of this is that all even numbers counting down from 10 to 1
by -2 would be included in the table.

The various values can be decimal as well as integer. For example:-

  /* Example10-5 */

  SAY 'The 5 times table for decimals'

  DO x = -.5 TO +.5 BY .1
    SAY 'Five times' x '=' x * 5
  END

This will display the table for all values from -0.5 to + 0.5 by
increments of 0.1.

There is one important point to note. This is the fact that, after the loop
is exited, the counter symbol does not end up with the TO value. It ends up
with the TO value incremented (or decremented for negative By values) by
the BY value.

Look again at Example10-3 where we have:-

  DO x = 1 TO 10 BY 2

The first time the loop is operated, "x" has a value of 1. Each time
END is reached, "x" is incremented by 2 and a comparison is made with the
TO value. If "x" is still less than or equal to the TO value (10 in this
case) then the loop is executed again. The loop is not exited until the
END instructions finds that "x" has been incremented to a value GREATER
than the TO value. In this case it must be MORE than 10.

If the BY value is negative, then "x" would be decremented to a value
LESS than the TO value.

If this extra line:-

  SAY 'Final value of x is' x

is added to the @{B}end@{UB} of Examples 10-2 to 10-5 inclusive then these
values would be displayed:-

                                       Output of Extra Line
  @{U}Example@{UU}  @{U}    DO Statement      @{UU}     @{U} after exit from loop  @{UU}

  10-2     DO x = 1 TO 10 BY 1        Final value of x is 11
  10-3     DO x = 1 TO 10 BY 2        Final value of x is 11
  10-4     DO x = 10 TO 1 BY -2       Final value of x is 0
  10-5     DO x = -.5 TO +.5 BY .1    Final value of x is 0.6

This is an important point to remember if the counter symbol is to
be used later in the program.

In all these examples the symbol used with the DO instructions (sometimes
called a counter) becomes an integral part of the loop programming
code. This need not be the case. The symbol could be used purely
and simply as a counter as in:-

  /* Example10-6 */

  DO x = 1 TO 5
    SAY '*****'
  END

This just repeats the SAY instruction 5 times displaying a 5 x 5
block of asterisks at the left edge of the window. However, it is
a clumsy way of counting compared to the @{"FOR" LINK "For"} method.


@{JCENTER}=== End of Text ===
@{JLEFT}





@ENDNODE

@NODE "For" "Article 10 - DO-END Loops - The FOR Method"

@{B}@{U}@{JCENTER}THE FOR METHOD@{UB}@{UU}
@{JLEFT}
@{"Example10-6" LINK "Symbol"122} could be rewritten in a much better format as:-

  /* Example10-7 */

  DO FOR 5
    SAY '*****'
  END

This produces exactly the same result.

The value after FOR can be a numeric symbol and/or an expression.
For example:-

  /* Example10-8 */

  DO x = 1 TO 3
    SAY 'Loop Execution Number' x
    DO FOR x * 2
      SAY '*****'
    END
  END

For each of the three executions of the first loop, the DO FOR loop
will multiply the value of the symbol x by 2. Thus the inner loop
will be executed:-

  2 times when x = 1
  4 times when x = 2
  6 times when x = 3

This will give this display:-

  Loop Execution Number 1
  *****
  *****
  Loop Execution Number 2
  *****
  *****
  *****
  *****
  Loop Execution Number 3
  *****
  *****
  *****
  *****
  *****
  *****

The FOR value @{B}MUST@{UB} be evaluated as a positive @{"integer number" LINK "ARB:Misc/Glossary/Integer_Numbers"}.

To get back to our 5 times table, if we used the FOR method, we would
have:-

  /* Example10-9 */

  SAY 'The 5 times table'

  x = 1
  DO FOR 10
    SAY 'Five times' x '=' x * 5
    x = x + 1
  END


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "While" "Article 10 - DO-END Loops - The WHILE Method"

@{B}@{U}@{JCENTER}THE WHILE METHOD@{UB}@{UU}
@{JLEFT}
This method allows the loop to continue @{B}WHILE@{UB} a certain @{B}condition@{UB} continues
to be @{B}TRUE.@{UB} When the condition becomes @{B}FALSE@{UB} the loop @{B}ceases to operate.@{UB}

Looking at our five times table again, it could be written as:-

  /* Example10-10 */

  SAY 'The 5 times table'

  x = 1
  DO WHILE x <= 10
    SAY 'Five times' x '=' x * 5
    x = x + 1
  END

In the expression "x <= 10" the "<=" is a "comparison operator" which
means "less than or equal to". This is jumping ahead just a little.
Comparison operators are discussed in @{"Article 11" LINK "ARB:Articles_11-20/11.Comparison_Operators/MAIN"}.

The loop will keep operating WHILE x is less than or equal to 10,
i.e. while the WHILE condition remains TRUE.

Once the "x = x + 1" line has made x equal to 11, the WHILE condition
becomes FALSE and so the program stops looping.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Until" "Article 10 - DO-END Loops - The UNTIL Method"

@{B}@{U}@{JCENTER}THE UNTIL METHOD@{UB}@{UU}
@{JLEFT}
Again, we could rewrite our five times table as:-

  /* Example10-11 */

  SAY 'The 5 times table'

  x = 1
  DO UNTIL x = 10
    SAY 'Five times' x '=' x * 5
    x = x + 1
  END

If you RX this program you will find that the last line display in the
"5 times table" is for an "x" value of 9, not 10.

When the UNTIL value is reached, the loop finishes without executing
a loop for the UNTIL value. To get the 10 value to operate, you could
use:-

  DO UNTIL x > 10

(The > means greater than).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Forever" "Article 10 - DO-END Loops - The FOREVER Method"

@{B}@{U}@{JCENTER}THE FOREVER METHOD@{UB}@{UU}
@{JLEFT}
This is a strange one when you first think about it. Why would you want a
loop to continue forever?

For instance, this program will not stop until you press CTRL-C:-

  /* Example10-12 */

  DO FOREVER
    SAY 'This will not stop until you press CTRL-C'
  END

Let's have yet another go at our five times table:-

  /* Example 10-13 */

  SAY 'The 5 times table'

  x = 1
  DO FOREVER
    SAY 'Five times' x '=' x * 5
    x = x + 1
    IF x > 10 THEN LEAVE
  END

The second last line simply means:-

  IF x is greater than 10 THEN LEAVE the loop

More on IF and LEAVE in later articles.

You will find that FOREVER can be very useful at times. An example is where
you, the programmer, do not know how many times the user will want to use
the loop. I will develop this further in the another article.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
