@DATABASE "ARB29"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 29 - Compound Symbols & Arrays"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 29 - COMPOUND SYMBOLS AND ARRAYS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" What Are Compound symbols?     " LINK "What"}
@{" Naming Compound Symbols        " LINK "Naming"}
@{" Dimensions Of Compound Symbols " LINK "Dimensions"}
@{" Initialising An Array          " LINK "Initialising"}
@{" UnInitialising An Array        " LINK "Uninitialising"}
@{" Example Program Of Arrays      " LINK "Example"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "What" "Article 29 - What Are Compound Symbols?"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - WHAT ARE COMPOUND SYMBOLS?@{UB}@{UU}
@{JLEFT}
In @{"Article 7" LINK "ARB:Articles_01-10/07.Symbols_Intro/MAIN"} we introduced the topic of Symbols and said that we would
leave @{B}Compound Symbols@{UB} to a later time which is @{B}now@{UB} .

A @{B}Compound Symbol@{UB} is one that consists of a @{"stem" LINK "ARB:Articles_01-10/07.Symbols_Intro/Stem"} and one or more other
parts, or dimensions. For example:-

   Stem.Part1
   Stem.Part1.Part2
   Stem.Part1.Part2.Part3

Each part is separated from the stem or another part by a period (.).

Following is some terminology associated with compound symbols:-

@{B}Array@{UB}     - all the compound symbols that have the same stem name.

@{B}Element@{UB}   - one of the compound symbols that make up the array.

  For example:- Person.1.1 }
                Person.1.2 }   are all elements of the
                Person.2.1 }   array with the stem Person.
                Person.2.2 }

@{B}Dimension@{UB} - One of the parts of a compound symbol.

  For example:- If the Person.Array had elements ranging from
                1 to 100 in the first part and 1 to 10 in the second part,
                then:-

                Person.1.x  to  Person.100.x  would be the 1st dimension

                Person.x.1  to  Person.x.10   would be the 2nd dimension


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Naming" "Article 29 - Naming Compound Symbols"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - NAMING COMPOUND SYMBOLS@{UB}@{UU}
@{JLEFT}
The "Stem" follows the same @{"naming rules" LINK "ARB:Articles_01-10/07.Symbols_Intro/Names"} as a simple symbol but ends with
a period (.) So it can @{B}start@{UB} with any of the characters in the groups:-

  a-z A-Z ! ? $ _

It can @{B}not@{UB} start with the period (.) or one of the numerics "0-9" but
subsequent characters can include the numerics.

Each subsequent part of a compound symbol can consist of one or more of
ANY of the characters from:-

  a-z A-Z ! ? $ _ 0-9

However, the period (.) must ONLY be used to separate the various parts
of the compound symbol.

Thus we could have names such as:-

  Score.1
  Score.2
  Score.3

or we could have:-

  Person.Name.Phone

@{B}When to use numbers and when to use letters?@{UB} Well, this will depend on
how you wish to use them. Numbers are probably the most useful, especially
if you are going to use loops to handle the data, such as in:-

  DO x = 1 to 10
    SAY Score.x
  END

In this loop, "x" would take on the values 1 to 10 and display each of
the compound symbols "Score.1" through to "Score.10".

You will find that this method of handling compound symbols to be extremely
useful.

So, whenever you know that you will want to use a part of the symbol for
counting (as above) then use numbers.

If you do not need this facility, then descriptive text may be
better.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Dimensions" "Article 29 - Dimensions Of Compound Symbols?"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - DIMENSIONS OF COMPOUND SYMBOLS?@{UB}@{UU}
@{JLEFT}
We can have arrays with:-

  1 part  per stem - 1 dimensional arrays
  2 parts per stem - 2 dimensional arrays
  3 parts per stem - 3 dimensional arrays

and so on.

It may be easier to understand if we have a look at how we would record
information on paper then how we would do the ARexx coding to display
it.

Lets look at a one dimensional array on paper:-


     _______________________
    |           |           |
    | Index No  |     1     |
    |-----------|-----------|
    |           |   Score   |
    |-----------|-----------|
    |    1      |    123    |
    |-----------|-----------|
    |    2      |     45    |
    |-----------|-----------|
    |    3      |    319    |
    |-----------|-----------|
    |    4      |     98    |
    |-----------|-----------|
    |    5      |    545    |
    |___________|___________|


This could represent 5 players in a game and their scores. To display
this in ARexx, we could have:-

  /* Example29-1.rexx */

  /* Scores allocated by another part of program */

  Score.1 = 123
  Score.2 = 45
  Score.3 = 319
  Score.4 = 98
  Score.5 = 545

/* Display Scores */

  SAY "Results are:-"
  DO x = 1 to 5
     SAY "Player" x "Score = " Score.x
  END

This would display:-

  Results are:-
  Player 1 Score = 123
  Player 2 Score = 45
  Player 3 Score = 319
  Player 4 Score = 98
  Player 5 Score = 545

A two dimensional array, on paper, could look something like this:-


     ___________________________________
    |           |           |           |
    | Index No  |     1     |     2     |
    |-----------|-----------|-----------|
    |           |   Name    |   Score   |
    |-----------|-----------|-----------|
    |    1      |   Jane    |    123    |
    |-----------|-----------|-----------|
    |    2      |   Tom     |     45    |
    |-----------|-----------|-----------|
    |    3      |   Dick    |    319    |
    |-----------|-----------|-----------|
    |    4      |   Mary    |     98    |
    |-----------|-----------|-----------|
    |    5      |   Harry   |    545    |
    |___________|___________|___________|


In ARexx, the array could be displayed with:-

  /* Example29-2.rexx */

  /* Names allocated at start of program */

  Player.1.Name = "Jane"
  Player.2.Name = "Tom"
  Player.3.Name = "Dick"
  Player.4.Name = "Mary"
  Player.5.Name = "Harry"

  /* Scores allocated by another part of program */

  Player.1.Score = 123
  Player.2.Score = 45
  Player.3.Score = 319
  Player.4.Score = 98
  Player.5.Score = 545

/* Display Scores */

  SAY "Results are:-"
  DO x = 1 to 5
       SAY "Score for" Player.x.Name "is" Player.x.Score
  END

Now our display would be:-

  Results are:-
  Score for Jane is 123
  Score for Tom is 45
  Score for Dick is 319
  Score for Mary is 98
  Score for Harry is 545

Now how about a larger table on paper:-


     _____________________________________________________
    |         |          |          |          |          |
    | IndexNo |    1     |    2     |    3     |    4     |
    |---------|----------|----------|----------|----------|
    |         | Surname  | GivenName| PhoneNo  | Type     |
    |---------|----------|----------|----------|----------|
    |   1     | Bloggs   | Fred     | 123 4567 | Business |
    |---------|----------|----------|----------|----------|
    |   2     | Cliggs   | Jack     | 234 5678 | Friend   |
    |---------|----------|----------|----------|----------|
    |   3     | Sluggs   | Tom      | 345 6789 | Family   |
    |_________|__________|__________|__________|__________|


How many dimensions in this array? @{B}Four@{UB} did you say? Have another think!

@{B}Two@{UB}? Give yourself a mintie!

Yes, it is still a two dimensional array.

To graphically represent a three dimensional array we would have to have
a three dimensional bit of paper! If, for example, you are doing some
complex mathematical calculations, or a representation of coordinates
on a three dimensional solid figure, you might need to use a three
dimensional array. More than three I cannot imagine, although I am not
saying they could not be used.

Each person's data can be represented by:-

  Person.v.h

where, in the above table, "v" is the vertical index number and "h" is
the horizontal index number. Thus, for Person number 2 (v=2), his data
could be displayed with:-

  SAY "Surname = " Person.2.1
  SAY "Given Name = " Person.2.2
  SAY "Phone = " Person.2.3
  SAY "Type = " Person.2.4

You can have as many index numbers in each direction, i.e. in each dimension,
as you like. However, I think that you will find that there will be only
a limited number of items that you can think up to include along the
horizontal index in the above tabular representation (up to 30 or 40, say).
The number of names (i.e. down the vertical index) will be limited by the
amount of memory that you have in your system.

Note that "vertical" and "horizontal" are only analogies for us humans
and have no meaning at all in ARexx.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Initialising" "Article 29 - Initialising An Array"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - INITIALISING AN ARRAY@{UB}@{UU}
@{JLEFT}
If you give a value to a stem, as in:-

  Score. = 0

then @{B}all@{UB} the elements of the array will have that value until some other
value is assigned to them. For example:-

  /* Example29-3 */

  Score. = 100 /* Give everyone a starting score of 100 */
  SAY "Results are:-"
  DO x = 1 to 3
     SAY "Player" x "Score = " Score.x
  END

This will display:-

  Results are:-
  Player 1 Score = 100
  Player 2 Score = 100
  Player 3 Score = 100

This initialisation can be useful in situations such as:-

- when you wish all elements to have the same non zero starting
  value, as in the above example, or

- if you wish to reset all values to, say, zero, when the
  program is rerun without exiting and RX'ing it again, or

- where you think you might try to do some arithmetic on an
  array element before it has been given a numeric value.

The last point is very important. With scores, say, you may be adding
to a person's score. The first time this is done you might have:-

  Score.1 = Score.1 + 10
  SAY Score.1
  --> Arithmetic Conversion Error

If "Score.1" has not been given a numeric value before this line then
its value will be a string "SCORE.1" which is NOT numeric. You can't do
arithmetic on strings so you would get the error message shown
above.

However, if you use:-

  Score. = 0
  Score.1 = Score.1 + 10
  SAY Score.1
  --> 10

then you will be O.K. as all elements of "Score." will have an initial
value of zero.

@{B}Be careful with this one!!@{UB} All previous values of @{B}all elements@{UB} of the
array will be given the value that is given to the stem. If you have some
elements of the array that should keep their values then do not use
it!!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Uninitialising" "Article 29 - UnInitialising An Array"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - UNINITIALISING AN ARRAY@{UB}@{UU}
@{JLEFT}
If you wish to remove @{B}all@{UB} elements of an array and return them to their
unitialised state, then you can use DROP on the stem. For example:-

  DROP Score.

(@{B}Note@{UB} - don't forget the . after the stem name!).

Now all compound symbols with the stem "Score." will be unitialised. @{B}Take
care with this one!@{UB} - you loose @{B}ALL@{UB} values of @{B}ALL@{UB} elements!!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Example" "Article 29 - Compound Symbols - Example Program"

@{B}@{U}@{JCENTER}COMPOUND SYMBOLS AND ARRAYS - EXAMPLE PROGRAM@{UB}@{UU}
@{JLEFT}
As an example of using arrays I have written a simple data base of people's
phone numbers. This example will also demonstrate the techniques of using
disk files that we talked about in Article 28.

This program is @{"Example30-1" LINK "ARB:Articles_21-30/Example30-1.rexx/MAIN"} which is discussed fully in the @{"next article" LINK "ARB:Articles_21-30/30.Example_Program/MAIN"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
