@DATABASE "ARB49"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 49 - Error Tracing & Debugging Pt 4"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 49 - ERROR TRACING & DEBUGGING - PART 4

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" Summary Of Recommended Debugging Procedures " LINK "Summary"}
@{"    Use The Initial Scan Phase               " LINK "Initial"}
@{"    Use TRACE() With SCAN Option             " LINK "Scan"}
@{"    Use TRACE() With Other Options           " LINK "Other"}
@{"    Use TRACE() With Interactive Mode        " LINK "Interactive"}
@{"    Use TRACE() With Command Inhibition      " LINK "Inhibition"}
@{"    Use the SIGNAL ON SYNTAX Routine         " LINK "Signal"}

@{" Errors In Logic Or Fact                     " LINK "LogicFact"}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Summary" "Article 49 - Error Tracing & Debugging Pt 4 - Recommended Procedures"

@{B}@{U}@{JCENTER}SUMMARY OF RECOMMENDED DEBUGGING PROCEDURE@{UB}@{UU}
@{JLEFT}
With a lot of small programs (e.g. those of less than, say, 10 lines),
you will probably think that the following procedures are not worth while.
This may well be so but, as we saw in @{"Example47-3" LINK "ARB:Articles_41-50/47.Error_Tracing-2/Scan"}, even small programs
can take a long time to execute and thus a long time to reach an error!

I would therefore recommend that you follow these steps in your debugging
procedures:-
@{JCENTER}
@{" Use The Initial Scan Phase          " LINK "Initial"}
@{" Use TRACE() With SCAN Option        " LINK "Scan"}
@{" Use TRACE() With Other Options      " LINK "Other"}
@{" Use TRACE() With Interactive Mode   " LINK "Interactive"}
@{" Use TRACE() With Command Inhibition " LINK "Inhibition"}
@{" Use the SIGNAL ON SYNTAX Routine    " LINK "Signal"}

You should also look for:-

@{" Errors In Logic Or Fact             " LINK "LogicFact"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Initial" "Article 49 - Error Tracing & Debugging Pt 4 - Initial Scan Phase"

@{B}@{U}@{JCENTER}USE THE INITIAL SCAN PHASE@{UB}@{UU}
@{JLEFT}
I say "Use The @{"Initial Scan Phase" LINK "ARB:Articles_41-50/46.ERROR_TRACING-1/Point2"}" but in actual fact this will be done
automatically for you when you first RX the program. These are the first
errors to be corrected as the program will not run until all such errors
have been fixed up.

Note that you may have to go through this phase a number of times as it
will only pick up one such error at a time, i.e. the first one it
reaches.

After fixing up one error, run the program again and the next (if any)
error of this type will be located.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Scan" "Article 49 - Error Tracing & Debugging Pt 4 - Use TRACE() With SCAN"

@{B}@{U}@{JCENTER}USE TRACE() WITH SCAN OPTION@{UB}@{UU}
@{JLEFT}
Use @{"TRACE('S')" LINK "ARB:Articles_41-50/47.ERROR_TRACING-2/AllOps"} by putting these lines at the start of your program:-

  SAY 'Enter TRACE() mode to be used:-'
  PULL Mode
  CALL TRACE(Mode)

(See @{"Lines 3-5 of Example49-1" LINK "LogicFact"11} for an example of its use.)

This will give you the following prompt before the program proper is
started:-

  Enter TRACE() mode to be use:-

Enter at this prompt the letter "S" for SCAN.

When the program proceeds beyond this point, there will be no further
program output, only tracing output. In this way, you will pick up a lot
of errors a lot sooner than by really running the program.

Once again, it will only show you the first error it finds then stops
program execution. You will have to keep using it until all errors have
been found and corrected. You can then go on to use @{"other trace options" LINK "Other"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Other" "Article 49 - Error Tracing & Debugging Pt 4 - Use Other Trace Options"

@{B}@{U}@{JCENTER}USE TRACE() WITH OTHER OPTIONS@{UB}@{UU}
@{JLEFT}
After you have fixed up all the errors found by using the @{"SCAN" LINK "Scan"} option,
you can enter any other TRACE() @{"option" LINK "ARB:Articles_41-50/47.ERROR_TRACING-2/Trace()"19} that you feel is appropriate to
the particular program when this prompt is shown:-

  Enter TRACE() mode to be used:-

After all errors have been detected, you would finally enter the @{"OFF" LINK "ARB:Articles_41-50/47.Error_Tracing-2/Off"} option
to have the program run without tracing.

See also:-

  @{" Use TRACE() With Interactive Mode   " LINK "Interactive"}
  @{" Use TRACE() With Command Inhibition " LINK "Inhibition"}
  @{" Errors In Logic Or Fact             " LINK "LogicFact"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Interactive" "Article 49 - Error Tracing & Debugging Pt 4 - Use TRACE() With Interactive Mode"

@{B}@{U}@{JCENTER}USE TRACE() WITH INTERACTIVE MODE@{UB}@{UU}
@{JLEFT}
It may be necessary to use the @{"Interactive Mode" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"} with Trace() to see what
is happening in the program.

If you have the @{"three lines to choose a trace option" LINK "Scan"} at the start of your
program then you can just wait for the prompt:-

  Enter TRACE() mode to be used:-

and enter ? with an option. For example:-

  ?R

Or you can put this line at the start of your program:-

  CALL TRACE('?R')

As an example, while interactive mode is on, if you are doubtful about
what value a variable symbol holds at any point of the program, you can
simply enter in the @{"G.T.C." LINK "ARB:Articles_41-50/47.Error_Tracing-2/GTC"} window:-

  SAY symbolname

and the program's output window will display the current value.

To demonstrate this, open up the G.T.C. and RX @{"Example48-2" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Example"}.

The program's output window should display:-

  X Loop = 1
  X Loop = 2
  X Loop = 3
  X Loop = 4
  X Loop = 5
  Y Loop = 1

and then stop.

The last few lines in the G.T.C. window should be:-

    8 *-* CALL TRACE('?');
        >>> "?"
        >>> "R"
    9 *-* DO Y = 1 to 5;
        >>> "1"
        >>> "5"
     10 *-* SAY 'Y Loop =' Y;
          >>> "Y Loop = 1"
  >+>

Because Line 8 turned on interactive tracing, it is now waiting for your
@{"input" LINK "ARB:Articles_41-50/48.Error_Tracing-3/What"15}.

Now enter at the >+> prompt:-

  SAY 'X =' x

and the program's output window should show:-

  X = 6

You can do the same for any symbol and, as mentioned earlier, you can
enter other things like little bits of @{"ARexx code" LINK "ARB:Articles_41-50/48.Error_Tracing-3/What"122} or send @{"commands" LINK "ARB:Articles_41-50/48.Error_Tracing-3/What"157} to
an external host.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Signal" "Article 49 - Error Tracing & Debugging Pt 4 - Use SIGNAL ON SYNTAX"

@{B}@{U}@{JCENTER}USE THE SIGNAL ON SYNTAX ROUTINE@{UB}@{UU}
@{JLEFT}
After you have finished with the @{"TRACE()" LINK "Scan"} function, the next thing to put
into a program are these lines (as used in @{"Example46-2" LINK "ARB:Articles_41-50/46.Error_Tracing-1/SourceLine()"26}):-

  SIGNAL ON SYNTAX

  ....... Insert your program here

  Syntax:
    SAY 'You have a syntax error!'
    SAY 'It is Error Number' RC 'in line number' Sigl
    SAY 'which is shown below in reverse video text.'||'a'x
    DO Count = Sigl-2 TO Sigl+2
      IF Count >0 & Count <= Lines THEN DO
        IF Count = Sigl THEN DO
          SAY 'Line' Count '1b'x'[7m'||SOURCELINE(Count)||'1b'x'[0m'
        END
        ELSE DO
          SAY 'Line' Count SOURCELINE(Count)
        END
      END
    END
    SAY 'a'x

This will pick up and display (in @{APEN 0}@{BG Shadow}reverse video@{APEN 1}@{BG Background}) lines with errors that
were not found using TRACE().

Again, it will be a @{B}one by one@{UB} procedure.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Inhibition" "Article 49 - Error Tracing & Debugging Pt 4 - Use TRACE() With Command Inhibition"

@{B}@{U}@{JCENTER}USE TRACE() WITH COMMAND INHIBITION@{UB}@{UU}
@{JLEFT}
If you are communicating with other programs then it would be advisable
to use @{"Command Inhibition" LINK "ARB:Articles_41-50/48.ERROR_TRACING-3/!"}.

If you have the @{"three lines to choose a trace option" LINK "Scan"} at the start of your
program then you can just wait for the prompt:-

  Enter TRACE() mode to be used:-

and enter:-

  !C

Or you can put this line at the start of your program:-

  CALL TRACE('!C')

This will trace all command clauses without sending the command to the
external host.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "LogicFact" "Article 49 - Error Tracing & Debugging Pt 4 - Errors In Logic Or Fact"

@{B}@{U}@{JCENTER}ERRORS IN LOGIC OR FACT@{UB}@{UU}
@{JLEFT}
The above procedures will find all the obvious errors in syntax, etc.

However, a lot of errors will be far more subtle and take a lot more hard
work trying to debug the program. These are the errors which, while
conforming to all requirements of ARexx itself, never the less contain
errors in logic that prevent the program from working in the way that you
want it to work.

The following example contains a couple of such errors. It is a simple
simulation of opening a disk file, writing a header to it then closing
it, then, maybe a lot later, reopening it to write 5 lines to it.

 1. /* Example49-1 */
 2.
 3. SAY 'Enter TRACE() mode to be used:-'
 4. PULL Mode
 5. CALL TRACE(Mode)
 6.
 7. SAY 'Creating file called "Ram:A_Load_Of_Garbage"'
 8.
 9. CALL OPEN('IntFile','Ram:A_Load_Of_Garbage','W')
10. WRITELN('IntFile','This is a file called "Ram:A_Load_Of_Garbage"')
11. CALL CLOSE('IntFile')
12.
13. /* lots more programming */
14.
15. CALL OPEN('IntFile','Ram:A_Load_Of_Garbage','W')
16.
17. Count = 0
18. DO FOREVER
19. Count = count + 1
20. Line = 'Line' Count
21. SAY 'Writing' Line
22. SAY Line
23. CALL WRITELN('IntFile',Line)
24. IF Count < 4 THEN EXIT
25. END
26.
27. CALL CLOSE('IntFile')

The first time you run this program, enter "O" for "OFF" option so as
to simulate running the program without any tracing.

The file created is supposed to contain these lines:-

  This is a file called "Ram:A_Load_Of_Garbage"
  Line 1
  Line 2
  Line 3
  Line 4
  Line 5

However, if you RX this then examine the file created, you will find that
it only contains this one line:-

  Line 1

There are two logical errors in the file which @{B}cannot@{UB} be picked up by
the initial scan phase or by the usage of SIGNAL ON SYNTAX.

Now rerun the program and enter "?R" of "Interactive Results Mode".

The most obvious one will be shown up when tracing gives this
output:-

   23 *-* CALL WRITELN('IntFile',Line);
        >>> "IntFile"
        >>> "Line 1"
        >>> "7"
   24 *-* IF Count < 4 THEN
        >>> "1"
>+>
     24 *-* EXIT;

This will quickly show that the EXIT was reached when "Count = 1" and
you can see that Line 22 has:-

  IF Count < 4 THEN

instead of:-

  IF Count > 4 THEN

Fixing this logical error will then result in our file containing these
lines:-

  Line 1
  Line 2
  Line 3
  Line 4
  Line 5

Out heading written at Line 10 of the program is still missing!

It will take some closer examination to see that the error is in Line
15 where I have used:-

  CALL OPEN('IntFile','Ram:A_Load_Of_Garbage','W')

which will open a file for writing and delete any old file already there
with the same name!

I should have used:-

  CALL OPEN('IntFile','Ram:A_Load_Of_Garbage','A')

which will reopen an existing file for @{B}appending@{UB} data to it.

These two errors are very simple. Although a lot of your errors will be
as simple as these, some logical errors will be a lot harder than this
to track down!

I cannot possibly hope to cover all the logical errors that could be made.
They would be almost as numerous as the number of ARexx programs that
have ever been written and the number of programmers who have written
them!! Each type of program will have its own types of possible logical
errors. It will take quite a bit of experience to enable you to easily
track down all the errors that you will make.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
