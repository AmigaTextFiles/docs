@DATABASE "ARB46"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 46 - Error Tracing & Debugging Part 1"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 46 - ERROR TRACING & DEBUGGING - PART 1

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" General Comments                     " LINK "General"}
@{" Error Numbers & Error Text           " LINK "Errors"}
@{" ARexx Error Numbers                  " LINK "Numbers"}
@{" Error Severity Number                " LINK "Severity"}
@{" Error Text & ERRORTEXT() Function    " LINK "Errortext()"}
@{" Point Of Error Detection             " LINK "Point"}
@{" The SOURCELINE() Function            " LINK "Sourceline()"}
@{" Using SOURCELINE() For Help Function " LINK "Using"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "General" "Article 46 - Tracing & Debugging Part 1 - General"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - GENERAL@{UB}@{UU}
@{JLEFT}
No matter how good a programmer you become, you will @{B}ALWAYS@{UB} make the odd
mistake or two in your programming. (Yes, even @{B}I@{UB} make mistakes at times
but I hope you do not find any in the example programs on this disk!!)

There are a number of Command Utilities and Built In Functions that will
help you trace through your programs as they are running to find where the
problem occurs. This and the following three articles will take you through
error tracing and debugging programs.

First of all we should take a quick look at errors, their numbers and what
they mean.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Errors" "Article 46 - Tracing & Debugging Part 1 - Error Numbers & Text"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - ERROR NUMBERS & ERROR TEXT@{UB}@{UU}
@{JLEFT}
You will no doubt have noticed by now that you will sometimes get error
messages appearing in your Shell/CLI window when you try to RX an ARexx
program. In case you haven't (@{B}are@{UB} you the perfect programmer??!!??)

RX this example program:-

  Line 1     /* Example46-1.rexx */
  Line 2
  Line 3     SAY 'Calling Function XYZ'
  Line 4     CALL XYZ
  Line 5     SAY 'Back from XYZ'

The output should be:-

  Calling Function XYZ
  +++ Error 15 in line 4: Function not found
  Command returned 10/15: Function not found

(Note - this assumes that you have @{B}not@{UB} got an ARexx program called "XYZ"
in the current directory or your REXX: directory when you use the RX
command to run the above program!)

The three lines of this output are described below:-

@{B}The first line@{UB}:-     Calling Function XYZ

- This is the result of the first SAY clause.
- It proves that the program has really started execution.

@{B}The second line@{UB}:-    +++ Error 15 in line 4: Function not found

- This is the output from the ARexx process when the program reaches the
  CALL clause. It cannot find the function XYZ so it returns an error
  message.

- The @{B}+++@{UB} symbol is one of the @{"Emblems" LINK "ARB:Articles_41-50/47.ERROR_TRACING-2/Output"} that we will look at in
  Tracing & Debugging Part 2

- Error 15 is one of the 48 odd ARexx @{"error numbers" LINK "Numbers".

- "Function not found" is the @{"text" LINK "Errortext()"} associated with Error 15.

- When the program stops it sends a message back to the RX command which is
  then displayed by RX as the third line of the above output.

@{B}The third line@{UB}:-     Command returned 10/15: Function not found

- This line is generated by the ARexx process.

- The "10" is the severity number of the error (see below). Nearly all
  errors return a severity code of 10.

- The "15" is the ARexx error number

- "Function not found" is the text associated with Error 15.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Numbers" "Article 46 - Tracing & Debugging Part 1 - ARexx Error Numbers"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - AREXX ERROR NUMBERS@{UB}@{UU}
@{JLEFT}
ARexx assigns a number to various error conditions. These numbers and their
meanings are given in the table shown in @{"Appendix A" LINK "ARB:Appendices/App-A_Error_Table/MAIN"}.

If, within a program, you use @{"SIGNAL ON SYNTAX" LINK "ARB:Articles_31-40/33.SIGNALLING/Syntax"} then you can use, with it,
the special variables @{"RC and SIGL" LINK "ARB:Articles_31-40/33.SIGNALLING/SiglRC"} to determine:-

- the error number by looking at the value held by the special variable @{B}RC@{UB}
- the line number in which it occurred with the value of the special
  variable @{B}SIGL@{UB}

However, some errors will be detected @{B}before@{UB} a program reaches the
execution stage in which case the @{B}SIGNAL ON SYNTAX will not be able to
detect the error.@{UB} See @{"Point of Error Detection" LINK "Point"}.

You can also determine the text of the error number by using the built in
function @{"ERRORTEXT(Number)" LINK "Errortext()"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Severity" "Article 46 - Tracing & Debugging Part 1 - Error Severity Number"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - ERROR SEVERITY NUMBER@{UB}@{UU}
@{JLEFT}
The "Severity" number shown in the @{"table of errors" LINK "ARB:Appendices/App-A_Error_Table/MAIN"} is the equivalent of
AmigaDOS's "FailAt" code numbers. It is the code number returned to the
host from which the ARexx program was launched. For example, if the program
is launched from AmigaDOS using RX from a Shell/CLI window then these
severity numbers will appear in the Shell/CLI window. This was illustrated
by Example46-1 above.

The severity levels are:-

   5 - Not very serious     (Only returned by @{"Error Number 1" LINK "ARB:Appendices/App-A_Error_Table/1"})
  10 - Reasonably serious   (Returned by all errors except 1 and 3)
  20 - Very Serious         (Only returned by @{"Error Number 3" LINK "ARB:Appendices/App-A_Error_Table/3"})


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Errortext()" "Article 46 - Tracing & Debugging Part 1 - Error Text & ERRORTEXT() Function"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - ERROR TEXT & ERRORTEXT() FUNCTION@{UB}@{UU}
@{JLEFT}
Each error number has an associated brief description of the error known as
the "Error Text". These are shown in the table of errors given in
@{"Appendix A" LINK "ARB:Appendices/App-A_Error_Table/MAIN"}.

You can determine the text of a number with the built in function
ERRORTEXT(). Its format is:-

  ERRORTEXT(Number)

where "Number" can be any positive integer number representing an error
number.

It returns one of these three possibilities:-

- The @{B}text of the error message@{UB} associated with the number if that number
  has an error text associated with it. For example:-

    SAY ERRORTEXT(24)
    --> Missing or Multiple THEN

- A @{B}null string@{UB} if the number is within the normal range of error numbers
  but there is no associated error text. For example:-

    SAY ERRORTEXT(4)
    -->
   (No output as 4 returns a null string.)

  In my version of ARexx (v1.15) error numbers @{"4" LINK "ARB:Appendices/App-A_Error_Table/4"}, @{"7" LINK "ARB:Appendices/App-A_Error_Table/7"} and @{"38" LINK "ARB:Appendices/App-A_Error_Table/38"}
  give null strings. If you get some text output with these numbers then
  you must have a different version of ARexx.

- The message @{B}Undiagnosed internal error@{UB} if the number is outside the
  normal range of error numbers. For example:-

    SAY ERRORTEXT(50)
    --> Undiagnosed internal error

  In my version of ARexx (v1.15) error number 0 and error numbers
  49 onwards give this message.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Point" "Article 46 - Tracing & Debugging 1 - Point Of Error Detection"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 1 - POINT OF ERROR DETECTION@{UB}@{UU}
@{JLEFT}
There are three points at which errors will @{B}normally@{UB} be detected and
trapped. These points are detailed below.

  @{" Point 1 " LINK "Point1"} - At an external host program

  @{" Point 2 " LINK "Point2"} - During ARexx's "Initial Scan" of the program

  @{" Point 3 " LINK "Point3"} - During execution of the ARexx program


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Point1" "Article 46 - Tracing & Debugging 1 - Point 1 Errors Detected By External Host"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 1 - POINT 1 ERROR DETECTED BY EXTERNAL HOST@{UB}@{UU}
@{JLEFT}
These are the errors that are picked up by the external program with which
ARexx is communicating. They are really errors associated with the external
environment. For this reason:-

- they @{B}cannot@{UB} be picked up during the @{"initial scan stage" LINK "Point2"}

- they @{B}cannot@{UB} be picked up by using @{"SIGNAL ON SYNTAX" LINK "ARB:Articles_31-40/33.SIGNALLING/Syntax"}

The most common of this type of error is:-

* @{"Error 1" LINK "ARB:Appendices/App-A_Error_Table/1"} - Program not found

Other errors in this category are:-

* @{"Error 10" LINK "ARB:Appendices/App-A_Error_Table/10"} - Invalid Message Package
* @{"Error 11" LINK "ARB:Appendices/App-A_Error_Table/11"} - Command String Error
* @{"Error 12" LINK "ARB:Appendices/App-A_Error_Table/12"} - Error Return From Function


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Point2" "Article 46 - Tracing & Debugging 1 - Point 2 Errors Detected Initial Scan Phase"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 1 - POINT 2 ERRORS DETECTED AT INITIAL SCAN PHASE@{UB}@{UU}
@{JLEFT}
The @{B}Initial Scan@{UB} takes place when you first call a program, either with the
RX command from AmigaDOS or from another host program. ARexx does a quick
scan through the text of the program looking for certain errors and, if it
finds any, reports on them @{B}before@{UB} the program is executed.

If any of these types of errors are found, @{B}no part at all@{UB} of the program is
executed.

Because the program is @{B}not@{UB} executed, these errors @{B}cannot@{UB} be picked up by
using @{"SIGNAL ON SYNTAX" LINK "ARB:Articles_31-40/33.SIGNALLING/Syntax"}.

(Compare this to errors detected at @{"Point 3" LINK "Point3"} which is @{B}during@{UB} program
execution and which @{B}are@{UB} picked up by using SIGNAL ON SYNTAX.)

Errors in the Point 2 category are:-

* @{"Error 5" LINK "ARB:Appendices/App-A_Error_Table/5"} - Unmatched quote
            i.e. the use of an opening " without a closing "
                 the use of an opening ' without a closing '
                 the mixture of the two types (" and ') in the one quote.

* @{"Error 6" LINK "ARB:Appendices/App-A_Error_Table/6"} - Unterminated Comment
            i.e. the use of /* without a corresponding */

            (Note the use of */ without /* is Error 41 - Invalid
            expression as * and / are arithmetical operators.)

* @{"Error 8" LINK "ARB:Appendices/App-A_Error_Table/8"} - Invalid Token
            This appears to include what is shown in the manuals as
            @{"Error 4" LINK "ARB:Appendices/App-A_Error_Table/4"} - non ASCII character found

@{B}Note@{UB} the manuals include these two error numbers as @{"Point 2" LINK "Point2"} errors:-

* @{"Error 4" LINK "ARB:Appendices/App-A_Error_Table/4"} - Invalid character
            A non ASCII Code was found in the program
            This fault now appears to give @{"Error 8" LINK "ARB:Appendices/App-A_Error_Table/8"}

            ERRORTEXT(4) --> Null string

* @{"Error 7" LINK "ARB:Appendices/App-A_Error_Table/7"} - Clause too long
            This fault now appears to give @{"Error 3" LINK "ARB:Appendices/App-A_Error_Table/3"}

            ERRORTEXT(7) --> Null string


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Point3" "Article 46 - Tracing & Debugging 1 - Point 3 Errors Detected During Program Execution"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 1
POINT 3 ERRORS DETECTED DURING PROGRAM EXECUTION@{UB}@{UU}
@{JLEFT}
These errors are only detected when the offending program clause is reached
@{B}during the execution@{UB} of the program. They are @{B}not found@{UB} during the
@{"Initial Scan" LINK "Point2"}.

These errors @{B}can@{UB} normally be trapped with @{"SIGNAL ON SYNTAX" LINK "ARB:Articles_31-40/33.SIGNALLING/Syntax"}.

The error numbers involved are 2, 3, 9 and 13 to 48 inclusive.

@{B}Nearly all@{UB} of these errors result from @{B}PROGRAMMER ERRORS@{UB} associated with
@{B}incorrect usage@{UB} of instructions and with trying to access hosts or
functions by using @{B}incorrect names or non existing names.@{UB}

As it can be @{B}very annoying@{UB} to have a program crash with these sort of
errors after running for some time, it is recommended that you use
@{"TRACE('SCAN')" LINK "ARB:Articles_41-50/47.Error_Tracing-2/Allops"} to pick up these errors as this TRACE() option will "run" the
program without making any actual output. This is much faster than normal
running with output. This will be discussed in the next article.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Sourceline()" "Article 46 - Tracing & Debugging Part 1 - SOURCELINE() Function"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - SOURCELINE() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
The format for this function is:-

  SOURCELINE([LineNumber])

which means that it can be used in one of these ways:-

  SOURCELINE()

  SOURCELINE(LineNumber)

This function can only act upon the program in which it is used.

The first format displays the number of lines in the program. For example:-

  SAY SOURCELINE()
  --> 43

The second format displays the text of the line number used as the
argument. For example:-

  SAY SOURCELINE(5)
  --> Text of line number 5

The usage of this function is shown in the following example. It is a handy
aid to debugging programs. Just put Line 3 at the start of your program and
Lines 11-25 at the end. Being at the start and end they will be easy to
delete when you have finished debugging.

This program will show the offending line in @{APEN 0}@{BG Shadow}reverse video@{APEN 1}@{BG Background} to make it stand
out. It will also show the 2 lines either side of it (as set up in
Line 15). However, Line 16 ensures that these extra lines will @{B}not@{UB} be shown
if Count is less than 1 (0 or negative is not allowed) or if Count is
greater than the total number of lines in the program (which is also not
allowed).

 1. /* Example46-2 */
 2.
 3. SIGNAL ON SYNTAX
 4.
 5. Lines = SOURCELINE()
 6.
 7. DO FOR X = 1 TO 10
 8.   SAY 'X =' x
 9. END
10.
11. Syntax:
12. SAY 'You have a syntax error!'
13. SAY 'It is Error Number' RC 'in line number' Sigl
14. SAY 'which is shown below in reverse video text.'||'a'x
15. DO Count = Sigl-2 TO Sigl+2
16.   IF Count >0 & Count <= Lines THEN DO
17.     IF Count = Sigl THEN DO
18.       SAY 'Line' Count '1b'x'[7m'||SOURCELINE(Count)||'1b'x'[0m'
19.     END
20.     ELSE DO
21.       SAY 'Line' Count SOURCELINE(Count)
22.     END
23.   END
24. END
25. SAY 'a'x

The output of this program should be:-

  You have a syntax error!
  It is Error Number 28 in line number 7
  which is shown below in reverse video text.

  Line 5 Lines = SOURCELINE()
  Line 6
  Line 7 @{APEN 0}@{BG Shadow}DO FOR X = 1 TO 10@{APEN 1}@{BG Background}
  Line 8 SAY 'X =' x
  Line 9 END

@{B}Note@{UB} that the line count @{B}includes@{UB} blank lines and comment lines
as well as proper program lines.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Using" "Article 46 - Tracing & Debugging Part 1 - Using SOURCELINE() For Help Function"
@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING - PART 1 - USING SOURCELINE() FOR HELP FUNCTION@{UB}@{UU}
@{JLEFT}
The manuals say that this feature could be used to embed a @{B}Help@{UB} function
into a program. One way that this could be done is shown in this example
program:-


  /* Example46-3 */

  /*
  Your full name with surname last should be entered here.
  You full phone number including STD code should be entered here.
  */

  SAY 'This is a demonstration of a HELP function'

  Name = '?'
  DO WHILE Name = '?'
    OPTIONS PROMPT 'Enter your name or ? for help '
    PULL Name
    IF Name = '?' THEN DO
      SAY '1b'x'[32m'||SOURCELINE(4)||'1b'x'[0m'
    END
  END

  Phone = '?'
  DO WHILE Phone = '?'
    OPTIONS PROMPT 'Enter phone number or ? for help '
    PULL Phone
    IF Phone = '?' THEN DO
      SAY '1b'x'[32m'||SOURCELINE(5)||'1b'x'[0m'
    END
  END

  SAY '1b'x'[32mHi there' Name 'at phone' Phone

However, it seems to me a rather complex way of doing the job! You would
have to be very careful about:-

- getting the line numbers right,
- making sure that the help lines are within comment indicators /* */ so
  that they will be ignored by the program except when the SOURCELINE()
  function reads their content,
- putting the comment indicators @{B}on separate lines@{UB} before and after
  the help lines otherwise they will be read as part of the help lines.

Why not just replace the SOURCELINE() in the SAY clauses with the actual
text being said?! If the same bit of text was to be used as the @{B}Help@{UB} at a
number of different points, you could easily put it into a symbol value and
SAY the symbol. For example:-

  /* Example46-4 */

  Help1 = 'Your full name with surname last should be entered here.'
  Help2 = 'You phone number including STD code should be entered here.'

  SAY 'This is a demonstration of a HELP function'

  Name = '?'
  DO WHILE Name = '?'
    OPTIONS PROMPT 'Enter your name or ? for help '
    PULL Name
    IF Name = '?' THEN DO
      SAY '1b'x'[32m'||Help1||'1b'x'[0m'
    END
  END

  Phone = '?'
  DO WHILE Phone = '?'
    OPTIONS PROMPT 'Enter phone number or ? for help '
    PULL Phone
    IF Phone = '?' THEN DO
      SAY '1b'x'[32m'||Help2||'1b'x'[0m'
    END
  END

  SAY '1b'x'[32mHi there' Name 'at phone' Phone

The output from this should be identical to @{"Example46-3" LINK "Using"} but, to my mind, it
is a lot simpler!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
