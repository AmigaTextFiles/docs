@DATABASE "ARB47"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 47 - Error Tracing & Debugging Part 2"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 47 - ERROR TRACING & DEBUGGING - PART 2

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" A Demonstration                  " LINK "Demo"}
@{" The GLOBAL TRACING Window        " LINK "GTC"}
@{" The TCO Command Utility          " LINK "TCO"}
@{" Demonstrating The GTC            " LINK "Demo2"}
@{" The TCC Command Utility          " LINK "TCC"}
@{" Creating Your Own Tracing Window " LINK "Own"}
@{" The TRACE() Built In Function    " LINK "Trace()"}
@{" The TRACE   Instruction          " LINK "Trace"}
@{" Output During Tracing            " LINK "Output"}
@{" Tracing Options - Discussion     " LINK "Discussion"}
@{" Options Tracing ALL Clauses      " LINK "Allops"}
@{"   SCAN          Option Example   " LINK "Scan"}
@{"   ALL           Option Example   " LINK "All"}
@{"   RESULTS       Option Example   " LINK "Results"}
@{"   INTERMEDIATES Option Example   " LINK "Intermediates"}
@{" Options Tracing COMMAND Clauses  " LINK "Command"}
@{"   COMMANDS      Option Example   " LINK "Commands"}
@{"   ERRORS        Option Example   " LINK "Errors"}
@{"   NORMAL        Option Example   " LINK "Normal"}
@{" Options Tracing LABEL Clauses    " LINK "Label"}
@{"   LABEL         Options Example  " LINK "Label"13}
@{" Options That Do NOT Trace        " LINK "Not"}
@{"   OFF           Option Example   " LINK "Off"}
@{"   BACKGROUND    Option Example   " LINK "Background"}
@{" Which Option To Use?             " LINK "Which"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Demo" "Article 47 - Error Tracing & Debugging 2 - A Demonstration"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - A DEMONSTRATION@{UB}@{UU}
@{JLEFT}
Before continuing with out discussion of Error Tracing and Debugging,
RX the following program in you normal Shell/CLI window. Don't worry about
the clause CALL TRACE('R') at this stage but what it does is to put a
lot of tracing information into the window.

 1. /* Example47-1*/
 2.
 3. CALL TRACE('R')
 4. Count = 0
 5.
 6. DO FOREVER
 7.
 8. Count = Count + 1
 9. SAY 'Count =' Count ' - Press CTRL-C to ABORT'
10.
11. END

The start of the display in your window should be:-

        >>> "N"
    4 *-* Count = 0;
        >>> "0"
    6 *-* DO FOREVER;
      8 *-* Count = Count + 1;
          >>> "1"
      9 *-* SAY 'Count =' Count ' - Press CTRL-C to ABORT';
          >>> "Count = 1 - Press CTRL-C to ABORT"
  Count = 1 - Press CTRL-C to ABORT
     11 *-* END;
      6 *-* DO FOREVER;
      8 *-* Count = Count + 1;
          >>> "2"
      9 *-* SAY 'Count =' Count ' - Press CTRL-C to ABORT';
          >>> "Count = 2 - Press CTRL-C to ABORT"
  Count = 2 - Press CTRL-C to ABORT
     11 *-* END;

Don't worry about what all this means at the moment. We will discuss that
a bit later but @{"click here" LINK "Output"10} if you want to have a preview!

For the time being @{B}just take note@{UB} that it is @{B}very difficult@{UB} to see what
is the tracing output and what is the normal program output!

To abort the program from its "FOREVER" loop, just press CTRL-C.

@{B}What we need to do is put the two outputs into different windows.@{UB}

To do this we use the @{"Global Tracing Window" LINK "GTC"}.


@{JCENTER}=== End of Text ===
@{JLEFT}













@ENDNODE

@NODE "GTC" "Article 47 - Error Tracing & Debugging 2 - Global Tracing Window"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - THE GLOBAL TRACING WINDOW@{UB}@{UU}
@{JLEFT}
To overcome the @{"above problem" LINK "Demo"43} ARexx has provided a @{B}Global Tracing Console@{UB}
or GTC for short.

It is @{B}global@{UB} because @{B}every@{UB} ARexx program that has been set to trace has
its tracing output displayed in this window if it is open!!!

It is therefore @{B}not advisable@{UB} to trace more than one program at a time
when the GTC is active unless you have some very good reason for doing so.

It is called a @{B}Tracing Console@{UB} because it is a console window in which
the tracing output is displayed.

It is opened by using the @{"TCO Command Utility" LINK "TCO"}

It is closed by using the @{"TCC Command Utility" LINK "TCC"}

A demonstration of its use can be read by @{"clicking here" LINK "Demo2"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "TCO" "Article 47 - Error Tracing & Debugging 2 - The TCO Command Utility"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - THE TCO COMMAND UTILITY@{UB}@{UU}
@{JLEFT}
This utility will open the @{"Global Tracing Console" LINK "GTC"} (GTC) window.

It is used in a Shell/CLI window without any arguments:-

  > TCO

Or it can be sent to AmigaDOS from an ARexx program:-

  ADDRESS 'COMMAND' 'TCO'

The GTC window is closed again with the @{"TCC" LINK "TCC"} command utility.

A demonstration of the use of the GTC can be read by @{"clicking here" LINK "Demo2"}.

@{B}@{U}The GTC Window Size@{UB}@{UU}

When the GTC is used, it opens a small window at the top middle of the
screen with this @{"window size specification" LINK "ARB:Articles_21-30/28.File_Handling/Console"}:-

  CON:160/0/320/80/ARexx/

I find this window too narrow and I cannot find any way to provide a window
specification when the window is opened with TCO. It is very annoying
having to resize it to a decent size!

This window specification is @{B}not@{UB} contained in the TCO file but in the
file:-

  SYS:System/RexxMast

My solution was to use a file editor (a program that allows you to enter
any file and change the contents of it byte by byte) to change this window
specification to:-

  CON:0/11/640/130/ARexx/

@{B}WARNING - DO NOT ATTEMPT THIS UNLESS YOU REALLY KNOW WHAT YOU ARE DOING!!!
and, if you do, make sure that you do it on a \it copy \it of RexxMast so
that, if you mess it up, you can go back to the original!!!@{UB}

If changing this window specification, you @{B}must make sure@{UB} that the new
specification is @{B}exactly the same length@{UB} as the original one. If you make
it longer then you will overwrite some other important part of the
program!!

Sorry - I can't put a copy of my revised RexxMast on this disk as the
original RexxMast is copyright! But I will discuss how to @{"Create Your Own" LINK "Own"}
Tracing Console Window a bit later.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Demo2" "Article 47 - Error Tracing & Debugging 2 - Demonstrating The GTC"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - DEMONSTRATING THE GLOBAL TRACING WINDOW@{UB}@{UU}
@{JLEFT}
To demonstrate The GTC, enter TCO at your Shell/CLI prompt and RX
@{"Example47-1" LINK "Demo"} again.

Now you will see the normal program output in the Shell/CLI window from
which the program was started and the tracing output in the GTC window.

The CTRL-C to break or stop programs can be entered in either the normal
Shell/CLI window in which program output is appearing or in the GTC window
in which the tracing output is appearing.

@{B}@{U}Slowing Down The GTC Output@{UB}@{UU}

It may be that the display in the GTC will be very fast and the first
lot of lines can disappear from the top of the window before you have
time to read them.

To prevent this problem, follow these steps. Try it out on @{"Example47-1" LINK "Demo"}.

1. Select the GTC window (Click once in it)

2. Type in any character - the \ is the most convenient as it is next to
   the back arrow key which will be used to delete the character you typed.

   Having a character typed in prevents any display in the window until the
   character is deleted. Program output will also be held up if it is
   waiting to output to the GTC window.

3. Select the normal Shell/CLI window and RX the program.

   There may be some program output but this will stop when an output to
   the GTC is needed.

4. Now reselect the GTC window and alternately press the back arrow key
   to delete the character and type in another character to start and stop
   the display.

@{B}@{U}How The Output Is Split Between The Two Windows@{UB}@{UU}

The normal program output @{B}always@{UB} goes to a @{"Stream" LINK "ARB:Misc/Glossary/Streams"} called the "STDOUT"
stream which is normally the Shell/CLI window from which the program was
launched.

When tracing is requested, ARexx looks for a stream called "STDERR". If
it cannot find it, then it sends its output to the stream "STDOUT"

When TCO is used to open the Global Tracing Console (GTC) window, then
it is the "STDERR" stream and all tracing output goes to it thus separating
the two outputs.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "TCC" "Article 47 - Error Tracing & Debugging 2 - The TCC Command Utility"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - THE TCC COMMAND UTILITY@{UB}@{UU}
@{JLEFT}
This utility will close the @{"Global Tracing Console" LINK "GTC"} (GTC) window.

(This is the window opened with the @{"TCO" LINK "TCO"} command utility.)

TCC is used either in a Shell/CLI window:-

  > TCC

or within an ARexx program (as per illustrated in @{"Lines 3 & 4" LINK "Own"16} of
Example47-2:-

  ADDRESS 'COMMAND'
  'TCC'

@{B}BUT note that@{UB}, if tracing is in @{"interactive mode" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"} (next article), then
the window will not close until all the interactive requests are answered.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Own" "Article 47 - Error Tracing & Debugging 2 - Creating Your Own Tracing Window"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - CREATING YOUR OWN TRACING WINDOW@{UB}@{UU}
@{JLEFT}
This section is not all that important so, if you like, you can skip over
it and go straight down to the heading @{"The TRACE()" LINK "Trace()"} Built In Function.
However, you may find it of interest as a practical example of opening
your own windows and of diverting the standard @{"streams" LINK "ARB:Misc/Glossary/Streams"}.

As mentioned @{"earlier" LINK "TCO"17}, the standard GTC window (in my version of ARexx)
is too small for my liking and I have changed the RexxMast file to make
it bigger.

If you do not feel up to this but want a bigger Tracing Console Window,
then you could try putting the bit of coding at Lines 1-8 (below) at the
start of programs that you wish to trace:-

  /* Example 47-2 */

 1. IF SHOW('F','STDERR') = 1 THEN DO
 2.   SAY 'GTC window is open. Closing it now'
 3.   ADDRESS 'COMMAND'
 4.   'TCC'
 5.   'WAIT 1 SECS'
 6. END

 7. SAY 'Opening own STDERR window'
 8. CALL OPEN('STDERR','CON:0/11/640/130/THIS IS MY OWN TRACING
           WINDOW'/CLOSE/WAIT','W')

 9. CALL TRACE('R')

10. DO Count = 1 to 10
11.   SAY 'Count =' Count
12. END

This program will open a window with the internal logical file name of
"STDERR" which is the same as that used by the GTC Therefore it cannot
be opened if the GTC is already open.

@{"Line 1" LINK "Own"18} checks to see if the file "STDERR" exists. If it does, then @{"Lines 2-5" LINK "Own"20}
operate. If not, the program jumps to @{"Line 7" LINK "Own"26}.

@{"Line 3" LINK "Own"21} makes AmigaDOS the host address.

@{"Line 4" LINK "Own"22} sends the "TCC" command to AmigaDOS in order to close the GTC
window.

@{"Line 5" LINK "Own"23} asks AmigaDOS to wait 1 second before returning. This is necessary
as I have found that if we go on to @{"Line 8" LINK "Own"27} too quickly then the GTC window
will not close until the program has been terminated.

@{"Line 8" LINK "Own"27} opens a new console window with the internal logical file name
'STDERR' so that the tracing output will go to it. You can give it any
window name that you like instead of the "THIS IS MY OWN TRACING
WINDOW"

For Workbench 2.0 and higher users, the CLOSE option will put a close
gadget in the window and the WAIT option will cause the window to stay
open until the close gadget is used. (Workbench 1.3 users - please see
note below.)

@{"Line 9" LINK "Own"30} turns on TRACE() and @{"Lines 10-12" LINK "Own"32} set up a simple loop to display.

Before RX'ing this program make sure that no other ARexx program is using
the GTC window if it is already open.

When you RX it you will see the new window open and all tracing output
will appear in the new window.

After you have finished with it you should click in the close gadget to
get rid of it as, each time the program is run, a new window will open.
I put the WAIT option into the window specification as otherwise the tracing
window would close as soon as the program finished thus making it hard
to read the last bit of tracing output before it disappeared.

If you happen to run a second ARexx program with tracing activated while
your own tracing window is open, then the other program will @{B}not@{UB} send
its tracing output to your window because @{B}your@{UB} window is @{B}not@{UB} a global
window. It is recognised only by the program from which it was opened.
Instead, any other program using TRACE() will put its tracing output into
the same Shell/CLI window from which it was started or into the GTC window
if the GTC window is opened @{B}after@{UB} a program opens your own tracing
window.

@{B}Note For Workbench 1.3 and earlier users@{UB}

If you are using Workbench 1.3 or earlier, the CLOSE & WAIT window options
in @{"Line 8" LINK "Own"27}  will not work and you should replace it with:-

  8. CALL OPEN('STDERR','CON:0/11/640/130/THIS IS MY OWN TRACING','W')

and you should also add these two extra lines to the end of the
program:-

 13. SAY 'a'x'PRESS RETURN TO TERMINATE PROGRAM'
 14. PULL Nothing

This is because your own tracing window will disappear as soon as the
program from which it was started finishes. These lines will keep your
tracing window open until you press return in the program output window
and thus you will not miss any tracing output.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Trace()" "Article 47 - Error Tracing & Debugging 2 - The TRACE() Function"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - THE TRACE() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
This function can be called at @{B}any point@{UB} of an ARexx program. In @{"Example47-1" LINK "Demo"},
it was used at the @{B}start@{UB} of the program. (See also the @{"TRACE" LINK "Trace"} instruction.)

Its format is:-

  TRACE([Option])

which means that it can be used in one of these ways:-

  TRACE()
  TRACE(Option)

If used @{B}without@{UB} an option the the @{B}default option@{UB} is used which is @{B}NORMAL@{UB}.

@{B}Note@{UB} that there is also a similar @{"TRACE" LINK "Trace"} instruction.

@{B}Option@{UB} can be one of these keywords:-

  SCAN           }
  ALL            } @{" Options that trace ALL Clauses     " LINK "Allops"}
  RESULTS        }
  INTERMEDIATES  }

  COMMANDS       }
  ERRORS         } @{" Options that trace COMMAND Clauses " LINK "Command"}
  NORMAL         }

  LABEL          } @{" Option that traces LABEL Clauses   " LINK "label"}

  BACKGROUND     }
  OFF            } @{" Options that do NOT trace          " LINK "Not"}

As usual, the @{B}first letter only@{UB} of the option need for used. For example:-

  TRACE('S')    is the same as    TRACE('SCAN')

As indicated above, the options can be divided into four categories and
their usages and purposes are discussed under the above headings.

The value of the option can be held by a symbol so that:-

  TRACE('RESULTS')

is the same as:-

  Mode = 'RESULTS'
  CALL TRACE(Mode)

When called, the function returns the value of the previous tracing mode.
If called for the first time this is "N" for "Normal" as this is the default
mode.

For example:-

  CALL TRACE('R')        /* Set to "Results" mode */
  .... more program
  PrevMode = TRACE('N')  /* Set to "Normal" mode and preserve previous */
                         /* mode in symbol "PrevMode" */
  .... more program
  CALL TRACE(PrevMode)   /* Set mode to that which existed before last */
                         /* call of TRACE() */

In this way, you can change the mode then return it to what it previously
was earlier in the program.

Note that when you use:-

  SymbolName = TRACE(Option)

then the TRACE() function is CALLed and the RESULT symbol is assigned
to SymbolName just as if you had used:-

  CALL TRACE(Option)
  SymbolName = Result


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Trace" "Article 47 - Error Tracing & Debugging 2 - The TRACE Instruction"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - THE TRACE INSTRUCTION@{UB}@{UU}
@{JLEFT}
As well as the @{"TRACE()" LINK "Trace()"} @{B}function@{UB}, there is also an @{B}instruction TRACE@{UB}. I
tend not to use it as I find the use of the function TRACE() easier.
However, I will explain it here in case you come across it in programs that
you read.

It has this format:-

  TRACE [Option] | [VALUE Expression]

The "|" indicates that you use one @{B}OR@{UB} the other of the two types of
arguments. As both are enclosed in [] you can use TRACE on its own. If so,
the "Normal" option is used as the default. This is the same as using the
function @{"TRACE()" LINK "Trace()"} without an option.

@{B}Option@{UB} can be one of these (which are the same as those listed for @{"TRACE()" LINK "Trace()"19}:-

  SCAN           }
  ALL            } @{" Options that trace ALL Clauses     " LINK "Allops"}
  RESULTS        }
  INTERMEDIATES  }

  COMMANDS       }
  ERRORS         } @{" Options that trace COMMAND Clauses " LINK "Command"}
  NORMAL         }

  LABEL          } @{" Option that traces LABEL Clauses   " LINK "label"}

  BACKGROUND     }
  OFF            } @{" Options that do NOT trace          " LINK "Not"}

They are discussed fully under the four above category headings.

If used, "Option" is @{B}literally@{UB} interpreted which means that, if a symbol
has been earlier used using the same name as an option, then the symbol
value is @{B}not@{UB} used. Thus if you use:-

  Results = 'The Answer'
  TRACE Results

then the the value of the @{B}symbol@{UB} "Results" is @{B}not@{UB} used in place of "Results"
in the TRACE instruction clause. "Results" is interpreted literally as
"Results"

Also, if you use:-

  Mode = 'Results'
  TRACE Mode

then your program will give an error message "Invalid keyword" as the
the "Mode" after "TRACE" has been interpreted literally as "Mode" which
is @{B}not@{UB} a legitimate keyword option! The value of the symbol "Mode" is
@{B}not@{UB} substituted.

@{B}Note@{UB} that this is different to the TRACE() function where you
@{"can use a symbol" LINK "Trace()"42} and its value as the "Option".

@{B}VALUE Expression@{UB} is used when you wish to use the value of a symbol as
the option. For example, to use the symbol "Mode" we would use:-

  Mode = 'Results'
  TRACE VALUE Mode

ARexx then finds the value of the symbol "Mode" and interprets it as
"Results" so that the above two lines are the equivalent of:-

  TRACE 'Results'


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Output" "Article 47 - Error Tracing & Debugging 2 - Output During Tracing " Function"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - OUTPUT DURING TRACING@{UB}@{UU}
@{JLEFT}
For all options except "SCAN", the program is actually operated and normal
program output will result. For this reason, it is best to have the
@{"GTC window" LINK "GTC"} operating so that the program's output can be observed
independently from the tracing output.

@{B}@{U}Output From Tracing@{UB}@{UU}

The display output by tracing uses these emblems:-

  @{U}Emblem@{UU} @{U}                     Meaning                           @{UU}

   *-*   An actual program line
   ...   An indication at the end of a line that it has been
            truncated as it is too long to fit the window
   +++   An error in syntax or a command error
   >C>   An expanded Compound Name
   >F>   The result of a call on a function
   >L>   A label clause                       (See Note 1 below)
   >O>   The result of a dyadic operation     (See Note 2 below)
   >P>   The result of a prefix operation     (See Note 3 below)
   >U>   An unitialised variable              (See Note 4 below)
   >V>   The value of a variable symbol
   >>>   The result of an expression or template
   >.>   The value of a @{"Place Holder" LINK "ARB:Articles_31-40/35.Parse-Templates/PlaceHolder"} token
   >+>   The pause for interactive tracing    (See Note 5 below)

@{B}Note 1@{UB} Although the manuals call >L> an indication of a "Label Clause",
in fact it indicates the values of things such as strings, fixed symbols,
etc. (See examples below).

@{B}Note 2@{UB} A dyadic operation is one involving two items. For example, an
arithmetic addition such as @{B}2 + 3@{UB} or a string concatenation such as
@{B}Name||Result@{UB}

@{B}Note 3@{UB} A prefix operation is one that evaluates expressions that have
a prefix such as "+" or "-". For example SAY -17

@{B}Note 4@{UB} I have not seen any instance of this emblem occurring. Unitialised
variables are those which have not been given a value. I have found that
any reference to an unitialised variable is by the ">L>" emblem as
in:-

  TRACE I
  SAY Name

  1 *-* say Name;
      >L> "NAME"

@{B}Note 5@{UB} @{"Interactive tracing" LINK "ARB:Articles_41-50/48.Error_Tracing-3/MAIN"} will be discussed in the next article.

Whereas all options will use at least one of these emblems, the option
that uses the most of them is the "INTERMEDIATES" option.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Discussion" "Article 47 - Error Tracing & Debugging 2 - Discussion Of Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - DISCUSSION OF TRACING OPTIONS@{UB}@{UU}
@{JLEFT}
The following notes discuss the various options that can be used in both
the @{"TRACE()" LINK "Trace()"} function and the @{"TRACE" LINK "Trace"} instruction.

There is an example program provided for each option. Before RX'ing the
example, you should always make sure that the @{"GTC" LINK "GTC"} window has been opened
with the @{"TCO" LINK "TCO"} command Utility so that you do not confuse program output
with tracing output.

The options, the headings under which they are discussed, and the example
programs for each option, are as follows:-

  @{" Options that trace ALL Clauses     " LINK "Allops"}

    SCAN           @{" Example47-3  " LINK "Scan"}
    ALL            @{" Example47-4  " LINK "All"}
    RESULTS        @{" Example47-5  " LINK "Results"}
    INTERMEDIATES  @{" Example47-6  " LINK "Intermediates"}

  @{" Options that trace COMMAND Clauses " LINK "Command"}

    COMMANDS       @{" Example47-7  " LINK "Commands"}
    ERRORS         @{" Example47-8  " LINK "Errors"}
    NORMAL         @{" Example47-9  " LINK "Normal"}

  @{" Option that traces LABEL Clauses   " LINK "label"}

    LABEL          @{" Example47-11 " LINK "Label"13}

  @{" Options that do NOT trace          " LINK "Not"}

    OFF            @{" Example47-12 " LINK "Off"}
    BACKGROUND     @{" Example48-4  " LINK "ARB:Articles_41-50/48.Error_Tracing-3/TS"52}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Allops" "Article 47 - Error Tracing & Debugging 2 - Options Tracing ALL  Clauses"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - OPTIONS TRACING ALL CLAUSES@{UB}@{UU}
@{JLEFT}
Options that trace @{B}ALL clauses@{UB}, and the example programs that demonstrate
them, are:-

  SCAN           @{" Example47-3 " LINK "Scan"}
  ALL            @{" Example47-4 " LINK "All"}
  RESULTS        @{" Example47-5 " LINK "Results"}
  INTERMEDIATES  @{" Example47-6 " LINK "Intermediates"}

These four options give a display of @{B}all@{UB} the program lines. An example
of the line display that would result if @{"Example47-1" LINK "Demo"} used the "ALL" option
is:-

    4 *-* Count = 0;
    6 *-* DO FOREVER;
      8 *-* Count = Count + 1;
      9 *-* SAY 'Count =' Count ' - Press CTRL-C to ABORT';
     11 *-* END;
      6 *-* DO FOREVER;
      8 *-* Count = Count + 1;
      9 *-* SAY 'Count =' Count ' - Press CTRL-C to ABORT';
     11 *-* END;
      6 *-* DO FOREVER;
      ... and so on

(@{"Click here" LINK "Output"10} for symbol explanation.)

Items that are @{B}not shown@{UB} are:-

  - Comments (i.e. parts enclosed by /* */) either on a line of their own
    or at the end of a line.

  - Blank lines.

The differences in the four options that trace all clauses are in:-

- the amount of extra information that is displayed and interspersed with
  the display of program lines,

- the output or non output from the program itself.

These differences are detailed in this table:-

           Clauses Traced   Program   Final Results  Intermediate  Error
           @{U}and Displayed @{UU}   @{U}Execution@{UU} @{U}Displayed    @{UU}  @{U} Results    @{UU}  @{U}Checks@{UU}

SCAN              All        None          No             No        Yes
ALL               All        Normal        No             No        No
RESULTS           All        Normal        Yes            No        No
INTERMEDIATES     All        Normal        Yes            Yes       No


@{B}Clauses Traced and Displayed@{UB} means that @{B}All@{UB} the program lines (clauses)
are shown as illustrated by the @{"above example output" LINK "Allops"11}. This is in comparison
to other groups of options that do @{B}not@{UB} display all program lines.

@{B}Program Execution - None@{UB} means that none of the clauses is actually executed
and there is @{B}no output@{UB} at all from the program.

@{B}Program Execution - Normal@{UB} means that all program clauses are operated
and all normal program output is shown in the program's output
window.

@{B}Final Results Displayed@{UB} means that the final results of evaluations are
displayed. For example:-

  8 *-* Count = Count + 1;
      >>> "2"

The final result of the expression is a value of 2 being assigned to "Count".

These final results include the values assigned to variable symbols by
instructions such as ARG, PARSE, PULL and by the = sign.

@{B}Intermediate Results@{UB} means that, as well as the final result, intermediate
results of evaluations are also displayed. For example:-

  8 *-* Count = Count + 1;
      >V> "1"
      >L> "1"
      >O> "2"
      >>> "2"

The intermediate results and the final result are:-

      >V> Value of the Count to the right of = is "1"
      >L> Value of fixed symbol "1" (after the +) is "1"
      >O> The result of the addition is "2"
      >>> The final result assigned to the Count to the left of = is "2"

(@{"Click here" LINK "Output"10} for symbol explanation.)

@{B}Error Checks@{UB} means that each clause is checked for errors that would
normally stop the program execution with an error message. This is only
available with SCAN. Tracing stops when the first error is found and
displayed.

Note that SCAN @{B}cannot@{UB} pick up errors such as:-

- @{"Initial Scan Stage" LINK "ARB:Articles_41-50/46.Error_Tracing-1/Point2"} errors which occurs immediately the program is RX'ed
  and before execution starts (e.g. the "unmatched quotes" error).

- @{B}Misspellings@{UB} in instructions or functions. If they are misspelled ARexx
  will simply assume that they are commands or symbols.

- @{B}Arithmetic conversion errors@{UB} (such as adding a number to a string)
  which SCAN somehow manages to ignore.

However, it @{B}does@{UB} allow the the program to be scanned for some types of
errors without actually operating any of the clauses.

If TRACE('S') is @{B}not@{UB} used then some programs might spend a lot of time
executing error free programming code before coming across an error much
later in the program. The length of time before such an error is found
would be extended quite a bit if other TRACE() options are in force.

Using the SCAN option will dramatically cut down this waste of time.

This is all illustrated in @{"Example47-3" LINK "Scan"} below.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Scan" "Article 47 - Error Tracing & Debugging 2 - Example Of SCAN Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF SCAN TRACING OPTION@{UB}@{UU}
@{JLEFT}
The following (incorrect) program shows how the SCAN option picks up a
situation where an "END" exists without a corresponding "DO" and prevents
a lot of lost time reaching the error.

  /* Example47-3 */

  /* This program contains an intentional error for SCAN to pick up */

  TRACE('S')

  DO Count = 1 to 10000
    SAY 'Count =' count
  END

  END

  SAY 'Count is over at last'

When RX'ed, the program output will @{B}nothing@{UB} except:-

   Command returned 10/26: Missing or unexpected END

but the tracing output will be:-

    7 *-* DO Count = 1 to 10000;
   11 *-* END;
  +++ Error 26 in line 11: Missing or unexpected END

(@{"Click here" LINK "Output"10} for symbol explanation.)

Without the TRACE('S') option, this program could take over 10 minutes,
on an unaccelerated Amiga 500, to run through the DO-END loop before it
found the error and stopped. Putting in the TRACE('S') option will pick
up the error immediately.

This is not the sort of program you would normally have but it does
illustrate that SCAN can pick up errors very quickly that would otherwise
not be picked up until the program had been running for a long time.

If there is more than one error then it will not show the second or
subsequent errors until the first error is corrected as it stops when the
first error is found.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "All" "Article 47 - Error Tracing & Debugging 2 - Example Of ALL Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF ALL TRACING OPTION@{UB}@{UU}
@{JLEFT}
  /* Example47-4 */

  TRACE('A')
  Count = 0

  DO FOR 2
    SAY 'Count =' CountIt(Count) ' - Press CTRL-C to ABORT'
  END
  EXIT

  CountIt:
  Count = Count + 1
  RETURN Count

The program output will be:-

  Count = 1 - Press CTRL-C to ABORT
  Count = 2 - Press CTRL-C to ABORT

The tracing output will be:-

  4 *-* Count = 0;
  6 *-* DO FOR 2;
    8 *-* SAY 'Count =' CountIt(Count) ' - Press CTRL-C to ABORT...
   13 *-* CountIt:
   13 *-* ;
   14 *-* Count = Count + 1;
   15 *-* RETURN Count;
   10 *-* END;
    6 *-* DO FOR 2;
    8 *-* SAY 'Count =' CountIt(Count) ' - Press CTRL-C to ABORT...
   13 *-* CountIt:
   13 *-* ;
   14 *-* Count = Count + 1;
   15 *-* RETURN Count;
   10 *-* END;
    6 *-* DO FOR 2;
  11 *-* EXIT;

(@{"Click here" LINK "Output"10} for symbol explanation.)

As you can see, it merely display the clause that is being executed at
each stage of the program without showing any evaluations of expressions
and symbols, etc. as is done by other options.

It could be useful if you merely want to follow the flow of a program.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Results" "Article 47 - Error Tracing & Debugging 2 - Example Of RESULTS Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF RESULTS TRACING OPTION@{UB}@{UU}
@{JLEFT}
This is the option that I use for most of my tracing.

This program will illustrate its use. It is the same as @{"Example47-6" LINK "Intermediates"} except
that 47-6 uses TRACE('I').

  /* Example47-5 */

  CALL TRACE('R')

  Input = 'Jack Spratt and his wife'
  PARSE VAR Input First Second .
  Count = 1
  Name.Count = First
  Count = Count + 1
  Name.Count = Second
  Count = -Count + 3
  SAY UPPER(Name.Count)

The only output from this program in its output window will be from the
last line which will be:-

  JACK

The tracing output will be:-

      >>> "N"
   5 *-* Input = 'Jack Spratt and his wife';
       >>> "Jack Spratt and his wife"
   6 *-* PARSE VAR Input First Second .;
       >>> "Jack"
       >>> "Spratt"
       >.> " and his wife"
   7 *-* Count = 1;
       >>> "1"
   8 *-* Name.Count = First;
       >>> "Jack"
   9 *-* Count = Count + 1;
       >>> "2"
  10 *-* Name.Count = Second;
       >>> "Spratt"
  11 *-* Count = -Count + 3;
       >>> "1"
  12 *-* SAY UPPER(Name.Count);
       >>> "Jack"
       >>> "JACK"

(@{"Click here" LINK "Output"10} for symbol explanation.)

Note that the very first line of the output is:-

  >>> "N"

without a line being shown before it.

This is because the first program line, which is the call to the TRACE()
function, cannot be displayed because tracing is not yet on! However,
the result of the call, i.e.:-

  >>> "N"

@{B}can@{UB} be shown because, by the time the function sends its result back to
the program, tracing @{B}has been@{UB} turned on.

The returned value "N" is the previous TRACE mode, i.e. the default mode
of "NORMAL". (You will recall that I said above that a call on the TRACE()
function returns the previous mode value.)

This output is simply a display of each program line (after the first
line but excluding blank lines and comments) and the results of all values
such as those assigned to variables.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Intermediates" "Article 47 - Error Tracing & Debugging 2 - Example Of INTERMEDIATES Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF INTERMEDIATES TRACING OPTION@{UB}@{UU}
@{JLEFT}
Example47-6 illustrates this option. Apart from using the INTERMEDIATES
option, i.e. TRACE('I'), it is the same as @{"Example47-5" LINK "Results"} so I won't repeat
it here. However, it is on the disk in full so that you can try it out.
@{"Click here" LINK "ARB:Articles_41-50/Example47-6.rexx/MAIN"} if you want to look at it.

Please refer to the table under the heading "Discussion of TRACE() and
TRACE Options" for the explanations of the emblems used in the GTC display.

Again, the only output from this program in its output window will be from
Line 12 which will be:-

  JACK

However, the output in the Global Tracing Console window will be as shown
below. I have split up this output so that I can insert my own comments
between the output for each line. Note that the first part of the output
for a line is the line itself preceded by the Line number then the "*-*"
emblem.

(@{"Click here" LINK "Output"10} for symbol explanation.)

In the following, the tracing output is in @{B}bold@{UB} and explanations
in plain text.

@{B}>F> "N"@{UB}

>F> indicates the value returned by the function TRACE() (See discussion
    of @{"Example 47-5" LINK "Results"} for an explanation of this and why no line display
    appears first.)

@{B}5 *-* Input = 'Jack Spratt and his wife';
    >L> "Jack Spratt and his wife"
    >>> "Jack Spratt and his wife"@{UB}

>L> indicates the value of the string after the "=".

>>> indicates the result of an assignment to the variable symbol "Input".

@{B}6 *-* PARSE VAR Input First Second .;
    >V> "Jack Spratt and his wife"
    >>> "Jack"
    >>> "Spratt"
    >.> " and his wife"@{UB}

>V> indicates the value of the variable symbol "Input".

>>> indicates the results of the template allocations.

>.> indicates the value of the @{"place holder" LINK "ARB:Articles_31-40/35.Parse-Templates/PlaceHolder"} "." (You will recall that,
    when a place holder "." is put into a template such as this, all the
    rest of the string or symbol value is assigned to the place holder.)

@{B}7 *-* Count = 1;
    >L> "1"
    >>> "1"@{UB}

>L> indicates the value of the fixed symbol "1".

>>> indicates the result of assigning a value to the symbol "Count".

@{B}8 *-* Name.Count = First;
    >V> "Jack"
    >>> "Jack"
    >C> "NAME.1"@{UB}

>V> indicates the value of the symbol "First".

>>> indicates the result of the assignment to "Name.1"

>C> indicates the result of expanding the "Name.Count" compound symbol
    to "Name.1" by substituting the value of "Count"

@{B}9 *-* Count = Count + 1;
    >V> "1"
    >L> "1"
    >O> "2"
    >>> "2"@{UB}

>V> indicates the value of the symbol "Count" (i.e. the "Count" to the
    right of the = sign).

>L> indicates the value of of the fixed symbol "1".

>O> indicates the result of the evaluation of dyadic expression "Count + 1"

>>> indicates the result of the evaluation which is the value assigned
    to the "Count" which is to the left of the = sign.

@{B}10 *-* Name.Count = Second;
     >V> "Spratt"
     >>> "Spratt"
     >C> "NAME.2"@{UB}

Comments here are the same as for Line 8

@{B}11 *-* Count = -Count + 3;
     >V> "2"
     >L> "3"
     >P> "-2"
     >O> "1"
     >>> "1"@{UB}

>V> indicates the value of the "Count" in the "-Count".

>L> is the value of the fixed symbol "3".

>P> is the result of the prefix operation which is the "-" in the "-Count"

>O> is the result of the dyadic operation "-Count + 3".

>>> is the value assigned to the "Count" to the left of the = sign.

@{B}12 *-* SAY UPPER(Name.Count);
     >C> "NAME.1"
     >V> "Jack"
     >F> "JACK"@{UB}

>C> indicates the result of the expansion of the compound name "Name.Count"
    into "Name.1" by the insertion of the value of the symbol "Count".

>V> indicates the value of the symbol "Name.1"

>F> indicates the result of the call to the function "UPPER()".


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Command" "Article 47 - Error Tracing & Debugging 2 - Options Tracing COMMAND  Clauses"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - OPTIONS TRACING COMMAND CLAUSES@{UB}@{UU}
@{JLEFT}
Options that trace @{B}only COMMAND clauses@{UB}, and the example programs that
demonstrate them, are:-

  COMMANDS       @{" Example47-7 " LINK "Commands"}
  ERRORS         @{" Example47-8 " LINK "Errors"}
  NORMAL         @{" Example47-9 " LINK "Normal"}

An explanation of how these example programs work can be read by
@{"clicking here" LINK "CommandExamples"}.

Program execution and program output occurs normally for all these options.

@{B}Command clauses@{UB} are those ones that send a command to an external host.

These options are shown below with their features:-

          @{U} Clauses Displayed   @{UU} @{U}Before/After@{UU}    @{U}    Errors Shown       @{UU}

COMMANDS  All Commands            Before        Non zero return codes

ERRORS    Commands generating     After         Non zero return codes
          non zero return codes

NORMAL    Commands generating     After         Return codes higher than
          return codes higher                   "Fail At" level
          than "Fail At" level

@{B}Clauses Displayed@{UB} indicates which of the Command Clauses are displayed.
Clauses other than Command Clauses are @{B}never@{UB} displayed with any of these
options.

@{B}Intermediate and final@{UB} results (as described under @{"All Clauses" LINK "Allops"65}) are @{B}not@{UB}
shown.

@{B}Return Codes@{UB} means the code numbers resulting from the operation of the
command within the external host. The standard codes, as used in AmigaDOS
commands, are:-

   0 - All O.K. - no problems

   5 - @{B}Warn@{UB} indicates some minor level of fault that can usually be
       safely ignored, or an indication that one of two possible conditions
       exists, the other condition returning zero.

  10 - @{B}Error@{UB} indicates that something did not happen that really should
       have happened and probably should be looked at.

  20 - @{B}Failure@{UB} indicates a more serious level of failure that really
       should not be ignored.

@{B}Before/After@{UB} indicates whether the command clause is displayed @{B}before@{UB}
the command is sent to the external host or @{B}after@{UB} the command has been
sent and a return code received.

"Before" indicates that all command clauses are displayed irrespective
of the return code value (as in the "COMMANDS" option).

"After" indicates that the command clause is only displayed if a non zero
return code is received after the command is executed. Naturally, this
cannot be determined until after the command has executed and returned
a value to ARexx!

@{B}Errors Shown@{UB} indicates whether all non zero return codes are displayed
or whether only on those exceeding the current "Fail At" level are
displayed.

AmigaDOS allows for a "Fail At" level which indicates the return code
value that will cause an AmigaDOS script to abort. The default "FailAt"
level is 10 which means that, if a command in the script gives a return
code @{B}less@{UB} than 10, the script will continue on to the next command; but
if it gives a return code of 10 or more the script will abort before the
next command.

The AmigaDOS command "FAILAT" allows the "Fail At" level to be changed
for any command script at any point within the script.

The ARexx instruction @{"OPTIONS" LINK "ARB:Articles_21-30/25.Options/Failat"} can change the FAILAT return code number
above which the ARexx program will abort and below which it will keep
going.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "CommandExamples" "Article 47 - Error Tracing & Debugging 2 - Examples Of Command Clause Tracing"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLES OF COMMAND CLAUSE TRACING@{UB}@{UU}
@{JLEFT}
The four examples of command clause tracing are all basically the same
as this:-

  /* Example47- .rexx */

 1. CALL TRACE(' ')

 2. ADDRESS 'COMMAND'

 3. SAY 'Copying 1 real file'
 4. 'COPY S:Startup-Sequence Ram:'
 5. 'List Ram:Startup-Sequence'

 6. SAY 'Copying 1 non existing file'
 7. 'COPY Ram:NonExistentCommand Ram:Nothing'

 8. 'Ram:NonExistentCommand'

 9. SAY 'Checking assignment of NonExistentAssignment:'
10. 'Assign NonExistentAssignment: Exists'

11. 'Delete Ram:Startup-Sequence'

The only exception is Example47-10 which has this extra line right at
the start:-

    OPTIONS FAILAT 21

Note that I have numbered @{B}blank lines@{UB} which I have not normally done with
previous examples. This is because the tracing output @{B}includes line numbers@{UB}
(even though the actual numbers are not part of the program) and it includes
@{B}blank lines@{UB}. The line numbers in the tracing output should line up with
the above numbers provided that you @{B}do not@{UB} delete blank lines from the
examples!

Provided that the @{"Global Tracing Window" LINK "GTC"} is open, the output in the Shell/CLI
window from which the examples are RXd should be:-

  Copying 1 real file
  Directory "Ram:" on Tuesday 22-Oct-96
  Startup-Sequence            3067 ----rw-d Today     13:47:56
  1 file - 4 blocks used
  Copying 1 non existing file
  Can't open NonExistentCommand for input - object not found
  COPY failed returncode 20
  Ram:NonExistentCommand: Unknown command
  Ram:NonExistentCommand failed returncode 10
  Checking assignment of NonExistentAssignment:
  NonExistentAssignment: not assigned
  Ram:Startup-Sequence  Deleted

However, it is not this output that we are interested in here. It is the
tracing output that should appear in to GTC window. This will differ from
one program to another and is discussed under the headings:-

  @{" Example  of COMMANDS Tracing Option " LINK "Commands"}
  @{" Example  of ERRORS   Tracing Option " LINK "Errors"}
  @{" Examples of NORMAL   Tracing Option " LINK "Normal"}

@{B}@{U}Line By Line Description Of Examples@{UB}@{UU}

@{B}Line 1@{UB} calls the trace function:-

  CALL TRACE("x")

with "x" being one of:-

  "C" for COMMANDS in Example47-7
  "E" for ERRORS   in Example47-8
  "N" for NORMAL   in Example47-9 & Example47-10

@{B}Line 2@{UB} makes AmigaDOS the host address:-

  ADDRESS 'COMMAND'

@{B}Lines 4, 5, 7, 8, 10 and 11@{UB} all send commands to the host AmigaDOS. Return
codes of 0, 5, 10 and 20 will be received.

@{B}Line 4@{UB}:-

  'COPY S:Startup-Sequence Ram:'

should operate without error as every Amiga should have a startup-sequence
file in "S:" and should have an active "Ram:" disk. The command should
therefore send a @{B}return code of 0@{UB} (zero) to indicate success.

@{B}Line 5@{UB}:-

  'List Ram:Startup-Sequence'

is there simply to show the previous command was successful. A @{B}return
code of 0@{UB} (zero) to indicate success should be received.

@{B}Line 7@{UB}:-

  'COPY Ram:NonExistentCommand Ram:Nothing'

As (hopefully) there is no file in Ram: called "NonExistentCommand" this
command will fail with a @{B}return code of 20@{UB}.

@{B}Line 8@{UB}:-

  'Ram:NonExistentCommand'

tries to run the non existing command. As it is not there, a @{B}return code
of @{UB}10 is received.

@{B}Line 10@{B}0@{UB}:-

  'Assign NonExistentAssignment: Exists'

tries to check if a non existing assignment has previously been made.
As it has not, a @{B}return code of 5@{UB} is returned.

@{B}Line 11@{UB}:-

  'Delete Ram:Startup-Sequence'

simply does our housekeeping by removing the file that we earlier copied
to Ram:. As it is there, the deletion should be successful and a @{B}zero
return code@{UB} would be received.

So, we have commands that return codes of 0, 5, 10 and 20.

The various examples will display tracing output of all, some or none
of these codes.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Commands" "Article 47 - Error Tracing & Debugging 2 - Example Of COMMANDS Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF COMMANDS TRACING OPTION@{UB}@{UU}
@{JLEFT}
Example47-7 demonstrates tracing command clauses using the @{B}COMMANDS@{UB} option.

@{"Click here" LINK "ARB:Articles_41-50/Example47-7.rexx/MAIN"} to read it.

@{"Click here" LINK "CommandExamples"} for a discussion of the program which includes:-
@{JCENTER}
@{" Program Output " LINK "CommandExamples"38}   and   @{" Line by line comments " LINK "CommandExamples"62}
@{JLEFT}
The @{B}tracing output@{UB} is as follows:-

    8 *-* 'COPY S:Startup-Sequence Ram:';
        >>> "COPY S:Startup-Sequence Ram:"
    9 *-* 'List Ram:Startup-Sequence';
        >>> "List Ram:Startup-Sequence"
   12 *-* 'COPY Ram:NonExistentCommand Ram:Nothing';
        >>> "COPY Ram:NonExistentCommand Ram:Nothing"
  +++ Command returned 20
   14 *-* 'Ram:NonExistentCommand';
        >>> "Ram:NonExistentCommand"
  +++ Command returned 10
   17 *-* 'Assign NonExistentAssignment: Exists';
        >>> "Assign NonExistentAssignment: Exists"
  +++ Command returned 5
   19 *-* 'Delete Ram:Startup-Sequence';
        >>> "Delete Ram:Startup-Sequence"

(@{"Click here" LINK "Output"10} for symbol explanation.)

As we are @{B}tracing command clauses@{UB}, only those clauses which send commands
to an external hosts are traced.

As the option @{"COMMANDS" LINK "Command"15} was used, @{B}all@{UB} such clauses are displayed even if
a zero return code results. This is because the tracing is carried out
@{B}before@{UB} the clause is sent to the host.

Note that @{B}all@{UB} non zero return codes @{B}are@{UB} shown after the "+++" emblem but
that zero return codes are @{B}not@{UB} shown.

Compare this with @{"ERRORS" LINK "Errors"} and @{"NORMAL" LINK "Normal"} where clauses showing zero return
codes are @{B}not@{UB} shown.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Errors" "Article 47 - Error Tracing & Debugging 2 - Example Of ERRORS Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF ERRORS TRACING OPTION@{UB}@{UU}
@{JLEFT}

Example47-8 demonstrates tracing command clauses using the ERRORS option.

@{"Click here" LINK "ARB:Articles_41-50/Example47-8.rexx/MAIN"} to read it.

@{"Click here" LINK "CommandExamples"} for a discussion of the program which includes:-
@{JCENTER}
@{" Program Output " LINK "CommandExamples"38}   and   @{" Line by line comments " LINK "CommandExamples"62}
@{JLEFT}
The @{B}tracing output@{UB} is as follows:-

   12 *-* 'COPY Ram:NonExistentCommand Ram:Nothing';
  +++ Command returned 20
   14 *-* 'Ram:NonExistentCommand';
  +++ Command returned 10
   17 *-* 'Assign NonExistentAssignment: Exists';
  +++ Command returned 5

(@{"Click here" LINK "Output"10} for symbol explanation.)

As we are @{B}tracing command clauses@{UB}, only those clauses which send commands
to an external hosts are traced.

As the option @{"ERRORS" LINK "Command"15} was used, only those command clauses that return
@{B}non zero codes@{UB} will be displayed. The symbol "+++" indicates the return
code values.

Compare this with @{"COMMANDS" LINK "Commands"} which displays @{B}all command clauses@{UB} and @{"NORMAL" LINK "Normal"}
where clauses showing return codes @{B}greater than the failat level@{UB} are
shown.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Normal" "Article 47 - Error Tracing & Debugging 2 - Example Of NORMAL Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF NORMAL TRACING OPTION@{UB}@{UU}
@{JLEFT}

Example47-9 and Example47-10 demonstrate tracing command clauses using
the NORMAL option.

@{"Click here" LINK "ARB:Articles_41-50/Example47-9.rexx/MAIN"} to read Example47-9

@{"Click here" LINK "ARB:Articles_41-50/Example47-10.rexx/MAIN"} to read Example47-10 - This is the same as Example47-7 except
                                   for the extra OPTIONS line at the start.

@{"Click here" LINK "CommandExamples"} for a discussion of the program which includes:-
@{JCENTER}
@{" Program Output " LINK "CommandExamples"38}   and   @{" Line by line comments " LINK "CommandExamples"62}
@{JLEFT}
The @{B}tracing output@{UB} from @{B}Example47-9@{UB} is as follows:-

   12 *-* 'COPY Ram:NonExistentCommand Ram:Nothing';
  +++ Command returned 20
   14 *-* 'Ram:NonExistentCommand';
  +++ Command returned 10

The @{B}tracing output@{UB} from @{B}Example47-10@{UB} is as follows:-

  @{B}(Absolutely nothing!)@{UB}

As we are @{B}tracing command clauses@{UB}, only those clauses which send commands
to an external hosts are traced.

As the option @{"NORMAL" LINK "Command"15} was used, only those command clauses that return
code @{B}greater than the failat level@{UB} are shown. The symbol "+++" indicates
the return code values.

@{B}Example47-9@{UB} does not set a failat level and so the default level of 10
is used. Therefore, command clauses returning codes of 10 or more are
the only ones showing. Codes of 0 and 5 are @{B}not shown@{UB}.

@{B}Example47-10@{UB} sets a failat level of 21. As all return codes from the program
are 20 or less, then there is @{B}no tracing output!@{UB}

Compare this with @{"COMMANDS" LINK "Commands"} which displays @{B}all command clauses@{UB} and @{"ERRORS" LINK "Errors"}
where clauses showing @{B}all non zero return codes@{UB} are shown.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Label" "Article 47 - Error Tracing & Debugging 2 - Options Tracing LABEL Clauses"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - OPTIONS TRACING LABEL CLAUSES@{UB}@{UU}
@{JLEFT}
There is only one keyword option that traces @{B}Label Clauses@{UB}. It is the
LABEL Option.

Program execution and output is normal.

It displays only the name of each label as program execution reaches that
label.

No results of evaluations are shown.

This program illustrates its use:-

  /* Example47-11 */

  CALL TRACE('L')

  Start:
  SAY 'This is the start of the program'

  CALL Middle
  SAY Result

  End:
  SAY 'This is the end of the program'

  EXIT

  Middle:
  RETURN 'This is the middle of the program'

The program output will be:-

  This is the start of the program
  This is the middle of the program
  This is the end of the program

The tracing output will be:-

   5 *-* Start:
    16 *-* Middle:
  11 *-* End:

(@{"Click here" LINK "Output"10} for symbol explanation.)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Not" "Article 47 - Error Tracing & Debugging 2 - Options That Do NOT  Trace"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - TRACING OPTIONS THAT DO NOT TRACE!@{UB}@{UU}
@{JLEFT}
Trace options that do @{B}not@{UB} trace?!?!

There are two options in this group that turn off the tracing operations.
Their names and their example programs are:-

  @{" OFF        " LINK "Off"}    @{" Example47-12 " LINK "Off"}
  @{" BACKGROUND " LINK "Background"}    @{" Example48-4  " LINK "ARB:Articles_41-50/48.Error_Tracing-3/TS"52}

If @{B}some other@{UB} tracing option was in effect before they are used, @{B}both@{UB}
will @{B}turn off@{UB} all tracing.

The difference in the two is how they react if @{"interactive tracing" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"} is
turned on @{B}after@{UB} a program has been RX'd with the use of OFF or BACKGROUND.

- if @{B}OFF@{UB} was previously used, interacting tracing @{B}will@{UB} become active

- if @{B}BACKGROUND@{UB} was previously used the program cannot be forced into
  @{"interactive tracing" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"} mode by the @{"TS command utility" LINK "ARB:Articles_41-50/48.Error_Tracing-3/TS"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Background" "Article 47 - Error Tracing & Debugging 2 - Example Of BACKGROUND Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF BACKGROUND TRACING OPTION@{UB}@{UU}
@{JLEFT}
The @{B}BACKGROUND@{UB} option:-

  TRACE('B')

will @{B}not do any tracing at all@{UB}. Its main function is to ensure that the
program will not go into @{"interactive tracing" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"} mode if the command utility
"TS" is used (see next article).

An example (@{"Example48-4" LINK "ARB:Articles_41-50/48.Error_Tracing-3/TS"52}) is included with the discussion of
@{"Interactive mode" LINK "ARB:Articles_41-50/48.Error_Tracing-3/Interactive"}.

It is useful if you wish to use the TS utility for other ARexx programs
that are running but to prevent one particular program from becoming
interactive.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Off" "Article 47 - Error Tracing & Debugging 2 - Example Of OFF Tracing Options"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - EXAMPLE OF OFF TRACING OPTION@{UB}@{UU}
@{JLEFT}
The @{B}OFF@{UB} option:-

  TRACE('O')

will turn off any previously set tracing option.

Example 47-12 sets the TRACE() mode to "Results" for part of the program,
sets it to "Off" for another part, then sets it to "Intermediates" for
the final part.

 1.  /* Example47-12 */
 2.
 3. CALL TRACE('R')
 4.
 5. Count = 1
 6. SAY 'Trace option is "R" - Count =' Count
 7.
 8. CALL TRACE('O')
 9.
10. Count = Count + 1
11. SAY 'Trace option is "O" - Count =' Count
12.
13. CALL TRACE('I')
14.
15. Count = Count + 1
16. SAY 'Trace option is "I" - Count =' Count

The program output, from @{B}Lines 6, 11 and 16@{UB} will be:-

  Trace option is "R" - Count = 1
  Trace option is "O" - Count = 2
  Trace option is "I" - Count = 3

The tracing output will be:-

      >>> "N"
  5 *-* Count = 1;
      >>> "1"
  6 *-* SAY 'Trace option is "R" - Count =' Count;
      >>> "Trace option is "R" - Count = 1"
  8 *-* CALL TRACE('O');
      >>> "O"
      >F> "O"
 15 *-* Count = Count + 1;
      >V> "2"
      >L> "1"
      >O> "3"
      >>> "3"
 16 *-* SAY 'Trace option is "I" - Count =' Count;
      >L> "Trace option is "I" - Count ="
      >V> "3"
      >O> "Trace option is "I" - Count = 3"
      >>> "Trace option is "I" - Count = 3"
 18 *-* ;

(@{"Click here" LINK "Output"10} for symbol explanation.)

Note that there is @{B}no output@{UB} from @{B}Lines 10-13@{UB} which is after tracing has
been turned off in @{B}Line 8@{UB} and before it is turned on again in @{B}Line 13@{UB}.

This demonstrates that you can trace different sections with different
mode options and some sections with trace off altogether.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Which" "Article 47 - Error Tracing & Debugging 2 - Which Option To Use?"

@{B}@{U}@{JCENTER}ERROR TRACING & DEBUGGING 2 - WHICH OPTION TO USE?@{UB}@{UU}
@{JLEFT}
This will depend a lot on the type of program you are using but what you
can do is to put these lines at the start of each program that you
write:-

  SAY 'Enter TRACE() mode to be used'
  PULL Mode
  CALL TRACE(Mode)

The first time you run the program you could enter "S" for @{"SCAN" LINK "AllOps"45} to check
for errors. After they are fixed up, then enter any mode you feel appropriate,
or "O" for @{"OFF" LINK "Off"} is you wish to run it without any mode operating.

After you are completely satisfied that all is O.K. with your program
you can remove these lines.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
