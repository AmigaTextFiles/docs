@DATABASE "ARB32"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 32 - The INTERPRET Instruction"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 32 - THE INTERPRET INSTRUCTION

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" Usage Of INTERPRET           " LINK "Usage"}
@{" The EXPRESSION For INTERPRET " LINK "Expression"}
@{" Tips For Using INTERPRET     " LINK "Tips"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Usage" "Article 32 - The INTERPRET Instruction - Usage"

@{B}@{U}@{JCENTER}THE INTERPRET INSTRUCTION - USAGE@{UB}@{UU}
@{JLEFT}
The format for INTERPRET is:-

  INTERPRET Expression

The @{"Expression" LINK "Expression"} can contain many types of things as will become clear as
we go along.

What INTERPRET does is to consider the "Expression" as a block of ARexx
program coding and treats it just as though it was preceded by DO and
followed by END. Therefore, it could be said that:-

  INTERPRET Expression

could be considered as being similar to:-

  DO
    Expression
  END

Maybe it will become a bit clearer if we look at it in action. First,
though, let's have another look at Example10-1 which display the 5 times
table in a simple loop:-

  /* Example10-1 */

  SAY 'The 5 times table'

  DO x = 1 to 10
    SAY 'Five times' x '=' x * 5
  END

We could rewrite this program as:-

  /* Example32-1.rexx */

  TimesTable = "SAY 'The 5 times table' ; DO x = 1 to 10 ;
                SAY 'Five times' x '=' x * 5 ; END"

  INTERPRET TimesTable

(@{B}Note@{UB} - the part that comes after "Times Table =" is all one program line
even though it takes up two physical lines in this window.)

This will give the following output:-

  The 5 times table
  Five times 1 = 5
  Five times 2 = 10
  Five times 3 = 15
  Five times 4 = 20
  Five times 5 = 25
  Five times 6 = 30
  Five times 7 = 35
  Five times 8 = 40
  Five times 9 = 45
  Five times 10 = 50

The Symbol "TimesTable" has been given a value that is equal to:-

   SAY 'The 5 times table' ; DO x = 1 to 10 ;
   SAY 'Five times' x '=' x * 5 ; END

(@{B}Note@{UB} - this is all @{B}one@{UB} program line.)

What has happened is that ARexx has taken the line:-

  INTERPRET timesTable

And changed it into the value of "timesTable" so that the program
becomes:-

  SAY 'The 5 times table'
  DO x = 1 to 10
    SAY 'Five times' x '=' x * 5
  END


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Tips" "Article 32 - The INTERPRET Instruction - Tips"

@{B}@{U}@{JCENTER}THE INTERPRET INSTRUCTION - TIPS@{UB}@{UU}
@{JLEFT}
Because each of the 4 instruction clauses from @{"Example10-1" LINK "Usage"26} have been put
into the one program line in @{"Example32-1" LINK "Usage"36}, they @{B}must@{UB} be separated by
semicolons.

The other thing you @{B}must take very careful note of@{UB} is that the whole
assigned value of @{"TimesTable" LINK "Usage"36} is included in double quotes (we cannot include
it in single quotes as the SAY strings are included in single quotes.

If we forgot to include the whole value in quotes and used:-

  /* Example32-2.rexx */

  TimesTable = SAY 'The 5 times table' ; DO x = 1 to 10 ;
               SAY 'Five times' x '=' x * 5 ; END

  INTERPRET TimesTable

Our display will give:-

Five times 1 = 5
Five times 2 = 10
Five times 3 = 15
Five times 4 = 20
Five times 5 = 25
Five times 6 = 30
Five times 7 = 35
Five times 8 = 40
Five times 9 = 45
Five times 10 = 50
THE 5 TIMES TABLE

Why???? - Well, the semicolon, when @{B}not@{UB} included in quotes, is a command
separator. The program really becomes the equivalent of:-

  TimesTable = SAY 'The 5 times table'
  DO x = 1 to 10
    SAY 'Five times' x '=' x * 5
  END

  INTERPRET TimesTable

So the symbol "TimesTable" holds only the value:-

  SAY 'The 5 times table'

and the rest of the program is operated as normal coding. The SAY command
is not executed until the INTERPRET at the end of the program.

Note that the string "The 5 times table" @{B}has been converted to upper case
even though it is in quotes@{UB} when the program is run!!

This happens in these sort of cases:-

  Instruction = 'SAY'
  INTERPRET Instruction 'This is a string'
  --> THIS IS A STRING

  Instruction = 'SAY'
  Text = 'This is a string'
  INTERPRET Instruction Text
  --> THIS IS A STRING

So @{B}why@{UB} is it converted to upper case even though it is in quotes??

In both cases, the INTERPRET instruction has joined two strings together
and, in doing so, has removed the quotes from around them. In both cases,
the INTERPRET line has become:-

  SAY This is a string

and, as we already know, when we SAY something @{B}not@{UB} in quotes, the words
are taken as symbol names and converted to upper case. As the symbols
have not been assigned a value, they are taken to have a value equal to
their name.

This can be demonstrated with this program:-

  /* Example32-3 */

  This = 'First'
  Is = 'Second'
  a = 'Third'
  string = 'Fourth'

  Instruction = 'SAY'
  Text = 'This is a string'
  INTERPRET Instruction Text

  Text = '"This is a string"'
  INTERPRET Instruction Text

The @{B}first@{UB} INTERPRET has been put into the program as:-

  SAY This is a string

but we have already given values to the four symbols "This", "is", "a"
and "string" so the output is:-

  First Second Third Fourth

The solution is to put the string into quotation marks @{B}within@{UB} the other
quotation marks (the quotes @{B}must@{UB} be of the different kind). This is
demonstrated in the final two lines of Example32-3 which will now output:-

  This is a string


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Expression" "Article 32 - The INTERPRET Instruction - The Expression"

@{B}@{U}@{JCENTER}THE INTERPRET INSTRUCTION - THE EXPRESSION@{UB}@{UU}

@{B}@{U}What Can go Into The "Expression" after "INTERPRET"?@{UB}@{UU}
@{JLEFT}
Virtually anything that can go into a normal ARexx program can go into
the "Expression". We have already seen that we can have @{"DO...END" LINK "Usage"36} loops.
We can also have many other types of programming although to do so causes
the whole thing to get rather complex.

@{B}One point to remember,@{UB} though, is that ARexx considers everything in the
value of "Expression" to be contained within a non-iterating DO...END.
As with any non-iterating DO...END we can use BREAK to get out of the
DO...END. This is illustrated by:-

  /* Example32-4 */

  MyExpression = "x = 1 ; SAY 'x =' x ; IF X = 1 THEN BREAK ;
                  SAY 'Will I reach this SAY instruction?'"

  INTERPRET MyExpression

When RX'ed, this program will display:-

  x = 1

The INTERPRET has done the equivalent of:-

  DO
    x = 1
    SAY 'x =' x
    IF X = 1 THEN BREAK
    SAY 'Will I reach this SAY instruction?'
  END

and, as a BREAK will cause a non-iterative loop to stop, the second SAY
command will never be reached!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
