@DATABASE "ARB34"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 34 - More String Functions"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 34 - MORE STRING FUNCTIONS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © F. P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}
@{JLEFT}

There are quite a few built in functions that can be used with strings that
we have not covered yet. Most of these are not used very often. A lot, if
not all, of these you might find a bit obscure. I doubt if you would use
them very often, if ever. If you like, give this article a miss. If you
later find that you need one of them then you can select it by name from
the index "Part 2 - Instructions/Functions".
@{JCENTER}

@{" The ABBREV()     Function " LINK "Abbrev()"}
@{" The COMPARE()    Function " LINK "Compare()"}
@{" The FIND()       Function " LINK "Find()"}
@{" The HASH()       Function " LINK "Hash()"}
@{" The INDEX()      Function " LINK "Index()"}
@{" The LASTPOS()    Function " LINK "Lastpos()"}
@{" The POS()        Function " LINK "Pos()"}
@{" The REVERSE()    Function " LINK "Reverse()"}
@{" The TRANSLATE()  Function " LINK "Translate()"}
@{" The VALUE()      Function " LINK "Value()"}
@{" The VERIFY()     Function " LINK "Verify()"}
@{" The WORD()       Function " LINK "Word()"}
@{" The WORDINDEX()  Function " LINK "Wordindex()"}
@{" The WORDLENGTH() Function " LINK "WordLength()"}
@{" The WORDS()      Function " LINK "Words()"}
@{" The XRANGE()     Function " LINK "Xrange()"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Abbrev()" "Article 34 - More String Functions - ABBREV()"

@{B}@{U}@{JCENTER}THE ABBREV() FUNCTION@{UB}@{UU}
@{JLEFT}
The format for this one is:-

  ABBREV(1stString,2ndString[,length])

It returns a @{"Boolean" LINK "ARB:Misc/Glossary/Boolean"} value of:-

  @{B}1 (= true)@{UB} if @{B}both@{UB} the following conditions are true:-

   - "2ndString" is an abbreviation of "1stString"
   - "2ndString" is of length equal to or greater than "Length"

  @{B}0 (= false)@{UB} if @{B}either or both@{UB} of the above two conditions are false.

The "Length" is optional and, if not used, a default length of 0 (zero)
is used.

The comparisons are @{B}case sensitive.@{UB}

Let's have a look at a few examples.

The following two are @{B}true@{UB} because "2ndString", in both lines, is an
abbreviation of "1stString" @{B}and@{UB} is equal to or longer than "Length":-

  SAY ABBREV('abcdef','abc',3)     --> 1
  SAY ABBREV('abcdef','abcde',3)   --> 1

The following is @{B}false@{UB} because, although "2ndString" @{B}is@{UB} an abbreviation
of "1stString", it is @{B}shorter@{UB} than "Length":-

  SAY ABBREV('abcdef','ab',3)      --> 0

The following is @{B}false@{UB} because "2ndString" is @{B}not@{UB} an abbreviation of
"1stString", even though the "Length" test is OK:-

  SAY ABBREV('abcdef','abcx',3)    --> 0

The following is @{B}false@{UB} because the case of the two strings does not
match:-

  SAY ABBREV('Abcdef','abc',3)     --> 0

The following is @{B}false@{UB} because "2ndString" is @{B}longer@{UB} than
"1stString":-

  SAY ABBREV('abc','abcdef',3)     --> 0

In this case a @{B}false@{UB} return would be given for @{B}any@{UB} "Length".

The following is @{B}true@{UB} because, although "2ndString" is a @{B}null@{UB} and has
no characters, the "Length" is zero. This is saying "No characters in
the strings are to be compared":-

  SAY ABBREV('abcdef','',0)        --> 1

As zero (0) is the default length, the above line is the same as:-

  SAY ABBREV('abcdef','')          --> 1


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Compare()" "Article 34 - More String Functions - COMPARE()"

@{B}@{U}@{JCENTER}THE COMPARE() FUNCTION@{UB}@{UU}
@{JLEFT}
This one compares two strings and tells you the character number of the
first difference in them. Its format is:-

  COMPARE(1stString,2ndString[,pad])

If the strings are of different length then the shorter string is padded
out to the same length as the longer string with the "Pad" character.
If "Pad" is omitted then the shorter strings is padded with "space"
characters.

The comparisons are @{B}case sensitive.@{UB}

  SAY COMPARE('abcd','abcd')
  --> 0
  No differences so 0 returned.

  SAY COMPARE('abcd','azcd')
  --> 2
  First difference at 2nd character

  SAY COMPARE('abcdef','abcd')
  --> 5
  The shorter string is padded to a length of 6 with spaces
  so the first difference is at the 5th character.

  SAY COMPARE('abcd!@#$','abcd','!')
  --> 6
  The 2nd string is padded with "!" to "abcd!!!!"
  so the first difference is at the 6th character.

  SAY COMPARE('Abcd!@#$','abcd','!')
  --> 1
  This is the same as the previous example except for
  the case of the 1st letter.
  It therefore returns 1 as the first difference.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Find()" "Article 34 - More String Functions - FIND()"

@{B}@{U}@{JCENTER}THE FIND() FUNCTION@{UB}@{UU}
@{JLEFT}
This finds a "Phrase" consisting of one or more words in a "string" and
gives us the number of the @{B}word@{UB} at which the match occurs. Its format is:-

  FIND(String,Phrase)

The matching is @{B}case sensitive.@{UB}

Examples are:-

  SAY FIND('The Amiga is the best computer','the')
  --> 4
  This returns 4 as the 4th word in the "String" is the
  match of "Phrase".
  The 1st word is not a match because the case is different.

  SAY FIND('The Amiga is the best computer','Amiga is the')
  --> 2
  This returns 2 because the 2nd word of "String" is the start
  of the matching "Phrase".

  SAY FIND('The Amiga is the best computer','Amiga is not the')
  --> 0
  This returns 0 as the "Phrase" was not found at all.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Hash()" "Article 34 - More String Functions - HASH()"

@{B}@{U}@{JCENTER}THE HASH() FUNCTION@{UB}@{UU}
@{JLEFT}
The format for this one is:-

  HASH(String)

It returns the "hash attribute" of the string. So what the %$#*!% is a
hash attribute?? It can be used for various obscure purposes such as check
sums and is a number between decimal 0 and 255, or hexadecimal 00 and FF.

HASH() calculates the hash number as follows:-

  1. Add together the ASCII codes for all the characters in the string.

  2. The sum obtained by Step 1 is then divided by decimal 256 or
     hexadecimal 100

  3. The @{B}remainder@{UB} of the division is the "hash attribute" number.

Sounds rather complex, doesn't it! By dividing by 256 (hex 100) the
remainder of the division will be somewhere between decimal 0 and 255
(hexadecimal 0 and FF).

An example of its use is:-

  SAY HASH('abc')              --> 38

The string "abc" has ASCII codes 97, 98 and 99 so applying the above formula
we get:-

   SAY (97 + 98 + 99) % 256    --> 1

   SAY (97 + 98 + 99) // 256   --> 38

So the two divisions (using @{"% and //" LINK "ARB:Articles_01-10/09.Arithmetic_Operators/Other"}) give 1 remainder 38 and the hash
attribute is 38.

@{B}Note@{UB} that HASH() is @{B}case sensitive@{UB}. Thus, by changing the case of the
above example, we get a different hash number:-

  SAY HASH('ABC')
  --> 198


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Index()" "Article 34 - More String Functions - INDEX()"

@{B}@{U}@{JCENTER}THE INDEX() FUNCTION@{UB}@{UU}
@{JLEFT}
INDEX() finds an occurrence of a pattern of characters within a string
of characters. Its format is:-

  INDEX(String,Pattern[,Start])

The matching process is @{B}case sensitive.@{UB}

See also:-

  @{"POS()" LINK "Pos()"} which is the same as INDEX() except that "String" and "Pattern"
  are reversed in the format.
  @{"LASTPOS()" LINK "Lastpos()"} which searches from the @{B}end@{UB} of the string.

The "Start" is optional and, if left out, the search of the string for
the pattern will start at the first character. If "Start" is included,
then the search will start at the character represented by the numeric
value of "Start". For example:-

  SAY INDEX('abczzzdefzzghi','zz')     --> 4

The first "zz" is at the 4th character.

Now let's go 1 past the 4th character to find the next occurrence of "zz"
by using a "Start" value of 5:-

  SAY INDEX('abczzzdefzzghi','zz',5)   --> 5

If you look at it the way ARexx does, you will see that the sub string
"zzz" contains the pattern "zz" twice!

Now let's start at character 6:-

  SAY INDEX('abczzzdefzzghi','zz',6)   --> 10

The first occurrence of "zz" starting from 6 is at character 10.

If we now start at 11 the function returns 0 telling us that there is
no match of "zz" from the 11th character onwards:-

  SAY INDEX('abczzzdefzzghi','zz',11)  --> 0

Lines 5-10 of the following program illustrate how you could find @{B}every@{UB}
occurrence of a pattern within a given string. It uses the same "String"
and "Pattern" as is used in the above examples which showed that the
"Pattern" occurred starting at characters 4, 5 and 10. A practical example
of the coding in the following Lines 5-10 is given in Lines 38-43 of
@{"Example39-2" LINK "ARB:Articles_31-40/39.Support.Library/39-2"192}.

  /* Example34-1 */

 1. String = 'abczzzdefzzghi'
 2. Pattern = 'zz'

 3. Count = 1
 4. Position = 1

 5. DO FOREVER

 6.   Position.Count = INDEX(String,Pattern,Position)
 7.   If Position.Count = 0 THEN LEAVE
 8.   Position = Position.Count + 1
 9.   Count = Count + 1

10. END

11. IF Count = 1 & Position.1 = 0 THEN DO
12.   SAY 'No matches found'
13. END
14. ELSE DO
15.   Count = 1
16.   DO FOREVER
17.     IF Position.Count = 0 THEN LEAVE
18.     SAY 'Match occurred at Position' Position.Count
19.     Count = Count + 1
20.   END
21. END

This program should display:-

  Match occurred at Position 4
  Match occurred at Position 5
  Match occurred at Position 10

You could play around with it by changing the values of "String" and
"Pattern" to see the effects of different values.

@{B}Lines 3 & 4@{UB} set up two symbol values at 1 so that we can keep a count
of the number of occurrences and the positions in the string at which
the occur.

@{B}Line 6@{UB} finds the character at which the "Pattern" occurs in the "String".
The first time round the FOREVER loop this position will be 1 so that
the first occurrence will be found.

@{B}Line 7@{UB} will allow the FOREVER loop to be left if no match is found.

@{B}Line 8@{UB} is reached only after a match is found. The "Position" symbol is
increased to 1 more than the position of the last occurrence of
"Pattern".

@{B}Line 9@{UB} increases the "Count" for the next comparison.

@{B}Line 12@{UB} is only reached if no matches at all are found. This occurs if
"Position.1" holds a value of 0 while Count = 1.

@{B}Lines 16-20@{UB} display all the occurrences of the match of "Pattern" in
"String". It has to be a FOREVER loop as we do not know how many
occurrences there have been so we set "Count" to 1 before the loop (at Line
15) and increment Count by 1 at Line 19 before the loop is repeated.

@{B}Line 17@{UB} allows the FOREVER loop to be left when there are no more
matches.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Lastpos()" "Article 34 - More String Functions - LASTPOS()"

@{B}@{U}@{JCENTER}THE LASTPOS() FUNCTION@{UB}@{UU}
@{JLEFT}

LASTPOS() finds an occurrence of a pattern of characters within a string
of characters. Its format is:-

  LASTPOS(Pattern,String[,start])

The matching process is @{B}case sensitive.@{UB}

It searches @{B}backwards@{UB} for "Pattern" from the @{B}end@{UB} of "String".

If "Start" is omitted, then the search starts at the @{B}end@{UB} of "String".

See also:-

  @{"POS()" LINK "Pos()"}
  @{"INDEX()" LINK "Index()"}

which both search from the @{B}start@{UB} of the string.

Please read the section on @{"INDEX()" LINK "Index()"} as it has the most detail and an example
program.

@{B}Note@{UB} that, even though the search starts at the @{B}last@{UB} character of the
string, the numbers in "Start" and in the result, refer to a count of
characters from the @{B}start@{UB} of the string.

This is demonstrated by the following example of LASTPOS():-

  SAY LASTPOS('zz','abczzzdefzzghi',7)  --> 5

The search has started at the 7th character from the @{B}start@{UB} of "String".
The search proceeded from there @{B}backwards@{UB} towards the @{B}start@{UB} of "String"
and reported that "Pattern" had been found at the 5th character from the
start of "String".

Examples of all three functions are shown following:-

  SAY INDEX('abczzzdefzzghi','zz')      --> 4
  SAY POS('zz','abczzzdefzzghi')        --> 4
  SAY LASTPOS('zz','abczzzdefzzghi',4)  --> 4

  SAY INDEX('abczzzdefzzghi','zz',5)    --> 5
  SAY POS('zz','abczzzdefzzghi',5)      --> 5
  SAY LASTPOS('zz','abczzzdefzzghi',9)  --> 5

  SAY INDEX('abczzzdefzzghi','zz',6)    --> 10
  SAY POS('zz','abczzzdefzzghi',6)      --> 10
  SAY LASTPOS('zz','abczzzdefzzghi')    --> 10


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Pos()" "Article 34 - More String Functions - POS()"

@{B}@{U}@{JCENTER}THE POS() FUNCTION@{UB}@{UU}
@{JLEFT}
POS() finds an occurrence of a pattern of characters within a string of
characters. Its format is:-

  POS(Pattern,String[,Start])

The matching process is @{B}case sensitive.@{UB}

See also:-

  @{"INDEX()" LINK "Index()"} which is the same as POS() except that "String" and "Pattern"
  are reversed in the format.
  @{"LASTPOS()" LINK "Lastpos()"} which searches from the @{B}end@{UB} of the string.

Please read the section on @{"INDEX()" LINK "Index()"} as it has the most detail and an example
program.

Examples of all three functions are shown following:-

  SAY INDEX('abczzzdefzzghi','zz')      --> 4
  SAY POS('zz','abczzzdefzzghi')        --> 4
  SAY LASTPOS('zz','abczzzdefzzghi',4)  --> 4


  SAY INDEX('abczzzdefzzghi','zz',5)    --> 5
  SAY POS('zz','abczzzdefzzghi',5)      --> 5
  SAY LASTPOS('zz','abczzzdefzzghi',9)  --> 5

  SAY INDEX('abczzzdefzzghi','zz',6)    --> 10
  SAY POS('zz','abczzzdefzzghi',6)      --> 10
  SAY LASTPOS('zz','abczzzdefzzghi')    --> 10


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Reverse()" "Article 34 - More String Functions - REVERSE()"

@{B}@{U}@{JCENTER}THE REVERSE() FUNCTION@{UB}@{UU}
@{JLEFT}
This one simple reverses the order of the characters in a string. Its
format is:-

  REVERSE(String)

For example:-

  SAY REVERSE('abcdefg')
  --> gfedcba

  SAY REVERSE('!TSEB ehT - agimA')
  --> Amiga - The BEST!')

  SAY REVERSE('.cte nem doog lla rof emit eht si woN')
  --> Now is the time for all good men etc.

@{B}Don't ask!!@{UB} I don't know what I would use this function for!!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Translate()" "Article 34 - More String Functions - TRANSLATE()"

@{B}@{U}@{JCENTER}THE TRANSLATE() FUNCTION@{UB}@{UU}
@{JLEFT}
The full format for this one is:-

  TRANSLATE(String[,Output][,Input][,Pad])

The only essential argument here is "String" as in:-

  TRANSLATE(String)

All the other arguments are optional.

When used in this format the "String" is converted to uppercase and so
it is the same as @{"UPPER()" LINK "ARB:Articles_11-20/18.Functions-String/Upper()"}. For example:-

  SAY TRANSLATE('This Will Be Upper')   --> THIS WILL BE UPPER

The other arguments, "Output", "Input" and "Pad" are optional but their
use makes this a rather complicated function that has nothing to do with
converting to upper case.

Let's ignore "Pad" to start with and look at "Output" and "Input" and
assume that they are strings of the same length. Now let's assume we have
these items:-

  String = 'This Will Not be Upper'
  Input  = 'NipU'
  Output = '1549'

ARexx lines up each character of "Input" and assigns it the corresponding
character in "Output" according to position in the string. The characters
in "String" that match characters in "Input" will be replaced with the
corresponding character in "Output".

In other words, for our example:-

  All "N" characters in "String" will become "1"
  All "i" characters in "String" will become "5"
  All "p" characters in "String" will become "4"
  All "U" characters in "String" will become "9"

So if we use:-

  SAY TRANSLATE('This Will Not be Upper','1549','NipU')

we get:-

  Th5s W5ll 1ot be 944er

If "Output" is @{B}longer@{UB} than "Input" then the character matches start from
the @{B}right@{UB} end of "Output". For example, with:-

  String = 'This Will Not be Upper'
  Input  = 'NipU'
  Output = '15497'

  All "N" characters in "String" will become "5"
  All "i" characters in "String" will become "4"
  All "p" characters in "String" will become "9"
  All "U" characters in "String" will become "7"

Note that the leftmost character "1" in "Output" is @{B}not@{UB} used.

So if we use:-

  SAY TRANSLATE('This Will Not be Upper','15497','NipU')

we get:-

  Th4s W4ll 5ot be 799er

On the other hand, if "Output" is @{B}shorter@{UB} than "Input" then the "Output"
string is made up to the same length as "Input" by the use of the "Pad"
character at the right end of "Output". As usual, if "Pad" is not used
then the space character is used as the pad. Although more than one
character can be put in the pad position, only the left most one will be
used.

So, if we have:-

  String = 'This Will Not be Upper'
  Input  = 'NipU'
  Output = '15'
  Pad    = '*'

The "Output" becomes:-

  Input  = 'NipU'
  Output = '15**'

  All "N" characters in "String" will become "1"
  All "i" characters in "String" will become "5"
  All "p" characters in "String" will become "*"
  All "U" characters in "String" will become "*"

So if we use:-

  SAY TRANSLATE('This Will Not be Upper','15','NipU','*')

we get:-

  Th5s W5ll 1ot be ***er

In the last paragraph of the @{"UPPER()" LINK "ARB:Articles_11-20/18.Functions-String/Upper()"999} function I said that there was no
equivalent function to convert a string to lower case but that it could
be done with the TRANSLATE() function. This example program demonstrates
how to do it simply by having these "Input" and "Output" strings:-

  Input  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  Output = 'abcdefghijklmnopqrstuvwxyz'

  /* Example34-2 */

  Input  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  Output = 'abcdefghijklmnopqrstuvwxyz'

  DO FOREVER
    SAY 'Enter a string to convert to lower case or Q to quit'
    PARSE PULL String
    IF UPPER(String) = 'Q' THEN EXIT
    SAY 'String entered was :-' String
    SAY 'String converted is:-' TRANSLATE(String,Output,Input)
  END

If you RX this and enter at the prompt:-

  THIS IS Partly in Upper CASE

then the program output will be:-

  String entered was :- THIS IS Partly in Upper CASE
  String converted is:- this is partly in upper case

Try it out on different strings with different cases and note that
characters other than A-Z are not altered.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Value()" "Article 34 - More String Functions - VALUE()"

@{B}@{U}@{JCENTER}THE VALUE() FUNCTION@{UB}@{UU}
@{JLEFT}
A string function or a numeric function? Doesn't really matter so I'll
throw it in here.

This one gives the value held by a symbol. Its format is:-

  VALUE('SymbolName')

For example:-

  Testing = 'This is a Test'
  SAY VALUE('Testing')
  --> This is a Test

It can also be used on symbols that hold numeric values. For example:-

  Number = 25
  SAY VALUE('Number')
  --> 25

  Number = 25 * 4
  SAY VALUE('Number')
  --> 100

Note that the symbol name @{B}must be within quotes@{UB} . If it is not, we can
get error messages or incorrect output as demonstrated by the following
examples.

The following example has spaces between the words in the symbol value
which results in the error message if the symbol name is not in
quotes:-

  Testing = 'This is a Test'
  SAY VALUE(Testing)
  --> Command returned 10/31: Symbol expected

The following example does not have spaces in the symbol value but the
symbol value is converted to upper case if the symbol name is not in
quotes:-

  Testing = 'This_is_a_Test'
  SAY VALUE(Testing)
  --> THIS_IS_A_TEST

The following example has given the symbol a negative numeric value and
an error message is given:-

  Testing = -3 * 5
  SAY VALUE(Testing)
  --> Command returned 10/31: Symbol expected

In all of the above three examples, no problem would be experienced if
the symbol name "Testing" was enclosed in quotes, as in:-

  SAY VALUE('Testing')


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Verify()" "Article 34 - More String Functions - VERIFY()"

@{B}@{U}@{JCENTER}THE VERIFY() FUNCTION@{UB}@{UU}
@{JLEFT}
The format for this is:-

  VERIFY(String,List[,'MATCH'])

Without the optional keyword "MATCH" the function looks for occurrences,
in "String", of the characters that appear in "List". It returns a number
representing the first character in "String" that is @{B}not@{UB} in "List".

For example:-

  SAY VERIFY('abcdef','cba')
  --> 4

The 4th character in "abcdef", i.e. "d", is the first that is @{B}not@{UB} contained
in "cba".

@{B}Note@{UB} that the order of the characters in "List" does not matter, so that:-

  SAY VERIFY('abcdef','cba')

is the same as these two:-

  SAY VERIFY('abcdef','abc')
  SAY VERIFY('abcdef','bac')

If we used:-

  SAY VERIFY('abcdef','fed')
  --> 1

The 1st character in "abcdef", i.e. "a", is the first that is @{B}not@{UB} contained
in "fed".

@{B}Note@{UB} that it @{B}IS@{UB} case sensitive, so that:-

  SAY VERIFY('abcdef','CBA')
  --> 1

The 1st character in "abcdef", i.e. "a", is the first that is @{B}not@{UB} contained
in "CBA".

It the keyword "MATCH" is used (or its initial "M", then the number returned
is the position of the character in "String" that @{B}IS@{UB} the first to match
any of the characters in "List".

For example, using the same strings as above:-

  SAY VERIFY('abcdef','cba','M')
  --> 1

The 1st character in "abcdef", i.e. "a", is the first to @{B}match@{UB} any character
in "cba".

   SAY VERIFY('abcdef','fed','M')
  --> 4

The 4th character in "abcdef", i.e. "d", is the first to @{B}match@{UB} any character
in "fed".


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Word()" "Article 34 - More String Functions - WORD()"

@{B}@{U}@{JCENTER}THE WORD() FUNCTION@{UB}@{UU}
@{JLEFT}
Don't confuse this with @{"WORDS()" LINK "Words()"}.

This one is a bit simpler than the last two! Its format is:-

  WORD(String,N)

and it returns the Nth word in the string. For example:-

  SAY WORD('Now is the time for all good men',7)
  --> good

If there are not as many words in the string as asked for, then a null
string is returned.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Wordindex()" "Article 34 - More String Functions - WORDINDEX()"

@{B}@{U}@{JCENTER}THE WORDINDEX() FUNCTION@{UB}@{UU}
@{JLEFT}
This one's format is:-

  WORDINDEX(String,N)

It gives you the starting position (as the number of characters from the
start of the string) of the Nth word in the string. For example:-

  SAY WORDINDEX('This is a string',2)
  --> 6

The 2nd word starts at the 6th character (don't forget to include the
spaces in your count of characters!).

  SAY WORDINDEX('This is a string',4)
  --> 11

The 4th word starts at the 11th character.

If "N" is 0 (zero) or a number greater than the number of words in the
string, then the return is 0 (zero).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Wordlength()" "Article 34 - More String Functions - WORDLENGTH()"

@{B}@{U}@{JCENTER}THE WORDLENGTH() FUNCTION@{UB}@{UU}
@{JLEFT}
This one's format is:-

  WORDLENGTH(String,N)

and it returns the @{B}length@{UB} of the Nth word. For example:-

  SAY WORDLENGTH('Now is the time for all good men',7)
  --> 4

The 7th word is "good" which has 4 characters.

If "N" is 0 (zero) or a number greater than the number of words in the
string, then the return is 0 (zero).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Words()" "Article 34 - More String Functions - WORDS()"

@{B}@{U}@{JCENTER}THE WORDS() FUNCTION@{UB}@{UU}
@{JLEFT}
Don't confuse this with @{"WORD()" LINK "Word()"}.

Getting simpler!!. The format for this is:-

  WORDS(String)

and it tells you how many words are in the string. For example:-

  SAY WORDS('Now is the time for all good men')
  --> 8


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Xrange()" "Article 34 - More String Functions - XRANGE()"

@{B}@{U}@{JCENTER}THE XRANGE() FUNCTION@{UB}@{UU}
@{JLEFT}
Now we end up with a slightly more complicated one. Its format is:-

  XRANGE([Start][,End])

What it does is give a string containing all the characters from "Start"
to "End" where "Start" and "End" are characters, or the @{"ASCII Codes" LINK "ARB:Appendices/App-C_ASCII_Codes/MAIN"} (in
hexadecimal) for characters. Thus the the character "A" can be represented
as "A" or its ASCII code '41'x (You will @{"remember" LINK "ARB:Articles_11-20/15.Strings_More/HexDec"} that strings can be
represented by hexadecimal numbers in quotes followed by "x" outside the
quotes.)

For example:-

  SAY XRANGE('a','z')
  --> abcdefghijklmnopqrstuvwxyz

  SAY XRANGE('61'x,'7a'x)
  --> abcdefghijklmnopqrstuvwxyz

  SAY XRANGE('!','@')
  --> !"#$%&'()*+,-./0123456789:;<=>?@

  SAY XRANGE('21'x,'40'x)
  --> !"#$%&'()*+,-./0123456789:;<=>?@


@{B}@{JCENTER}>>> End of File <<<@{UB}
@{JLEFT}

@ENDNODE
