@DATABASE "ARB39"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 39 - The RexxSupport.Library"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 39 - THE REXXSUPPORT.LIBRARY

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{" General Comments        " LINK "General"}
@{" The SHOWDIR()  Function " LINK "Showdir()"}
@{"     Example Programs    " LINK "Example"}
@{" The SHOWLIST() Function " LINK "Showlist()"}
@{" The STATEF()   Function " LINK "Statef()"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "General" "Article 39 - The RexxSupport.Library - General Comments"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - GENERAL COMMENTS@{UB}@{UU}
@{JLEFT}
Way back in @{"Article 1 - Getting Started" LINK "ARB:Articles_01-10/01.Getting_Started/Software"} I said that one of the files needed
for ARexx was a file in "Libs:" called "REXXSUPPORT.LIBRARY".

This library contains another 11 functions that can be used by the ARexx
programmer. However, as they are not part of the main ARexx interpreter,
the rexxsupport.library file has to be added to ARexx's @{"Library List" LINK "ARB:Articles_31-40/38.Functions-More/LibraryList"} with
the @{"ADDLIB()" LINK "ARB:Articles_31-40/38.Functions-More/Addlib()"} Built In Function that we looked at in the last
article.

Once this library has been added to the Library List, the following
functions become available:-

  ALLOCMEM()  - See @{" Memory Handling " LINK "ARB:Articles_41-50/41.Memory_Handling/Allocmem()"}
  CLOSEPORT() - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Closeport()"}
  FREEMEM()   - See @{" Memory Handling " LINK "ARB:Articles_41-50/41.Memory_Handling/Freemem()"}
  GETARG()    - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Getarg()"}
  GETPKT()    - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Getpkt()"}
  OPENPORT()  - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Openport()"}
  REPLY()     - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Reply()"}
  SHOWDIR()   - See @{" This Article    " LINK "Showdir()"}
  SHOWLIST()  - See @{" This Article    " LINK "Showlist()"}
  STATEF()    - See @{" This Article    " LINK "Statef()"}
  WAITPKT()   - See @{" Communications  " LINK "ARB:Articles_31-40/40.Communications/Waitpkt()"}

I will talk about only 3 of these functions here. The others will be left
until the articles mentioned above.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Showdir()" "Article 39 - The RexxSupport.Library - The SHOWDIR() Function"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - THE SHOWDIR() FUNCTION@{UB}@{UU}
@{JLEFT}
This function allows the contents of a disk directory to be displayed.
Its format is:-

  SHOWDIR(Name [,'ALL'|'FILE'|'DIR'] [,Pad])

Two @{"example program" LINK "Example"} demonstrating its usage is included.

@{B}Name@{UB} is the only essential part. The others are options.

@{B}Name@{UB} is the name of the directory to be displayed.

@{B}Name@{UB} can be the actual name of the directory (if so put it in quotes as
it is a string) or it can be a symbol whose value is the name of a
directory. For example:-

  SHOWDIR('System')  --> Displays contents of System if System is a
                         sub directory of the current directory

  Name = 'System'
  SHOWDIR(Name)      --> Displays contents of System if System is a
                         sub directory of the current directory

If the directory is @{B}not@{UB} a sub directory of the current directory, then
the @{B}path@{UB} to the directory must be included in the name string. For
example:-

  SHOWDIR('WorkBench2.1:System')
  --> Displays contents of the system directory on disk Workbench2.1

If the directory to be displayed is the current directory then a null
string can be used:-

  SHOWDIR('') --> Shows contents of the current directory

@{B}Note@{UB} that you can @{B}NOT@{UB} use:-

  SHOWDIR()

with nothing between the brackets (as you can with other functions). There
@{B}must@{UB} be something there even if it is only '' representing a null
string.

@{B}'ALL'|'FILE'|'DIR'@{UB} These are keyword options. The "|" indicates that only
one of them can be used at a time. As with other keyword options, you
can use the full option name or just the initial letter.

@{B}ALL@{UB} will show @{B}all@{UB} the contents of the directory, i.e. both sub directory
names and file names. It is the @{B}default option@{UB} if none of these options
are used. It is the equivalent of the AmigaDOS command line:-

  DIR DirName

@{B}FILE@{UB} will show only the names of the files in the directory. It is the
equivalent of the AmigaDOS Command line:-

  DIR DirName FILES

@{B}DIR@{UB} will show only the names of the sub directories in the directory.
It is the equivalent of the AmigaDOS Command line:-

  DIR DirName DIRS

@{B}Note@{UB} that, where I say that a keyword is the equivalent of an AmigaDOS
DIR option, I mean it in the sense of the items that will be displayed,
@{B}NOT@{UB} in the @{B}way@{UB} that those items are displayed. Unlike the AmigaDOS command
"Dir", the output is @{B}not@{UB} sorted alphabetically, nor is it put into two
columns.

@{B}Pad@{UB} is the character that separates the names in the display. The default
is, as usual, the space character. If you wish to use a pad character
without using one of 'ALL'|'FILE'|'DIR' then you must put two commas between
the name and the pad:-

  SHOWDIR(Name,,Pad)

For example:-

  SHOWDIR(Name,,';') --> names separated by semicolons

For a simple display of the directory, you could use this simpler
alternative:-

  ADDRESS COMMAND 'Dir DirName Option'

where "Option" is one of the AmigaDOS Dir Command options (e.g. "Dirs"
for directories only or "Files" for files only). For example:-

  ADDRESS COMMAND 'Dir Sys: Files'

The advantage of this is that the AmigaDOS command "DIR" will sort the
output alphabetically and place it into two columns.

As far as I can see, the main advantage of using SHOWDIR() would be to
allow all the names to be placed into an array of compound symbols.
@{"Example 39-2" LINK "39-2"} illustrates this.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Example" "Article 39 - The RexxSupport.Library - Example Programs For SHOWDIR()"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - EXAMPLE PROGRAM FOR SHOWDIR()@{UB}@{UU}
@{JLEFT}
I have included two example programs on the disk that demonstrate the
use of @{"SHOWDIR()" LINK "Showdir()"}.

@{" Example 39-1 " LINK "39-1"} is a simple program to allow the user to enter the name
of a directory to be viewed.

@{" Example 39-2 " LINK "39-2"} is a bit more complex and it is suggested that you read
its specification first then have a go at writing it yourself.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "39-1" "Article 39 - The RexxSupport.Library - Explanation Of Example  39-1"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - EXPLANATION OF EXAMPLE 39-1@{UB}@{UU}
@{JLEFT}
@{"Click here" LINK "Example39-1.rexx/MAIN"} to read Example39-1 in full. A line by line description follows.

@{B}Lines 1-4@{UB}:-

   1. IF EXISTS('Libs:rexxsupport.library') = 0 THEN DO
   2. SAY 'c'x'Sorry - Your Libs: directory does not contain the
               rexxsupport.library file'
   3. EXIT
   4. END

will ensure that the library to be added actually exists in the Libs:
directory but, as mentioned in the last article, you still have to get
the @{"case of the letters" LINK "ARB:Articles_31-40/38.Functions-More/Show()"41} correct in Lines 5 & 6!!

@{B}Lines 5-7@{UB}:-

   5. IF SHOW('L','rexxsupport.library') = 0 THEN DO
   6. CALL ADDLIB('rexxsupport.library',0,-30,0)
   7. END

check to ensure that the library is not yet in the Library List and add
it if it is not.

@{B}Lines 8-15@{UB}:-

   8. SAY 'c'x'Enter the name of the directory to view using its full path'
   9. SAY 'or just press RETURN with no entry for the current directory.'
  10. PARSE PULL DirName

  11. IF DirName = '' THEN DirName = PRAGMA('D')

  12. SAY 'a'x'Enter: A - For Files and Directories'
  13. SAY ' F - For Files only'
  14. SAY ' D - For Directories only'

  15. PULL Type

allow the user to enter the name of the directory to be viewed and whether
"All", "Files" or "Directories" are to be included.

@{B}Line 10@{UB} uses PARSE PULL (instead of just PULL) for the directory name
so that Line 16 can display it in the same case as the user used to enter
it.

@{B}Line 11@{UB} checks to see if return only was pressed at Line 10 (meaning the
current directory is required). If so the symbol "DirName" will have a
null value and PRAGMA('D') is used to give the symbol "DirName" the name
of the current directory.

@{B}Line 15@{UB} uses PULL on its own so that, whatever case the user uses, it
will be converted to upper case.

@{B}Lines 16-17@{UB}:-

  16. SAY 'a'x'Directory for' DirName 'is:-'||'a'x

  17. SAY SHOWDIR(DirName,Type,'a'x)

@{B}Line 17@{UB} uses the full SHOWDIR() format. The "Pad" option is the line feed
character Hexadecimal 'a' which will ensure that each name is on a separate
line.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "39-2" "Article 39 - The RexxSupport.Library - Explanation Of Example Programs 39-2"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - EXPLANATION OF EXAMPLE PROGRAM 39-2 FOR SHOWDIR()@{UB}@{UU}
@{JLEFT}
As far as I can see, the main advantage of using SHOWDIR() would be to
allow all the names to be placed into an array of compound symbols. Example
39-2 (below) illustrates this. Before going further, however, it is time
for you to @{"try your own skills" LINK "ARB:Misc/Using_ARB/Writing"} as a programmer. The specifications for
the program are:-

1. Open the rexxsupport.library.

2. Ask the user to enter the name of the directory to be read
   or press "RETURN only" to read the current directory.

3. Display the contents of the directory in the following manner
   (where "Dirname" appears, the name of the entered directory should
   be shown, or the name of the current directory is RETURN only was
   pressed):-

      Dirname contains these directories:-

         sub directory names on separate files

      Dirname contains these files:-

         file names on separate lines

4. If there are no sub directories or no files, then a suitable message
   should be shown, such as:-

      Dirname contains these directories:-

         No sub directories in Dirname

      Dirname contains these files:-

         No files in Dirname

   RX Example39-2 and have a look at the output to see what I mean.

My solution is shown explained below on a line by line basis. See how
it compares to your program. @{"Click here" LINK "Example39-2.rexx/MAIN"} to read in in full.

    /* Example39-2 */

The following symbol table declares what they are used for and sets a
couple of them to their required values.

    Clear     = 'c'x  /* Clear the window                             */
    Count     =       /* Counter for loops                            */
    DirName   =       /* Name of directory being read                 */
    Dirs      =       /* List of sub directories from SHOWDIR()       */
    Down      = 'a'x  /* Move cursor down one line                    */
    Files     =       /* List of files from SHOWDIR()                 */
    Last      =       /* Previous value of mark                       */
    Left      =       /* Left hand marker position in parse           */
    Mark      =       /* Counter for loop in function                 */
    Name      =       /* Name of dir or file list passed to function  */
    Name.     =       /* Names of directories or files in list        */
    Number    =       /* Number of entries in Dirs or Files           */
    Position  =       /* Number of position of marker in parse symbol */
    Position. =       /* Position of marker in parse symbol           */
    Right     =       /* Right hand marker in parse                   */

@{B}Lines 1-11@{UB}:-

   1. IF EXISTS('Libs:rexxsupport.library') = 0 THEN DO
   2.   SAY Clear'Sorry - Your Libs: directory does not contain the
                  rexxsupport.library file'
   3.   EXIT
   4. END

   5. IF SHOW('L','rexxsupport.library') = 0 THEN DO
   6.   CALL ADDLIB('rexxsupport.library',0,-30,0)
   7. END

   8. SAY Clear'Enter the name of the directory to view using its
                full path'
   9. SAY 'or just press RETURN with no entry for the current directory.'
  10. PARSE PULL DirName

  11. IF DirName = '' THEN DirName = PRAGMA('D')

are the same as those in @{"Example39-1" LINK "39-1"}.

@{B}Line 12@{UB}

  12. Dirs = SHOWDIR(DirName,'D',':')

puts the list of sub directories into the symbol "Dirs". I have used a
"Pad" of ":" which will be used as a marker in the parsing operation in
the "GetNames" function.

@{B}Lines 13-16@{UB}:-

  13. IF Dirs = '' THEN DO
  14.   Number = 1
  15.   Name.1 = 'No sub directories in' DirName
  16. END

check to see if "Dirs" has a null value. If so there were no sub directories
in the main directory "DirName". The "Number" and "Name.1" symbols are
set to the values shown for use in the loop at @{"Lines 19-21" LINK "39-2"113}.

@{B}Line 17@{UB}:-

  17. ELSE CALL GetNames(Dirs)

is only reached if "Dirs" @{B}does@{UB} have a value other than null. This means
that there @{B}are@{UB} sub directory names. This being so, the internal function
"GetName" is called.

@{B}Lines 18-21@{UB}:-

  18. SAY Down||Dirname 'contains these directories:-'||Down
  19. DO Count = 1 to Number
  20.   SAY ' 'Name.Count
  21. END

display the sub directory names found by the function "GetName". The values
of "Number" and "Name.Count" are determined in that function.

@{B}Lines22-31@{UB}:-

  22. Files = SHOWDIR(DirName,'F',':')

  23. IF Files = '' THEN DO
  24.   Number = 1
  25.   Name.1 = 'No files in' DirName
  26. END
  27. ELSE CALL GetNames(Files)

  28. SAY Down||DirName 'contains these files:-'||Down
  29.   DO Count = 1 to Number
  30.   SAY ' 'Name.Count
  31. END

do the same for files in the directory "DirName" as @{"Lines 12-21" LINK "39-2"86} do for
sub directories in the directory "DirName".

@{B}Line 32@{UB}:-

  32. SAY

gives a blank line in the window simply to separate the output from the
CLI prompt that will appear when the program ends.

@{B}Line 33@{UB}:-

  33. EXIT

EXITs so that we do not accidently fall into the following
function.

@{B}Line 34@{UB}:-

  34. GetNames:

is the start of the function called at @{"Line 17" LINK "39-2"105} and @{"Line 27" LINK "39-2"123}. Its first
purpose is to determine the positions of the markers ":" in the string
of names.

We cannot simply pick out the words in the string with the WORD() and
WORDS() functions as a particular directory or file name might have spaces
in it and thus one name may have more than one word.

Nor can we use a simple PARSE operation using the pattern marker ":" as
we do not know how many directory or file names there are in the string
"Name".

Therefore we have to determine the position numbers of the marker characters
":" so that we can use absolute marker positions to retrieve the
names.

The function's second purpose is to place the directory or file names
into the array "Name.Mark" in @{"Line 50" LINK "39-2"223} using the positions of the
":" characters already determined.

@{B}Line 35@{UB}:-

  35. PARSE ARG Name

places the "String" in CALL GetName(String) in @{"Line 17" LINK "39-2"105} and @{"Line 27" LINK "39-2"123} into
the symbol "Name".

@{B}Line 36-37@{UB}:-

  36. Number = 1
  37. Position = 1

set up the initial symbol values

@{B}Lines 38-43@{UB}:-

  38. DO FOREVER
  39.   Position.Number = INDEX(Name,':',Position)
  40.   IF Position.Number = 0 THEN LEAVE
  41.   Position = Position.Number + 1
  42.   Number = Number + 1
  43. END

determine the positions of the character ":" in the string "Name". This
is the same coding as used in @{"Example 34-1" LINK "ARB:Articles_31-40/34.Strings_More/Index()"50}. The number of directory or
file names will be in the final value of the symbol "Number".

@{B}Line 44@{UB}:-

  44. Position.0 = 0

sets a dummy position number "Position.0" to a value of 0. When we go
through the following DO...END loop the first time @{"Line 48" LINK "39-2"223}  will give
"Position.0" a value of 1 so that the first parsing operation will start
at the first character of the string "Name".

@{B}Line 45@{UB}:-

  45. Position.Number = LENGTH(Name) + 1

sets the last position to the length of the string "Name" + 1. When we
left the loop in @{"Lines 38-43" LINK "39-2"193} the final "Position.Number" was 0. However,
we need it to point to the position one past the end of the string.

@{B}Line 46-51@{UB}:-

  46. DO Mark = 1 TO Number
  47.   Last = Mark - 1
  48.   Left = Position.Last + 1
  49.   Right = Position.Mark
  50.   PARSE VAR Name =Left Name.Mark =Right
  51. END

carry out one or more parsing operations. The actual number is the value
held by the symbol "Number" which was set in the DO...END loop at
@{"Lines 38-43" LINK "39-2"193} to hold the number of directory or file names in the "Name"
string. The parsing uses absolute markers "=Left" and "=Right". You will
recall that the string retrieved by the parsing starts at the left number
and ends at the right number - 1. Therefore we can use the position of the
":" to the right of the name being retrieved but we must use
"Position.Last + 1" to bypass the ":" at the left of the string.

@{B}Line 52@{UB}:-

  52. RETURN

returns the program flow from the function to the main program at @{"Line 18" LINK "39-2"105}
or @{"Line 28" LINK "39-2"123}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Showlist()" "Article 39 - The RexxSupport.Library - The SHOWLIST() Function"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - THE SHOWLIST() FUNCTION@{UB}@{UU}
@{JLEFT}
The SHOWLIST() function would not normally be used by the average ARexx
programmer. Some of its options are rather obscure and probably only of
interest to the dedicated programmer. I include them in the list for the
sake of completeness. The beginner should not worry about them.

The format for this function is as follows:-

  SHOWLIST(Option [,Name] [,Pad])

where the option and the items it displays can be one of the
following:-

 @{U}Option@{UU}@{U} Items Displayed@{UU}

   A    Names of all assigned devices (but without the name of the
        directory to which they are assigned).

   D    Names of all opened device drivers. For example, if a printer that
        uses the parallel port has been used then the devices
        "printer.device" and "parallel.device" will be in the list.

   H    Names of all opened handlers. This will mainly be the names of the
        disk drive handlers and the CON (console handler), PAR (Parallel
        Port) etc.

   I    Names of interrupt routines that are active.

   L    Names of all libraries that have been opened for use
        and held in the Amiga's memory resident library area in RAM.
        (@{B}Note@{UB} that this is @{B}not@{UB}:-
         - a list of the contents of the Libs: directory
         - a list of names in the @{"Library List" LINK "ARB:Articles_31-40/38.Functions-More/libraryList"}

   M    Names of RAM memory units in you system,
        e.g. "expansion memory" and "chip memory"

   P    Names of available ports. This is the same output as @{"Show('P')" LINK "ARB:Articles_21-30/24.Talking-Programs-2/P"}

   R    Names of available resources,
        e.g. "FileSystem.resource", "disk.resource", "keymap.resource"

   S    Names of available Semaphores. Normally these would be
        « SetPatch » and « IPrefs » i.e. programs that are running in the
        background that need to signal (semaphore) information to the
        system.

   T    Names of Ready Tasks. This is normally the task that is currently
        being handled by the CPU. Normally this would be ARexx as the
        CPU handled only one program at a time (see "W" below).

   V    Names of available Volumes. These are the floppy disk names and
        the hard drive partition names that are currently mounted or
        being referenced. They are @{B}not@{UB} the device names such as
        "df0:".

   W    Names of all waiting tasks, i.e. all programs currently running
        but not currently being handled by the CPU.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Statef()" "Article 39 - The RexxSupport.Library - The STATEF() Function"

@{B}@{U}@{JCENTER}REXXSUPPORT.LIBRARY - THE STATEF() FUNCTION@{UB}@{UU}
@{JLEFT}
This function returns a string of information about the disk file that
is nominated. Its format is:-

  STATEF(FileName)

For example:-

  SAY STATEF('S:')
  --> DIR 0 1 ----RWED 6846 729 2443

  SAY STATEF('S:Startup-Sequence')
  --> FILE 3067 6 ----RWED 6845 1189 1207

The string returned is:-

  Type Length Blocks Protection Days Minutes Ticks Comment

@{B}Type@{UB}       - the word DIR or FILE depending on whether the "FileName" is
             the name of a directory or a file.

@{B}Length@{UB}     - the length of the file in bytes (0 returned if directory).

@{B}Blocks@{UB}     - the size of the file in blocks (0 returned if directory).

@{B}Protection@{UB} - the state of the protection bits of the file

@{B}Days@{UB}       - the day on which the file was created expressed as the number
             of days since 1st January 1978 which is day 0 (zero),

@{B}Minutes@{UB}    - the time in minutes at which the file was created expressed
             as minutes since midnight.

@{B}Ticks@{UB}      - the fraction of a minute since the last "Minute" expressed
             as seconds time clock frequency. For Australian Amigas, the
             clock frequency is 50HZ so 10 seconds after the last minute
             would be 500 ticks. For American Amigas working on a clock
             frequency of 60 HZ 10 seconds would be 600 ticks.

@{B}Comment@{UB}    - The comment (if any) added to the file.

Thus, if a file had these details as given by the AmigaDOS "List" command:-

  FileName 1800 ----rwed 13-Jan-95 10:02:10
  : This file has a comment

The use of STATEF(FileName) would give:-

  FILE 1800 2 ----RWED 6221 602 500 This file has a comment

13-Jan-95 is 6221 days after 01-Jan-78

The time 10:02 is 602 minutes after midnight

500 ticks is 10 seconds.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
