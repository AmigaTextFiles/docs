@DATABASE "ARB17"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 17 - Built In Functions"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 17 - BUILT IN FUNCTIONS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}
@{JLEFT}

In the @{"last article" LINK "ARB:Articles_11-20/16.Functions-Internal/Main"} we started off our look at functions by discussing
"Internal Functions". This time I will start to explain about "Built In
Functions".
@{JCENTER}

@{" General Discussion            " LINK "General"}
@{" Invoking Built In Functions   " LINK "Invoking"}
@{" Syntax Of Built In Functions  " LINK "Syntax"}
@{"  - Arguments                  " LINK "Arguments"}
@{"  - Keywords                   " LINK "Keywords"}
@{"  - The PAD Option             " LINK "Pad"}
@{" The SPACE() Built In Function " LINK "Space()"}
@{" Other Built In Functions      " LINK "Other"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "General" "Article 17 - Built In Functions - General Discussion"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - GENERAL DISCUSSION@{UB}@{UU}
@{JLEFT}
"Built In Functions" are ones that are @{B}built in@{UB} to the AREXX system. We
have seen these examples of them already:-

  CENTER() - @{"Article  6" LINK "ARB:Articles_01-10/06.Centring_Text/MAIN"}
  RANDOM() - @{"Article 12" LINK "ARB:Articles_11-20/12.Conditional_Statements/Tossing"18}
  ARG()    - @{"Article 16" LINK "ARB:Articles_11-20/16.Functions-Internal/Arg()"}

There are about 88 of these built in functions, but don't let this worry
you. Most people would use only a handful of them.

Don't forget that, where I show example coding, I will show the output
that you can expect to see in your output window after the "-->" as
in:-

  SAY 'Hi there!'
  --> Hi There


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Invoking" "Article 17 - Built In Functions - Invoking"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - INVOKING@{UB}@{UU}
@{JLEFT}
In the last article we discussed the two methods of @{"calling or invoking"  LINK "ARB:Articles_11-20/16.Functions-Internal/Invoking"}
internal functions.

Built In Functions can be invoked in exactly the same way. The following
three methods would give the same result:-

First Method:-

  CALL FunctionName(arguments,options)
  SAY Result

e.g.:-

  CALL DATE('Normal')
  SAY RESULT
  --> 11 Nov 1996

Second Method:-

  SAY FunctionName(arguments,options)

e.g.:-

  SAY DATE('Normal')
  --> 11 Nov 1996

Third Method:-

  CALL FunctionName arguments,options
  SAY Result

e.g.:-

  CALL DATE 'Normal'
  SAY Result
  --> 11 Nov 1996

Both of the first two methods are legitimate but you will find that one
is better in some circumstances and the other better at other
times.

The third method, i.e. that of @{B}not@{UB} using parentheses, is @{B}inadvisable@{UB} in
my opinion. I will talk a bit about it now as you are likely to see it
used at times and thus you should be ready to recognise it for what it
is. However, don't use it yourself for the following reasons.

Apart from anything else, it is harder to read the program as the
parentheses make it a lot easier to see at a glance that it is a function.

Also, in some cases, it is @{B}essential@{UB} to use the parentheses.

To illustrate this, let's go back to our "Coin Toss Program" where we
used the random function with:-

  HeadTail = RANDOM(1,2,TIME('S'))

We @{B}could@{UB} use this alternatives:-

  CALL RANDOM 1,2,TIME('S') ; HeadTail = Result

but we could @{B}not@{UB} use either of these:-

  CALL RANDOM 1,2,TIME 'S' ; HeadTail = Result

  HeadTail = RANDOM 1,2,TIME('S')

If you try to work out the dos and don'ts of when you can and can't use
parentheses you will probably end up totally confused and with errors
in your program.

@{B}Get into the habit of always using parentheses@{UB} and you won't go wrong
and your program will be easier to read!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Syntax" "Article 17 - Built In Functions - Syntax"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - SYNTAX@{UB}@{UU}
@{JLEFT}
Each built in function has its own syntax which follows a form such as
one of the following. Note that they can use @{B}arguments@{UB} (arg1, arg2, etc.)
and @{B}options@{UB} or @{B}keyword options@{UB} (opt1, opt2, etc.):-

   FunctionName(argument)

   FunctionName(arg1,arg2)

   FunctionName(arg1,arg2 [,option])

   FunctionName(arg1,arg2 [,opt1][,opt2])

   FunctionName(arg1,arg2,[opt1|opt2|opt3])

The arguments inside the parentheses (), but @{B}not@{UB} enclosed in square brackets
[], are @{B}essential.@{UB}

The arguments, or options, inside the @{B}square brackets@{UB} [] are @{B}optional.@{UB}
However, if an optional argument is omitted, there will often be a default
value that ARexx uses.

This discussion is continued under the headings:-

  @{"  - Arguments                  " LINK "Arguments"}
  @{"  - Keywords                   " LINK "Keywords"}
  @{"  - The PAD Option             " LINK "Pad"}

And an example of a built in function is discussed under the
heading:-

  @{" The SPACE() Built In Function " LINK "Space()"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Arguments" "Article 17 - Built In Functions - Arguments"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - ARGUMENTS@{UB}@{UU}
@{JLEFT}
Argument names given in the syntax are an indication of what goes in that
position. The names shown in the syntax are not used as such but are
replaced by the user's information. For example, in the OPEN syntax:-

  OPEN(File,Filename[,'APPEND',|'READ'|'WRITE'])

we do @{B}not@{UB} use the arguments "File" and "Filename" literally. We replace
these with our own strings. For example:-

  OPEN('TestFile','s:startup-sequence','WRITE')

As strings are required, they are enclosed in single quotes.

(We will be looking at @{"OPEN()" LINK "ARB:Articles_21-30/28.File_Handling/OPEN()"} in Article 28.)

The above OPEN() example will open for "WRITEing" an internal ARexx file
called "TestFile" using the disk file "s:startup-sequence". ARexx uses
two file names - the "Logical" or "Internal" file name which is for its
own internal use only and the "External" file name that is loaded from
or saved to disk. We will discuss how ARexx handles files in @{"Article 28" LINK "ARB:Articles_21-30/28.File_Handling/files"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Keywords" "Article 17 - Built In Functions - Keywords"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - KEYWORD OPTIONS@{UB}@{UU}
@{JLEFT}
In some cases, @{"KEYWORDS" LINK "ARB:Misc/Glossary/Keywords"} are used instead of optional arguments.

Keywords are NOT replaced with the user's information (as with arguments)
but are used as such or with their first letter only.

The @{B}CASE@{UB} (upper or lower) of the keyword does not matter, nor does it
matter whether you use the @{B}full word@{UB} or its @{B}first letter only.@{UB} You will
find that different manuals display the syntax in different ways.

I will use the OPEN syntax to demonstrate these ways all of which are
legitimate:-

  OPEN(File,Filename[,'APPEND',|'READ'|'WRITE'])
  OPEN(File,Filename[,'Append',|'Read'|'Write'])
  OPEN(File,Filename[,'append',|'read'|'write'])
  OPEN(File,Filename[,'A',|'R'|'W'])
  OPEN(File,Filename[,'a',|'r'|'w'])

(Just as an aside, ARexx only looks at the first character so you could
have garbage after the "A" or "R" or "W" !! For example, you could
use:-

  OPEN(File,Filename,'Amiga Lives Forever!!!')

instead of:-

  OPEN(File,Filename,'A')

It would not worry the computer but it @{B}would@{UB} cause some confusion to the
human reader so don't do it!)

The "File" and "Filename" are essential arguments. As indicated @{"earlier" LINK "Arguments"},
actual names of files will replace the words used above.

The "APPEND", "READ" and "WRITE" are @{B}keyword@{UB} options. Because they are
in square brackets they need not be used.

Where keywords are optional and none is used, ARexx will often use a default
keyword. In the case of OPEN() it uses the "READ" keyword as the
default.

The upright bar "|" indicates that they are alternatives of which only
one can be used in any one instruction clause.

The keywords can NOT be substituted with the user's own information (as
in the case of the arguments mentioned above).

When keyword options are available, the syntax may show them as in the
OPEN syntax above or, if there are a lot of options available, the syntax
might use something like:-

   TIME(option)

For TIME() the manuals give a table listing 7 optional keywords:-

   CIVIL
   ELAPSED
   HOURS
   MINUTES
   NORMAL
   RESET
   SECONDS

I will explain these TIME() options in @{"Article 20" LINK "ARB:Articles_11-20/20.Functions-Date&Time/TIME()"}. I only show them here
to illustrate that a table such as this would be identical to showing
the syntax as:-

 
TIME('Civil'|'Elapsed'|'Hours'|'Minutes'|'Normal'|'Reset'|'Seconds')

So, where you see the word "option" have a look for the table setting
out the available keywords.

@{B}@{U}Important Note re Using Keyword Options@{UB}@{UU}

@{B}WARNING!!@{UB} - Whichever way you use your keywords (upper or lower case,
first letter or full word) it is @{B}very advisable to always include them
within quotes@{UB} as shown above. As with any string, you can use single quotes
('') or double quotes ("").

Although it is possible for it to work without the quotes, in some
circumstances it will create an error message. This can occur if you use
the keyword name as a symbol elsewhere in your program.

The following two examples illustrate this point. The first does @{B}not@{UB} put
the option in quotes:-

  /* Example17-1.rexx */

  SAY 'Civil Time before counter loop is:'
  SAY TIME(C)

  DO c = 1 to 5
    SAY "C =" c
  END

  SAY 'Civil Time after counter loop is:'
  SAY TIME(C)

This will give an output like this:-

  Civil Time before counter loop is:
  9:59AM
  C= 1
  C= 2
  C= 3
  C= 4
  C= 5
  Civil Time after counter loop is:
  +++ Error 18 in line 11: Invalid argument to function
  Command returned 10/18: Invalid argument to function

The final line has been interpreted as:-

  SAY TIME(6)

which is definitely @{B}not@{UB} legitimate!! This has happened as the DO loop
is exited with a "C" value of 6.

@{B}You have been warned!!@{UB}

Changing Example17-1 to the following solves the problem:-

  /* Example17-2.rexx */

  SAY 'Civil Time before counter loop is:'
  SAY TIME('C')

  DO c = 1 to 5
    SAY "C =" c
  END

  SAY 'Civil Time after counter loop is:'
  SAY TIME('C')

Now the output will be like this:-

  Civil Time before counter loop is:
  10:03AM
  C= 1
  C= 2
  C= 3
  C= 4
  C= 5
  Civil Time after counter loop is:
  10:03AM

The moral is @{B}ALWAYS@{UB} enclose option keywords within quotes!!

To understand the reason for this, we need to go back to how symbols work.
If no assignment has been made to a symbol, its value is its own name.
So if "C" has @{B}not@{UB} been used as a symbol before TIME(C) (as in the second
SAY instruction in Example17-1) then the "C" in TIME(C) would have a value
of "C" and all would be O.K. However, once "C" has been used as a symbol
and assigned a value, all is @{B}not@{UB} O.K.!

Anything in quotes is a string and @{B}not@{UB} a symbol so no problem
occurs.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Pad" "Article 17 - Built In Functions - The PAD Option"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - THE PAD OPTION@{UB}@{UU}
@{JLEFT}
A lot of functions that deal with strings often have "PAD" as an optional
argument. In these cases, you do NOT use the word "PAD" but substitute
in its place a character that you wish to be used as padding in the
string.

In most cases, if the "PAD" is omitted, then the "space" character will
be used as a default.

In some cases, the "PAD" character will be added to the start and/or the
end of the string. In other cases it may be added between words in the
string.

I will now describe the @{"SPACE()" LINK "Space()"} function to illustrate the PAD option.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Space()" "Article 17 - Built In Functions - The SPACE() Function"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - SPACE()@{UB}@{UU}
@{JLEFT}
The "Space()" function has this format:-

  SPACE(String,n[,PAD])

which means put "n" number of pad characters between each word in the
"String". For example:-

  SAY SPACE('Test the space function',3)
  --> Test   the   space   function

There are now three spaces between each word. The "PAD" option has not
been used so the default character "Space" has been used for
padding.

However, if we use "*" as a pad character, as in:-

  SAY SPACE('Test the space function',3,'*')
  --> Test***the***space***function

we end up with three "*" between each word.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Other" "Article 17 - Built In Functions - Other Function Explanations"

@{B}@{U}@{JCENTER}BUILT IN FUNCTIONS - EXPLANATIONS OF OTHER FUNCTIONS@{UB}@{UU}
@{JLEFT}
The following articles deal with these types of built in
functions:-

  Functions dealing with strings        - @{"Article 18" LINK "ARB:Articles_11-20/18.Functions-String/MAIN"}
  Functions dealing with numbers        - @{"Article 19" LINK "ARB:Articles_11-20/19.Functions-Numeric/MAIN"}
  Functions dealing with Date & Time    - @{"Article 20" LINK "ARB:Articles_11-20/20.Functions-Date&Time/MAIN"}
  Functions dealing with Random Numbers - @{"Article 21" LINK "ARB:Articles_21-30/21.Functions-Random/MAIN"}
  Functions for Bit Manipulation        - @{"Article 22" LINK "ARB:Articles_21-30/22.Functions-Manip_Bits/MAIN"}
  Functions dealing with files          - @{"Article 28" LINK "ARB:Articles_21-30/28.File_Handling/MAIN"}
  Functions for strings (additional)    - @{"Article 34" LINK "ARB:Articles_31-40/34.Strings_More/MAIN"}

There are also some functions that crop up incidentally in other articles.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
