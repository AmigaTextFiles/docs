@DATABASE "ARB16"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 16 - Internal Functions"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 16 - INTERNAL FUNCTIONS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{B}@{U}CONTENTS OF THIS ARTICLE@{UB}@{UU}
@{JLEFT}
This article has ended up being rather large but if you are going to use
Internal Functions properly then it would be best to read it all
thoroughly.

The items covered in this article are:-

@{JCENTER}
@{" Types of Functions        " LINK "Types"}
@{" Labels                    " LINK "Labels"}
@{" Internal Functions:       " LINK "Internal"}
@{"  - Purpose                " LINK "Purpose"}
@{"  - Examples               " LINK "Examples"}
@{"  - Construction           " LINK "Construction"}
@{"  - Invoking               " LINK "Invoking"}
@{" The CALL instruction      " LINK "Call"}
@{" The RETURN instruction    " LINK "Return"}
@{" The RESULT Symbol         " LINK "Result"}
@{" The ARG Instruction       " LINK "Arg"}
@{" The ARG() Function        " LINK "Arg()"}
@{" The PROCEDURE Instruction " LINK "Procedure"}
@{" Larger Function coding    " LINK "Larger"}
@{" COIN TOSS Version 3       " LINK "Tossing"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Types" "Article 16 - Internal Functions - Types Of Functions"

@{B}@{U}@{JCENTER}TYPES OF FUNCTIONS@{UB}@{UU}
@{JLEFT}
As this is the first of a series of articles about functions, I will make
a brief mention of the types of functions available.

There are three types of @{"functions" LINK "ARB:Misc/Glossary/Functions"} recognised by ARexx. They are:-

- Internal Functions   -  This Article
- Built In Functions   -  @{"Article 17" LINK "ARB:Articles_11-20/17.Functions-Built_in/MAIN"}
- Function Libraries   -  @{"Article 39" LINK "ARB:Articles_31-40/39.Support.Library/MAIN"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Labels" "Article 16 - Internal Functions - Labels"

@{B}@{U}@{JCENTER}LABELS@{UB}@{UU}
@{JLEFT}
Before we start talking about internal functions we should talk about
labels. A @{"label clause" LINK "ARB:Misc/Glossary/Clauses"30} (label for short) is a method of naming the start
of a particular block of programming code. It is a name followed by a
colon (:). Examples are:-

  Start:
  Evaluate:
  ReadDisk:

The @{B}name@{UB} for a label should follow the same rules as outlined for symbols
in @{"Article 7" LINK "ARB:Articles_01-10/07.Symbols_Intro/Names"}.

A label is, in fact, a special sort of fixed symbol.

You can use labels to identify sections of the program or to indicate
the beginning of an internal function.

The label is usually put on a line of its own with its program coding
indented and starting on the next line. For example, in the following
lines, the "Multiply:" is the label and the "SAY" line is the start of
its programming:-

  Multiply:
    SAY 'Five times' x '=' 5 * x
    .... rest of coding
  RETURN

However, it can also have program coding coming immediately after it on
the same line as in:-

  Multiply: SAY 'Five times ' x '=' 5 * x

For the sake of uniformity, and to make it easier to read programs, I
would suggest that you stick to the first method of having the label on
a line of its own and indenting all of the function's programming code
except for the final RETURN. (See @{"Examples" LINK "Examples"}).

Unless a function is invoked, or called, by its name, ARexx will ignore
any labels it comes across in the program coding. Therefore the programmer
can use labels to mark certain spots in the program for his/her own
assistance in reading the program. This is illustrated in Line 39 of
@{"Example 16-11"  LINK "Tossing"62} where I have used the label:-

  Display_Results:

to indicate the start of the coding that displays the results. However,
I really prefer comment clauses for this sort of thing as in these lines
from the same program:-

  /* Initialise the Program Symbols */

  /* Main Program Loop */

  /* Display Results */


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Internal" "Article 16 - Internal Functions - Discussion"

@{B}@{U}@{JCENTER}INTERNAL FUNCTIONS - DISCUSSION@{UB}@{UU}
@{JLEFT}
In @{"Article 10" LINK "ARB:Articles_01-10/10.DO-END_LOOPS-1/MAIN"} and @{"Article 14" LINK "ARB:Articles_11-20/14.DO-END_LOOPS-2/MAIN"} we saw how we could carry out repetitive
task by using the DO-END instructions.

These loops are fine when the repetition is required all at the one time,
as in the multiplication tables we were looking at. However, there are
times when the repetition comes at various and diverse points of the program
rather than all at once and so the DO-END system will not work. This is
where we need to use one of the @{"three types of functions" LINK "ARB:Misc/Glossary/Functions"}.

Internal Functions are discussed under these headings:-

  @{" Purpose      " LINK "Purpose"}
  @{" Examples     " LINK "Examples"}
  @{" Construction " LINK "Construction"}
  @{" Invoking     " LINK "Invoking"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Purpose" "Article 16 - Internal Functions - Purpose"

@{B}@{U}@{JCENTER}PURPOSE OF INTERNAL FUNCTIONS@{UB}@{UU}
@{JLEFT}
The main purpose of an internal function is to avoid having to use the
same or very similar coding over and over again. Just the one block of
coding can be used as many times as required.

Another very useful feature of Internal Functions is that, if you are
going to use the same routines over and over again in different programs,
then you can create and keep on disk a whole "library" of functions. Those
that you need for a particular program can then be loaded up from disk
at will and included in the program you are writing.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Examples" "Article 16 - Internal Functions - Examples"

@{B}@{U}@{JCENTER}EXAMPLES OF AN INTERNAL FUNCTION@{UB}@{UU}
@{JLEFT}
Before going into a detailed description of internal functions, let's
go back to our five times table and demonstrate how we can do the job
using an internal function. Two different methods of @{B}invoking@{UB} the function
are used in these two examples. Don't worry about how they work for the
time being. I will explain it later under the heading @{"Invoking" LINK "Invoking"}.

  /* Example 16-1.rexx */

 1. SAY 'The 5 times table'

 2. DO x = 1 to 10
 3.   CALL Multiply
 4.   SAY 'Five times' x '=' Result
 5. END
 6. EXIT

 7. Multiply:
 8. RETURN x*5


  /* Example 16-2.rexx */

 1. SAY 'The 5 times table'

 2. DO x = 1 to 10
 3.   SAY 'Five times' x '=' Multiply(x)
 4.
 5. END
 6. EXIT

 7. Multiply:
 8.   ARG m
 9. RETURN m*5

In both these examples, the function is invoked, or called, 10 times,
i.e. for each of the values of "x" from 1 to 10. Each time, the program
skips down to the function starting at line 7 which does its job then
RETURNS to where it came from, i.e. the end of Line 3. When the END
increments "x" to value 11, the loop is no longer operated and the EXIT
command causes the program to exit out of ARexx completely.

In Example 16-2 the ARG instruction (discussed @{"later" LINK "Arg"}) allows you to transfer
the value in parentheses after the function name (in this case the value
held by the symbol "x") to the symbol immediately after the ARG keyword.
It is like using:-

  m = x

These methods are rather more cumbersome ways of doing a "Times Table"
than the original method used in @{"Article 10" LINK "ARB:Articles_01-10/10.DO-END_LOOPS-1/What"} but, as I have said before,
it is useful to see how the same job can be done in a number of different
ways.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Construction" "Article 16 - Internal Functions - Construction"

@{B}@{U}@{JCENTER}CONSTRUCTION OF INTERNAL FUNCTIONS@{UB}@{UU}
@{JLEFT}
An internal function should always:-

- Start with a LABEL
- End with the instruction RETURN.

For example:

  Label:
    Instruction Clause1
    Instruction Clause2
    ....
  RETURN

Or:-

  Label:
    Instruction Clause1
    Instruction Clause2
    ....
  RETURN value

@{B}Label@{UB} - this is a name given to the function which is used to enable other
parts of the program to "Invoke" or "Call" the function by that
name.

@{B}RETURN@{UB} - this is an instruction that tells ARexx the point at which the
function ends and to go back to the point in the main program from which
the function was invoked. See @{"The RETURN Instruction" LINK "Return"} for more details.

@{B}Value@{UB} - this can be placed immediately after the RETURN and is a value
that is passed back to the main program. If it is a numerical value then
it can be an expression needing evaluation, as in Examples 16-1 and 16-2
above. However, it need not be a numerical value but could be a string
value. See @{"The RETURN Instruction" LINK "Return"} for more details.

Value is @{B}optional@{UB} if the function is invoked with @{"the CALL instruction" LINK "Call"}
but @{B}is essential@{UB} if the function is invoked without the CALL instruction.

@{B}Program Coding@{UB} - All the program coding between the @{B}Label@{UB} and the @{B}RETURN@{UB}
is carried out each time the function is invoked. This program code in
the function can be a lot larger than the two examples given above. It
can be quite simple, or can be very complex with DO-END loops and/or
IF-THEN-ELSE evaluations.

In fact, you could think of the program coding within a function as a
sub program of the main program. In some programming languages, it would
be called a sub routine.

Remember, though, that it is the final value after RETURN that is sent
back to the main program.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Invoking" "Article 16 - Internal Functions - Invoking"

@{B}@{U}@{JCENTER}INVOKING A FUNCTION@{UB}@{UU}
@{JLEFT}
An Internal Function can be invoked in two ways, as illustrated in Examples
16-1 and 16-2.

In @{"Example16-1" LINK "Examples"9}, we used the @{B}CALL@{UB} instruction. In this case, ARexx makes
use of a special symbol @{"Result" LINK "Result"}. The value or calculation used after RETURN
in the function is automatically assigned as the value of @{B}Result@{UB} so that
you can use @{B}Result@{UB} in the same way as any other symbol. For example, you
can "SAY" it (as in @{"Line 4 of Example16-1" LINK "Examples"10}) or you can use it in other
calculations (if it is numeric).

If the function is CALLed (as in @{"Line 3 of Example16-1" LINK "Examples"10}) then the RETURN
instruction does not need to have a value after it although we did have
one in this example.

In @{"Line 3 of Example16-2" LINK "Examples"23}, we used the function name followed by parentheses
(round brackets) with the values to be passed to the function included
in the parentheses. We @{B}did not@{UB} use the @{B}CALL@{UB} instruction so the use of
the value after RETURN is essential.

In this case, the @{B}Value@{UB} after @{B}RETURN@{UB} (@{"Line 9" LINK "Examples"33} is automatically substituted
into the instruction clause in place of the function name. In these lines
from Example16-2:-

  SAY 'Five times' x '=' Multiply(x)

  RETURN m*5

the @{B}Value@{UB} (m*5) after RETURN appears in place of "Multiply(x)" so that
when x = 3, for example, the RETURN would send back a value of 3*5, or
15, to the main program and the SAY line would, in effect, become:-

  SAY 'Five times' x '=' 15

@{B}Note carefully@{UB} that, if you do @{B}not@{UB} use CALL then you @{B}must@{UB} use a value
after the RETURN command. The absence of a value will result in an error
message "Function did not return value".

Example16-3, below, shows that you can pass more than one value to the
function by separating the values by commas:-

  /* Example 16-3.rexx */

  SAY 'Enter number of Times Table'
  PULL Number
  SAY 'The' Number 'times table'

  DO x = 1 to 10
   SAY Number 'times' x '=' Multiply(Number,x)
  END
  EXIT

  Multiply:
    ARG m,n
  RETURN m*n


@{JCENTER}=== End of Text ===
@{JLEFT}




@ENDNODE

@NODE "Call" "Article 16 - Internal Functions - The CALL Instruction"

@{B}@{U}@{JCENTER}THE CALL INSTRUCTION@{UB}@{UU}
@{JLEFT}
The CALL instruction has this syntax:-

  CALL FunctionName [expression][,expression][,...........]

The expressions in square brackets are optional. That is, the function
can be CALLed with or without using expressions after its name. In Line
3 of @{"Example16-1" LINK "Examples"9} we used CALL without any expression.

The final square brackets with dots indicate that the number of expressions
can be at the programmers discretion. That is, you can have one or two
or more.

The values of the expressions are passed to the function and, if it is
an internal function, these values are picked up by the @{"ARG" LINK "Arg"} instruction.

To illustrate this, let's rewrite @{"Example16-3" LINK "Invoking"40} as follows so that we use
the CALL instruction:-

  /* Example 16-4.rexx */

 1. SAY 'Enter number of Times Table'
 2. PULL Number
 3. SAY 'The' Number 'times table'

 4. DO x = 1 to 10
 5.   CALL Multiply Number,x
 6.   SAY Number 'times' x '=' Result
 7. END
 8. EXIT

 9. Multiply:
10.   ARG m,n
11. RETURN m*n

The @{B}CALL@{UB} instruction can be used for:-

- invoking an internal function as illustrated above.

- invoking a built in function - See @{"Article 17" LINK "ARB:Articles_11-20/17.Functions-Built_In/MAIN"}

- invoking a function from an external library - See @{"Article 39" LINK "ARB:Articles_31-40/39.Support.Library/MAIN"}

- invoking a second ARexx program from within a first ARexx program.

The final usage is illustrated by these two programs:-

  /* Example16-5.rexx */

  Value1 = 'VALUE FROM EXAMPLE16-5'
  SAY 'I am calling Example16-6 from Example16-5'
  SAY 'and I am sending to it the value:-    ' Value1

  CALL 'ARB:Articles_11-20/Example16-6.rexx' Value1
  SAY 'a'x'I am back to 16-5 from 16-6'
  SAY 'The result returned from 16-6 is:-    ' Result

(Note - ARB: is assigned to the disk or directory holding the "ARexx For
Beginners Files" when you double click on the "Index" icon.)

  /* Example16-6.rexx */

  ARG Value2
  Value3 = 'VALUE FROM EXAMPLE16-6'
  SAY 'a'x'Here I am at Example16-6'
  SAY 'Example16-5 sent me the value:-      ' Value2
  SAY 'I am returning to 16-5 the value:-   ' Value3
  RETURN Value3

If you RX Example16-5 the resultant output of @{B}both@{UB} programs will be:-

  I am calling Example16-6 from Example16-5
  and I am sending to it the value:-    VALUE FROM EXAMPLE16-5

  Here I am at Example16-6
  Example16-5 sent me the value:-       VALUE FROM EXAMPLE16-5
  I am returning to 16-5 the value:-    VALUE FROM EXAMPLE16-6

  I am back to 16-5 from 16-6
  The result returned from 16-6 is:-    VALUE FROM EXAMPLE16-6

So you can see how the second ARexx program has acted in the same way
as an internal function of the first program.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Return" "Article 16 - Internal Functions - The RETURN Instruction"

@{B}@{U}@{JCENTER}THE RETURN INSTRUCTION@{UB}@{UU}
@{JLEFT}
Although I have mention it quite a bit already, I had better give it a
proper description!

RETURN can be used in one of these formats:-

  RETURN

  RETURN Expression

If the first format is used (i.e. @{B}without@{UB} the "Expression") then no value
is passed back from the Function to the main program. This usage is only
valid if the CALL instruction is used to invoke the function.

If the second format is used, the the value of the "Expression" is
@{B}automatically@{UB} assigned as the value of the special symbol @{"RESULT" LINK "Result"}.

The use of the "Expression" is @{B}optional@{UB} if the CALL instruction @{B}is@{UB} used
but it is @{B}essential@{UB} if the CALL instruction is @{B}not@{UB} used.

Although RETURN is normally used in a Function, its use in the main program
is not an error. Its effect is the same as that of the @{"EXIT" LINK "ARB:Articles_11-20/12.Conditional_Statements/Exit"} instruction.

@{B}However,@{UB} I would suggest that you use EXIT and RETURN only as follows:-

@{B}EXIT@{UB}   - to exit from an ARexx program and return to the external host
         i.e. back to AmigaDOS or to another non-ARexx program.

@{B}RETURN@{UB} - to return from an internal function back to the main program.
         or to another ARexx program that has called the program it is in.

If you stick to this, then it will be easier to read the program and
understand what is going on


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Result" "Article 16 - Internal Functions - The RESULT Symbol"

@{B}@{U}@{JCENTER}THE RESULT SYMBOL@{UB}@{UU}
@{JLEFT}
RESULT is a special symbol used by ARexx to return a value from a function
to the main program when the function is invoked with the CALL instruction.

It is @{B}not@{UB} used when CALL is not used in the invokement of the function.

Whenever an internal function ends with:-

  RETURN expression

ARexx does the equivalent of:-

  RESULT = expression

Thus, in Example16-4, @{"Line 11" LINK "Call"33} does the equivalent of:-

  RESULT = m*n

The programmer can then use RESULT in any way that he/she likes within
the rules for using any other symbol. We saw an example of its use in
@{"Line 6" LINK "Call"27} of Example16-4.

RESULT will hold its value until one of these events happens:-

- the same function is recalled
- another function is called
- the programmer assigns another value to it

at which time another value will be assigned to RESULT.

If there is no expression placed after RETURN then any previous values
held by RESULT are discarded and RESULT returns to the main program with
the same value as any symbol that has not yet had an assignment made to
it, i.e. its value will be its own name RESULT.

Although it is quite possible for the programmer to use the name "Result"
as one of his/her own symbols, it is very unwise to do so. If you do,
and make a call to a function, the value held by "Result" will be lost!!
It will be overwritten by the value returned to the main program by the
called function. So... @{B}don't use "Result" as you own symbol!!@{UB}


@{JCENTER}=== End of Text ===
@{JLEFT}

@ENDNODE

@NODE "Arg" "Article 16 - Internal Functions - The ARG Instruction"

@{B}@{U}@{JCENTER}THE ARG INSTRUCTION@{UB}@{UU}
@{JLEFT}
We will have a full discussion of the ARG instruction, which is really
an abbreviation of "PARSE UPPER ARG", when we come to look at @{"parsing" LINK  "ARB:Articles_31-40/36.Parse-Templates-2/Arg"}.
I will only discuss here the way it is used in the above examples.

You can use the ARG instruction when you invoke a function in such a way
as to send the value(s) of expression(s) to the function in the ways
illustrated by Examples 16-3 and 16-4, i.e.:-

  Example16-1:-     SAY Number 'times' x '=' Multiply(Number,x)

  Example16-4:-     CALL Multiply Number,x

The ARG instruction will assign values to the symbol(s) that follow it.
For example, in Examples 16-3 and 16-4 we had:-

  ARG m,n

which, in both examples, acts as the equivalent of:-

  m = Number
  n = x

By using ARG in this way, the symbols used in the main program can be
kept entirely separate from the symbols used in the functions. This is
not important in the above examples. The following would work just as
well as @{"Example16-3" LINK "Invoking"40}:-

  /* Example 16-7.rexx */

  SAY 'Enter number of Times Table'
  PULL Number
  SAY 'The' Number 'times table'

  DO x = 1 to 10
    SAY Number 'times' x '=' Multiply(Number,x)
  END
  EXIT

  Multiply:
  RETURN Number*x

However, you will find that it can be very useful, if not essential, to
keep main program and function symbols quite separate in some more complex
usages of functions so it is a good habit to get into.

See also @{"PROCEDURE" LINK "Procedure"} which explains how to make sure that symbols with the
same name in the main program and in the function can have separate values
without interfering with each other.


@{JCENTER}=== End of Text ===
@{JLEFT}












@ENDNODE

@NODE "Arg()" "Article 16 - Internal Functions - The ARG() Function"

@{B}@{U}@{JCENTER}THE ARG() FUNCTION@{UB}@{UU}
@{JLEFT}
The ARG() Function is a "Built In Function". We will be looking at these
in @{"Article 17" LINK "ARB:Articles_11-20/17.Functions-Built_In/MAIN"}. However, it seems best to look at ARG() here as it can
be used with Internal Functions.

ARG() is used to:-

- determine how many arguments were sent to the current environment, or
- determine what those arguments are, or
- determine if an argument number exists or not.

"Current Environment" means the program or function in which ARexx is
currently operating.

The ARG() function is a way of retrieving the argument values without
using the ARG instruction or its PARSE equivalent.

It can be used in one of these formats:-

  ARG()
  ARG(Number)
  ARG(Number,'EXISTS')
  ARG(Number,'OMITTED')

"Number" is optional (but @{B}must@{UB} be used if either "EXISTS" or "OMITTED"
is used). For example:-

  ARG(2,'EXISTS')

"EXISTS" and "OMITTED" are @{B}Keyword Options@{UB} which we will look at in
@{"Article 17" LINK "ARB:Articles_11-20/17.Functions-Built_In/Keywords"}. Only @{B}one@{UB} of them can be used in the one instruction clause.
As we will see in the next article, these two keyword options can be used
in full or with only their initial letter "E" or "O". For example:-

  ARG(2,'O')
  ARG(3,'E')

Let's look at these bit by bit.

If you use ARG without any keywords, as in:-

  ARG()

then the number of arguments sent to the environment is returned. For
example:-

  SAY ARG() --> 2

This would indicate that 2 arguments were used.

If a number is in the brackets, then the string value of that argument
number is returned. For example:-

  SAY ARG(1) --> String Value

If "EXISTS" or "OMITTED" is used, then a @{"boolean" LINK "ARB:Misc/Glossary/Boolean"} value of 0 or 1 is returned
to indicate whether that argument number exists or not. For
example:-

  If ARG(2) @{B}does@{UB} exist then            SAY ARG(2,'E') --> 1
                                       SAY ARG(2,'O') --> 0

  If ARG(2) does @{B}not@{UB} exist then        SAY ARG(2,'E') --> 0
                                       SAY ARG(2,'O') --> 1

Note that one is the reverse of the other.

This is all illustrated by this example:-

  /* Example16-8 */

  CALL TestFunction 'One',,'','Four' /* Take careful note of positions */
                                     /* of the commas and quotes!!! */
  EXIT

  TestFunction:

  Arguments = ARG()
  SAY 'There are' Arguments 'arguments'

  SAY 'a'x'First loop is:-'
  DO Count = 1 TO Arguments
    SAY 'Argument' Count '=' ARG(Count)
  END

  SAY 'a'x'Second loop is:-'

  DO Count = 1 to Arguments+1
    IF ARG(Count,'E') = 1 THEN SAY 'Argument' Count 'does exists'
    ELSE SAY 'Argument' Count 'does not exist'
  END

  SAY 'a'x'Third loop is:-'

  DO Count = 1 to Arguments+1
    IF ARG(Count,'O') = 0 THEN SAY 'Argument' Count 'does exists'
    ELSE SAY 'Argument' Count 'does not exist'
  END

  RETURN

The above program should give this output:-

  There are 4 arguments

  First loop is:-
  Argument 1 = One
  Argument 2 =
  Argument 3 =
  Argument 4 = Four

  Second loop is:-
  Argument 1 does exists
  Argument 2 does not exist
  Argument 3 does exists
  Argument 4 does exists
  Argument 5 does not exist

  Third loop is:-
  Argument 1 does exists
  Argument 2 does not exist
  Argument 3 does exists
  Argument 4 does exists
  Argument 5 does not exist

This has shown that there were 4 arguments sent from the main program
to the function.

It has also shown that the "E" and "O" keyword options are exactly the
reverse of each other.

The CALL instruction used was:-

  CALL TestFunction 'One',,'','Four'

and the arguments were:-

  First   @{B}One@{UB}
  Second  @{B}no argument!!@{UB}
  Third   @{B}''@{UB}
  Fourth  @{B}Four@{UB}

The second argument @{B}does not exist@{UB} (as told to us that by the second and
third loops). Even though it does not exist, @{B}it is counted in the argument
count!!@{UB} This is because the argument count is really a count of @{B}argument
positions.@{UB} Take careful note of this seeming anomaly.

The third argument exists but has a @{B}null value@{UB} given to it by the two
quotes with nothing in between them.

You should take care to fully understand the difference between the second
and third arguments.

As there were only 4 arguments, the 5th does not, of course, exist.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Procedure" "Article 16 - Internal Functions - The PROCEDURE Instruction"

@{B}@{U}@{JCENTER}THE PROCEDURE INSTRUCTION@{UB}@{UU}
@{JLEFT}
As I said @{"above" LINK "Arg"44}, it can be important at times to keep main the program's
symbols separate from function symbols.

It may happen that you load up a bit of function coding from disk to use
in a new program and find that you have duplicated symbol names. This
could cause problems with erroneous results unless you use the PROCEDURE
instruction at the start of a function. Its syntax can be one of:-

  PROCEDURE

  PROCEDURE EXPOSE symbol

  PROCEDURE EXPOSE symbol symbol ....

When used on its own (as in the first syntax example) it causes @{B}all@{UB}
symbol names in the main program to be kept separate from any identical
symbol names in the function. For example:-


  /* Example16-9.rexx */

  /* Main Part 1 */

  MyName = 'Fred Bloggs'
  SAY 'My name is (ex Main Part1.1)  ' MyName
  CALL Function_1
  SAY 'My name is (ex Main Part1.2)  ' MyName

  /* Main Part 2 */

  MyName = 'Jack Spratt'
  SAY 'My name is (ex Main Part2.1)  ' MyName
  CALL Function_2
  SAY 'My name is (ex Main Part2.2)  ' MyName

  EXIT

  Function_1:
    MyName = 'Jane Doe'
    SAY 'My name is (ex Function-1)' MyName
  RETURN

  Function_2:
    PROCEDURE
    MyName = 'Jane Doe'
    SAY 'My name is (ex Function-2)' MyName
  RETURN


This will display:-

  My name is (ex Main Part1.1) Fred Bloggs
  My name is (ex Function-1) Jane Doe
  My name is (ex Main Part1.2) Jane Doe
  My name is (ex Main Part2.1) Jack Spratt
  My name is (ex Function-2) Jane Doe
  My name is (ex Main Part2.2) Jack Spratt

What has happened is that, in Part 1 of the main program, we have set
up a symbol "MyName" with the value "Fred Bloggs". However, we have called
Function_1, which uses the same symbol name and when we return to part
1 of the main program, we find that "MyName" now has the value assigned
to it in Function_1.

In Part 2, we set up "MyName" to be "Jack Spratt" and called Function_2.
The only difference between the two functions is that the second one uses
the PROCEDURE instruction. On returning to Part 2, we find that Function_2
has @{B}not@{UB} alter the value of "MyName" in the main program, even though it
was assigned a different value in the function.

Now let's see what happens if we use the EXPOSE keyword:-

  /* Example16-10.rexx */

  MyName = 'Fred Bloggs'
  HisName = 'Jack Spratt'

  SAY 'My Name is' MyName
  SAY 'His name is' HisName

  CALL Function

  SAY 'My Name is' MyName
  SAY 'His name is' HisName

  EXIT

  Function:
    PROCEDURE EXPOSE HisName
    MyName = 'Nothing'
    HisName = 'Nothing'
  RETURN

This program will display:-

  My Name is Fred Bloggs
  His name is Jack Spratt
  My Name is Fred Bloggs
  His name is Nothing

The use of EXPOSE has told ARexx that we want the main program symbol
"HisName" to be "exposed" to the function, but that all other main program
symbols should not be exposed.

Thus, even though both symbols have been assigned the value "Nothing"
by the function, only the unexposed symbol "MyName" is unchanged after
the return to the main program. After the return to the main program,
the exposed "HisName" has the value assigned to it in the function.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Larger" "Article 16 - Internal Functions - Larger Function Coding"

@{B}@{U}@{JCENTER}LARGER FUNCTION CODING@{UB}@{UU}
@{JLEFT}
The above examples had very simple coding of only one or a few lines in
the functions. As mentioned above, the function can contain as much coding
as you like and it can be very simple or very complex with conditional
statements and loops, etc.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Tossing" "Article 16 - Internal Functions - Coin Toss Program - Version 3"

@{B}@{U}@{JCENTER}COIN TOSS PROGRAM - VERSION 3@{UB}@{UU}
@{JLEFT}
If we go back to our coin toss program started in Articles 12 @{"Example 12-5" LINK "ARB:Articles_11-20/12.Conditional_Statements/Tossing"}
and developed further in Article 14 @{"Example14-1" LINK "ARB:Articles_11-20/14.Do-End_Loops-2/Tossing"} we will see that we had
a bit of repetitive programming in that we told the user that he won or
lost in two separate places.

In the following example we use functions to do the job (Lines
@{"48-51 and 52-55" LINK "Tossing"74}) and to count the number of wins and losses. We also count
the number of heads and tails in the main program at Lines @{"27 and 33" LINK "Tossing"47}.

The full program is as follows:-


/* Example16-11 */

/* Initialise the Program Symbols */

 1. Win      = 'You picked a WINNER' /* String to say if win */
 2. Lose     = 'Your choice was a FIZZER' /* String to say if lose */
 3. Heads    = 0   /* Keep track of number of heads */
 4. Tails    = 0   /* Keep track of number of tails */
 5. Wins     = 0   /* Keep track of number of wins */
 6. Losses   = 0   /* Keep track of number of losses */
 7. HeadTail = RANDOM(,,TIME('s')) /* record result of toss */
 8. YesNo    =    /* record yes or no response */
 9. Choice   =    /* record choice of H or T or Q */

/* Main Program Loop */

10. DO forever
11.   SAY ; SAY 'Coin Toss Program' ; SAY
12.   SAY 'Enter your choice: H - Heads, T - Tails, Q - Quit'
13.   PULL Choice
14.   IF Choice = 'Q' THEN DO
15.     SAY ; SAY 'Quitting Program - Are you sure? (Y/N)'
16.     PULL YesNo
17.     IF YesNo = 'Y' THEN EXIT
18.     ELSE ITERATE
19.   END
20.   ELSE DO
21.     IF Choice ~= 'H' & Choice ~= 'T' THEN DO
22.       SAY 'Wrong entry - enter again'
23.       ITERATE
24.     END
25.     HeadTail = RANDOM(1,2)
26.     IF HeadTail = 1 THEN DO
27.       Heads = Heads + 1
28.       SAY 'The coin came up HEADS'
29.       IF Choice = 'H' THEN CALL Right
30.       ELSE CALL Wrong
31.     END
32.     ELSE DO
33.       Tails = Tails + 1
34.       SAY 'The coin came up TAILS'
35.       IF Choice = 'T' THEN CALL Right
36.       ELSE CALL Wrong
37.     END
38.   END

39. Display_Results:

40.   SAY ; SAY 'Results to Date are:-' ; SAY
41.   SAY 'Number of Heads =' Heads
42.   SAY 'Number of Tails =' Tails
43.   SAY ; SAY 'Number of Wins =' Wins
44.   SAY 'Number of losses =' Losses

45. END

46. EXIT

47. /* Functions */

48. Right:
49.   SAY Win
50.   Wins = Wins + 1
51. RETURN

52. Wrong:
53.   SAY Lose
54.   Losses = Losses + 1
55. RETURN


The main difference between the above program (Example16-11) and @{"Example14-1" LINK "ARB:Articles_11-20/14.Do-End_Loops-2/Tossing"}
is the inclusion of the count of the number of times heads and tails come
up and the number of wins and losses, and the display of these results
(@{"Lines 40-44" LINK "Tossing"63}) and the use of functions to carry out the repetitive task
of telling the user if he won or lost and counting the wins and losses
(Lines @{"48-51 and 52-55" LINK "Tossing"74}). These new bits of coding should not need any
explanation.

The 4 numeric symbols (@{"Lines 3-6" LINK "Tossing"19}) need to be equated to a numeric value,
even though it is zero, because the first time they are used an arithmetic
calculation is performed on them (at Lines @{"27 & 33" LINK "Tossing"47} and @{"50 &54" LINK "Tossing"71}). If they
had NOT been equated to a numeric value, then their value would be their
name, which is a string, and the attempt at arithmetic would result in
a program crash with an error message.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
