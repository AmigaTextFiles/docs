@DATABASE "ARB18"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 18 - Built In Functions For Strings"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 18 - BUILT IN FUNCTIONS WHICH DEAL WITH STRINGS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}
@{JLEFT}

There are quite a few built in functions that let you manipulate strings
and find out information about strings. A lot of these are of limited
use and the beginner may not use them at all. In this article I will only
cover those that I feel that the beginner may find of use. The others
will either be covered in @{"Article 34" LINK "ARB:Articles_31-40/34.Strings_More/MAIN"} or as I use them in later articles.

Don't forget that arguments shown in square brackets [] are optional and
those not in [] are essential.

As usual, in all the examples I will show the result of the program line
after the "-->" indicator.

If you have not yet done so, you should first read @{"Article 17" LINK "ARB:Articles_11-20/17.Functions-Built_In/MAIN"} for some
general information about built in functions.
@{JCENTER}

@{" The COPIES()   Function         " LINK "Copies()"}
@{" The LENGTH()   Function         " LINK "Length()"}
@{" The DATATYPE() Function         " LINK "DataType()"}
@{" The UPPER()    Function         " LINK "Upper()"}
@{" The UPPER Instruction           " LINK "Upper"}
@{" Changing Strings                " LINK "Changing"}
@{" LEFT() and RIGHT() Functions    " LINK "Left()"}
@{" What Happens To The Old String? " LINK "What"}
@{" The SUBSTR()   Function         " LINK "Substr()"}
@{" The SUBWORD()  Function         " LINK "Subword()"}
@{" The STRIP()    Function         " LINK "Strip()"}
@{" The COMPRESS() Function         " LINK "Compress()"}
@{" The TRIM()     Function         " LINK "Trim()"}
@{" The DELSTR()   Function         " LINK "Delstr()"}
@{" The DELWORD()  Function         " LINK "Delword()"}
@{" The INSERT()   Function         " LINK "Insert()"}
@{" The OVERLAY()  Function         " LINK "Overlay()"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Copies()" "Article 18 - Built In Functions - COPIES()"

@{B}@{U}@{JCENTER}THE COPIES() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  COPIES(String,Number)

This function creates a new string comprising the "String" used in the
function duplicated "Number" of times. For example:-

  SAY COPIES('*',5)      --> *****
  SAY COPIES('Fred',3)   --> FredFredFred


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Length()" "Article 18 - Built In Functions - LENGTH()"

@{B}@{U}@{JCENTER}THE LENGTH() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:- LENGTH(String)

This function returns the length (number of characters) of the "String".
For example:-

  SAY LENGTH('Test String')
  --> 11

Don't forget that the space between the "Test" and "String" is also a
character!

Leading and trailing spaces are also counted, as in:-

  x = '  Test String  '
  SAY LENGTH(x)
  --> 15

(There are two spaces at before "Test" and after "String".)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "DataType()" "Article 18 - Built In Functions - DATATYPE()"

@{B}@{U}@{JCENTER}THE DATATYPE() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  DATATYPE(String[,Option])

If @{"Option" LINK "DataType()"34} is not used, then this function returns either NUM or CHAR
depending on whether "String" can or cannot be evaluated purely as a
number.

If the string is evaluated as a number, the NUM is returned.

If the string contains any characters that prevent it being evaluated
as a number then CHAR is returned.

For example:-

  SAY DATATYPE('Test String')   --> CHAR
  SAY DATATYPE(3.45)            --> NUM

  Name = 'Fred Bloggs'
  SAY DATATYPE(Name)            --> CHAR

  x = 4.5 ; y = 7
  SAY DATATYPE(x/y)             --> NUM

  SAY DATATYPE(23)              --> NUM
  SAY DATATYPE(23abc)           --> CHAR

Note that a number can be in quotes or not in quotes. It is still a number.
For example:-

  SAY DATATYPE('3.45')          --> NUM

If "Option" is used, then it must be one of the following keywords. Each
keyword tells you whether the "String" contains the type of characters
in the right hand column:-

    @{U}KEYWORD            @{UU}    @{U}TEST CHARACTERS@{UU}

    Alphanumeric           A-Z a-z 0-9
    Binary                 Binary digits (0 and 1)
    Lowercase              a-z
    Mixed                  A-Z a-z
    Numeric                legitimate numbers
    Symbol                 ARexx symbols
    Upper                  A-Z
    Whole                  Integer (Whole) numbers
    X                      Hexadecimal Strings
                           (0-9 and A-F)

As mentioned before, you can use just the first letter of these keywords
(see examples below).

If the function finds only the test characters in the string then it returns
the value "1". If it finds characters other than the test characters then
it returns the value "0". These are the @{"Boolean" LINK "ARB:Misc/Glossary/Boolean"} values of "1" (one) for
"True" and "0" (zero) for "False".

For example:-

  SAY DATATYPE('Fred','U') --> 0
  SAY DATATYPE('Fred','M') --> 1

The first is false as characters other than upper case were found. The
second is true as the only characters found were mixed upper and lower
case.

  x = 23.3
  SAY DATATYPE(x,'W') --> 0
  SAY DATATYPE(x,'N') --> 1

The first is false because the symbol "x" does not hold a value equal
to a whole number. The second is true because it is a legitimate
number.

  SAY DATATYPE(10CF,'X') --> 1
  SAY DATATYPE(10CG,'X') --> 0

The first is true because "10CF" represents a hexadecimal number but "10CG"
does not so the second is false.

Try out the others for yourself until you get the hang of it.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Upper()" "Article 18 - Built In Functions - UPPER()"

@{B}@{U}@{JCENTER}THE UPPER() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  UPPER(String)

Do not confuse the function UPPER() with the @{B}instruction@{UB} @{"UPPER" LINK "Upper"}. @{"Click here" LINK "Upper"35}
to read about the differences between the two.

This function will convert all the alpha characters (A-Z, a-z) into upper
case no matter what case they are already in. It has no effect on characters
outside the alpha range. For example:-

  SAY UPPER('This is a TEST')              --> THIS IS A TEST
  SAY UPPER('My Phone is 123 4567')        --> MY PHONE IS 123 4567
  SAY 'He said' UPPER('"What a MESS!!"')   --> He said "WHAT A MESS!!"

This function can be quite useful where you ask the user to enter some
information and you wish to use it in, say, a search of a database. You
must compare the data entered with that in the data base on the same terms
so you could use something like:-

  IF UPPER(NameEntered) = UPPER(NameExDataBase)

Now you can be sure that all of the comparisons are done only on upper
case characters and so it will not matter which case the user uses to
enter the data.

Note that, if you use a symbol in the function, the value of the symbol
is @{B}not@{UB} changed. A new string is created. For example:-

  Name = 'Fred Bloggs'
  New = UPPER(Name)
  SAY 'Name =' Name
  SAY 'New =' New

  --> Name = Fred Bloggs
      New = FRED BLOGGS

Note that the value of "Name" is unaltered. Only the new symbol "New"
has the value put into upper case.

There is no equivalent function to convert to lower case. However, it
could be done with the @{"TRANSLATE()" LINK "ARB:Articles_31-40/34.Strings_More/Translate()"104} function.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Upper" "Article 18 - Built In Functions - UPPER Instruction"

@{B}@{U}@{JCENTER}THE UPPER INSTRUCTION@{UB}@{UU}
@{JLEFT}
Do not confuse the instruction UPPER with the @{B}function@{UB} @{"UPPER()" LINK "Upper()"}. @{"Click here" LINK "Upper"35}
to read about the differences between the two.

Although this is an instruction rather than a function, I will mention
it here as it does much the same thing as the UPPER() function.

It is an @{B}undocumented@{UB} instruction. That is, it is not mentioned in the
manuals put out by Commodore (at least not in the two manuals that I
have!).

The syntax for it is:-

  UPPER Symbol [Symbol] [Symbol] .......

You must have at least one symbol name after UPPER but you can also have
a number of symbols separated by spaces.

You cannot use it on a literal string as you can with UPPER(). For example,
this is not allowed:-

  UPPER 'This is a String'

An example of its use is:-

  Name = 'Fred Nurks'
  SAY Name
  UPPER Name
  SAY name

  --> Fred Nurks
      FRED NURKS

The main difference between this and UPPER() is that UPPER changes the
actual value of the symbol (as illustrated above) whereas UPPER() does
not. UPPER() produces a new value which can be assigned to another symbol
or SAYed leaving the value of the old symbol unchanged. For
example:-

  Name = 'Fred Nurks'
  SAY Name
  SAY UPPER(Name)
  SAY Name

  --> Fred Nurks
      FRED NURKS
      Fred Nurks

You could use UPPER() to duplicate the action of UPPER with this:-

  Name = 'Fred Nurks'
  SAY name
  Name = UPPER(Name)
  SAY Name

  --> Fred Nurks
      FRED NURKS

In other words, the use of:-

  UPPER name

is the same as:-

  Name = UPPER(Name)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Changing" "Article 18 - Built In Functions - Changing Strings"

@{B}@{U}@{JCENTER}CHANGING STRINGS@{UB}@{UU}
@{JLEFT}
There are various functions that allow you to change strings, e.g. chop
a piece out of a string and use just that part, or add a bit to it. The
ones that I describe in this article are:-

@{" The LEFT()     Function " LINK "Left()"}
@{" The RIGHT()    Function " LINK "Left()"}
@{" The SUBSTR()   Function " LINK "Substr()"}
@{" The SUBWORD()  Function " LINK "Subword()"}
@{" The STRIP()    Function " LINK "Strip()"}
@{" The COMPRESS() Function " LINK "Compress()"}
@{" The TRIM()     Function " LINK "Trim()"}
@{" The DELSTR()   Function " LINK "Delstr()"}
@{" The DELWORD()  Function " LINK "Delword()"}
@{" The INSERT()   Function " LINK "Insert()"}
@{" The OVERLAY()  Function " LINK "Overlay()"}

We should also look at:-

@{" What Happens To The Old String? " LINK "What"}

There is one other that can chop up strings but I will leave it for later.
It is @{"WORD()" LINK "ARB:Articles_31-40/34.Strings_More/Word()"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Left()" "Article 18 - Built In Functions - LEFT() & RIGHT()"

@{B}@{U}@{JCENTER}THE LEFT() & RIGHT() BUILT IN FUNCTIONS@{UB}@{UU}
@{JLEFT}
These two functions allow you to select the left part or the right part
of a string, or of a symbol holding a string value.

Their full syntax is:-

  LEFT(String,Number[,Pad])
  RIGHT(String,Number[,Pad])

When used in this format:-

  LEFT(String,Number)
  RIGHT(String,Number)

The "Number" tells how many characters to take from the left part or the
right part of "String" respectively.

For example:-

  SAY LEFT('Test Match',4)
  --> Test

  x = RIGHT('Test Match',4)
  SAY x
  --> atch

If the value of the "Number" option is greater than the length of the
string and the @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"} option is not used, then the new string is padded
out with spaces. The space character is the default pad. In these examples
I have used the "." character to indicate where a space would be:-

  SAY LEFT('Test',6)
  --> Test..

  SAY RIGHT('Test,6)
  --> ..Test

If used in this form:-

  LEFT(String,Number,Pad)
  RIGHT(String,Number,Pad)

then any character put in the place of @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"}  will be used instead of a
space. For example:-

  SAY LEFT('Test',6,'*')
  --> Test**

  SAY RIGHT('Test,6,'*')
  --> **Test


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "What" "Article 18 - Built In Functions - What Happens to the Old String?

@{B}@{U}@{JCENTER}WHAT HAPPENS TO THE OLD STRING?@{UB}@{UU}
@{JLEFT}
Before going any further, it is important to note that the "Old String"
and the "New String" are completely different strings (except for the
exception noted below). Therefore the term "chopping up strings" is a
bit of a misnomer. This is illustrated by this example:-

  x = 'Test Match'
  y = LEFT(x,4)
  SAY 'x =' x
  SAY 'y =' y

  --> x = Test Match
      y = Test

This principal extends to all the functions in this article that relate
to picking out a part of the string or adding to it.

The "Old String" is always left unchanged UNLESS you use something like
this:-

  x = 'Test Match'
  SAY 'x =' x
  x = LEFT(x,4)
  SAY 'x =' x

  --> x = Test Match
      x = Test

In this sort of case, "x" is both the "Old" and the "New" string.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Substr()" "Article 18 - Built In Functions - SUBSTR()"

@{B}@{U}@{JCENTER}THE SUBSTR() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  SUBSTR(String,Start[,Length][,Pad])

This one lets you pick out part of the string from anywhere within it,
not just the left or right ends.

@{B}"Start"@{UB} is a number that indicates the starting character from the
left.

@{B}"Length"@{UB} is a number that indicates how many characters to take from the
string. If it is omitted, the whole of the rest of "String" is
used.

@{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"}  is a character that indicates what to use as padding if the requested
length takes the new string beyond the length of "String". If omitted,
a space is used as padding.

Examples are:-

  SAY SUBSTR('Test Match',3)
  --> st Match

No "Length" has been specified so the new string starts at the 3rd character
and takes up all of the rest of "String".

  x = SUBSTR('Test Match',3,5)
  SAY 'x =' x
  SAY 'with length of' LENGTH(x)

  --> x = st Ma
      with length of 5

This indicates that "x" now holds the value "st Ma" and is 5 character
long (note that the space in the middle is a character!).

  x = SUBSTR('Test Match',3,15)
  SAY 'x =' x
  SAY 'with length of' LENGTH(x)

  --> x = st Match
      with length of 15

No "Pad" option has been used so ARexx has used the "space" character
to pad the string out to the requested 15 characters. This is why we can
only see 8 characters (st Match) whereas the length is shown as 15.

  x = SUBSTR('Test Match',3,15,'*')
  SAY 'x =' x
  SAY 'with length of' LENGTH(x)

  --> x = st Match*******
      with length of 15

Now we can see the padding that we could not see in the previous
example.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Subword()" "Article 18 - Built In Functions - SUBWORD()"

@{B}@{U}@{JCENTER}THE SUBWORD() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  The SUBWORD() function

  SUBWORD(String,Number[,Length]

This one counts in WORDS rather than characters.

It starts at word number "Number" and, if "Length" is not used, gives
you the rest of the "String" from that word onwards. For example:-

  x = 'Australia England Test Match Today'
  SAY SUBWORD(x,3)
  --> Test Match Today

The "Length" option gives the number of WORDS (not characters) to be used.
For example:-

  x = 'Australia England Test Match Today'
  SAY SUBWORD(x,2,3)
  --> England Test Match


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Strip()" "Article 18 - Built In Functions - STRIP()"

@{B}@{U}@{JCENTER}THE STRIP() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  STRIP(String[{,'B'|'L'|'T'}][,Pad])

We saw in the @{"SUBSTR()" LINK "Substr()"37} function that strings can sometimes have spaces
at the start or end that may not be obvious. These can sometimes be quite
a problem, The STRIP() function can get rid of them. Instead of PADding,
it really DE-pads, even though it has the word @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"}  in its syntax.

The "|" character in the "'B'|'L'|'T'" means use only one of 'B', 'L'
or 'T'. These represent the end(s) of the "String" from which the stripping
is to be done:-

  B   BOTH ends of the string
  L   LEADING (front) end only
  T   TRAILING (back) end only

This syntax looks rather complex so let's go through it bit by bit.

First of all, everything after the "String" can be left out as it is all
in square brackets [] which indicate "optional" (but see below for the
meaning of the {} brackets within the [] brackets). Its simple form then
becomes:-

  STRIP(String)

As no options have been given, the default options are used which
are:-

  Pad = Space
  Ends = Both

In other words, it strips spaces from both the front and back of the string,
but not from anywhere in the middle. For example:-

  x = '   Test Match       '
  SAY 'x =' x 'with length of' LENGTH(x)
  y = STRIP(x)
  SAY 'y =' y 'with length of' LENGTH(y)

  --> x =    Test Match        with length of 20
      y = Test Match with length of 10

You can see from the positioning of the "Test Match" in the output that
the spaces from the @{B}front@{UB} and @{B}back@{UB} are removed but the space in the middle
has @{B}not@{UB} been removed.

If you specify "L" or "T" you get the spaces stripped from the front (L
for leading) or back (T for Trailing) as in:-

  x = '   Test Match       '
  SAY 'x =' x 'with length of' LENGTH(x)
  y = STRIP(x,'L')
  SAY 'y =' y 'with length of' LENGTH(y)

  --> x =    Test Match        with length of 20
      y = Test Match        with length of 17

You can see from the positioning of the "Test Match" in the output that
the spaces from the front are removed but @{B}not@{UB} from the back or
middle.


  x = '   Test Match       '
  SAY 'x =' x 'with length of' LENGTH(x)
  y = STRIP(x,'T')
  SAY 'y =' y 'with length of' LENGTH(y)

  --> x =    Test Match        with length of 20
      y =    Test Match with length of 13

You can see from the positioning of the "Test Match" in the output that
the spaces from the back are removed but @{B}not@{UB} from the front or
middle.

In the proper syntax:-

  STRIP(String[{,'B'|'L'|'T'}][,Pad])

the "'B'|'L'|'T'" is in curlies {} inside squares []. Squares mean optional
and curlies mean essential. This may sound a bit contradictory but it
means that, although they are not essential if the simple syntax is used,
as in:-

  STRIP(String)

one of them @{B}is@{UB} essential if the @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"} option is used. This is because,
if you try to use "Pad" without one of 'B', 'L' or 'T', then ARexx will
interpret the "Pad" as being a keyword option. ARexx looks at the @{B}position@{UB}
of the arguments and with STRIP the position after the "String" must be
one of "B", "L" or "T". If it is not, then an error will occur.

So, if you want a "Pad" option, make sure that you use one of 'B', 'T'
or 'L' so that the "Pad" can be in its correct position. You may see it
done this way:-

  SAY STRIP('**Test Match**',,'*')
  --> Test Match

In this case, the TWO commas between the string and the "Pad" ('*') means
that the default option of 'B' is used and the "Pad" is in its correct
position.

As already mentioned, when "Pad" is @{B}not@{UB} used, @{B}spaces@{UB} are stripped from
the front and/or back ends. If "Pad" @{B}is@{UB} used, then any characters in the
"Pad" (usually only one character) found at the front and/or back ends
are stripped from the string:-

  SAY STRIP('***Test Match*****','B','*')
  --> Test Match

  SAY STRIP('***Test Match*****','L','*')
  --> Test Match*****

  SAY STRIP('***Test Match*****','T','*')
  --> ***Test Match

If the "Pad" contains more than one character, it will remove all of those
characters up to the point where it finds a character that does not match
one in the "Pad". For example:-

  SAY STRIP('*^*^Test *^ Match**^^','B','^T*')
  --> est *^ Match

Note that all the pad characters "^" "T" "*" are removed from both ends
irrespective of the order in which they appear until "e" at the start
or "h" at the back is reached. However, the "Pad" characters are @{B}not@{UB} removed
from other parts of the string.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Compress()" "Article 18 - Built In Functions - COMPRESS()"

@{B}@{U}@{JCENTER}THE COMPRESS() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  The COMPRESS() Function

The syntax for this is:-

  COMPRESS(String[,list])

What it does is to remove all characters contained in "list" from the
"String". Whereas STRIP() removes only from the front and/or the back
of a string, COMPRESS() will remove from @{B}anywhere@{UB} in the string. For
example:-

  x = ' How Long is a String '
  SAY 'x =' x
  SAY 'with length of' LENGTH(x)
  y = COMPRESS(x,'S s')
  SAY 'y =' y
  SAY 'with length of' LENGTH(y)

  --> x = How Long is a String
      with length of 22
      y = HowLongiatring
      with length of 14

The @{B}List@{UB} is "S s". That has a space character in the middle. Therefore
all spaces and all uppercase and lowercase esses (Ss) are removed.

If the "list" option is omitted, the default "list" is the space character
only. For example:-

  x = ' How Long is a String '
  SAY 'x =' x
  SAY 'with length of' LENGTH(x)
  y = COMPRESS(x)
  SAY 'y =' y
  SAY 'with length of' LENGTH(y)

  --> x = How Long is a String
      with length of 22
      y = HowLongisaString
      with length of 16

Now only the space characters have been removed


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Trim()" "Article 18 - Built In Functions - TRIM()"

@{B}@{U}@{JCENTER}THE TRIM() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  TRIM(String)

This one trims only the SPACE character from the END of the string it
is identical to:-

  STRIP(String,'T')

(See @{"STRIP()" LINK "Strip()"} for explanations and examples.)

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Delstr()" "Article 18 - Built In Functions - DELSTR()"

@{B}@{U}@{JCENTER}THE DELSTR() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  DELSTR(String,Start[,Length])

This one  deletes a sub string from the main string starting at the "Start"
number. If "Length" is @{B}not@{UB} used, it deletes all of the rest of the string.
For example:-

  SAY DELSTR('Test Match',3)
  --> Te

The sub string, which is all of the old string from the 3rd character
onwards, has been removed.

If "Length" @{B}is@{UB} used, that length of string is deleted from the "Start"
position. For example:-

  SAY DELSTR('Test Match',3,5)
  --> Tetch

In this case, a sub string 5 characters long starting at character 3 (i.e.
"st Ma") has been removed.

(Don't forget that the "old" string is @{"not changed" LINK "What"}.)

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Delword()" "Article 18 - Built In Functions - DELWORD()"

@{B}@{U}@{JCENTER}THE DELWORD() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  DELWORD(String,Start[,Length])

This one is similar to @{"DELSTR()" LINK "Delstr()"} except that words are removed instead
of characters. The "Start" is the number of the word. The "Length" is
the number of words. For example:-

  SAY DELWORD('Australia England Test Match Today',3)
  --> Australia England

As no "Length" has been given ALL of the string from the 3rd word onwards
has been removed.

  SAY DELWORD('Australia England Test Match Today',3,2)
  --> Australia England Today

The string that is removed (Test Match) starts at the 3rd word and is
2 words long.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Insert()" "Article 18 - Built In Functions - INSERT()"

@{B}@{U}@{JCENTER}THE INSERT() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  INSERT(New,Old[,Start][,Length][,Pad])

This one is the opposite of @{"DELSTR()" LINK "Delstr()"}. It inserts a new string into the
old string.

The "New" string is inserted into the "Old" string starting AFTER the
"Start" character of the old string. For example, if the "Start" number
is "3" the new string is inserted AFTER the 3rd character of the "Old"
string. If "Start" is @{B}not@{UB} given, the "New" is inserted in front of the
"Old". It assumes a "Start" of 0 (zero). For example:-

  SAY INSERT('Test ','Match')
  --> Test Match

but if you use:-

  SAY INSERT('Test ','Match ',3)
  --> MatTest ch

The "New" string "Test " has been inserted into the "Old" string "Match"
starting AFTER the third character (note that the "New" string has a space
as its last character).

The "Length" option specifies how many characters from the "New" string
are to be used. If it is omitted (as in the above example) then ALL the
"New" string is used. If it is less than the length of "New" then only
the "Length" number of characters from the start are used, as in:-

  SAY INSERT('Test ','Match',3,2)
  --> MatTech

If "Length" is longer than "New" then the @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"}  character is used, which
is a space if "Pad" is omitted. For example:-

  SAY INSERT('Test ','Match',3,10,'*')
  --> MatTest *****ch

The "New" string that has been inserted into the "Old" string is:-

   Test *****

because 'Test ' has been padded out with asterisks to a length of 10
characters.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Overlay()" "Article 18 - Built In Functions - OVERLAY()"

@{B}@{U}@{JCENTER}THE OVERLAY() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:-  OVERLAY(New,Old[,Start][,Length][,Pad])

This one is somewhat similar to @{"INSERT()" LINK "Insert()"} except that the "New" string
is "overlaid" instead of being "inserted". With "insert" all of the character
of "Old" are kept. With "overlay" some of the "Old" characters are
overwritten.

Another important difference between INSERT() and OVERLAY() is that INSERT()
starts at the character AFTER the "Start" number but OVERLAY() starts
AT the "Start" number.

These two differences can be illustrated by these examples:-

  SAY INSERT('***','123456789',3)
  -->123***456789

  SAY OVERLAY('***','123456789',3)
  --> 12***6789

As with INSERT(), the "Length" and @{"Pad" LINK "ARB:Articles_11-20/17.Functions-Built_In/Pad"}  options in OVERLAY() control
the length of the "New" string to be used and the "Pad" character to be
used if the specified "New" string is shorter than the specified "Length".
For example:-

  SAY OVERLAY('Australia','England',3,4)
  --> EnAustd

Here the first 4 characters of 'Australia' are inserted into 'England'
starting at character number 3.

  SAY OVERLAY('Australia','England Always The Best',1,14,'!')
  --> Australia!!!!! The Best

Here a new string 14 characters long is created by taking the "New" string
"Australia" and padding it out to 14 characters with the "!" character.
This new string is then inserted into the "Old" string starting at the
1st character.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
