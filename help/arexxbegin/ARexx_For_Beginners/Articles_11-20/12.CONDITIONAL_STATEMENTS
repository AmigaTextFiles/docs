@DATABASE "ARB12"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 12 - Conditional Statements"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 12 - CONDITIONAL STATEMENTS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}
@{JLEFT}

The use of IF...THEN...ELSE can be quite simple or, in some circumstances,
especially if we have @{B}nested@{UB} IF...THEN...ELSE statements, quite complex.
In fact there a couple of traps for the unwary which could make a program
do something in the wrong way.

I would therefore recommend that you read @{B}all of this article.@{UB}
@{JCENTER}

@{" Making Decisions - IF...THEN...ELSE " LINK "Making"}
@{" The EXIT Instruction                " LINK "Exit"}
@{" Tossing A Coin - Example Program    " LINK "Tossing"}
@{" Nested IF...THEN...ELSE Statements  " LINK "Nested"}
@{" The NOP Instruction                 " LINK "Nop"}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Making" "Article 12 - Conditional Statements - Making Decisions"

@{B}@{U}@{JCENTER}CONDITIONAL STATEMENTS - MAKING DECISIONS

THE    IF   THEN   ELSE    INSTRUCTIONS@{UB}@{UU}
@{JLEFT}

@{B}@{U}MAKING DECISIONS@{UB}@{UU}

There are not many programming tasks that do not make decisions. The way
the programmer gets the program to make these decisions is by use of the
IF...THEN...ELSE keywords.

These work in a similar way to a parent saying to a child something
like:-

  @{B}IF@{UB} you are good @{B}THEN@{UB} you can watch TV
  or @{B}ELSE@{UB} you will go to bed.

The ARexx equivalent can be used in one of these ways:-

Format 1:-

  IF expression THEN instruction clause
  ... rest of program

Format 2:-

  IF expression THEN instruction clause 1
  ELSE instruction clause 2
  ... rest of program

Format 3:-

  IF expression THEN DO
    instruction clause 1
    instruction clause 2
    instruction clause 3
  END
  ELSE DO
    instruction clause 4
    instruction clause 5
  END
  ... rest of program

@{B}Note carefully@{UB} that you @{B}must not have@{UB} any other clauses between:-

- the "THEN ..." and the ELSE in Format 2 (above), or

- the END belonging to the "THEN DO" and the ELSE in Format 3
(above).

If you do, you will end up with an error situation.

The "expression" must be capable of being evaluated as being TRUE or FALSE.
This is the same as saying that the expression must be evaluated as having
one of the two @{"Boolean" LINK "ARB:Misc/Glossary/Boolean"} values of 0 or 1.

If the "expression" is TRUE then the instruction following the THEN is
carried out and the instruction following ELSE is completely ignored (if
there is an ELSE statement).

If the "expression" is FALSE then the instruction following the THEN is
completely ignored and the instruction following the ELSE is carried out
or, if there is no ELSE, then the next program line after the IF...THEN
is executed.

It is @{B}impossible@{UB} for @{B}both@{UB} the THEN and the ELSE instructions to be executed.
It is equally @{B}impossible@{UB} for @{B}both@{UB} of them to be ignored. It @{B}must@{UB} be one
@{B}or@{UB} the other that is executed.

Note that, in reality, the THEN and ELSE will only operate ONE instruction
before the program goes on to the next line. This is as per the formats
1 and 2 above.

However, if you wish the THEN and/or the ELSE to operate a number of
instructions then you must use a @{B}block@{UB} of code commencing with
@{B}DO@{UB} and ending with @{B}END.@{UB} The DO instruction is then considered as the one
instruction that the THEN or ELSE executes.

@{B}@{U}An Example@{UB}@{UU}

As an example, let's make ARexx tell us which numbers are odd and which
are even. To do this we will use the two @{"arithmetic operators" LINK "ARB:Articles_01-10/09.Arithmetic_Operators/MAIN"} that do
division (% and /). The first gives us an integer result and the second
a decimal result. For example:-

  3 % 2 = 1              4 % 2 = 2
  3 / 2 = 1.5            4 / 2 = 2

Thus, a test of:-

  x % 2 = x / 2

will be true for even numbers and false for odd numbers. This gives us
the required true or false comparison. Our program is:-

 /* Example12-1.rexx */

 1. DO x = 1 TO 10
 2. IF x % 2 = x / 2 THEN SAY x 'is even'
 3. ELSE SAY x 'is odd'
 4. END

If you RX this program your display should be:-

  1 is odd
  2 is even
  3 is odd
  4 is even
  5 is odd
  6 is even
  7 is odd
  8 is even
  9 is odd
  10 is even

Lines 1 and 4 set up a loop to be carried out 10 times, i.e. for all values
of symbol "x" from 1 to 10.

Line 2 is operated for each of the 10 times the loop is operated.

If "x" is an even number then the last part of line 2 (after the THEN)
is carried out. The program then completely skips over Line 3 and goes
to Line 4.

If "x" is an odd number then the last part of Line 2 (after the THEN)
is ignored and the program goes to Line 3.

Line 3 is only reached if the "IF" in Line 2 determines that "x" is an
odd number. Thus this line is operated only 5 times during the 10 operations
of the loop. It is bypassed the other 5 times.

Line 4 is reached for each of the 10 operations of the loop. It determines
if "x" is still in the range of 1 - 10 and sends the program back to Line
2 if it is. If "x" is over 10 then the program looks for a line after
Line 4 and, as there isn't one, the program ends.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Exit" "Article 12 - Conditional Statements - The EXIT Instruction"

@{B}@{U}@{JCENTER}CONDITIONAL STATEMENTS - THE EXIT INSTRUCTION@{UB}@{UU}
@{JLEFT}
Before proceeding to our next example, I will describe the EXIT instruction
which is used in this example. This article is a good place to discuss
it as EXIT is widely used in conditional statements to allow the program
to cease in some circumstances but continue in others. This is illustrated
in Line 9 of @{"Example12-5" LINK "Tossing"46} where we EXIT if the user enters a wrong key.
We will see a lot of other examples of its use in further example
programs.

See also @{"RETURN" LINK "ARB:Articles_11-20/16.Functions-Internal/Return"} in Article 16.

@{B}EXIT@{UB} causes the ARexx program to immediately stop. All program code after
it is ignored and control returns to the platform from which the ARexx
program was launched.

It can be used in one of these ways:-

  EXIT

  EXIT Expression

When the simple format (EXIT) is used, the program simply stops without
passing any information back to the program that launched it.

When used with an "Expression", the "Expression" can be a "string" or
a "numeric".

@{B}If "Expression" is a "number"@{UB} or a symbol holding a numeric value, and
the ARexx program was launched from AmigaDOS with RX, then a message will
appear in the CLI window in a similar manner to AmigaDOS "Return Code"
messages. Try out this program:-

  /* Example12-2 */

  SAY 'Enter a number'
  PULL Number
  EXIT Number

If you RX this and enter an integer number, say 5, then AmigaDOS will
respond with a message such as:-

  Command returned 5

If you enter a non integer number or non numeric characters then AmigaDOS
will respond with:-

  Command returned 10/47: Arithmetic conversion error

because it tries to convert the returned expression into an integer
number.

If the ARexx program was launched from within an AmigaDOS script, then
you can exit ARexx with various return values depending on the conditions
and allow the AmigaDOS script to interpret the return code it receives
and take different actions for different code numbers just as you can
with return codes from AmigaDOS commands. AmigaDOS scripts can use these
commands:-

  IF FAIL    Acts if return code 20 or more
  IF ERROR   Acts if return code 10 or more
  IF WARN    Acts if return code 5 or more

If a host program is written in such a way as to accept return codes,
then EXIT could be used to send code numbers back to the host
program.

@{B}"Expression" can be a "string".@{UB} This is useful if you are calling an ARexx
program from an external program. The external program can then access
and use the "expression".

We can illustrate this with the following two programs. The first of these
uses two items that we have not yet covered. They are the @{"CALL" LINK "ARB:Articles_11-20/16.Functions-Internal/Call"} instruction
and the special symbol @{"RESULT" LINK "ARB:Articles_11-20/16.Functions-Internal/Result"} both of which will be covered in
@{"Article 16" LINK "ARB:Articles_11-20/16.Functions-Internal/Main"}

They are quite simple really. CALL, in this context, allows you to launch
one ARexx program from within another. RESULT is one of ARexx's special
symbols. In this context, RESULT will automatically be assigned the value
of the "expression" that follows the EXIT instruction in the other
program.

  /* Example12-3 */

  SAY 'I am Example12-3 and I am now going to Example12-4' ; SAY
  CALL 'Example12-4.rexx'
  SAY ; SAY 'I am back from Example12-4 and have received this string
             from it:-' ; SAY
  SAY RESULT


  /* Example12-4 */

  Item = 'This string is from Example12-4'
  SAY 'I am Example12-4 and I will send this string back to
       Example12-3:-' ; SAY
  SAY Item
  EXIT Item

If you RX Example12-3 you will get this display:-

  I am Example12-3 and I am now going to Example12-4

  I am Example12-4 and I will send this string back to Example12-3:-

  This string is from Example12-4

  I am back from Example12-4 and have received this string from it:-

  This string is from Example12-4

The symbol "Item" has been given a value in Example12-4 which is sent
back to Example12-3 by the line:-

  EXIT Item

The value of "Item" is transferred to the special symbol RESULT in the
last line of Example12-3.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Tossing" "Article 12 - Conditional Statements - Example - Tossing A Coin"

@{B}@{U}@{JCENTER}CONDITIONAL STATEMENTS - TOSSING A COIN@{UB}@{UU}
@{JLEFT}
An example program using DO blocks with IF...THEN statements is shown
in Example12-5. I will show its lines below as I explain them. If you
want to read it all in one go then @{"click here" LINK "ARB:Articles_11-20/Example12-5.rexx/MAIN"}.

@{B}Lines 1 and 2@{UB}:-

  1    correct = 'You won'
  2    wrong = 'You lost'

set up symbols to be used with the SAY instructions in lines 14, 15, 19,
20. This does not save much in this small program but it demonstrates
that, if you have long strings that will be used more than once, then
you can save a lot by assigning the strings as symbol values and then
SAYing the symbols.

@{B}Line 3@{UB}:-

  3    CALL RANDOM(,,TIME('s'))

initialises the RANDOM() function. I will explain this fully later on
but for those wanting to jump ahead and read up on how RANDOM works then
double click on @{"here" LINK "ARB:Articles_21-30/21.Functions-Random/MAIN"}.

Just forget about Line 3 for the time being.

@{B}Lines 4-6@{UB}:-

  4    SAY 'c'x'Coin Toss Program' ; SAY
  5    SAY 'Enter your choice - H for Heads or T for Tails' ; SAY
  6    PULL choice

should not need explanation

@{B}Line 7@{UB}:-

  7    IF choice ~= 'H' & choice ~= 'T' THEN DO

uses an IF that checks for two possibilities with the @{"comparison operators" LINK "ARB:Articles_11-20/11.Comparison_Operators/MAIN"}
@{B}~=@{UB} (Not Equal) and the @{"logical operator" LINK "ARB:Articles_11-20/13.Logical_Operators/MAIN"} @{B}&@{UB} (And). All together, this line
means that "if the user does not enter "H" @{B}and@{UB} does not enter "T" then
DO lines 8 and 9.

@{B}Lines 7-10@{UB}:-

  7    IF choice ~= 'H' & choice ~= 'T' THEN DO
  8      SAY ; SAY 'Wrong entry'
  9      EXIT
 10    END

are an example of a DO-END block after an IF without an ELSE.

@{B}Line 8@{UB} tells the user that he made a wrong entry (i.e. neither an "H"
nor a "T").

@{B}Line 9@{UB} uses the EXIT instruction to tell ARexx to finish executing the
program.

@{B}Line 11@{UB}:-

 11    headtail = RANDOM(1,2)

again uses the RANDOM() function (see Line 3 above). With this usage,
it assigns the number 1 or 2 in a random fashion to the symbol "headtail".
No other value can be given to this symbol.

@{B}Lines 12-21@{UB}:-

  12   IF headtail = 1 THEN DO
  13     SAY ; SAY 'HEADS came up'
  14     IF choice = H THEN SAY correct
  15     ELSE SAY wrong
  16   END
  17   ELSE DO
  18     SAY ; SAY 'TAILS came up'
  19     IF choice = T THEN SAY correct
  20     ELSE SAY wrong
  21   END

are an example of an IF...THEN...ELSE in which a DO-END block is executed
for both the THEN and the ELSE options. Note that both of the DO's need
their own END's. They are also an example of the fact the IF statements
can be @{"nested" LINK "Nested"}.

This program does not enable you to play more than once without RX-ing
the program again. When we look at DO loops more fully in @{"Article 14" LINK "ARB:Articles_11-20/14.Do-End_Loops-2/Tossing"} I
will expand this program to make it more versatile.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Nested" "Article 12 - Conditional Statements - Nested Statements"

@{B}@{U}@{JCENTER}NESTED IF...THEN...ELSE STATEMENTS@{UB}@{UU}
@{JLEFT}
@{"Lines 12 - 21" LINK "Tossing"69} in Example12-5 above demonstrated that IF...THEN...ELSE
statements can be @{B}nested@{UB} inside each other. One of the following formats
can be used for nested IF...THEN...ELSE statements:-

1. The nested IF...THEN may immediately follow the first one, as in:-

   IF ... THEN IF ... THEN ....

   or:-

   IF ... THEN
      IF ... THEN ....

   @{"Lines 2 and 3" LINK "Nested"60} of Example12-6 below is an example of this sort of format.

2. The nested IF...THEN may be anywhere within a DO..END block of
   programming code that follows the first IF...THEN, as in:-

   IF ... THEN DO
     program code
     IF ... THEN DO
       program code
     END
     program code
   END

3. If there are ELSE statements, the format may look like this:-

   IF ... THEN DO
     program code
     IF ... THEN DO
       program code
     END
     ELSE DO
       program code
     END
     program code
   END
   ELSE DO
     program code
     IF ... THEN DO
       program code
     END
     ELSE DO
       program code
     END
     program code
   END

If you are using DO-END statements within nested IFs then you should be
careful to ensure that every DO has its own END.

There can also be problems, if you are not careful, with ELSE statements.
This is illustrated by the following example program, which is supposed
to display all even numbers between 3 and 8:-

 /* Example12-6.rexx */
 /* This program does not work properly!! */

 1. DO x = 1 TO 10
 2. IF x > 2 & x < 9 THEN
 3.   IF x % 2 = x / 2 THEN SAY x 'is even'
 4. ELSE SAY 'X =' x 'which is outside the range 3 - 8'
 5. END

Lines 1 and 5 set up a loop to be carried out 10 times, i.e. for all values
of symbol "x" from 1 to 10.

Line 2 tests to see if the number held by the symbol "x" is within the
range 3 to 8. It says:-

  IF x > 2 & x < 9 THEN
  IF x is greater than 2 AND x is less than 9 THEN

If this statement is true, then the IF in line 3 is carried out, which
is, in effect, a "nested IF".

Line 4 is supposed to be an ELSE for the IF in Line 2, i.e. it is supposed
to tell you that the value held by "x" is outside the range 3 to 8 if
Line 2 is false.

What this program will display, however, is:-

  X = 3 which is outside the range 3 - 8
  4 is even
  X = 5 which is outside the range 3 - 8
  6 is even
  X = 7 which is outside the range 3 - 8
  8 is even

This is @{B}NOT@{UB} what was intended!! The even numbers in the range are being
shown (as desired) but the odd numbers in the range are being shown as
@{B}outside@{UB} the range!

@{B}So what has happened??@{UB}

The ELSE in Line 4 has @{B}bound@{UB} itself to the @{B}second@{UB} IF...THEN in Line 3,
not the first IF...THEN in Line 2

When IF statements are nested and ELSE is used for any one of them
then:-

- the @{B}innermost@{UB} ELSE will bind itself to the @{B}innermost@{UB} IF...THEN

- the @{B}outermost@{UB} ELSE will bind itself to the @{B}outermost@{UB} IF...THEN

- any other intermediate ELSEs will bind themselves to the appropriate
  IF...THENs in the order in which they appear working from the innermost
  one outwards.

So how do we overcome the problem if an @{B}inner@{UB} IF...THEN does @{B}not@{UB} need
an ELSE but the @{B}outer@{UB} IF...THEN @{B}does@{UB} need an ELSE? - Read on to find out
about the @{"NOP" LINK "Nop"} instruction!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Nop" "Article 12 - Conditional Statements - The NOP Instruction"

@{B}@{U}@{JCENTER}CONDITIONAL STATEMENTS - THE NOP INSTRUCTION@{UB}@{UU}
@{JLEFT}
NOP means "No OPeration". In other words "Do nothing".

Why would we need an instruction to tell ARexx to do nothing?!?!

To explain this, let's carry on from Example12-6 above which we found
was doing the wrong thing.

To get it to do the right thing, we need an ELSE for each of the nested
IFs even though the innermost IF does not really need an ELSE.

So, we tell the innermost ELSE to @{B}do nothing@{UB} as in this correction of
@{"Example12-6" LINK "Nested"55}:-

 /* Example12-7.rexx */
 /* This is a correction to Example12-6 */

 1. DO x = 1 TO 10
 2. IF x > 2 & x < 9 THEN
 3.   IF x % 2 = x / 2 THEN SAY x 'is even'
 4.   ELSE NOP
 5. ELSE SAY 'X =' x 'which is outside the range'
 6. END

Now our display correctly shows this:-

  X = 1 which is outside the range
  X = 2 which is outside the range
  4 is even
  6 is even
  8 is even
  X = 9 which is outside the range
  X = 10 which is outside the range

Each of the two IF...THENs have their own ELSE and there is no problem.
(Not a very practical program but it demonstrates the point well
enough!)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
