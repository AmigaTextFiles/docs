@DATABASE "ARB19"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 19 - Built In Functions For Numerics"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 19 - BUILT IN FUNCTIONS WHICH DEAL WITH NUMERICS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}
@{JLEFT}

If you are wanting to play around with numbers, there are a few functions
that will help you do this.

I have included in this category some functions that convert characters
to their @{"ASCII codes" LINK "ARB:Appendices/App-C_ASCII_Codes/MAIN"} and vice versa.
@{JCENTER}

@{" The ABS()  Function        " LINK "Abs()"}
@{" The SIGN() Function        " LINK "Sign()"}
@{" MAX() & MIN() Functions    " LINK "Max()"}
@{" The TRUNC() Function       " LINK "Trunc()"}
@{" Conversion Functions:-     " LINK "Conversion"}
@{"    B2C()                   " LINK "B2C"}
@{"    C2B()                   " LINK "C2B"}
@{"    C2D()                   " LINK "C2D"}
@{"    C2X()                   " LINK "C2X"}
@{"    D2C()                   " LINK "D2C"}
@{"    D2X()                   " LINK "D2X"}
@{"    X2C()                   " LINK "X2C"}
@{"    X2D()                   " LINK "X2D"}
@{" Hex-Dec Conversion Program " LINK "HexDec"}
@{" D2B()  B2D()  X2B()  B2X() " LINK "Own"}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Abs()" "Article 19 - Built In Functions - ABS()"

@{B}@{U}@{JCENTER}THE ABS() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:  ABS(number)

This will give you the absolute value of a number ignoring its sign. For
example:-

  SAY ABS(-3.33)           --> 3.33
  SAY ABS(3.33)            --> 3.33

  x = 3 * -5 ; SAY ABS(x)  --> 15


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Sign()" "Article 19 - Built In Functions - SIGN()"

@{B}@{U}@{JCENTER}THE SIGN() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:  SIGN(number)

This will return a value of:-

   1 if the number is positive
   0 if the number is zero
  -1 if the number is negative

For example:-

  SAY SIGN(33.3)    --> 1
  SAY SIGN(0)       --> 0
  SAY SIGN(-0.66)   --> -1

  x = 3 ; y = -5 ; SAY SIGN(x * y)   --> -1

NOTE - my two versions of the AREXX manual both state that a return of
1 is given if the number is positive or zero but in actual fact when the
number is zero the SIGN() function returns zero as indicated in the above
example (try it out!).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Max()" "Article 19 - Built In Functions - MAX() & MIN()"

@{B}@{U}@{JCENTER}THE MAX() & MIN() BUILT IN FUNCTIONS@{UB}@{UU}
@{JLEFT}
Syntax:  MAX(number,number [,number][,.......]
         MIN(number,number [,number][,.......]

Where you see options ending with "......." it indicates that the number
of options (in this case numbers) can be determined by the user. The
essential arguments require two numbers. The user determines how many more
than two are to be inserted, up to a maximum of 15. Built in Functions
cannot be used with more than 15 arguments.

These two functions return the maximum or minimum value, respectively,
of the numbers specified in the arguments. For example:-

  x = 5.67 ; y = 2 ; z = -45.3
  SAY MAX(x,y,z,32.6)           --> 32.6
  SAY MIN(x,y,z,32.6)           --> -45.3

"But my programs will handle a lot more than 15 numbers so how can I get
the minimum and maximum?" I hear you say!

This is fairly simple, really, and a lot simpler than putting a lot of
numbers into one of these two functions.

Let's say that you have a symbol called "Number" and that you know the
range of values that it will hold during the program will be somewhere
between 0 and 1000. Set up two symbols called "Min" and "Max" at the start
of your program as follows:-

  Min = 1000
  Max = 0

Now have some program coding like this:-

  IF Number > Max THEN Max = Number
  IF Number < Min THEN Min = Number

Now the symbols "Min" and "Max" will reduced or increased respectively
each time "Number" goes below the previous minimum or above the previous
maximum.

This technique is illustrated in this example:-

  /* Example19-1 */

  CALL RANDOM(,,TIME('s'))
  Max = 1
  Min = 1000

  DO FOR 100
    Number = RANDOM(1,1000)
    IF Number > Max THEN Max = Number
    IF Number < Min THEN Min = Number
  END

  SAY 'Maximum random number generated =' Max
  SAY 'Minimum random number generated =' Min

(Sorry to use @{"RANDOM" LINK "ARB:Articles_21-30/21.Functions-Random/Main"} again before we have studied it properly but it is
a good way to get a lot of numbers!)

This program generates, 100 times, a random number which is within the
range 1 to 1000. As no number can be below 1 and none above 1000, I have
set the symbols "Min" and "Max" to 1000 and 1 respectively.

Each time a number is generated, it is compared to both the symbols "Min"
and "Max". If it is less than "Min" then "Min" is made equal to "Number".
If it is greater than "Max" then "Max" is made equal to "Number".

If you RX this program, you will find that you will not always get minimums
of 1 and maximums of 1000 as there is no guarantee that random numbers
will reach both the upper and the lower limits.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Trunc()" "Article 19 - Built In Functions - TRUNC()"

@{B}@{U}@{JCENTER}THE TRUNC() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Syntax:  TRUNC(number[,places])

This will return the integer part of the number followed by the number
of decimal places that you specify. For example:-

  SAY TRUNC(13.1234567,3)             --> 13.123
  SAY TRUNC(0.0054,7)                 --> 0.0054000
  x = 5 ; y = 3 ; SAY TRUNC(x/y,2)    --> 1.66
  SAY TRUNC(55.432,0)                 --> 55
  SAY TRUNC(55.432)                   --> 55

The last and second last examples are the same because, if the "Places"
option is omitted, a default value of 0 is used.

Note that there is @{B}no@{UB} rounding of the result. It merely truncates the
result to the specified number of places.

If you want to have numbers rounded off to set number of places then you
need to use the @{"NUMERIC" LINK "ARB:Articles_31-40/31.Numbers_More/Numeric"} instruction which we will discuss in Article
31.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Conversion" "Article 19 - Built In Functions - Conversion Functions"

@{B}@{U}@{JCENTER}THE CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}
There are 8 functions dealing with the conversion of numbers between binary,
decimal and hexadecimal, and between characters and their ASCII code numbers.
These are:-

For   Hexadecimal -> Decimal       @{"X2D()" LINK "X2D"}
For   Decimal     -> Hexadecimal   @{"D2X()" LINK "D2X"}

For   Hexadecimal -> Character     @{"X2C()" LINK "X2C"}
For   Character   -> Hexadecimal   @{"C2X()" LINK "C2X"}

For   Binary      -> Character     @{"B2C()" LINK "B2C"}
For   Character   -> Binary        @{"C2B()" LINK "C2B"}

For   Decimal     -> Character     @{"D2C()" LINK "D2C"}
For   Character   -> Decimal       @{"C2D()" LINK "C2D"}

The characters have these meanings:-

  B - Binary number
  C - Character
  D - Decimal number
  X - Hexadecimal number
  2 - TO

Thus:-

@{B}B2C()@{UB} - Convert ASCII code number in @{B}Binary@{UB} form
        @{B}TO @{UB}a @{B}Character@{UB}.

@{B}C2B()@{UB} - Convert a @{B}Character@{UB}
        @{B}TO @{UB}its ASCII code number in @{B}Binary@{UB}.

@{B}D2C()@{UB} - Convert ASCII code number in @{B}Decimal@{UB}
        @{B}TO @{UB}a @{B}Character@{UB}.

@{B}C2D()@{UB} - Convert a @{B}Character@{UB}
        @{B}TO @{UB}its ASCII code number in @{B}Decimal@{UB}.

@{B}X2C()@{UB} - Convert ASCII code number in @{B}heXadecimal@{UB} form
        @{B}TO @{UB}a @{B}Character@{UB}.

@{B}C2X()@{UB} - Convert a @{B}Character@{UB}
        @{B}TO @{UB}its ASCII code number in @{B}heXadecimal@{UB}.

@{B}D2X()@{UB} - Convert a @{B}Decimal@{UB} number
        @{B}TO @{UB}a @{B}heXadecimal@{UB} number.

@{B}X2D()@{UB} - Convert a @{B}heXadecimal@{UB} number
        @{B}TO @{UB}a @{B}Decimal number@{UB}.

@{"Click here" LINK "HexDec"} for an example program to illustrate the use of some of these
functions.

@{B}@{U}Note that there are no functions equivalent to:-@{UB}@{UU}

   D2B()   B2D()   X2B()   B2X()

(But you can @{"make your own!!" LINK "Own"}

However, this can be rectified by using these combinations:-


   D2B()  =   C2B(D2C())

   e.g.   SAY C2B(D2C(97))  --> 01100001

   B2D()  =   C2D(B2C())

   e.g.   SAY C2D(B2C(01100001)) --> 97

   X2B()  =   C2B(X2C())

   e.g.   SAY C2B(X2C(7D))  --> 01111101

   B2X()  =   C2X(B2C())

   e.g.   SAY C2X(B2C(01111101))  --> 7D


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Own" "Article 19 - Built In Functions - D2B()  B2D()  X2B()  B2X()"

@{B}@{U}@{JCENTER}YOUR OWN  D2B()  B2D()  X2B()  B2X()  CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

If you want to use the non existing functions:-

   D2B()   B2D()   X2B()   B2X()

then you could create your own set of internal functions in a little script
and add it to any program in which you wish to use them. This is
illustrated in Example19-3 which follows.

To use it yourself, all you need do is to save all the lines after EXIT
and add them to any of your programs. You then use any of the four internal
functions  D2B()  B2D()  X2B()  B2X()  in the same way as the eight built
in functions.

The program is straightforward enough not to need any explanation:-


  /* Example19-3.rexx */

  ECHO "Enter a decimal number"
  PULL Number
  SAY 'Decimal' Number '=' D2B(Number) 'Binary'

  ECHO "Enter a binary number"
  PULL Number
  SAY 'Binary' Number '=' B2D(Number) 'Decimal'

  ECHO "Enter a Hexadecimal number"
  PULL Number
  SAY 'HexaDecimal' Number '=' X2B(Number) 'Binary'

  ECHO "Enter a binary number"
  PULL Number
  SAY 'Binary' Number '=' B2X(Number) 'Hexadecimal'

  EXIT

  D2B:

    PROCEDURE
    ARG Number

  RETURN C2B(D2C(Number))

  B2D:

    PROCEDURE
    ARG Number

  RETURN C2D(B2C(Number))

  X2B:

    PROCEDURE
    ARG Number

  RETURN C2B(X2C(Number))

  B2X:

    PROCEDURE
    ARG Number

  RETURN C2X(B2C(Number))


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "B2C" "Article 19 - Built In Functions - B2C()"

@{B}@{U}@{JCENTER}THE B2C() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}
@{B}B2C()@{UB} converts an @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{"binary" LINK "ARB:Misc/Glossary/Binary"} form @{B}TO @{UB}a @{B}character@{UB}.

The usage is:-

  B2C(string)

where @{"string" LINK "ARB:Misc/Glossary/Strings"} is the number to be converted.

The function returns the character(s) that the binary number ASCII code
represents.

Example:-

  SAY B2C(01100001)   --> a

The binary number should have 8 digits.

More than one binary number can be included. For example:-

  SAY B2C(011000010110001001100011)  --> abc

          01100001 = a
                  01100010 = b
                          01100011 = c

Each group of eight digits represent one character


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "C2B" "Article 19 - Built In Functions - C2B()"

@{B}@{U}@{JCENTER}THE C2B() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}C2B()@{UB} converts a @{B}character@{UB} @{B}TO @{UB}its @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{"binary" LINK "ARB:Misc/Glossary/Binary"} form.

The usage is:-

  C2B(string)

where @{"string" LINK "ARB:Misc/Glossary/Strings"} is a character or a symbol holding an equivalent value.

The function returns the binary number representing the ASCII code for
the character(s).

Example:-

  SAY C2B('a')        --> 01100001

More than one character can be in the string. For example:-

  SAY C2B('abc')      --> 011000010110001001100011

Each group of eight digits represent one character


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "C2D" "Article 19 - Built In Functions - C2D()"

@{B}@{U}@{JCENTER}THE C2D() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}C2D()@{UB} converts a @{B}character@{UB} @{B}TO @{UB}its @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{"binary" LINK "ARB:Misc/Glossary/Binary"} form.

Its usage can be one of:-

  C2D(string)
  C2D(string,number)

where @{"string" LINK "ARB:Misc/Glossary/Strings"} is the number to be converted.

The function returns a decimal number representing the ASCII code for the
character(s).

Example:-

  SAY C2D('a')        --> 97

More than one character up to a @{B}maximum of four@{UB} can be included.
For example:-

  SAY C2D('abc')      --> 6382179

At first glance, this number 6382179 does not appear to relate to any of
the ASCII codes belonging to 'abc'. However, if you then use:-

  SAY C2B('abc')      --> 011000010110001001100011

This binary number is the equivalent of the 6382179 that we got with C2D().

If the option @{B}number@{UB} is used then the string is truncated to "number" of
characters starting from the @{B}RIGHT@{UB} end of the string.

For example:-

  SAY C2D('abc',1)     --> 99         99 is the ASCII code for 'c')

  SAY C2D('abc',2)     --> 25187      25187 = 0110001001100011
                                              01100010 = b
                                                      01100011 = c


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "C2X" "Article 19 - Built In Functions - C2X()"

@{B}@{U}@{JCENTER}THE C2X() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}C2X()@{UB} converts a @{B}character@{UB} TO its @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{"hexadecimal" LINK "ARB:Misc/Glossary/Hexadecimal"}.

Its usage is:-

  C2X(string)

where @{"string" LINK "ARB:Misc/Glossary/Strings"} is the character to be converted.

The function returns a hexadecimal number representing the ASCII code for
the characters(s).

For example:-

  SAY C2X('z')        --> 7A

More than one character can be included in the string. For example:-

  SAY C2X('MNO')      --> 4D4E4F

                          4D = M
                          4E = N
                          4F = O


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "D2C" "Article 19 - Built In Functions - D2C()"

@{B}@{U}@{JCENTER}THE D2C() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}D2C()@{UB} converts an @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{B}decimal@{UB} form TO a @{B}character@{UB}.

The usage is:-

  D2C(number)

where "number" is the decimal number to convert

The function returns the character(s) that the decimal ASCII code
represents.

Example:-

  SAY D2C(97)         --> a

Numbers representing more than one character can be included. For example:-

  SAY D2C(6382179)    --> abc

The 6382179 is the same number as used in one of the @{"C2D()" LINK "C2D"20} examples.

You can only use numbers that represent up to a maximum of 4 characters.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "D2X" "Article 19 - Built In Functions - D2X()"

@{B}@{U}@{JCENTER}THE D2X() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}D2X()@{UB} converts a @{B}decimal@{UB} number TO a @{"hexadecimal" LINK "ARB:Misc/Glossary/Hexadecimal"} number.

Its usage can be one of:-

  D2X(number)
  D2X(number,digits)

where "number" is the number to be converted and "digits"

The function returns a hexadecimal number equal to the original decimal
number.

Example:-

  SAY D2X(250)        --> FA

  SAY D2X(930991)     --> E34AF

(See @{"Example19-2" LINK "HexDec"178} for an example of its use.)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "X2C" "Article 19 - Built In Functions - X2C()"

@{B}@{U}@{JCENTER}THE X2C() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}


@{B}X2C()@{UB} converts @{"ASCII" LINK "ARB:Misc/Glossary/ASCII"} code number in @{"hexadecimal" LINK "ARB:Misc/Glossary/Hexadecimal"} form @{B}TO @{UB}a @{B}character@{UB}.

Its usage is:-

   X2C(string)

where @{"string" LINK "ARB:Misc/glossary/Strings"} is the hexadecimal number to convert.

The function returns character(s) that the hexadecimal number ASCII code
represents.

Example:-

   SAY X2C(7A)         --> z

   SAY X2C(797A)       --> yz


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "X2D" "Article 19 - Built In Functions - X2D()"

@{B}@{U}@{JCENTER}THE X2D() CONVERSION FUNCTION@{UB}@{UU}
@{JLEFT}

@{B}X2D()@{UB} converts a @{"hexadecimal" LINK "ARB:Misc/Glossary/Hexadecimal"} number TO a @{B}decimal number@{UB}.

The function returns a decimal number equal to the original hexadecimal
number.

Its usage is:-

   X2D(string)

where @{"string" LINK "ARB:Misc/Glossary/Strings"} is the hexadecimal number to be converted.

   SAY X2D(FA)         --> 250

   SAY X2D(3FA9)       --> 16297

(See @{"Example19-2" LINK "HexDec"171} for an example of its use.)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "HexDec" "Article 19 - Built In Functions - Example Program Hex-Dec Converter"

@{B}@{U}@{JCENTER}EXAMPLE PROGRAM - HEXADECIMAL-DECIMAL CONVERTER PROGRAM@{UB}@{UU}
@{JLEFT}
To demonstrate the use some of the @{"conversion functions" LINK "Conversion"}, I have written
a program to convert hexadecimal numbers to decimal numbers and vice versa.
This program will:-

- give a menu to ask the user if Hex to Dec or Dec to Hex is wanted, or
  whether the program should be quitted.

- ask for the number to be converted and reject numbers that do not conform
  to decimal or hexadecimal format.

- reject numbers larger than decimal 268435455 (funny things happen with
  larger numbers).

O.K. - you are supposed to be learning how to program in ARexx. So, using
the above specification, how about having a go at this yourself and
comparing your program with mine? From now on I will sometimes ask you to
try to write a program before you look at my program. Please @{"READ ME" LINK "ARB:Misc/Using_ARB/Writing"}.

@{"Click here" LINK "ARB:Articles_11-20/Example19-2.rexx/MAIN"} to read the program in full.

Read on below for a line by line explanation.

@{B}Line 1@{UB}:-

   1   Clear = 'c'x   /* clear the window */

sets up the symbol "Clear" to hold the hexadecimal value 'c'x which will
clear the screen when SAYed as in @{B}Line 8.@{UB}

@{B}Line 2@{UB}:-

   2   Down = 'a'x /* move cursor down one line */

sets up the symbol "Down" to hold the hexadecimal value 'a'x which will
move the cursor down one line thus causes a blank line to be displayed
as in @{B}Lines 8, 9, 15, 19 and 43.@{UB}

@{B}Line 3@{UB}:-

   3   LMarg = COPIES(' ',23) /* left margin 23 spaces */

uses "COPIES" to create a string consisting of 23 spaces (the ' ' in
COPIES(' ',23) has one space between the two quotes). When "LMarg" is
SAYed, as in @{"Lines 9-11" LINK "HexDec"71}.

23 spaces will be printed before the string that follows "LMarg" so as
to get all lines reasonably centred and starting one under the
other.

@{B}Lines 4-6@{UB}:-

   4   Item =         /* user's selection from menu */
   5   Number = 0     /* number to convert */
   6   ErrMessage =   /* message re incorrect number */

describe the rest of the symbols used in the program.

@{B}Lines 7@{UB}:-

   7   DO FOREVER

is the start of the main program loop that can only be exited by the user
entering "Q" at Line 12. The loop ends at @{"Line 41" LINK "HexDec"192}.

@{B}Lines 8-12@{UB}:-

   8     SAY Clear||Down||CENTRE(' DECIMAL HEXADECIMAL CONVERTER',77)

   9     SAY Down||LMarg 'Enter H for Hex to Dec'
  10     SAY LMarg 'Enter D for Dec to Hex'
  11     SAY LMarg 'Enter Q to Quit Program'
  12     PULL Item

tell the user what to enter then PULL the entry at @{B}Line 12@{UB}.

@{B}Line 13@{UB} is the first test of the user entry:-

  13   IF Item = 'Q' THEN EXIT

It exits the program completely if "Q" is selected at @{B}Line 12@{UB}.

@{B}Lines 14-18@{UB}:-

  14   IF Item ~= 'H' & Item ~= 'D' THEN DO
  15     SAY Down||LMarg 'Wrong selection!!'
  16     CALL PressAny
  17     ITERATE
  18   END

test for a wrong entry. Only "H" or "D" are allowable and if neither is
entered then Lines 15-17 are activated.

The ITERATE at @{B}Line 17@{UB} will cause the next iteration of the main loop
started at @{"Line 7" LINK "HexDec"60}.

@{B}Lines 19-20@{UB} get the number to convert:-

  19   SAY Down||LMarg 'Enter number to convert'
  20   PULL Number

@{B}Line 21@{UB}:-

  21   DROP ErrMessage

DROPs the symbol "ErrMessage" so that I can test it at @{"Line 34" LINK "HexDec"156} to see
if it has picked up a value between this Line21 and Line 34. As we may
be going through the loop many times, "ErrMessage" may reach this point
in a later iteration of the loop still having a value it picked up in
a previous iteration. This old value must be got rid of or we will have
erroneous program operation!

@{B}Lines 22-25@{UB}:-

  22   IF Item = 'H' THEN DO
  23     IF LENGTH(Number) > 7 THEN ErrMessage = 'too large'
  24     IF DATATYPE(Number,'X') = 0 THEN ErrMessage = 'not hexadecimal'
  25   END

test to see if a hexadecimal number conversion was requested at @{"Line 12" LINK "HexDec"67}
and, if so, test it to see if:-

- "Number" is longer than 7 characters. Hex FFFFFFF is the decimal
number
  268435455 above which we do not want to go.

- "Number" is a legitimate hexadecimal number.

@{B}Lines 26-33@{UB}:-

  26   ELSE DO
  27     IF DATATYPE(Number,'N') = 0 THEN ErrMessage = 'not decimal number'
  28     ELSE DO
  29       IF DATATYPE(Number,'W') = 0 THEN ErrMessage = 'not an integer'
  30       IF SIGN(Number) = -1 THEN ErrMessage = 'negative'
  31       IF Number > 268435455 THEN ErrMessage = 'too large'
  32     END
  33   END

are only reached if "Item" is "D" for conversion of a decimal
number

@{B}Line 27@{UB} tests for a legitimate number and sets up "ErrMessage" if it is
not. This must be done before the test in @{B}Lines 29-31@{UB} can be carried out
as a non-number may stop the program with error messages in Lines 29 &
30..

@{B}Line 28-32@{UB} are only reached if it is a legitimate decimal number. However,
we still need to reject:-

- non integer numbers (@{B}Line 29@{UB})
- negative numbers    (@{B}Line 30@{UB})
- numbers too big     (@{B}Line 31@{UB})

@{B}Line 34-36@{UB}:-

  34   IF SYMBOL('ErrMessage') = 'VAR' THEN DO
  35     CALL WrongNumber
  36     ITERATE
  37   END

detect if the symbol "ErrMessage" has a value or not. After the @{"Line 21 DROP" LINK "HexDec"103}
instruction, SYMBOL('ErrMessage') will return 'LIT' if "Errmessage" still
has no value and the program will go to @{B}Line 38@{UB}. If "ErrMessage" @{B}has@{UB} been
given a value in the area @{"Lines 22-25" LINK "HexDec"114} or @{"Lines 27-31" LINK "HexDec"130} due to an erroneous
input then it will return 'VAR' and the program will go to @{B}Line 35@{UB} to
call the "WrongNumber" internal function then @{B}Line 36@{UB} for another iteration
of the "DO-FOREVER" loop starting at @{"Line 7" LINK "HexDec"60}.

@{B}Line 38@{UB}:-

  38   IF Item = 'H' THEN SAY LMarg 'Hex' Number '= Dec' X2D(Number)

checks if the conversion is @{B}from hexadecimal@{UB} and, if so, does the conversion
and display.

@{B}Line 39@{UB}:-

  39   ELSE SAY LMarg 'Dec' Number '= Hex' D2X(Number)

is only reached if the conversion is @{B}from decimal@{UB} and does the conversion
and display

@{B}Line 40@{UB}:-

  40   CALL PressAny

is reached in both line 38 and line 39.

@{B}Line 41@{UB}:-

  41 END

is the end of the "DO FOREVER" loop started at @{"Line 7" LINK "HexDec"60}.

@{B}Lines 42-45@{UB}

  42   PressAny:
  43     SAY Down||LMarg 'Press any key to continue'
  44     PULL
  45   RETURN

are the internal function "PressAny" that is called from @{B}Lines 16, 40
and 48@{UB}. Well worth putting into a function for this many calls rather than
having it repeated 4 times.

@{B}Lines 46-49@{UB}:-

  46   WrongNumber:
  47     SAY LMarg 'Number is' ErrMessage '- Try again'
  48     CALL PressAny
  49   RETURN

are the internal function "WrongNumber" called from @{B}Line 35@{UB}. Since this
function is only called once it could have been handled by replacing
@{B}Line 35@{UB} with @{B}Lines 46 and 49@{UB}. However, I wanted to demonstrate that you
can call one internal function from within another which I have done at
@{B}Line 48@{UB}.

So there it all is. How did your attempt at the program compare with this
one?!?! It could differ quite a bit and still work O.K. In programming,
there are often many ways of doing the one job.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
