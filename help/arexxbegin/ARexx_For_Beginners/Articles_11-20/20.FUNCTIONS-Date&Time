@DATABASE "ARB20"
@INDEX "ARB:Misc/Index.Text/Main"
@HELP "ARB:Misc/Help/Main"
@NODE "Main" "ARexx For Beginners - Article 20 - Date & Time Built In Functions"

@{B}@{U}@{JCENTER}AREXX FOR BEGINNERS

ARTICLE 20 - DATE & TIME BUILT IN FUNCTIONS

BY FRANK BUNTON@{UB}@{UU}

@{" COPYRIGHT © FRANK P. BUNTON 1995-1998 " LINK "ARB:Misc/Read_Me_First!!/Copyright"}

@{JCENTER}
@{" The DATE() Function       " LINK "Date()"}
@{" Getting The `Proper' Date " LINK "Getting"}
@{" Other DATE() Options      " LINK "Other"}
@{" The TIME() Function       " LINK "Time()"}
@{" The MILLENNIUM Clock      " LINK "Millennium"}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Date()" "Article 20 - The DATE() Built In Function"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Getting the date seems like a simple task but there are some complexities
that will need explaining. Its full syntax is:-

  DATA([Option][,date][,format])

I am going to leave the "[,date][,format]" part of this format until further
into this article under the heading @{"The Other DATE() Options" LINK "Other"} and look
first at the simple syntax of the DATE() function which is:-

  DATE([Option])

It can be one of the words in the following table. As with other built
in functions you can abbreviate the option word to its first letter
only.

As "Option" is shown in square brackets [] it can be left out:-

  DATE()

in which case the "NORMAL" option from the following table is used
automatically.

In the examples in the table below I am assuming a date of 22nd July
1997

 @{B}@{U}Option Word@{UB}@{UU}  @{B}@{U}            What it Produces          @{UB}@{UU}  @{B}@{U}Example@{UB}@{UU}

  @{"BASEDATE" LINK "Basedate"}    Days since 1st Jan 0001                 729592
  @{"CENTURY " LINK "Century"}    Days since 1st Jan of current century   35632
  @{"DAYS    " LINK "Days"}    Days since 1st Jan this year            203
  @{"EUROPEAN" LINK "European"}    European format DD/MM/YY                22/07/97
  @{"INTERNAL" LINK "Internal"}    Days since 1st Jan 1978                 7142
  @{"JULIAN  " LINK "Julian"}    Date in Julian format YYDDD             97203
  @{"MONTH   " LINK "Month"}    Current month in full in mixed case     July
  @{"NORMAL  " LINK "Normal"}    Normal format DD MMM YY                 22 Jul 1997
  @{"ORDERED " LINK "Ordered"}    Format is YY/MM/DD                      97/07/22
  @{"SORTED  " LINK "Ordered"}    Format is YYYYMMDD                      19970722
  @{"USA     " LINK "Usa"}    Format is MM/DD/YY                      07/22/97
  @{"WEEKDAY " LINK "Weekday"}    Day of week only                        Tuesday


@{JCENTER}=== End of Text ===
@{JLEFT}





@ENDNODE

@NODE "Basedate" "Article 20 - The DATE() Built In Function - BASEDATE Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - BASEDATE OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('B') --> 729592

This gives number of days that have passed since the 1st January 0001.
(Or so the ARexx manual says! A quick calculation and it looks like it
starts counting from 1st January 1BC (there was no year 0). Please let
me know if I have miscalculated - I won't sleep until I know for sure!!!
Seriously, though, @{B}why@{UB} would anyone @{B}ever@{UB} need such a number!??!?


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Century" "Article 20 - The DATE() Built In Function - The CENTURY Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE CENTURY OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('C') --> 35632

If my mathematics is right then the starting day (Day 1) that is used
by ARexx for the "Century" option is 1st January 1900 which is, in reality,
the first day of the @{B}last year of the 19th century!!@{UB} Day 1 of the century
should be @{B}1st January 1901@{UB} (but let's not get into an argument on that
one until we get to 1st January 2000!!). Again, who on earth would ever
want to know?!?


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Days" "Article 20 - The DATE() Built In Function - The DAYS Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE DAYS OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('D') --> 203

A much more useful option. Day 1 is 1st January of the current year and
this option counts from there to the current date.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "European" "Article 20 - The DATE() Built In Function - The EUROPEAN Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE EUROPEAN OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('E') --> 22/07/97

Another rather useful option as Australians use this format (day of month
followed by month) rather than the @{"American" LINK "Usa"} method.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Internal" "Article 20 - The DATE() Built In Function - The INTERNAL Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE INTERNAL OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('I') --> 7142

"Internal" days start from the earliest date that the Amiga will recognise,
i.e. 1st January 1978. However, this date is taken as Day 0, not Day 1
so there is a difference in this method of counting and that for @{"Century" LINK "Century"}.

We will see how this option can be used under the heading
@{"Other DATE() Options" LINK "Other"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Julian" "Article 20 - The DATE() Built In Function - The JULIAN Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE JULIAN OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('J') --> 97203

The "Julian" format puts the last two numbers of the year first then three
digits representing the number of days in the year. Thus:-

  If date is  1st Jan 1997    then     SAY DATE('J') --> 97001
  If date is 31st Dec 1997    then     SAY DATE('J') --> 97365
  If date is 31st Dec 1997    then     SAY DATE('J') --> 97366

There may be some uses for this but I can't think of them at the moment.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Month" "Article 20 - The DATE() Built In Function - The MONTH Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE MONTH OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('M') --> July

This gives you the name of the current month in full, first letter upper
case and the rest lower case. It is the only option that will give the
name of the month in full and its use is illustrated in @{"Example20-1" LINK "Getting"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Normal" "Article 20 - The DATE() Built In Function - The NORMAL Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE NORMAL OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('N') --> 22 Jul 97
SAY DATE()    --> 22 Jul 97

"Normal" is the default option so if no option is specified by the user
then ARexx uses "Normal". For the sake of clarity, I would suggest that
you use the "N" option in the parentheses.

Why is it "Normal"? Who knows! But it is the closest that the ARexx options
come to the AmigaDOS "Date" command format of 22-Jul-97. It is also the
format that was (still is??) used by the Australian Army for dates.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Ordered" "Article 20 - The DATE() Built In Function - ORDERED & SORTED Options"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE ORDERED & SORTED OPTIONS@{UB}@{UU}
@{JLEFT}
SAY DATE('O') --> 97/07/22
SAY DATE('S') --> 19970722

Both these formats can be used for sorting dates into chronological order.
Other date formats are not at all suitable for simple sort routines as
sorts all start from the left most character. If we used normal dates
we would get dates sorted on the day of the month first in numerical order,
then the month in alphabetical order, then years in numerical order. The
years would be all over the place! For example:-

   12 Aug 94
   12 Feb 90
   13 Jan 88
   22 Dec 79
   31 Jan 00

But with "Ordered" or "Sorted" options for the same dates we would
get:-

  @{U}Actual Date@{UU}   @{U}Ordered @{UU}         @{U}Actual Date@{UU}  @{U} Sorted @{UU}

   31 Jan 00    00/01/31
   22 Dec 79    79/12/22          22 Dec 79   19791222
   13 Jan 88    88/01/13          13 Jan 88   19880113
   12 Feb 90    90/02/12          12 Feb 90   19900212
   12 Aug 94    94/08/12          12 Aug 94   19940812
                                  31 Jan 00   20000131

"Ordered" will be O.K. For dates up to 31st December 1999 but, as you
can see above, it will fail for dates from 1st January 2000 as it will
put all dates for 2000 @{B}before@{UB} all other dates! So, with the end of the
1900's rapidly approaching, if you are going to sort dates it would be
best to use "Sorted"


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Usa" "Article 20 - The DATE() Built In Function - The USA Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE USA OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('U') --> 07/22/97

Us "Aussies" will not be using this "back to front" date that the Americans
insist on using! (The above represents 22nd July 1997.)


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Weekday" "Article 20 - The DATE() Built In Function - The WEEKDAY Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - THE WEEKDAY OPTION@{UB}@{UU}
@{JLEFT}
SAY DATE('W') --> Tuesday

Another useful one as it is the only option that gives us the name of
the day. See @{"Example20-1" LINK "Getting"} for an example of its use.


@{JCENTER}=== End of Text ===
@{JLEFT}

@ENDNODE

@NODE "Getting" "Article 20 - The DATE() Built In Function - Getting The Proper Date"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - GETTING THE PROPER DATE@{UB}@{UU}
@{JLEFT}
None of the DATE() options give the date in a format such as:-

  @{B}Monday 22nd July 1997@{UB}

so, as a simple exercise in ARexx and using the DATE() function, try to
write a program that will:-

- give the current date with the correct suffix for ordinal numbers
  as in 1st, 2nd, 3rd, 4th etc.

- give the user the option of whether the day of the week is displayed so
  that it can show one of:-

    Monday 22nd July 1997
    22nd July 1997

Have a go at writing a program to do this but please @{"READ ME" LINK "ARB:Misc/Using_ARB/Writing"} first.

To see my solution in full please @{"click here" LINK "ARB:Articles_11-20/Example20-1.rexx/MAIN"}.

Following line by line description of the program.

   /* Example20-1 */
   /* Copyright © 1995 - Frank Bunton */

   /* Getting the "Proper" Date */

@{B}Lines 1 & 2@{UB}:-

 1. SAY 'c'x'Producing "Proper Date" - Do you want to include day
        name? (Y/N)'
 2. PULL Which

simply ask if the user want the day name included.

@{B}Line 3@{UB}:-

  3. DayName = DATE('W')

uses the @{"Weekday" LINK "Weekday"} option for DATE() to get the name of the day in full.
Logically we would only do this if the user answered "Y" to the question
in @{B}Line 1@{UB} but it takes less programming, and does no harm, to do it this
way and only use it in @{"Line 12" LINK "Getting"134} if it is needed.

@{B}Line 4@{UB}:-

  4. Day = STRIP(RIGHT(DATE('O'),2),'L','0')

uses the @{"Ordered" LINK "Ordered"} option for DATE() from which we can obtain the day of
the month as the rightmost 2 characters. We could just as well have used
the @{"Sorted" LINK "Ordered"} option.

If the date is 9th July 1997, then:-

  DATE('O')  --> 97/0709/

We then use the RIGHT() function to pick up these two characters:-

      RIGHT(DATE('O'),2)
  =   RIGHT('97/07/22'),2)
  --> 09

However, this gives rise to our first problem which is that, when the
day is between 1 and 9, we will end up with a @{B}string@{UB} which has a first
character of "0" (zero), i.e. 01 to 09.

There are a few ways to get rid of this leading zero but the most logical
and straightforward one is in @{B}Line 4@{UB} above. This uses STRIP() with the
"L" option and a "Pad" character of "0" (zero) to remove the leading
zero.

      STRIP(RIGHT(DATE('O'),2),'L','0')
  =   STRIP('09','L','0')
  --> 9

@{B}Line 5@{UB}:-

  5. Month = DATE('M')

uses the @{"Month" LINK "Month"} option to get the month in its full spelling.

@{B}Line 6@{UB}:-

  6. Year = LEFT(DATE('S'),4)

gets the 4 leftmost characters from the @{"Sorted" LINK "Ordered"} option which is the only
option that gives the year in full, e.g. "1997" not "97". Note the we
could @{B}NOT@{UB} use the @{"Ordered" LINK "Ordered"} option instead of sorted as it only gives the
last two numbers of the year.

Now comes our next problem which is to put the proper ordinal number suffix,
i.e. "st" or "nd" or "rd" or "th" onto the number that represents the
day of the week bearing in mind that @{B}not all numbers@{UB} ending in 1, 2 or
3 take the suffixes "st", "nd" or "rd". The numbers 11, 12 and 13, when
used as ordinal numbers, take the "th" suffix.

@{B}Line 7@{UB}:-

  7. Suffix = 'th'

sets up the symbol "Suffix" to be "th" which is the most common one. It
will be changed by @{B}Line 8, 9 or 10@{UB} if necessary.

@{B}Line 8@{UB}:-

   8. IF Day = 1 | Day = 21 | Day = 31 THEN Suffix = 'st'

checks to see if the symbol "Day" holds 1, 21 or 31 in which case the
suffix must be "st".

@{B}Line 9@{UB}:-

  9. IF Day = 2 | Day = 22 THEN Suffix = 'nd'

checks to see if the symbol "Day" holds 2 or 22 in which case the suffix
must be "nd".

@{B}Line 10@{UB}:-

  10. IF Day = 3 | Day = 23 THEN Suffix = 'rd'

checks to see if the symbol "Day" holds 3 or 23 in which case the suffix
must be "rd".

@{B}Line 11@{UB}:-

   11. ProperDate = Day||Suffix Month Year

joins it all together into the symbol "ProperDate" without the day
name.

@{B}Line 12@{UB}:-

   12. IF Which = 'Y' THEN ProperDate = DayName ProperDate

checks to see if the day name is needed (as PULLed in @{"Line 2" LINK "Getting"30}) and, if
so, adds it to the front of "ProperDate".

@{B}Line 13@{UB}:-

   13. SAY ProperDate

displays the "Proper Date".

@{JCENTER}=== End of Text ===
@{JLEFT}










@ENDNODE

@NODE "Other" "Article 20 - The DATE() Built In Function - Other DATE() Option"

@{B}@{U}@{JCENTER}THE DATE() BUILT IN FUNCTION - OTHER DATE() OPTIONS@{UB}@{UU}
@{JLEFT}
This gets a bit complex and is not very important so, if you like, skip
over this and go to the @{"TIME()" LINK "Time()"} function. You can always come back to this
at a later time.

The simple format explained @{"earlier" LINK "Date()"} gives you the @{B}current date@{UB} only, i.e. as
held by the Amiga's system clock. To obtain a date @{B}other than@{UB} the current
date you use the @{B}full@{UB} format which is a little more complex:-

  DATE([options],[date],[format])

  @{B}Options@{UB} - is as explained @{"earlier" LINK "Date()"29}

  @{B}Date@{UB}    - is a positive integer number representing either the number of
            "Internal System Days" (i.e. in the format such as can be
            obtained by @{"DATE('I'" LINK "Internal"}) or the date in  "Sorted" format (i.e. in
            the format such as can be obtained by @{"DATE('S')" LINK "Ordered"}

            The dates must be on or after Amiga's starting date of
            1st January 1978 which is DATE('I') = 0

            My version of ARexx (v1.15) gives an error message if I use
            dates that are greater than 1st January 2100, i.e.:-

                 DATE('I') greater than 44560
                 DATE('S') greater than 21000101

            But I don't think that I'll be around to worry about it then!

  @{B}Format@{UB}  - is "I" or "S" to indicate whether the number used for "Date" is
            an "Internal System" date or a "Sorted" date. If "Format" is
            omitted the "I" is assumed. We have to tell ARexx which date
            format the integer number "Date" is in as some numbers could
            be taken either way.

What this format does is to ask for a DATE in the format specified in
@{B}"Options"@{UB} for a day @{B}other than@{UB} the current date and which is calculated
by reference to the integer number @{B}"Date"@{UB} which is in the @{B}"Format"@{UB} specified
("Internal" or "Sorted").

Why is all this rigmarole needed? Maybe a couple of examples (as follow
the two @{B}questions@{UB} below) may help to clarify it. I will continue to assume
the current date is 22nd July 1997 as I did above.

@{B}Question:  How many days is it until Joe Blow's birthday on 30th November?@{UB}

Today's date (22 Jul 97) in "internal" days is obtained with:-

  DATE('I')

  --> 7142 for 22-Jul-97

You could obtain the internal days for the birthday by using the AmigaDOS
"Date" command to change the Amiga's system date to 30th November 1997
then using DATE('I') again but that is extremely cumbersome!

So let's ask ARexx to do it with:-

  DATE('I',19971130,'S')

  --> 7273

This is saying "give me an internal number of system days (the 'I' at
the start) for the date '19971130' which is a date in the 'S' (sorted)
format".

So the number of days until Joe Blow's birthday is obtained with:-

  SAY DATE('I',19971130,'S') - DATE('I')
  --> 131

@{B}Question:  What will be the date in 131 days time?@{UB}

You can get the answer (on 22-Jul-97) with:-

  SAY DATE('N',DATE('I')+131,'I')
  --> 30 Nov 97

This line is saying "Give me a date in `Normal' format (The 'N' at the
start) for a date which is the current internal number of days + 131 and
the number I am giving you is in "Internal" format (the last 'I')".

There is an example program on the disk @{"Example20-2" LINK "ARB:Articles_11-20/Example20-2.rexx/MAIN"} which is too long
to put in here but it has a lot of comments in it to explain it along
the way. Have a read of it and try it out.

This example program will tell you how many days between the current date
and the date entered by the user.

It also shows you how to check that the user enters a legitimate date.
for example, it rejects the 29th February on non leap years.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Time()" "Article 20 - The TIME() Built In Function"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION@{UB}@{UU}
@{JLEFT}
Getting the time is simpler than getting the date. It has this format:-

  TIME([Option])

The "option" can be one of the words in the following table. As with other
built in functions you can abbreviate the option word to its first letter
only.

As "Option" is shown in square brackets [] it can be left out:-

  TIME()

in which case the "NORMAL" option from the following table is used
automatically.

The following examples assume a current time of 21:12:44 and, for "elapsed",
a period of 33.45 seconds of elapsed time.

 @{B}@{U}Option Word@{UB}@{UU}  @{B}@{U}            What it Produces            @{UB}@{UU}   @{B}@{U}Example@{UB}@{UU}

  @{"CIVIL  " LINK "Civil"}     Current time in 12 hour clock format       9:12PM
  @{"NORMAL " LINK "Normal2"}     Current time in 24 hour format             21:12:44
  @{"HOURS  " LINK "Hours"}     Current time since midnight hours only     21
  @{"MINUTES" LINK "Minutes"}     Current time in minutes since midnight     1272
  @{"SECONDS" LINK "Seconds"}     Current time since midnight in seconds     76364
  @{"RESET  " LINK "Reset"}     Reset the "elapsed time" clock             0.00
  @{"ELAPSED" LINK "Elapsed"}     Seconds on elapsed time clock since reset  33.45


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Civil" "Article 20 - The TIME() Built In Function - The CIVIL Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE CIVIL OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('C') --> 9:12PM

This tells you the time in the plain 12 hour format using the AM or PM
indicator.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Reset" "Article 20 - The TIME() Built In Function - The RESET Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE RESET OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('R') --> 0.00

This resets the "Elapsed Time" clock to zero. See @{"Example20-4" LINK "Elapsed"24} where it
is used at the start of a program. It can also be used anywhere else in
a program when a reset is desired. See @{"Example20-5" LINK "Elapsed"61}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Elapsed" "Article 20 - The TIME() Built In Function - The ELAPSED Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE ELAPSED OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('E') --> 33.45

This gives a positive number to 2 decimal places for the number of seconds
since the "Elapsed Time" clock has been reset. In the above example, 33.45
seconds have elapsed. You can use this option to measure events to one
hundredth of a second.

According to one of my ARexx manuals, this clock is supposed to be started
when the ARexx program is started. However, I have found, with my version
of ARexx (1.15), that the elapsed time clock is @{B}not@{UB} started until one
of the options TIME('E') or TIME('R') is used. Try out these two programs
to test it on your version of ARexx:-

  /* Example20-3.rexx */

  DO x = 1 to 1000
  END
  SAY TIME('E')


  /* Example20-4.rexx */

  CALL TIME('R')
  DO x = 1 to 1000
  END
  SAY TIME('E')


With my set up I get these results:-

  From Example20-3                                --> 0.00
  From Example20-4 on my unaccelerated Amiga 500  --> 3.12
  From Example20-4 on my accelerated   Amiga 1200 --> 0.56

You may well get different times depending on your system.

You may also get a slower time than you normally would if you have other
programs running that are demanding CPU time.

So, quite obviously, in Example20-3 the elapsed time clock is @{B}not@{UB} set
at the start of the program.

As an example of using the "Elapsed Time" clock, try out your reaction
time with Example20-5:-

  /* Example20-5.rexx */
  /* Reaction time Tester */

 1. CALL RANDOM(,,TIME('S'))

 2. DO FOREVER

 3. SAY 'a'x'Test your reaction time - press RETURN when so requested'
 4. Delay = RANDOM(1,10)
 5. CALL TIME('R')
 6. DO UNTIL TIME('E') > Delay
 7. END

 8. SAY 'a'x'Press RETURN'
 9. CALL TIME('R')
10. PULL AnyKey
11. Time = TIME('E')

12. SAY 'Your reaction time was' Time 'seconds'
13. SAY 'a'x'Another Test? (N or RETURN=Y)'
14. PULL AnyKey
15. IF AnyKey = 'N' THEN EXIT

16. END

This program gets a random delay time (@{B}Line 4@{UB}) between 1 and 10 seconds
(so as the user cannot predict when the message to press Return will appear)
then waits until the elapsed time exceeds the delay time (@{B}Line 6@{UB}). RANDOM()
will be discussed in the @{"next article" LINK "ARB:Articles_21-30/21.Functions-Random/MAIN"}.

It then asks the user to press return, resets the clock (@{B}Line 9@{UB}) and gets
the elapsed time (@{B}Line 11@{UB}) after RETURN is pressed (@{B}Line 10@{UB}).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Hours" "Article 20 - The TIME() Built In Function - The HOURS Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE HOURS OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('H') --> 21

This gives a positive integer number for the number of hours since midnight
ignoring the number of minutes and seconds.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Minutes" "Article 20 - The TIME() Built In Function - The MINUTES Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE MINUTES OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('M') --> 1272

This gives a positive integer number for the number of minutes since
midnight ignoring the number of seconds.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Normal2" "Article 20 - The TIME() Built In Function - The NORMAL Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE NORMAL OPTION@{UB}@{UU}
@{JLEFT}

SAY TIME('N') --> 21:12:44
SAY TIME()    --> 21:12:44

"Normal" is the default option so if no option is specified by the user
then ARexx uses "Normal". For the sake of clarity, I would suggest that
you use the "N" option in the parentheses.

Why is it "Normal"? I'm only guessing, but Maybe it's because it is the
same as the time output from the AmigaDOS "Date" command.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Seconds" "Article 20 - The TIME() Built In Function - The SECONDS Option"

@{B}@{U}@{JCENTER}THE TIME() BUILT IN FUNCTION - THE SECONDS OPTION@{UB}@{UU}
@{JLEFT}
SAY TIME('S') --> 76364

This gives a positive integer number for the number of seconds since
midnight.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Millennium" "Article 20 - DATE() & TIME() - The MILLENNIUM Clock"

@{B}@{U}@{JCENTER}DATE() & TIME() - THE MILLENNIUM CLOCK@{UB}@{UU}
@{JLEFT}

O.K. - just for a bit of fun, let's write a program that will tell us:-

   xx Days xx Hours xx Minute xx Seconds until the next MILLENNIUM!!

and keep displaying it showing the remaining time counting downwards

I am assuming that you are reading this @{B}BEFORE@{UB} 1st January 2001!

And if you are one of those who think that the new millennium will start
on 1st January 2000 then you are a year out! It could only start then
if there was a year 0 (zero) between 1 AD and 1 BC but there
@{B}WAS NO SUCH YEAR!@{UB}

@{"Have a go at it yourself" LINK "ARB:Misc/Using_ARB/Writing"} before reading my versions.

@{"Version 1" LINK "v1"} displays the information in the CLI window it was started in.

@{"Version 2" LINK "v2"} displays the information in its own window.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "v1" "Article 20 - DATE() & TIME() - The MILLENNIUM Clock - Version 1"

@{B}@{U}@{JCENTER}DATE() & TIME() - THE MILLENNIUM CLOCK VERSION 1@{UB}@{UU}
@{JLEFT}

    /* Example 20-6.rexx */

    /* The MILLENNIUM Clock - Version 1 */

  1. SAY 'c'x

  2. DO FOREVER
  3.   Days    = 8400 - DATE('I')
  4.   Time = TIME('N')
  5.   Seconds = 60 - RIGHT(Time,2)
  6.   Minutes = 59 - SUBSTR(Time,4,2)
  7.   Hours = 23 - LEFT(Time,2) 
  8.   SAY 'b'x Days 'Days' Hours 'Hours' Minutes 'Minutes' Seconds
           'Seconds until the next MILLENNIUM!!    '

  9. END

This program will use the CLI window in which it was started for its
output.

@{B}Line 1@{UB} - will clear the screen.

@{B}Lines 2 & 9@{UB} - set up a continual loop. The program can only be stopped
by using @{"CTRL-C or the HI command" LINK "ARB:Articles_01-10/03.Command_Utilities/Stopping"}.

@{B}Line 3@{UB} - determines the number of days to go until the new millennium.

The number of days until 1st January 2001 is given by:-

   @{"DATE('I','20010101','S')" LINK "Other"}  =  8401

but as we are counting hours, minutes, seconds as well we will subtract the
current days (DATE('I') from 8400 as there is a "carry" of one when
subtracting.

@{B}Line 4@{UB} - gets the time in the @{"normal" LINK "Normal2"} format which is   hh:mm:ss

We should use this one value to obtain the other data because, if we used
separate readings, we could get an hour ticking over before we got the
minutes, or the minutes ticking over before we got the seconds.

@{B}Line 5-7@{UB} - get the hours, minutes and seconds.

We must subtract from 23, not 24, for the hours as there will be a "carry"
of 1 from the minutes subtraction.

Likewise, we must subtract from 59, not 60, for the minutes as there will
be a "carry" of 1 from the seconds subtraction.

The seconds are subtracted from 60 as they are really the first and there
is no carry.

@{"Version 2" LINK "v2"} is basically the same as this but opens its own window for
the display.

Line 8 - is the actual display. It has 4 spaces between the end of the text
and the closing quote (') as sometimes one or more of the numbers will
change from 2 digits to 1 digit and the next display would be shorter than
the previous one. The spaces will blank out any "overhang" from the
previous SAY.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "v2" "Article 20 - DATE() & TIME() - The MILLENNIUM Clock - Version 2"

@{B}@{U}@{JCENTER}DATE() & TIME() - THE MILLENNIUM CLOCK VERSION 2@{UB}@{UU}
@{JLEFT}

/* Example 20-7.rexx */

/* The MILLENNIUM Clock - Version 2 */

CALL CLOSE('STDOUT')

CALL OPEN('STDOUT','CON:0/11/640/40/Count Down to New Millennium','W')

DO FOREVER

  Days    = 8400 - DATE('I')
  Time = TIME()
  Seconds = 60 - RIGHT(Time,2)
  Minutes = 59 - SUBSTR(Time,4,2)
  Hours = 23 - LEFT(Time,2) 

  SAY 'b'x Days 'Days' Hours 'Hours' Minutes 'Minutes' Seconds
      'Seconds until the next MILLENNIUM!!   '

END

After the first two lines (starting with CALL CLOSE and CALL OPEN) this
is almost identical to @{"Version 1" LINK "v1"}.

The only difference is that the line:-

  SAY 'c'x

is @{B}NOT@{UB} used as we are opening a new window and there will be nothing in it
to clear.

We have not yet dealt with the subject of opening a window like this.
If you want to read ahead, then @{"click here" LINK "ARB:Articles_51-60/51.ARexx_With_Other_Progs/Creating"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE
