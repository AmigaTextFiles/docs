@DATABASE ArexxReference
@WORDWRAP
@FONT Topaz 8
@Remark version date format is day.month.year
@$VER: ArexxReference.guide 1.32 (22.07.2009) © Ernest Unrau,  22-Jul-2009.
@INDEX INDEX
@NODE MAIN "ARexx Reference"

        CONTENTS: AREXX REFERENCE

    @{" About " LINK About}
    @{" Commands " LINK Commands}
    @{" Instructions " LINK Instructions}
    @{" Functions (Internal) " LINK FunctionsInternal}
    @{" Functions (Support.library) " LINK FunctionsSupportlibrary}
    @{" Interrupts " LINK Interrupts}
    @{" Libraries " LINK Libraries}
    @{" Operators " LINK Operators}
    @{" Parsing " LINK Parsing}
    @{" RexxC   " LINK RexxC}
    @{" Tracing " LINK Tracing}
    @{" Tips " LINK Tips}
    @{" Code Samples " LINK "Code Samples"}
    @{" RexxIndex   " LINK Index}
@ENDNODE

@NODE About "About"
ABOUT THIS GUIDE:

ARexx command and function reference guide created December 20 1994 by:
    Ernest Unrau, 261 Tulip St., Morden MB  R6M 1H9, CANADA
    E-mail: ejunrau@mts.net (alt., saskwatch@mts.net)
    AX25 address: Inactive at present. Current callsign is VE4CJ.

This reference guide is Update Version 1.32, July 22, 2009.

This document is freeware and may be freely redistributed as long as the copyright notice is left intact. It is not original other than design and concept, and is intended as an on-line reference tool drawn from the Commodore/Amiga International system software manuals. No warranty is expressed or implied with respect to its accuracy or fitness for use. It would be appreciated, however, that any errors or suggestions be reported back to the author/compiler.

Thanks to those who contributed ideas and tips to make this guide more effective; my apologies to anyone I may have missed:

  - Stefan A. Haubenthal <stefan.haubenthal@web.de>
  - Bernd Gollesch <bgollesch@sime.at>
  - Guido Mersmann <geit@gmx.de>
  - Christoph Gutjahr <c.gutjahr@gmx.de>
  - Christer Oldhoff <coldhoff@swipnet.se>

History:
-------
-version 1.32, 22-Jul-2009: minor editing changes.

-version 1.31, 12-Feb-2009: added reference notes for additional undocumented functions in rexxsupport.library. Thanks to Christer Oldhoff for kindly supplying the missing information.

-version 1.30, 31-Aug-2008: added reference note for undocumented DELAY() function in rexxsupport.library.

-version 1.29, 20-Aug-2008: minor formatting change (text style) on sign().

-version 1.28, 26-Jul-2007: Corrected nodes sort on instructions page.

-version 1.27, 23-Jul-2007: more formatting changes and improvements including: syntax documentation and undocumented defaults for BITAND(), BITOR(), and BITXOR(), TIME(), and TRACE().

-version 1.26, 19-Jul-2007: BITAND() examples; TIME() reformatted; SIGN() corrected;  SPACE() function expanded; digits argument available for D2C(); more option links for trace(); examples for verify()

-version 1.25, 13-Jul-2007: minor changes, such as expanded NOP, PROCEDURE.

-version 1.24, 13-Jul-2007: added index link; updated d2x() and x2d() functions.

-version 1.23, 18-Mar-2007: updated contact info

-version 1.22, 01-Jun-2005: Added code module section

-version 1.21, 12-Apr-2005: fixed missing "'" in Translate() example code

-version 1.20, 30-Dec-2004: added example code for RXSET in RexxC section

-version 1.19, 35-Sep-2004: added "Tips" section

-version 1.18, 06-Sep-2004: Minor formatting changes

-version 1.17, 24-May-2004: fixed wording for Hash() function.
                            Example code for procedure, call(), parse
                            Tips for Call() and arg()

-version 1.16, 31-Mar-2004: clarified result returned for trace()

-version 1.15, 29-Mar-2004: typographic corrections on "about" page.

-version 1.14, 15-Jan-2004: minor syntax errors corrected.

-version 1.13, 08-Aug-2003: added example code to parse by position; changed function reference to four column layout instead of five to better fit screen.

-version 1.12, 21-Nov-1998: added instructions "PUSH" and "QUEUE". These were not included in the instruction section of the manuals that came with Workbench 2.05 but instead were appended, consequently these two commands were missed when compiling this Arexx Reference guide.

-version 1.11, 08-Feb-1998: minor documention errors corrected.

-version 0 (version number not included): completed first document Dec. 20, 1994

@ENDNODE

@Node Index "RexxIndex"
    AREXX INSTRUCTION/FUNCTION INDEX

    [ A ]
    @{" ABBREV()    " LINK "ABBREV()"}
    @{" ABS()       " LINK "ABS()"}
    @{" ADDLIB()    " LINK "ADDLIB()"}
    @{" ADDRESS     " LINK "ADDRESS"}
    @{" ADDRESS()   " LINK "ADDRESS()"}
    @{" ALLOCMEM()  " LINK "ALLOCMEM()"}
    @{" ARG         " LINK "ARG"}
    @{" ARG()       " LINK "ARG()"}
    @{" APSHDIR()   " LINK "APSHDIR"}


    [ B ]
    @{" B2C()       " LINK "B2C()"}
    @{" BADDR()     " LINK "BADDR"}
    @{" BITAND()    " LINK "BITAND()"}
    @{" BITCHG()    " LINK "BITCHG()"}
    @{" BITCLR()    " LINK "BITCLR()"}
    @{" BITCOMP()   " LINK "BITCOMP()"}
    @{" BITOR()     " LINK "BITOR()"}
    @{" BITSET()    " LINK "BITSET()"}
    @{" BITTST()    " LINK "BITTST()"}
    @{" BITXOR()    " LINK "BITXOR()"}
    @{" BREAK       " LINK "BREAK"}

    [ C ]
    @{" C2B()       " LINK "C2B()"}
    @{" C2D()       " LINK "C2D()"}
    @{" C2X()       " LINK "C2X()"}
    @{" CALL        " LINK "CALL"}
    @{" CENTRE()    " LINK "CENTRE()"}
    @{" CLOSE()     " LINK "CLOSE()"}
    @{" CLOSEPORT() " LINK "CLOSEPORT()"}
    @{" COMPARE()   " LINK "COMPARE()"}
    @{" COMPRESS()  " LINK "COMPRESS()"}
    @{" COPIES()    " LINK "COPIES()"}

    [ D ]
    @{" D2C()       " LINK "D2C()"}
    @{" D2X()       " LINK "D2X()"}
    @{" DATATYPE()  " LINK "DATATYPE()"}
    @{" DATE()      " LINK "DATE()"}
    @{" DELAY()     " LINK "DELAY()"}
    @{" DELETE()    " LINK "DELETE()"}
    @{" DELSTR()    " LINK "DELSTR()"}
    @{" DELWORD()   " LINK "DELWORD()"}
    @{" DIGITS()    " LINK "DIGITS()"}
    @{" DO          " LINK "DO"}
    @{" DROP        " LINK "DROP"}

    [ E ]
    @{" ECHO        " LINK "ECHO"}
    @{" ELSE        " LINK "ELSE"}
    @{" END         " LINK "END"}
    @{" EOF()       " LINK "EOF()"}
    @{" ERRORTEXT() " LINK "ERRORTEXT()"}
    @{" EXISTS()    " LINK "EXISTS()"}
    @{" EXIT        " LINK "EXIT"}
    @{" EXPORT()    " LINK "EXPORT()"}

    [ F ]
    @{" FILE()      " LINK "FILE()"}
    @{" FIND()      " LINK "FIND()"}
    @{" FORBID()    " LINK "FORBID()"}
    @{" FORM()      " LINK "FORM()"}
    @{" FORWARD()   " LINK "FORWARD()"}
    @{" FREEMEM()   " LINK "FREEMEM()"}
    @{" FREESPACE() " LINK "FREESPACE()"}
    @{" FUZZ()      " LINK "FUZZ()"}

    [ G ]
    @{" GETARG()    " LINK "GETARG()"}
    @{" GETCLIP()   " LINK "GETCLIP()"}
    @{" GETPKT()    " LINK "GETPKT()"}
    @{" GETSPACE()  " LINK "GETSPACE()"}

    [ H ]
    @{" HASH()      " LINK "HASH()"}

    [ I-J ]
    @{" IF          " LINK "IF"}
    @{" IMPORT()    " LINK "IMPORT()"}
    @{" INDEX()     " LINK "INDEX()"}
    @{" INSERT()    " LINK "INSERT()"}
    @{" INTERPRET   " LINK "INTERPRET"}
    @{" ITERATE     " LINK "ITERATE"}

    [ L ]
    @{" LASTPOS()   " LINK "LASTPOS()"}
    @{" LEAVE       " LINK "LEAVE"}
    @{" LEFT()      " LINK "LEFT()"}
    @{" LENGTH()    " LINK "LENGTH()"}
    @{" LINES()     " LINK "LINES()"}

    [ M-N ]
    @{" MAKEDIR()   " LINK "MAKEDIR()"}
    @{" MAX()       " LINK "MAX()"}
    @{" MIN()       " LINK "MIN()"}
    @{" NEXT()      " LINK "NEXT()"}
    @{" NOP         " LINK "NOP"}
    @{" NULL()      " LINK "NULL()"}
    @{" NUMERIC     " LINK "NUMERIC"}

    [ O-P ]
    @{" OFFSET()    " LINK "OFFSET()"}
    @{" OPEN()      " LINK "OPEN()"}
    @{" OPENPORT()  " LINK "OPENPORT()"}
    @{" OPTIONS     " LINK "OPTIONS"}
    @{" OTHERWISE   " LINK "OTHERWISE"}
    @{" OVERLAY()   " LINK "OVERLAY()"}
    @{" PARSE       " LINK "PARSE"}
    @{" PERMIT()    " LINK "PERMIT()"}
    @{" POS()       " LINK "POS()"}
    @{" PRAGMA()    " LINK "PRAGMA()"}
    @{" PROCEDURE   " LINK "PROCEDURE"}
    @{" PULL        " LINK "PULL"}
    @{" PUSH        " LINK "PUSH"}

    [ Q ]
    @{" QUEUE       " LINK "QUEUE"}

    [ R ]
    @{" RANDOM()    " LINK "RANDOM()"}
    @{" RANDU()     " LINK "RANDU()"}
    @{" READCH()    " LINK "READCH()"}
    @{" READLN()    " LINK "READLN()"}
    @{" REMLIB()    " LINK "REMLIB()"}
    @{" RENAME()    " LINK "RENAME()"}
    @{" REPLY()     " LINK "REPLY()"}
    @{" RETURN      " LINK "RETURN"}
    @{" REVERSE()   " LINK "REVERSE()"}
    @{" RIGHT()     " LINK "RIGHT()"}

    [ S ]
    @{" SAY         " LINK "SAY"}
    @{" SEEK()      " LINK "SEEK()"}
    @{" SELECT      " LINK "SELECT"}
    @{" SETCLIP()   " LINK "SETCLIP()"}
    @{" SHELL       " LINK "SHELL"}
    @{" SHOW()      " LINK "SHOW()"}
    @{" SHOWDIR()   " LINK "SHOWDIR()"}
    @{" SHOWLIST()  " LINK "SHOWLIST()"}
    @{" SIGN()      " LINK "SIGN()"}
    @{" SIGNAL      " LINK "SIGNAL"}
    @{" SOURCELINE()" LINK "SOURCELINE()"}
    @{" SPACE()     " LINK "SPACE()"}
    @{" STATEF()    " LINK "STATEF()"}
    @{" STORAGE()   " LINK "STORAGE()"}
    @{" STRIP()     " LINK "STRIP()"}
    @{" SUBSTR()    " LINK "SUBSTR()"}
    @{" SUBWORD()   " LINK "SUBWORD()"}
    @{" SYMBOL()    " LINK "SYMBOL()"}

    [ T ]
    @{" TIME()      " LINK "TIME()"}
    @{" TRACE()     " LINK "TRACE()"}
    @{" TRANSLATE() " LINK "TRANSLATE()"}
    @{" TRIM()      " LINK "TRIM()"}
    @{" TRUNC()     " LINK "TRUNC()"}
    @{" TYPEPKT()   " LINK "TYPEPKT()"}

    [ U-V ]
    @{" UPPER()     " LINK "UPPER()"}
    @{" VALUE()     " LINK "VALUE()"}
    @{" VERIFY()    " LINK "VERIFY()"}

    [ W ]
    @{" WAITPKT()   " LINK "WAITPKT()"}
    @{" WHEN        " LINK "WHEN"}
    @{" WORD()      " LINK "WORD()"}
    @{" WORDINDEX() " LINK "WORDINDEX()"}
    @{" WORDLENGTH()" LINK "WORDLENGTH()"}
    @{" WORDS()     " LINK "WORDS()"}
    @{" WRITECH()   " LINK "WRITECH()"}
    @{" WRITELN()   " LINK "WRITELN()"}

    [ X-Z ]
    @{" X2C()       " LINK "X2C()"}
    @{" X2D()       " LINK "X2D()"}
    @{" XRANGE()    " LINK "XRANGE()"}
@ENDNODE

@NODE Commands "Commands"
Usual syntax of a command is dictated by the external host for which it is intended, but normally will follow the form of a name or letter followed by parameter data.

Command names can be given as either a symbol or a string, but it is safer to use a string to prevent being mistaken as a keyword.

The interpretation of the received commands depends entirely on the host application.

The destination for a command depends upon a host address, which is the name of the public message port managed by an external program.

ARexx maintains two implicit host addresses: a "current" and a "previous" value. These can be changed at any time using the @{" ADDRESS " LINK "ADDRESS"} instruction or its synonym @{" SHELL " LINK "SHELL"}. The current address can be inspected using the @{" ADDRESS() " LINK "ADDRESS()"} built-in function.

The default host address is REXX, but the Interpreter also maintains a host address called AREXX which is an asynchronous port, ie.- calls or commands to this address return immediately without indicating an error. This is equivalent to "run rx <program>" but without the overhead of an extra shell
process.

One special host address is recognized. The string COMMAND indicates that the command should be issued directly to the underlying DOS. All other host addresses are assumed to refer to a public message port.
@ENDNODE

@NODE FunctionsInternal "Functions (Internal)"

            AREXX BUILT-IN FUNCTIONS

@{" ABBREV()    " LINK "ABBREV()"}    @{" D2C()       " LINK "D2C()"}    @{" LEFT()      " LINK "LEFT()"}    @{" STORAGE()   " LINK "STORAGE()"}
@{" ABS()       " LINK "ABS()"}    @{" D2X()       " LINK "D2X()"}    @{" LENGTH()    " LINK "LENGTH()"}    @{" STRIP()     " LINK "STRIP()"}
@{" ADDLIB()    " LINK "ADDLIB()"}    @{" DATATYPE()  " LINK "DATATYPE()"}    @{" LINES()     " LINK "LINES()"}    @{" SUBSTR()    " LINK "SUBSTR()"}
@{" ADDRESS()   " LINK "ADDRESS()"}    @{" DATE()      " LINK "DATE()"}    @{" MAX()       " LINK "MAX()"}    @{" SUBWORD()   " LINK "SUBWORD()"}
@{" ARG()       " LINK "ARG()"}    @{" DELSTR()    " LINK "DELSTR()"}    @{" MIN()       " LINK "MIN()"}    @{" SYMBOL()    " LINK "SYMBOL()"}
@{" B2C()       " LINK "B2C()"}    @{" DELWORD()   " LINK "DELWORD()"}    @{" OPEN()      " LINK "OPEN()"}    @{" TIME()      " LINK "TIME()"}
@{" BITAND()    " LINK "BITAND()"}    @{" DIGITS()    " LINK "DIGITS()"}    @{" OVERLAY()   " LINK "OVERLAY()"}    @{" TRACE()     " LINK "TRACE()"}
@{" BITCHG()    " LINK "BITCHG()"}    @{" EOF()       " LINK "EOF()"}    @{" POS()       " LINK "POS()"}    @{" TRANSLATE() " LINK "TRANSLATE()"}
@{" BITCLR()    " LINK "BITCLR()"}    @{" ERRORTEXT() " LINK "ERRORTEXT()"}    @{" PRAGMA()    " LINK "PRAGMA()"}    @{" TRIM()      " LINK "TRIM()"}
@{" BITCOMP()   " LINK "BITCOMP()"}    @{" EXISTS()    " LINK "EXISTS()"}    @{" RANDOM()    " LINK "RANDOM()"}    @{" TRUNC()     " LINK "TRUNC()"}
@{" BITOR()     " LINK "BITOR()"}    @{" EXPORT()    " LINK "EXPORT()"}    @{" RANDU()     " LINK "RANDU()"}    @{" UPPER()     " LINK "UPPER()"}
@{" BITSET()    " LINK "BITSET()"}    @{" FIND()      " LINK "FIND()"}    @{" READCH()    " LINK "READCH()"}    @{" VALUE()     " LINK "VALUE()"}
@{" BITTST()    " LINK "BITTST()"}    @{" FORM()      " LINK "FORM()"}    @{" READLN()    " LINK "READLN()"}    @{" VERIFY()    " LINK "VERIFY()"}
@{" BITXOR()    " LINK "BITXOR()"}    @{" FREESPACE() " LINK "FREESPACE()"}    @{" REMLIB()    " LINK "REMLIB()"}    @{" WORD()      " LINK "WORD()"}
@{" C2B()       " LINK "C2B()"}    @{" FUZZ()      " LINK "FUZZ()"}    @{" REVERSE()   " LINK "REVERSE()"}    @{" WORDINDEX() " LINK "WORDINDEX()"}
@{" C2D()       " LINK "C2D()"}    @{" GETCLIP()   " LINK "GETCLIP()"}    @{" RIGHT()     " LINK "RIGHT()"}    @{" WORDLENGTH()" LINK "WORDLENGTH()"}
@{" C2X()       " LINK "C2X()"}    @{" GETSPACE()  " LINK "GETSPACE()"}    @{" SEEK()      " LINK "SEEK()"}    @{" WORDS()     " LINK "WORDS()"}
@{" CENTRE()    " LINK "CENTRE()"}    @{" HASH()      " LINK "HASH()"}    @{" SETCLIP()   " LINK "SETCLIP()"}    @{" WRITECH()   " LINK "WRITECH()"}
@{" CLOSE()     " LINK "CLOSE()"}    @{" IMPORT()    " LINK "IMPORT()"}    @{" SHOW()      " LINK "SHOW()"}    @{" WRITELN()   " LINK "WRITELN()"}
@{" COMPARE()   " LINK "COMPARE()"}    @{" INDEX()     " LINK "INDEX()"}    @{" SIGN()      " LINK "SIGN()"}    @{" X2C()       " LINK "X2C()"}
@{" COMPRESS()  " LINK "COMPRESS()"}    @{" INSERT()    " LINK "INSERT()"}    @{" SOURCELINE()" LINK "SOURCELINE()"}    @{" X2D()       " LINK "X2D()"}
@{" COPIES()    " LINK "COPIES()"}    @{" LASTPOS()   " LINK "LASTPOS()"}    @{" SPACE()     " LINK "SPACE()"}    @{" XRANGE()    " LINK "XRANGE()"}
@ENDNODE

@NODE FunctionsSupportlibrary "Functions (Support.library)"
    REXXSUPPORT.LIBRARY FUNCTIONS:
    -----------------------------

Rexxsupport.library should be located in the "libs:" directory. The rexxsupport.library is invoked with the syntax:

    addlib('rexxsupport.library',0,-30,0)


    @{" ALLOCMEM()  " LINK "ALLOCMEM()"}
    @{" APSHDIR()   " LINK "APSHDIR"}   ??? No documentation available
    @{" BADDR()     " LINK "BADDR"} *
    @{" CLOSEPORT() " LINK "CLOSEPORT()"}
    @{" DELAY()     " LINK "DELAY()"}
    @{" DELETE()    " LINK "DELETE()"} *
    @{" FILE()      " LINK "FILE()"}   ??? No documentation available
    @{" FORBID()    " LINK "FORBID()"} *
    @{" FORWARD()   " LINK "FORWARD()"}   ??? No documentation available
    @{" FREEMEM()   " LINK "FREEMEM()"}
    @{" GETARG()    " LINK "GETARG()"}
    @{" GETPKT()    " LINK "GETPKT()"}
    @{" MAKEDIR()   " LINK "MAKEDIR()"} *
    @{" NEXT()      " LINK "NEXT()"} *
    @{" NULL()      " LINK "NULL()"} *
    @{" OFFSET()    " LINK "OFFSET()"} *
    @{" OPENPORT()  " LINK "OPENPORT()"}
    @{" PERMIT()    " LINK "PERMIT()"} *
    @{" RENAME()    " LINK "RENAME()"} *
    @{" REPLY()     " LINK "REPLY()"}
    @{" SHOWDIR()   " LINK "SHOWDIR()"}
    @{" SHOWLIST()  " LINK "SHOWLIST()"}
    @{" STATEF()    " LINK "STATEF()"}
    @{" TYPEPKT()   " LINK "TYPEPKT()"} **
    @{" WAITPKT()   " LINK "WAITPKT()"}

*NOTE: Syntax info for a number of the commands documented above, indicated with "*", was supplied by Christer Oldhoff <coldhoff@swipnet.se>. He writes, "All the descriptions of the commands are cited from "AMIGA Programmer's Guide to ARexx", Commodore-Amiga, Inc., 1991... I hope You find this information useful." Thanks for your kind assistance, Christer.

**TYPEPKT() syntax is taken from the ArexxGuide by Robin Evans, found on Aminet.



@ENDNODE

@NODE Instructions "Instructions"
        AREXX INSTRUCTIONS
        ------------------
    @{" ADDRESS   " LINK "ADDRESS"}        @{" NUMERIC   " LINK "NUMERIC"}
    @{" ARG       " LINK "ARG"}        @{" OPTIONS   " LINK "OPTIONS"}
    @{" BREAK     " LINK "BREAK"}        @{" OTHERWISE " LINK "OTHERWISE"}
    @{" CALL      " LINK "CALL"}        @{" PARSE     " LINK "PARSE"}
    @{" DO        " LINK "DO"}        @{" PROCEDURE " LINK "PROCEDURE"}
    @{" DROP      " LINK "DROP"}        @{" PULL      " LINK "PULL"}
    @{" ECHO      " LINK "ECHO"}        @{" PUSH      " LINK "PUSH"}
    @{" ELSE      " LINK "ELSE"}        @{" QUEUE     " LINK "QUEUE"}
    @{" END       " LINK "END"}        @{" RETURN    " LINK "RETURN"}
    @{" EXIT      " LINK "EXIT"}        @{" SAY       " LINK "SAY"}
    @{" IF        " LINK "IF"}        @{" SELECT    " LINK "SELECT"}
    @{" INTERPRET " LINK "INTERPRET"}        @{" SHELL     " LINK "SHELL"}
    @{" ITERATE   " LINK "ITERATE"}        @{" SIGNAL    " LINK "SIGNAL"}
    @{" LEAVE     " LINK "LEAVE"}        @{" WHEN      " LINK "WHEN"}
    @{" NOP       " LINK "NOP"}

@ENDNODE

@NODE Interrupts "Interrupts"
When an interrupt is enabled and its corresponding condition arises, a transfer of control to the label specific to that interrupt occurs.

The special variable SIGL is set to the current line number whenever a transfer of control occurs. If an ERROR or SYNTAX condition causes an interrupt, the special variable RC is set to the error code that triggered the interrupt.

A SYNTAX interrupt will transfer control to the label "SYNTAX:".

There are two forms of the @{" SIGNAL " LINK "SIGNAL"} instruction:
1)SIGNAL {ON | OFF} condition.
  In this form SIGNAL must be followed by one of the keywords ON or OFF and one of the condition keywords listed below:
     BREAK_C
     BREAK_D
     BREAK_E
     BREAK_F
     ERROR
     HALT
     IOERR
     NOVALUE
     SYNTAX

2)SIGNAL [value] expression

An immediate interrupt is generated that transfers control to the label specified by the expression result. The instruction thus acts as a "computed goto".

You cannot use an interrupt transfer to jump into the range of a DO-loop or other control structure.
@ENDNODE

@NODE Libraries "Libraries"
Libraries:
---------
Not every Amiga shared library can be used as an ARexx function library. Function libraries must have a special entry point specified as an integer offset (e.g. "-30") from the library base. Each library should include documentation providing its version number and the integer offset to its "query" entry point.

For example, to open the rexxsupport.library in order to access its functions, use the following syntax:
    addlib('rexxsupport.library',0,-30,0)

-See @{" ADDLIB() " LINK "ADDLIB()"} function
-See @{" Functions support library" LINK "FunctionsSupportLibrary"}
@ENDNODE

@NODE Operators "Operators"
Operator Sequences and Priorities:
=================================

Op.:   Pri.:   Definition:
--------------------------
~	  8     Logical NOT
+	  8     Prefix Conversion
-	  8     Prefix Negation
**       7     Exponentiation
*        6     Multiplication
/        6     Division
%        6     Integer Division
//       6     Remainder
+        5     Addition
-        5     Subtraction
||       4     @{"Concatenation" LINK "Concatenation"}
(blank)  4     Blank concatenation
==       3     Exact equality
~==      3     Exact inequality
=        3     Equality
~=       3     Inequality
>        3     Greater than
>=or~<   3     Greater than or equal to
<        3     Less than
<=or~>   3     Less than or equal to
&        2     Logical AND
|        1     Logical inclusive OR
^ or &&  1     Logical exclusive OR
@ENDNODE

@NODE Parsing "Parsing"
Parsing is an operation that extracts substrings from a string and assigns them to variables. Parsing is performed using the @{" PARSE " LINK "PARSE"} instruction or its variants @{" ARG " LINK "ARG"} and @{" PULL " LINK "PULL"}. Parsing is controlled by a template, and there are two basic template objects:
  -MARKERS: Absolute, Relative, and Pattern markers
  -TARGETS: usually specified by variable symbols. A placeholder is a
            special symbol denoted by a period.

Parsing by tokenization:
When a variable is followed immediately by another variable, the value string is determined by breaking the input string into words separated by blanks. Each word is assigned to a variable in the template. Values determined by tokenization will never have leading or trailing blanks. Normally the last variable in the template receives the untokenized remainder of the input string. A placeholder symbol, a period (.), when present serves to accept the remainder of the string, except that it isn't actually assigned a value.

Parsing by position:
If the fields in the input string have known positions, value strings can be specified by absolute or relative positions, indicated as + or - numbers.

Program Example:

  /*Example of parsing by position */

  /*Record format looks like:
    Start: 1-5
    Length: 6-10
    Data itself found at (start,length)
  */

  Record='0001100016Shake and bake!!'
  PARSE value record with 1 start +5 length +5 = start Data +length
  say 'Start:' start
  say 'Length:' Length
  say 'Data field: ' Data

Program output:
Start: 00011
Length: 00016
Data field:  Shake and bake!!

@ENDNODE

@NODE RexxC "RexxC"
AREXX is supplied with a number of command utilities located in the REXXC directory. These commands can be run from the Shell and are applicable only when the AREXX resident process is active:

HI - usage: HI
Sets the global halt flag, which causes all active ARexx programs to receive and external halt request. Each program will exit immediately unless its @{" HALT " LINK "Interrupts"} interrupt has been enabled. The halt flag does not remain set, but is cleared automatically after all current programs have received the request.

RX - usage: RX name [arguments]
This command launches an ARexx program. If an explicit path isn't given, then the current directory as well as REXX: are searched for a program called "name". The optional argument string is passed to the program.

RX can be launched from either a tool or a project icon. It accepts tooltype arguments using CONSOLE for a window specification and CMD for a command string. If no CMD string is suppplied, the command will attempt to execute the (project) file as an AREXX program. The rx command will also attempt to start Rexx Mast if it's not active. Example:
  Icon type: Project
  Default Tool: sys:rexxc/rx
  Possible tool types:
    Console = con:0/0/620/200/Example/Close
    CMD = rexxprogram arg1 arg2

RXLIB - usage: RXLIB library-name offset version
Opens a function library so that it can be called from AREXX and can also be used to list the currently-defined functions. The priority argument gives the search priority and must be in the range -100 to 100 inclusive.

The offset argument is the actual integer offset to the library's entry point and should be documented with each library. The version is the required library version and can usually be omitted since the default is to load any version.

RXSET - usage: RXSET [name[[=] value]]
Adds a (name,value) pair to the Clip List. Name strings are assumed to be mixed case. If RXSET is invoked without arguments, it will list all pairs in the Clip List.

  Example: code snippet by Christoph Gutjahr - c.gutjahr@gmx.de
  -------
  Assuming you have the dos command program "requeststring"...

    cmdid='req'pragma('id')
    address command 'rxset' cmdid '`requeststring "TITLE" "BODY"`'
    inputstring=getclip(cmdid)
    call setclip(cmdid,'')

RXC - usage: RXC
Closes the resident process as soon as the last AREXX program finishes.

TCC - usage: TCC
Closes the global tracing console as soon as all active programs are no longer using it.

TCO - usage: TCO
Opens the global tracing console. The tracing output from all active programs is diverted automatically to the new console.

TE - usage: TE
Clears the global tracing flag, which forces the tracing mode to OFF for all active ARexx programs.

TS - usage: TS
Starts interactive tracing by setting the external trace flag, which forces all active ARexx programs into interactive tracing mode.

WaitForPort - Usage: WaitForPort [name of port]
A command utility that specifies a port and then waits 10 seconds for the port to appear. A return code of 0 indicates that the port was found; 5 indicates that the application is not currently running or that the port itself does not exist. Port names are case sensitive.
@ENDNODE


@NODE Tracing "Tracing"
TRACING OPTIONS:
---------------
Note: the keywords that select options can be shortened to one letter
for convenience:

  ALL           -all clauses traced
  BACKGROUND    -no tracing performed and program can't be forced into
                 interactive tracing
  COMMANDS      -command traced before being sent to external host.
                 Non-zero codes are displayed on the console.
  ERRORS        -command generating a non-zero return code are traced
                 after the clause is executed.
  INTERMEDIATES -all clauses traced and intermediate results displayed
                 during expression evaluation.
  LABELS        -label clauses traced as executed. Label displayed each
                 time a transfer of control takes place.
  NORMAL        -the default. Command clauses with return codes higher than
                 current error failure level are traced after execution
                 and an error message is displayed.
  OFF           -off
  RESULTS       -all clauses traced before execution and the final result
                 of each expression is displayed.
  SCAN          -special option that traces all clauses and checks for
                 errors, but suppresses actual execution of statements.

TRACING PREFIX CODES:
--------------------
  +++ Command or syntax error
  >C> Expanded compound name
  >F> Result of a function call
  >L> Label clause
  >O> Result of a dyadic operation
  >P> Result of a prefix operation
  >U> Uninitialized variable
  >V> Value of a variable
  >>> Expression or template result
  >.> "Placeholder" token value

COMMAND INHIBITION
   -special ARexx tracing mode that suppresses host commands; the clauses are
    evaluated but not actually sent to the external host.
   -may be used with any trace option. It is controlled by the "!" character,
    which may appear by itself or may precede any of the alphabetic options
    in a @{" TRACE " LINK "TRACE()"} instruction. Each occurrence toggles the inhibition mode
    currently in effect. Command inhibition is cleared when tracing is set
    to OFF.

INTERACTIVE TRACING
   -controlled by the "?" character, either by itself or in combination
    with an alphabetic trace option. Each occurrence toggles the mode
    currently in effect.
        -eg. TRACE ?R

@ENDNODE

@NODE Concatenation "Concatenation"
There are 3 means of concatenation:
----------------------------------
1)"||" operator:
    -joins two strings into a single string with no intervening blank.
2)" " or ' ' (blank) operator:
    -joins two strings into a single string with one intervening blank.
3)abuttal:
    -When a string and symbol are abutted they are joined as though
     the "||" operator had been used.

Example: assuming we have the symbol Punc=',' and two strings: 'why me'
and 'Mom?' the results would be:

a) say 'why me'||'Mom?'   --> why meMom?
b) say 'why me' 'Mom?'    --> why me Mom?
c) say 'why me'Punc'Mom'  --> why me,Mom?
d) say 'why me'Punc 'Mom' --> why me, Mom?
@ENDNODE

@NODE ADDRESS "ADDRESS"
ADDRESS
usage: ADDRESS [symbol | string | [[value] [expression]]
   -specifies a host address for commands issued by the interpreter. There
    are four forms for the address instruction:
    1)ADDRESS {string|symbol} expression
      sends the results of expression to a host without changing the
      previous or current address.
    2)ADDRESS {string|symbol}
      specifies the new host address
    3)ADDRESS [VALUE] expression
      the result of expression specifies the new host address and the
      current address becomes the previous address.
    4)ADDRESS
      toggles between the current and previous hosts.

-Caution: the following is a common addressing mistake:
     /* a program specific address */
     programaddress='ProWrite'
     address programaddress command

This will fail because the interpreter attempts to pass the command to a  port called PROGRAMADDRESS instead of ProWrite. To make it work, use the  VALUE keyword to tell ARexx to interpret the expression:
     address value programaddress command
-see also @{" Address() " LINK "Address()"}, @{" Commands " LINK "Commands"}
@ENDNODE

@NODE ARG "ARG"
ARG
usage: ARG [template] [,template...]
   -retrieves one or more argument strings available to the program and
    assigns values to the variables in the template.
@ENDNODE

@NODE BREAK "BREAK"
BREAK
usage: BREAK
   -used to exit a @{" DO " LINK "DO"} or an @{" INTERPRET" LINK "INTERPRET"}ed instruction
-see also @{" Interrupts " LINK "Interrupts"}
@ENDNODE

@NODE CALL "CALL"
CALL
usage: CALL {symbol|string} [expression] [,expression,...]
-used to invoke an internal or external function
-A special variable called RESULT holds the value returned by the function
-If a result is not returned, then RESULT is @{" DROP " LINK "DROP"}ed (made uninitialized)

Example code #1:
---------------
[Note: this format puts the arguments into CALL() form which places call parameters as separate, comma-separated arguments: (arg1,arg2, etc.) which have to be retrieved with parsing arg(1), arg(2), etc.]

Var=56.4446
say var
Call Round(var,2) /* ask function to round to two decimal places */
Var=result
say Var
Exit

Round:
 procedure
 /* parse and round decimal number to specified decimal precision */
 parse value arg(1)*1.0 with integer '.' fraction
 Precision=arg(2)
 Parse numeric NumDigits .
 numeric digits 2
 fraction=trunc('.'||fraction,precision)
 numeric digits NumDigits
RETURN integer+fraction

Example code #2:
---------------
[Note: this format puts the arguments into "CALL var1 var2, etc." form which places call parameters as space delimited arguments, and which then have to be retrieved with parsing format PARSE ARG arg1 arg2 arg3 .]

Var=56.4446
say var
Call Round var 2 /* ask function round to two decimal places */
Var=result
say Var
Exit

Round:
 procedure
 /* parse and round decimal number to specified decimal precision */
 parse arg integer '.' fraction precision
 Parse numeric NumDigits . /* discover current setting for precision */
 numeric digits precision
 fraction=trunc('.'||fraction,precision)
 numeric digits NumDigits  /* restore precision */
RETURN integer+fraction


TIP:
---
"CALL" works together with ARG() without () in this format...

   /* Example 1 */
   options results
   call checkarg 15,20
   say rc result
   exit

   CheckArg:
     call arg()  /* get the number of supplied arguments */
   return result

Returns: RC 2

...But "CALL" fails in this format...

   /* Example 2 */
   options results
   call checkarg 15,20
   say rc result
   exit

   CheckArg:
   arg()
   return result

Returns: Command returned 10/37: Invalid template

It will work, though, if you substitute "arg()" with the following:

   CheckArg:
   x=arg()
   return x

Returns: RC 2

@ENDNODE


@NODE DO "DO"
DO
usage: DO [[var=exp]|[exp] [TO exp] [BY exp]] [FOR exp] [FOREVER] [WHILE
    EXP | UNTIL EXP]
   -begins a block of instructions
@ENDNODE

@NODE DROP "DROP"
DROP
usage: DROP variable [variable...]
   -specified variables are reset to uninitialized state
@ENDNODE

@NODE ECHO "ECHO"
ECHO
usage: ECHO [expression]
   -synonym for the @{" SAY " LINK "SAY"} instruction
@ENDNODE

@NODE ELSE "ELSE"
ELSE
usage: ELSE [;] [conditional statement]
   -alternative conditional branch for an @{" IF " LINK "IF"} statement
@ENDNODE

@NODE END "END"
END
usage: END [variable]
   -terminates the range of a @{" DO " LINK "DO"} or @{" SELECT " LINK "SELECT"} instruction
@ENDNODE

@NODE EXIT "EXIT"
EXIT
usage: EXIT [expression]
   -terminates the execution of a program and is valid anywhere within a
    program
@ENDNODE

@NODE IF "IF"
IF
usage: IF expression [THEN] [;] [conditional statement]
   -used in conjunction with THEN and @{" ELSE " LINK "ELSE"} instructions
@ENDNODE

@NODE INTERPRET "INTERPRET"
INTERPRET
usage: INTERPRET expression
   -treats the expression as though it were a source statement block in
    your program.
@ENDNODE

@NODE ITERATE "ITERATE"
ITERATE
usage: ITERATE [variable]
   -terminates the current iteration of a @{" DO " LINK "DO"} instruction and begins the
    next
@ENDNODE

@NODE LEAVE "LEAVE"
LEAVE
usage: LEAVE [variable]
   -forces an immediate exit from an iterative @{" DO " LINK "DO"} range
@ENDNODE

@NODE NOP "NOP"
NOP
usage: NOP
  -does nothing (a @{b}NO@{ub}-o@{b}P@{ub}eration instruction)
  -used to control the binding of @{" ELSE " LINK "ELSE"} clauses in
   compound @{" IF " LINK "IF"} statements

 @{u}EXAMPLE@{uu}:

  IF i = j THEN           /* First or "outer" IF */
    IF j = k then a = 0   /* Inner IF */
    ELSE NOP              /* "Binds" or controls the inner IF */
  END                     /* Binds to outer IF */

@ENDNODE

@NODE NUMERIC "NUMERIC"
NUMERIC
usage: NUMERIC {DIGITS | FUZZ} expression
   or: NUMERIC FORM {SCIENTIFIC | ENGINEERING}
    -sets options regarding numeric precision and format. Options are:

  1)NUMERIC DIGITS expression
    Specifies the number of digits of precision for arithmetic
    calculations
  2)NUMERIC FUZZ expression
    Specifies the number of digits to be ignored in numeric comparison
    operations. Must be less than the current DIGITS setting
  3)NUMERIC FORM SCIENTIFIC
    Specifies that numbers requiring exponential notation be expressed in
    SCIENTIFIC notation; mantissa is between 1 and 10
  4)NUMERIC FORM ENGINEERING
    Normalizes exponential notation so that its exponent is a multiple of
    three and the mantissa (if not 0) is between 1 and 1000
@ENDNODE

@NODE OPTIONS "OPTIONS"
OPTIONS
usage: OPTIONS [FAILAT expression]
       sets the limit at or above which command return codes
       will be signalled as errors.
   or: OPTIONS [PROMPT expression]
       provides a string to be used as the prompt with the PULL (or
       PARSE PULL) instruction
   or: OPTIONS [RESULTS]
       indicates the interpreter should request a result string when it
       issues commands to an external host
@ENDNODE

@NODE OTHERWISE "OTHERWISE"
OTHERWISE
usage: OTHERWISE [;] [conditional statement]
   -valid only within the range of a SELECT instruction and must follow
    all of the "When...Then" statements.
@ENDNODE

@NODE PARSE "PARSE"
PARSE
usage: PARSE [UPPER] input-source [template]  [template...]
   -extracts one or more substrings from a string and assigns them to
    variables. Various forms:

  1)UPPER - input string made uppercase before parsing
  2)ARG - retrieves argument string supplied when program was invoked
  3)EXTERNAL - input string is read from STDERR stream so as not to
    disturb PUSHed or QUEUEd data. If multiple templates are supplied, each
    template will read a new string. This source options is the same as PULL
  4)NUMERIC - current numeric options placed in a string in the order
    DIGITS, FUZZ, FORM separated by a single space.
  5)PULL - reads a string from the input console
  6)SOURCE - the source string for the program is retrieved, formatted as:
           {COMMAND | FUNCTION} {0|1} called resolved ext host
    The first token shows whether invoked as a command or function; the
    2nd is a boolean flag indicating whether a result string was requested
    by the caller; the called token is the name used to invoke this
    program; resolved is the final resolved name of the program; ext is
    the file extension to be used for searching (default "rexx"); host is the
    initial host address for commands
  7)VALUE expression WITH - input string is the result of the supplied
    expression. The WITH keyword is required to separate the expression
    from the template.
  8)VAR variable - the value of the specified variable is used as the
    input string.
  9)VERSION - information about the ARexx interpreter is supplied in the
    form: "the version cpu mpu video freq"

Example code #1:
---------------
[Note: this format puts the arguments into CALL Function() form which places call parameters as separate, comma-separated arguments: (arg1,arg2, etc.) which have to be retrieved with parsing arg(1), arg(2), etc.]

Var=56.4446
say var
Call Round(var,2) /* ask function to round to two decimal places */
Var=result
say Var
Exit

Round:
 procedure
 /* parse and round decimal number to specified decimal precision */
 parse value arg(1)*1.0 with integer '.' fraction
 Precision=arg(2)
 Parse numeric NumDigits .
 numeric digits 2
 fraction=trunc('.'||fraction,precision)
 numeric digits NumDigits
RETURN integer+fraction

Example code #2:
---------------
[Note: this format puts the arguments into "CALL function var1 var2, etc." form which places call parameters as space delimited arguments, and which then have to be retrieved with parsing format PARSE ARG arg1 arg2 arg3 .]

Var=56.4446
say var
Call Round var 2 /* ask function round to two decimal places */
Var=result
say Var
Exit

Round:
 procedure
 /* parse and round decimal number to specified decimal precision */
 parse arg integer '.' fraction precision
 Parse numeric NumDigits . /* discover current setting for precision */
 numeric digits precision
 fraction=trunc('.'||fraction,precision)
 numeric digits NumDigits  /* restore precision */
RETURN integer+fraction

@ENDNODE

@NODE PROCEDURE "PROCEDURE"
PROCEDURE
usage: PROCEDURE [EXPOSE variable [variable...]]
   -used with an internal function to create a new symbol table
   -the EXPOSE sub-keyword provides a selective mechanism for accessing the
    caller's symbol table, and for passing global variables to a function.
    The variables following the EXPOSE keyword are taken to refer to
    symbols in the caller's table. Any subsequent changes made to these
    variables will be reflected in the caller's environment.
   -variables in the EXPOSE list may include stem or compound symbols, in
    which case the ordering of the variables is significant. The EXPOSE
    list is processed from left to right and compound symbols are expanded
    based on the values in effect in the new generation (that is, in the
    order in which they are activated).
      - For example: suppose J in the caller's environment is "123" and J
        is uninitialized in the new environment (the procedure). Then,
           -PROCEDURE EXPOSE J A.J  ---> exposes J and A.123 because J is
                                         "123" in the calling environment
           -PROCEDURE EXPOSE A.J J  ---> exposes A.J and J

      - Exposing a stem has the effect of exposing all possible compound
        symbols derived from that stem:
           -PROCEDURE EXPOSE A.     ---> exposes A.I, A.J, A.J.J, A.123 etc.

Example code:

Var=56.4446
say var
Precision=2
Call Round(var) /* ask function round to two decimal places */
Var=result
say Var
Exit

Round:
 procedure expose Precision
 /* parse and round number to specified decimal precision */
 parse value arg(1)*1.0 with integer '.' fraction
 Parse numeric NumDigits .
 numeric digits 2
 fraction=trunc('.'||fraction,precision)
 numeric digits NumDigits
RETURN integer+fraction

@ENDNODE

@NODE PULL "PULL"
PULL
usage: PULL [template] [,template...]
   -shorthand form of @{" PARSE " LINK "PARSE"} UPPER PULL
@ENDNODE

@NODE PUSH "PUSH"
PUSH
The PUSH instruction is used to prepare a stream of data to be read by a command shell or other program. It appends a newline to the result of the expression, then stacks or "pushes" it into the STDIN stream. Stacked lines are placed in the stream in "last-in, first-out" order and are available to be read just as though they had been entered interactively. For example, after issuing the instructions:

PUSH line 1
PUSH line 2
PUSH line 3

the stream would be read in the order line 3, line 2 and line 1.

PUSH allows the STDIN stream to be used as a private scratch pad to prepare data for subsequent processing. For example, several files could be concatenated with delimiters between them by simply reading the input files, PUSHing the line into the stream and inserting a delimiter where required. For example:

Do i=1 to 5
  push 'echo "Line 'i'"'
  end
@ENDNODE

@NODE QUEUE "QUEUE"
QUEUE
The QUEUE instruction is used to prepare a stream of data to be read by a command shell or other program. It is very similar to the PUSH instruction and differs only in that the data lines are placed in the STDIN stream in "first-in, first-out" order. In this case, the instructions:

QUEUE line 1
QUEUE line 2
QUEUE line 3

would be read in the order line 1, line 2 and line 3. The QUEUEd lines always precede all interactively-entered lines and always follow any PUSHed (stacked) lines. For example:

Do i=1 to 5
  QUEUE 'echo "Line 'i'"'
  end

@ENDNODE

@NODE RETURN "RETURN"
RETURN
usage: RETURN [expression]
   -used to leave a function and return to point of invocation.
    "Expression" is returned as the function result
@ENDNODE

@NODE SAY "SAY"
SAY
usage: SAY [expression]

    -The result of expression is written or "echoed" to the output console with a "newline" character appended.
    -If expression is omitted an empty (or null) string is sent; that is, a "newline" or line-feed only is sent as an "empty" line.

@ENDNODE

@NODE SELECT "SELECT"
SELECT
usage: SELECT
   -begins a group of instructions containing one or more @{" WHEN " LINK "WHEN"}
    instructions and possibly an @{" OTHERWISE " LINK "OTHERWISE"} clause. Must be terminated by
    an @{" END " LINK "END"} statement.
@ENDNODE

@NODE SHELL "SHELL"
SHELL
usage: SHELL [symbol | string | [[value] [expression]]
   -synonym for the @{" ADDRESS " LINK "ADDRESS"} instruction
@ENDNODE

@NODE SIGNAL "SIGNAL"
SIGNAL
usage: SIGNAL {ON|OFF} condition
   or: SIGNAL [value] expression

  1)first form controls the state of the internal interrupt flags. Must be followed by ON or OFF keywords, and one of the condition keywords listed below:

    BREAK_C - a control-C was detected
    BREAK_D - a control-D was detected
    BREAK_E - a control-E was detected
    BREAK_F - a control-F was detected
    ERROR - a host command returned a non-zero code
    HALT - an external HALT request was detected
    IOERR - an error was detected by the I/O system
    NOVALUE - an uninitialized variable was used
    SYNTAX - a syntax or execution error was detected

  2)SIGNAL [value] expression
    An immediate interrupt is generated that transfers control to the label specified by the expression result. The instruction thus acts as a "computed goto".

 -see also @{" INTERRUPTS " LINK "INTERRUPTS"} for other info and special variables
@ENDNODE

@NODE WHEN "WHEN"
WHEN
usage: WHEN expression [THEN [;] [condition statement]]

   -similar to the @{" IF " LINK "IF"} instruction, but is valid only within a @{" SELECT " LINK "SELECT"} range.
@ENDNODE

@NODE ABBREV() "ABBREV()"
usage: ABBREV(string1,string2,[length])

-returns a boolean value indicating whether string2 is an abbrev. of string1
@ENDNODE

@NODE ABS() "ABS()"
usage: ABS(number)
-returns the absolute value of the number argument
@ENDNODE

@NODE ADDLIB() "ADDLIB()"
usage: ADDLIB(name,priority,[offset,version])

    -adds a function library or a function host to the Library List maintained by the resident process
    -name specifies the name of a function library, or the public message port associated with that host. It is case-sensitive, and libraries should reside in the LIBS: directory
    -priority specifies the search priority and must be an integer between 100 and -100 inclusive
    -offset is the integer offset to a library's "query" entry point
    -version is an integer specifying the minimum acceptable release level of the library
@ENDNODE

@NODE ADDRESS() "ADDRESS()"
usage: ADDRESS()

    -returns the current host address string where commands will be sent
    -see also @{" SHOW() " LINK "SHOW()"}
@ENDNODE

@NODE ARG() "ARG()"
usage: ARG([number],['Exists'|'Omitted'])

    -returns the number of arguments supplied to the current environment
    -if "number" parameter alone is given,the corresponding argument string is returned.
    -if "number" and one of the keywords is given, the returned boolean value indicates the status of the corresponding argument
    -see also @{" Parse " LINK "Parse"}
@ENDNODE

@NODE B2C() "B2C()"
usage: B2C(string)
    -converts a string of binary digits (0,1) into the corresponding packed character representation.
    -blanks are permitted in the string, but only at byte boundaries
    -see also @{" X2C() " LINK "X2C()"}
@ENDNODE

@NODE BITAND() "BITAND()"
usage: BITAND(string1 [,string2] [,pad])
       default: bitand(string) = bitand(string,'20'x)

   -the argument strings are logically ANDed together, with the length of the result being the longer of the two
   -if a pad character is supplied, the shorter string is padded on the right. If not, the operation terminates at the end of the shorter string. The operation terminates at the end of the shorter string and the remainder of the longer string is appended to the result.
   -with only the 1st argument supplied, BITAND() supplies '20'x (ascii 32) as the default 2nd argument. This acts on the supplied string1 argument by replacing lower case characters with space characters, and replacing upper case characters by a NUL ('00'x characters). Example: say c2x(bitand('Test'))  --> 00202020 (thanks to Stefan Haubenthal for this one)

The purpose of BITAND is string comparison. A couple of examples to illustrate (note the use of c2b() in combination with the BITAND() function to provide a printable result; without it you may not achieve a result that is viewable in the shell):

 /* Example of BITAND() function */
 a=c2b(d2c(1))
 b=c2b(d2c(2))
 say a
 say b
 say bitand(a,b)
 EXIT

produces the following results that are easy to trace:

 say a           returns ----> 00000001
 say b           returns ----> 00000010
 say bitand(a,b) returns ----> 00000000

In "a" the 1st (rightmost) bit is set and the remainder are not. In "b" the 2nd bit is set but the rest are not. When ANDing them, since none of the corresponding bits in both strings "a" and "b" are set, all prove false when ANDed together, therefore all bits are set as zeros (meaning "false", or "not true").

To illustrate further, in "a" the 1st bit is true, or "1", but bit 1 is false or zero in "b", therefore a-bit1 AND b-bit1 is "false" or "0"; that is they are both "not true" (or you could say: it is "false" that they are both true, therefore the answer is "0"). The same occurs for the rest of the bits when comparing strings "a" and "b" as bit-for-bit in sequence from right to left, least significant bit to most significant bit.

The manual gives the illustration of:

BITAND('0313'x,'FFF0'x)  -- '0310'x

but to view the output in printable form you actually have to convert the result back to hex in this way:

say C2X(BITAND('0313'x,'FFF0'x))  displays --> 0310

@ENDNODE

@NODE BITCHG() "BITCHG()"
usage: BITCHG(string,bit)

-changes the state of the specified bit in the string
-bit 0 is the low-order bit of the rightmost byte of the string
@ENDNODE

@NODE BITCLR() "BITCLR()"
usage: BITCLR(string,bit)

-clears (sets to zero) the specified bit
-bit 0 is the low-order bit of the rightmost byte of the string
@ENDNODE

@NODE BITCOMP() "BITCOMP()"
usage: BITCOMP(string1,string2[,pad])

    -compares the string bit-by-bit, starting at bit 0
    -returned value is the bit number of the first bit in which the strings differ or -1 if identical
@ENDNODE

@NODE BITOR() "BITOR()"
usage: BITOR(string1,string2[,pad])
       default: BITOR(string1) = BITOR(string1,'20'x)
    -the strings are logically ORed together
    -the length of the result is the longer of the two operand strings
    -if a pad character is supplied, the shorter string is padded on the right, else the operation terminates at the end of the shorter string and the remainder of the longer string is appended to the result.
    -if only the first argument is supplied, BITOR() acts upon string1 as if '20'x were supplied for the 2nd argument. (Thanks to Stefan Haubenthal for pointing out this feature). This acts like a shorthand lowercase conversion function, a function that is missing in arexx. ARexx has the UPPER() function to convert a string to uppercase, but no equivalent function to convert to lowercase.

Example: BITOR('Test')  outputs ---> test

@ENDNODE

@NODE BITSET() "BITSET()"
usage: BITSET(string,bit)

    -Sets the specified bit in the argument string to 1
    -bit 0 is the low-order bit of the rightmost byte of the string
@ENDNODE

@NODE BITTST() "BITTST()"
usage: BITTST(string,bit)
    -boolean return indicates the state of the specified bit in the string
    -bit 0 is the low-order bit of the rightmost byte of the string
@ENDNODE

@NODE BITXOR() "BITXOR()"
usage: BITXOR(string1,string2[,pad])
       default: bitxor(string1) = bitxor(string1,'20'x)

    -the strings are logically exclusively-ORed together
    -the result is the longer of the two operand strings
    -if a pad character is supplied, the shorter string is padded on the right and the remainder of the longer string is appended to the result
    -with only the 1st argument supplied BITXOR() functions acts like a shorthand function to swap case. (Thanks to Stefan Haubenthal for pointing this one out).

Example:
  say bitxor('Test') outputs ---> tEST

@ENDNODE

@NODE C2B() "C2B()"
usage: C2B(string)

-converts a character string into the equivalent string of binary digits
-see also @{" C2X() " LINK "C2X()"}
@ENDNODE

@NODE C2D() "C2D()"
usage: C2D(string,[n])

    -returns the ascii decimal number of string
    -if "n" is supplied the string is considered to be a number in n bytes
    -the string is truncated or padded with nulls on the left as required, and the sign bit is extended for the conversion
@ENDNODE

@NODE C2X() "C2X()"
usage: C2X(string)

-converts string to the corresponding hexadecimal number
-see also @{" C2B() " LINK "C2B()"}
@ENDNODE

@NODE CENTRE() "CENTRE()"
usage: CENTRE(string,length,[pad])
usage: CENTER(string,length,[pad])

-centres the string argument in a string with the specified length
-pad characters or blanks are added as necessary
@ENDNODE

@NODE CLOSE() "CLOSE()"
usage: CLOSE(file)

-closes the given file specified by the given logical name
-returned value is a boolean success flag
@ENDNODE

@NODE COMPRESS() "COMPRESS()"
usage: COMPRESS(string,[list])

    -if list is omitted then leading, trailing, or embedded blank characters are removed from the string
    -specified characters are removed from string if optional list is supplied
@ENDNODE

@NODE COMPARE() "COMPARE()"
usage: COMPARE(string1,string2,[pad])

    -compares two strings and returns index of first position they differ or 0 if identical
    -the shorter string is padded as required using the supplied character or blanks
@ENDNODE

@NODE COPIES() "COPIES()"
usage: COPIES(string,number)

    -creates a new string by concatenating the specified number of copies of the original
@ENDNODE

@NODE D2C() "D2C()"

usage: D2C(number)
    or D2C(number [,digits])*

    -creates a string whose value is the binary (packed) representation of the given decimal number

*The ARexx manuals ©1991 and ©1995 do not mention a digits argument for d2c(), nor does the online Arexx manual supplied with OS3.9. (Thanks to Stefan Haubenthal for this information. In his IFF2rexx application, Stefan has used D2C(len,4) to get IFF conforming long words.)

Examples:
 say c2x(d2c(1555,1))  returns ---> 13
 say c2x(d2c(1555,2))  returns ---> 0613
 say c2x(d2c(1555,3))  returns ---> 000613

 say c2d(d2c(1555,1))  returns ---> 19
 say c2d(d2c(1555,2))  returns ---> 1555
 say c2d(d2c(1555,3))  returns ---> 1555
 say c2d(d2c(1555,4))  returns ---> 1555

 say c2b(d2c(1555,1))  returns ---> 00010011
 say c2b(d2c(1555,2))  returns ---> 0000011000010011
 say c2b(d2c(1555,3))  returns ---> 000000000000011000010011
 say c2b(d2c(1555,4))  returns ---> 00000000000000000000011000010011

@ENDNODE

@NODE D2X() "D2X()"
usage: D2X(number,[digits])

-converts a decimal number to hexadecimal.
-digits argument sets the number of rightmost hex digits returned of the result.
-digits argument cannot be greater than 8.
-the result is padded with zeros on the left according to the digits argument.
-see also @{" numeric " LINK "numeric"} digits and @{" x2d() " LINK "x2d()"}.

The ARexx reference manual does not explain the digits argument. Comments welcome [see @{" About " LINK "About"}].

The following example executed from the DOS shell illustrates the action that takes place with/without the digits argument ( "--->" denotes the result):

 say d2x(672850) ----> A4452
 say d2x(672850,0) -->
 say d2x(672850,1) --> 2
 say d2x(672850,2) --> 52
 say d2x(672850,3) --> 452
 say d2x(672850,4) --> 4452
 say d2x(672850,5) --> A4452
 say d2x(672850,6) --> 0A4452
 say d2x(672850,7) --> 00A4452
 say d2x(672850,8) --> 000A4452
 say d2x(672850,9) --> Invalid argument to function

@ENDNODE

@NODE DATE() "DATE()"
usage: DATE([option] [,date] [,format])

-returns the current date in the specified format
-options (may be shortened to first character):
 Basedate:  -number of days since January 1,0001
 Century:   -number of days since January 1 of the century
 Days:      -number of days since January 1 of the current year
 European:  -date in form DD/MM/YY
 Internal:  -internal system days
 Julian:    -the date as YYDDD
 Month:     -current month (mixed case)
 Normal:    -date as DD MMM YYYY
 Ordered:   -date as YY/MM/DD
 Sorted:    -date as YYYYMMDD
 USA:       -date as MM/DD/YY
 Weekday:   -day of the week (mixed case)

    -the second argument is an integer specifying either system days (default) or a sorted date (YYYYMMDD)
    -the third argument specifies the form of the date and can be either "I" or "S"
@ENDNODE

@NODE DATATYPE() "DATATYPE()"
usage: DATATYPE(string,[option])
    -without option specified tests whether the string parameter is a valid number and returns either NUM or CHAR
    -with option specified returns boolean result
    -option keywords (may be abbreviated to 1st character):

  KEYWORD:     CHARACTERS ACCEPTED:
 ----------------------------------
 Alphanumeric  Alphabetics (A-Z,a-z) or Numeric (0-9)
 Binary        Binary Digits String
 Lowercase     Lowercase Alphabetics (a-z)
 Mixed         Mixed Upper/Lowercase
 Numeric       Valid Numbers
 Symbol        Valid REXX Symbols
 Upper         Uppercase Alphabetics (A-Z)
 Whole         Integer Numbers
 X             Hex digits string
@ENDNODE

@NODE DELSTR() "DELSTR()"
usage: DELSTR(string,n,[length])

-deletes substring out of string beginning with nth character
@ENDNODE

@NODE DELWORD() "DELWORD()"
usage: DELWORD(string,n,[length])

-deletes substring out of string beginning with nth word including trailing blanks
@ENDNODE

@NODE DIGITS() "DIGITS()"
usage: DIGITS()

-returns the current @{" numeric " LINK "numeric"} digits setting
@ENDNODE

@NODE EOF() "EOF()"
usage: EOF(file)

    -returns boolean value 1 (True) if the end-of-file has been reached and 0 (False) if not reached
@ENDNODE

@NODE ERRORTEXT() "ERRORTEXT()"
usage: ERRORTEXT(n)

-returns the error message corresponding to specified ARexx error code "n"
@ENDNODE

@NODE EXISTS() "EXISTS()"
usage: EXISTS(filename)

-tests existence of a file. Filename can include the path.
@ENDNODE

@NODE EXPORT() "EXPORT()"
usage: EXPORT(address,[string],[length],[pad])

    -copies data from optional string into a previously allocated memory area. The length parameter specifies the maximum number of characters to copy; default is the length of the string.
    -if length is longer than the string, the remaining area is filled with the pad character of nulls.
    -returns the number of characters copied.
    -see also @{" IMPORT() " LINK "IMPORT()"} and @{" STORAGE() " LINK "STORAGE()"}
@ENDNODE

@NODE FORM() "FORM()"
usage: FORM()

-returns the current numeric form setting
@ENDNODE

@NODE FIND() "FIND()"
usage: FIND(string,phrase)

    -locates a phrase of words in a larger string and returns the word number of the matched position
@ENDNODE

@NODE FREESPACE() "FREESPACE()"
usage: FREESPACE(address,length)

    -returns a block of memory of a given length to the interpreter's internal pool. The address argument must be a 4-byte string obtained by a prior call to @{" GETSPACE() " LINK "GETSPACE()"}
    -not always necessary to release allocated internally allocated memory, since ARexx releases it to the system when the program terminates.

    -calling FREESPACE() with no arguments returns the amount of memory available in the interpreter's internal pool.
@ENDNODE

@NODE FUZZ() "FUZZ()"
usage: FUZZ()

    -returns the current numeric fuzz setting. See also @{" Numeric " LINK "Numeric"}
@ENDNODE

@NODE GETCLIP() "GETCLIP()"
usage: GETCLIP(name)

-Searches the Clip List for name and returns the associated value string
-Search is case-sensitive
-If not found a null string is returned
-See also @{" SETCLIP() " LINK "SETCLIP()"}
@ENDNODE

@NODE GETSPACE() "GETSPACE()"
usage: GETSPACE(length)

    -allocates a block of memory from the interpreter's internal pool
    -returned value is the 4-byte value of the allocated block
    -internal memory is automatically returned to the system when the ARexx program terminates
    -The @{" Support library " LINK "FunctionSupportLibrary"} includes the function @{" ALLOCMEM() " LINK "ALLOCMEM()"} which allocates memory from the system free list. See also @{" FREESPACE() " LINK "FREESPACE()"}
@ENDNODE

@NODE HASH() "HASH()"
usage: HASH(string)

-returns the hash attribute of a string as a decimal number and updates the internal hash value of the string
@ENDNODE

@NODE IMPORT() "IMPORT()"
usage: IMPORT(address,[length])

-creates a string by copying data from the specified 4-byte address
-copy terminates at a null byte if length is not specified
-see also @{" EXPORT() " LINK "EXPORT()"}
@ENDNODE

@NODE INDEX() "INDEX()"
usage: INDEX(string,pattern,[start])

-searches for the first occurrence of pattern in string, beginning at specified start position.
@ENDNODE

@NODE INSERT() "INSERT()"
usage: INSERT(new,old,[start],[length],[pad])

-inserts the new string into the old string after the specified start position. Default start position is 0.
@ENDNODE

@NODE LASTPOS() "LASTPOS()"
usage: LASTPOS(pattern,string,[start])

-searches backwards for the first occurrence of pattern in string.
-default start position is the end of the string
@ENDNODE

@NODE LEFT() "LEFT()"
usage: LEFT(string,length,[pad])

-returns specified length of leftmost substring in string
-padded with blanks or supplied pad if shorter than requested length
@ENDNODE

@NODE LENGTH() "LENGTH()"
usage: LENGTH(string)

-returns the length of a string
@ENDNODE

@NODE LINES() "LINES()"
usage: LINES(file)

    -returns the number of lines queued or typed ahead at the logical file, which must refer to an interactive stream.
    -the line count is obtained as the secondary result of a @{" WaitForChar() " LINK "WaitForChar()"} call
@ENDNODE

@NODE MAX() "MAX()"
usage: MAX(number,number[,number,...])

-returns the maximum of the numeric arguments.
-At least two args needed, and must be numeric
@ENDNODE

@NODE MIN() "MIN()"
usage: MIN(number,number[,number,...])

-returns the minimum of the numeric arguments.
-At least two args needed, and must be numeric
@ENDNODE

@NODE OPEN() "OPEN()"
usage: OPEN(file,filename,['Append'|'Read'|'Write')

-Accesses an external file
-file argument is the logical 'alias' for filename.
-filename is the actual name of the file and may include device and
 directory path.
-returns a boolean value indicating success or failure to open
-no limit to number of open files
-open files are closed automatically when the program exits.
-See also @{" CLOSE() " LINK "CLOSE()"}, @{" READCH() " LINK "READCH()"}, @{" WRITECH() " LINK "WRITECH()"}, @{" READLN() " LINK "READLN()"}, and @{" WRITELN() " LINK "WRITELN()"}.
@ENDNODE

@NODE OVERLAY() "OVERLAY()"
usage: OVERLAY(new,old,[start],[length],[pad])

-overlays new string onto old string at specified start position
@ENDNODE

@NODE POS() "POS()"
usage: POS(pattern,string,[start])

-searches for pattern in string, beginning at start
@ENDNODE

@NODE PRAGMA() "PRAGMA()"
usage: PRAGMA(option,[value])

    Makes changes to the system environment in which the program operates. Some attributes return the previous value installed. Others only set a boolean success flag. The first letter of the option is sufficient.
    example: Pragma('D')

-OPTIONS:
 @{b}@{u}D@{uu}@{ub}irectory    -specifies a new current directory

 @{b}@{u}P@{uu}@{ub}riority     -specifies a new task priority within range -128 to 127.
               ARexx programs should never be run at a higher priority
               than the resident process, currently a value of 4.

 @{b}@{u}I@{uu}@{ub}d           -returns the task ID (address of the task block) which is
               a unique identifier.

 @{b}@{u}S@{uu}@{ub}tack        -Defines a new stack value for your current ARexx program.

The current implemented options are:

 @{b}@{u}W@{uu}@{ub}indowPtr    @{i}Pragma('W',{'NULL' | 'WorkBench'})@{ui}
              controls the task's WindowPtr field. Setting it to NULL
              suppresses requestors generated by a DOS call.

 @{b}@{u}*@{uu}@{ub}       @{i}Pragma('*',[name])@{ui} defines the specified logical name as the
         current ('*') console handler. Allows the user to open two
         streams on one window. If the name is omitted, the console
         handler is set to that of the client's process.

@ENDNODE

@NODE RANDOM() "RANDOM()"
usage: RANDOM([min],[max],[seed])

-returns a pseudo-random integer in the interval specified by min and max
-max-min must <=1000
-values from @{" RANDU() " LINK "RANDU()"} can be scaled & translated for a greater value range
-seed argument can be used to initialize the random number generator
@ENDNODE

@NODE RANDU() "RANDU()"
usage: RANDU([seed])

-returns a uniformly distributed, pseudo-random number between 0 and 1
-the number of digits precision is set by according to @{" Numeric " LINK "Numeric"} Digits setting
-see also @{" RANDOM() " LINK "RANDOM()"}
@ENDNODE

@NODE READCH() "READCH()"
usage: READCH(file,length)

-reads characters from a file into a string. See also @{" Readln() " LINK "Readln()"}
@ENDNODE

@NODE READLN() "READLN()"
usage: READLN(file)

-reads characters from a file into a string up to a newline character
-the returned string does not include the "newline."
-see also @{" Readch() " LINK "Readch()"}
@ENDNODE

@NODE REMLIB() "REMLIB()"
usage: REMLIB(name)

-removes an entry from the library list maintained by the resident process
-returns a boolean result
-function does not make a distinction between function libraries and function
 hosts
-see also @{" Addlib() " LINK "Addlib()"}
@ENDNODE

@NODE REVERSE() "REVERSE()"
usage: REVERSE(string)

-reverses the sequence of characters in a string
@ENDNODE

@NODE RIGHT() "RIGHT()"
usage: RIGHT(string,length,[pad])

-returns the specified right-hand portion of the string, and filled with
 given pad character if specified
@ENDNODE

@NODE SEEK() "SEEK()"
usage: SEEK(file,offset,['Begin' | 'Current' | 'End'])

-moves to a new position (offset) in the given logical file
-default is Current
-the returned value is the new position relative to the start of the file
@ENDNODE

@NODE SETCLIP() "SETCLIP()"
usage: SETCLIP(name,[value])

-adds a name-value pair to the Clip List maintained by the resident process
-an existing entry of the same name is updated with the supplied value
-entries may be removed by specifying a null value
-see also @{" Getclip() " LINK "Getclip()"}
@ENDNODE

@NODE SHOW() "SHOW()"
usage: SHOW(option,[name],[pad])

-returns the names in the resource list by option, or tests to see whether an
 entry with the specified name is available
-currently implemented options keywords are Clip, Files, Libraries, Ports:
    Clip -Examines the names in the clip list
    Files -Examines names of currently open logical files
    Libraries -Examines names of function libraries or function hosts
        in the Library List
    Ports -Examines names in the system Ports List
-if the name argument is omitted, a string is returned containing the
 resource names separated by blanks or a supplied pad character.
-the name entries are case-sensitive
@ENDNODE

@NODE SIGN() "SIGN()"
usage: SIGN(number)

-returns 1 if number is positive, zero if zero, and -1 if the number is negative
@{i}-note that the 1995 manual is in error here, because it states that the function returns 1 if the number is positive or zero. Thanks to Stefan A. Haubenthal <stefan.haubenthal@web.de> for pointing this one out.@{ui}

@ENDNODE

@NODE SOURCELINE() "SOURCELINE()"
usage: SOURCELINE([line])

-returns text for the specified line of the currently executing ARexx program
-returns the total number of lines in the file if line argument omitted
@ENDNODE

@NODE SPACE() "SPACE()"
usage: SPACE(string,n,[pad])

-reformats the string with n spaces/blanks between each pair of words
-a pad character will be used instead of blanks if given
-specifying n as 0 will remove all blanks
-failing to supply the "n" argument is the same as providing "0". All blanks are removed.
-see also @{" Compress() " LINK "Compress()"} and @{" Strip() " LINK "Strip()"}

Examples:
say space('w1 w2   w3 w4')   returns --->  w1w2w3w4
say space('w1 w2   w3 w4',2,'##')   returns --->  w1##w2##w3##w4

@ENDNODE

@NODE STORAGE() "STORAGE()"
usage: STORAGE([address],[string],[length],[pad])

-copies data from string into the indicated memory address.
-if given, address argument must be a 4-byte string
-if length is longer than string, remaining area is filled with the pad
 character or nulls
-calling storage() without arguments returns available system memory
-returned value is the previous contents of the memory area
-see also @{" Export() " LINK "Export()"}
@ENDNODE

@NODE STRIP() "STRIP()"
usage: STRIP(string,[{'B'|'L'|'T'}|,[pad])

-removes leading & trailing blanks from the string (default both)
-second argument specifies removal of Leading, Trailing, or Both
-optional "pad" character specifies character to be removed
@ENDNODE

@NODE SUBSTR() "SUBSTR()"
usage: SUBSTR(string,start,[length],[pad])

-returns the substring of string beginning at start for specified length
-if substring is shorter than the requested length, it is padded on the right
 with blanks or specified pad
@ENDNODE

@NODE SUBWORD() "SUBWORD()"
usage: SUBWORD(string,n,[length])

-returns substring from string beginning with nth word for specified length
 in words (default is remaining length of string)
-returned string never has leading or trailing blanks
@ENDNODE

@NODE SYMBOL() "SYMBOL()"
usage: SYMBOL(name)

-tests if name is a valid ARexx symbol
-returns BAD if not a valid symbol, LIT if uninitialized, and VAR if it
 has been assigned a value.
@ENDNODE

@NODE TIME() "TIME()"
usage: TIME(option)
       default: TIME() = TIME('n')

-returns the current system time or controls the internal elapsed time
 counter. Without the option argument supplied this function returns the
 system time formatted as HH:MM:SS.
-it is only necessary to supply the first letter of the option argument.

 Options are:
    Civil     -current time, 12 hour format
    Elapsed   -elapsed time in seconds
    Hours     -current time in hours since midnight
    Minutes   -current time in minutes since midnight
    Normal    -current time in 24 hour format
    Reset     -Reset the elapsed time clock
    Seconds   -current time in seconds since midnight

@ENDNODE

@NODE TRACE() "TRACE()"

usage: TRACE(@{"option" LINK "Tracing"})
       default: TRACE() = TRACE('n')

-sets the tracing mode to specified @{" option. " LINK "Tracing"}
-mode can be altered even during interactive tracing
-TRACE() and TRACE(option) both return the trace mode in use BEFORE the call is made, but TRACE() can also be used to discover the current trace mode in use:

   example: var = Trace()
            sets 'var' to the current trace mode as if it were set by
            supplying the argument 'n', but returns the prior mode in
            the variable 'RESULT'.

   example: trace('a')
            sets the trace mode to 'ALL' but returns the prior
            mode in the global variable 'RESULT'.

   example program:
      /* Show results from trace() command...*/
      options results
      call trace('a')      /* sets result to N */
      say '1.' rc result   /* proved in this line */
      say '2.' trace()     /* outputs A as current mode in use...*/
      say '3.' rc result   /* but still shows N as prior mode */
      say '4.' trace()     /* outputs A as the current mode...*/
      call trace('n')      /* sets N as current mode but...*/
      say '5.' rc result   /* sets result to A as prior mode!*/
      say '6.' trace()     /* outputs N as current mode BUT
                              sets result to A as the prior mode!*/

-see @{" Tracing " LINK "Tracing"} options and @{" RexxC " LINK "RexxC"}
@ENDNODE

@NODE TRANSLATE() "TRANSLATE()"
usage: TRANSLATE(string[,output][,input][,pad])

-constructs a translation table for character substitution in a string
-translates to uppercase if only string is given
-if given, characters in the input table are converted to the corresponding
 characters in the output table
-characters beyond the end of the output table are replaced with blanks or
 the specified pad character
-the result string is alway the same length as the original string
-input and output tables may be any length
-example: translate('abcde','123','cbade','+') ===> 321++
@ENDNODE

@NODE TRIM() "TRIM()"
usage: TRIM(string)

-removes trailing blanks from a string
@ENDNODE

@NODE TRUNC() "TRUNC()"
usage: TRUNC(number,[places])

-returns the integer part of the number and specified decimal places
-default places is 0
@ENDNODE

@NODE UPPER() "UPPER()"
usage: UPPER(string)
-translates a string to uppercase
-is faster for short strings than @{" Translate() " LINK "Translate()"}
@ENDNODE

@NODE VALUE() "VALUE()"
usage: VALUE(name)

-returns the value of the symbol represented by name
@ENDNODE

@NODE VERIFY() "VERIFY()"
usage: VERIFY(string,list[,'Match'])
       VERIFY(string,list[,'m'])
       VERIFY(string,list[,'Match'][,start])

Note: third usage example above is not documented in the 1991 and 1995 editions of the ARexx manuals. Thanks to @{" Stefan A. Haubenthal " LINK "ABOUT"} for pointing this one out.

-if Match keyword omitted: returns position of the first character in string NOT contained in list, or 0 if all characters contained in list.

-if Match keyword supplied: returns position of the first character in string which IS in the list, or 0 if none are present.

Examples:
 SAY VERIFY('123456','0123456789')      --> 0
 SAY VERIFY('123a56','0123456789')      --> 4
 SAY VERIFY('123a56','0123456789')      --> 4
 say VERIFY('123756','123456')          --> 4
 SAY VERIFY('123a45','abcdefghij','m')  --> 4
 say verify('123756','123456','m')      --> 1
 say VERIFY('123756','123456','m',4)    --> 5

@ENDNODE

@NODE WORD() "WORD()"
usage: WORD(string,n)

-returns nth word in string or null if fewer than n words
@ENDNODE

@NODE WORDINDEX() "WORDINDEX()"
usage: WORDINDEX(string,n)

-returns start position of nth word in string or 0 if fewer than n words
@ENDNODE

@NODE WORDLENGTH() "WORDLENGTH()"
usage: WORDLENGTH(string,n)

-returns the length of the nth word in string
@ENDNODE

@NODE WORDS() "WORDS()"
usage: WORDS(string)

-returns number of words in string
@ENDNODE

@NODE WRITECH() "WRITECH()"
usage: WRITECH(file,string)

-writes string to given logical file
-returned value is actual number of characters written
-see @{" Writeln() " LINK "Writeln()"}
@ENDNODE

@NODE WRITELN() "WRITELN()"
usage: WRITELN(file,string)

-writes string to given logical file and appends "newline" character
-returned value is actual number of characters written
-see @{" Writech() " LINK "Writech()"}
@ENDNODE

@NODE X2C() "X2C()"
usage: X2C(string)

-converts string of hex digits into packed character representation
-blank characters are allowed at byte boundaries
@ENDNODE

@NODE X2D() "X2D()"
usage: X2D(string,digits)

-converts a hexadecimal number to decimal
-the digits arguments specifies the number of rightmost hex digits used in the conversion.
-digits argument cannot be greater than 8.
-see also @{" numeric " LINK "numeric"} digits and @{" d2x() " LINK "d2x()"}

The ARexx reference manual does not explain the digits argument. Other references say digits sets the length of the hex string used for conversion, and the string is truncated or padded with 0's on the left if longer or shorter than string. But the latter suggestion doesn't appear to work that way. However, a conversion from decimal to hex with the @{" d2x() " LINK "d2x()"} function is padded with zeros.

Following example illustrates the action that takes place with/without the digits argument ( "--->" denotes the result):

say x2d(0a4452)   ---> 672850
say x2d(0A4452,0) ---> 0
say x2d(0A4452,1) ---> 2
say x2d(0A4452,2) ---> 82
say x2d(0A4452,3) ---> 1106
say x2d(0A4452,4) ---> 17490
say x2d(0A4452,5) ---> -375726
say x2d(0A4452,6) ---> 672850
say x2d(0A4452,7) ---> 672850
say x2d(0A4452,8) ---> 672850
say x2d(0A4452,9) ---> "Invalid argument to function" error message

@{u}Comments welcome@{UU}. [see @{" About " LINK "About"}]

1)"The string may contain max. 8 digits because it's a 32 bit value." ­stefan.haubenthal@web.de


@ENDNODE

@NODE XRANGE() "XRANGE()"
usage: XRANGE([start],[end])

-generates a string of all characters between the start and end values
-default start character is '00'x and default end is 'FF'x
@ENDNODE

@NODE "APSHDIR" "APSHDIR"
APSHDIR

This keyword can be found within the rexxsupport.library, but it does not appear to be a user function. If anyone has information to the contrary, please @{" contact " LINK "about"} the author. Thank you.
@ENDNODE

@NODE BADDR "BADDR()"
BADDR

BADDR(bptr):
Converts a BCPL-style pointer (BPTR) into a C-style pointer.

@ENDNODE

@NODE DELETE() "DELETE()"
DELETE(path)

Delete the file or directory given by path.

@ENDNODE

@NODE FILE() "FILE()"
FILE()

This keyword can be found within the rexxsupport.library, but it does not appear to be a user function. If anyone has information to the contrary, please @{" contact " LINK "about"} the author. Thank you.
@ENDNODE

@NODE FORBID() "FORBID()"
FORBID()

Forbids task switching until a call to PERMIT() is encountered. Calls to FORBID() and PERMIT() can be nested--task switching will only be enabled when the outermost PERMIT() is executed. Task switching is automatically enabled when an ARexx program terminates, regardless of nesting level.

@ENDNODE

@NODE FORWARD() "FORWARD()"
FORWARD()

This keyword can be found within the rexxsupport.library, but it does not appear to be a user function. If anyone has information to the contrary, please @{" contact " LINK "about"} the author. Thank you.
@ENDNODE

@NODE MAKEDIR() "MAKEDIR()"
MAKEDIR()

Creates the new directory specified by /path/ and returns a boolean result. The function will only fail if the directory could not be created, and not if it already exists.
@ENDNODE

@NODE NEXT() "NEXT()"

NEXT(address, [offset])
Returns the four-byte value at the /address/ (which is expected to be a four-byte string) plus offset if specified. It can be used to follow an Exec linked list forward or backward.
@ENDNODE

@NODE NULL() "NULL()"
NULL()
Returns a null pointer as a four-byte string '0000 0000'x.

@ENDNODE

@NODE OFFSET() "OFFSET()"

OFFSET(address, displacement):

Compares a new address as the signed displacement from a base address. The address must be a four-byte string, and the displacement argument is a decimal integer. This function provides a convenient way to compute the address of a field in a data structure without requiring calls to C2D() and D2C().

@ENDNODE

@NODE PERMIT() "PERMIT()"
PERMIT()
Enables task switching when disabled by a previous call to FORBID(). Calls to FORBID() and
PERMIT() can be nested--task switching will only be enabled when the outermost PERMIT() is executed. Task switching is automatically enabled when an ARexx program terminates, regardless of nesting level. The return value is the current nesting count, or -1 if task switching is enabled.

@ENDNODE

@NODE RENAME() "RENAME()"
RENAME(oldpath, newpath)

Renames the file or directory specified by oldpath as newpath and returns a boolean result.

@ENDNODE

@NODE TYPEPKT() "TYPEPKT()"
Usage: TYPEPKT(address, [mode])
       Returned result is a  string, number, or Boolean value

Seldom required in message ports; however, this function returns information
about a message packet received at the <address>. The <address> argument
must be a valid address string, usually obtained using WAITPKT().

If the mode argument is omitted, the function returns a packed 4-byte
value, which can be translated to obtain information that is (except for
one instance) also available via the mode argument. The meaning of
each byte is:

The mode arguments may be specified with just the first letter of the following:

   Mode       Information provided
   ---------  -------------------------------------------------------
   Arguments  Returns the number of arguments. This information is
              contained in byte 0 of the unpacked return string.

   Command    Returns TRUE (1) if the packet was called as a command.
              This information is contained in byte 3 of the return
              string, which has a value of '01'x for commands.

   Function   Returns TRUE (1) if the packet was called as a function.
              This information is contained in byte 3 of the return ,
              string, which has a value of '02'x for functions.

Byte 2 of the packed return string specifies the modifier flags set
when the packet was called. The  REPLY() function automatically
handles any modifiers set by the calling command or function.

Calls to a port opened with an ARexx script should be sent as commands
(which have a single argument string by default). "That makes this function
somewhat superfluous, but since it echoes an interface function that is genuinely
useful in those other languages, it can be useful in  prototyping an ARexx
interface that will be transferred to a lower-level language" -Robin Evans.


@ENDNODE

@NODE ALLOCMEM() "ALLOCMEM()"
usage: ALLOCMEM(length,[attribute])

-Allocates specified size block of memory from the system free-memory pool
 and returns its address as a 4-byte string
-The optional attribute parameter must be a standard EXEC memory allocation
 flag, supplied as a 4-byte string. The default attribute is for "PUBLIC"
 memory (not cleared). The ROM kernel manuals for information on memory
 types and attribute parameters
-This function should be used whenever memory is allocated for use by
 external programs. The user is responsible to release memory no longer
 needed. The following list taken from "Advanced Amiga Basic" may give some
 direction:
    "AllocMem() lets you choose what kind of memory you get by forming a
 flag value. The flag value is the sum of the bit values for the desired
 combination of memory types. Usually, you'll just want to get a chunk of
 memory and don't care what you get. For this, use a value of zero... Public
 memory (type 1) is assumed to be used by many different routines, so the
 system memory manager is not allowed to relocate it...Here is a list of
 symbolic names and values used with AllocMem() to choose other kinds of
 memory:
    MEMF_PUBLIC     1    Stable, non-relocatable memory area
    MEMF_CHIP       2    Chip memory
    MEMF_FAST       4    Fast memory
    MEMF_CLEAR  65536    Memory area is cleared"
-see also @{" Freemem() " LINK "Freemem()"}
@ENDNODE

@NODE CLOSEPORT() "CLOSEPORT()"
usage: CLOSEPORT(name)

-Closes the message port specified by the name argument, which must have been
 allocated by a call to OPENPORT() within the current ARexx program. Any
 messages received but not yet REPLYed are automatically returned with the
 return code set to 10.
-see also @{" Reply() " LINK "Reply()"}, @{" OpenPort() " LINK "OpenPort()"}
@ENDNODE

@NODE FREEMEM() "FREEMEM()"
usage: FREEMEM(address,length)

-Releases a block of memory of the given length to the system freelist
-The address parameter is a four-byte string, typically obtained by a prior
 call to @{" Allocmem() " LINK "Allocmem()"}. @{" FreeMem() " LINK "FreeMem()"} cannot be used to release memory allocated
 using @{" Getspace() " LINK "Getspace()"}, the ARexx internal memory allocator. The returned value is
 a boolean success flag.
@ENDNODE

@NODE DELAY() "DELAY()"
usage: DELAY(n)

-This function not documented in the ARexx manual.
-Provides a system friendly delay instead of loading the system with a "busy loop".
-Argument "n" is a numeric value equivalent to 50 ticks per second.
-example: call delay(100) -> delays for approximately 2 seconds.
@ENDNODE

@NODE GETARG() "GETARG()"
usage: GETARG(packet,[n])

-extracts a command, function name, or argument string from a message
 packet. The packet argument must be a 4-byte address obtained from a
 prior call to @{" Getpkt() " LINK "Getpkt()"}
-The optional n argument specifies the slot containing the string to be
 extracted and must be less than or equal to the actual argument count for
 the packet
-Commands and function names are always in slot 0. Function packets may
 have argument strings in slots 1 to 15.
@ENDNODE

@NODE GETPKT() "GETPKT()"
usage: GETPKT(name)

-Checks message port given as name for available messages
-The named message port must have been opened by a prior call to @{" Openport() " LINK "Openport()"}
 within the current ARexx program. The returned value is the 4-byte address
 of the first message packet or '0000 0000'x if no packets were available.
-The function returns immediately if a packet isn't found at the message
 port. Instead of "busy-looping" on a port, the program should call @{" Waitpkt() " LINK "Waitpkt()"}
 and allow other tasks to proceed.
@ENDNODE

@NODE OPENPORT() "OPENPORT()"
usage: OPENPORT(name)

-Creates a public message port with the given name. The returned boolean
 value indicates whether the port was successfully opened. An initialization
 failure will occur if another port of the same name already exists or if a
 signal bit couldn't be allocated.
-The message port is allocated as a Port Resource node and is linked into the
 program's global data structure. Ports are automatically closed when the
 program exits and any pending messages are returned to the sender. See also
 @{" Closeport() " LINK "Closeport()"}
@ENDNODE

@NODE REPLY() "REPLY()"
usage: REPLY(packet,rc)

-Returns a message packet to the sender, with the primary result field set
 to the value given by the rc argument. The secondary result is cleared
-The packet argument must be supplied as a 4-byte address and the rc argument
 must be a whole number
-see @{" Getpkt() " LINK "Getpkt()"}, @{" Waitpkt() " LINK "Waitpkt()"}
@ENDNODE

@NODE SHOWDIR() "SHOWDIR()"
usage: SHOWDIR(directory,['ALL'|'File'|'Dir'],[pad])

-Returns the contents of the specified directory as a string of names
 separated by blanks
-The second parameter is a keyword indicating whether all entries, only
 files, or only subdirectories will be included
@ENDNODE

@NODE SHOWLIST() "SHOWLIST()"
usage: SHOWLIST({'A'|'D'|'H'|'I'|'L'|'M'|'P'|'R'|'S'|'T'|'V'|'W'},[name],[pad])

-The first argument selects from the following list:
    Assigned directories
    Device drivers
    Handlers
    Interrupts
    Libraries
    Memory list items
    Ports
    Resources
    Semaphores
    Tasks (ready tasks)
    Volume names
    Waiting tasks
-Returns a list separated by blanks if only one argument supplied
-Returns a list separated by the pad character if pad given
-If name is supplied returns boolean value indicating whether specified list
 contains that name
-Names are case-sensitive
-Task switching is forbidden while the list is scanned.
@ENDNODE

@NODE STATEF() "STATEF()"
usage: STATEF(filename)

-Returns information string about an external file
-Format of the string is:
    {DIR | FILE } length blocks protection days minutes ticks comment
-The length token gives the file length in bytes and the block token specifies the file length in blocks
@ENDNODE

@NODE WAITPKT() "WAITPKT()"
usage: WAITPKT(name)

-Waits for a message to be received at the specified port-name which must
 have been opened by a call to @{" Openport() " LINK "Openport()"} within the current ARexx program.
-The returned boolean value indicates whether a message packet is available
 at the port. Normally the returned value will be 1 (True), since the
 function waits until an event occurs at the message port
-The packet must then be removed by a call to @{" Getpkt() " LINK "Getpkt()"} and should be
 returned eventually using the @{" Reply() " LINK "Reply()"} function. Any message packets received but
 not returned when the program exits are automatically REPLYed with
 the return code set to 10
@ENDNODE

@NODE "Tips" "Tips"
Tips Section:
------------
1)WRITING BINARY AND HEX STRINGS -Ernest Unrau
2)MEMORY ADDRESSES AND HEX CODE  -Guido Mersmann

***

1)WRITING BINARY AND HEX STRINGS:
  ------------------------------

-By Ernest Unrau

This method is not documented in the Arexx manuals. Thanks instead to other programmers who demonstrated the technique in their scripts.

It is sometimes useful to include a binary or formatted string into your ARexx program code by converting it to text string in Hexadecimal code. This allows one to include the binary information, yet continue to edit the script in a text-only editor.

ARexx allows one to convert the string back to its character representation simply by quoting the string and adding the binary or hex designator.

Examples:

The character 'a' in binary code is 01100001. You can produce this conversion at the shell command line interface with the command:
   rx "say c2b('a')"
outputs,
  01100001
To convert back in the script, use this command in the shell:
  rx "say '01100001'b"
outputs
  a

The character 'a' in hexadecimal code is 61. You can produce this conversion at the shell command line interface with the command:
  rx "say c2x('a')"
outputs,
  61
To convert back in the script, use this command in the shell:
  rx "say '61'x"
outputs
  a

Similarly you can convert the string from its character representation to decimal:
  rx "say c2d('a')"
outputs,
  97
but there doesn't seem to be a similar way to convert the string back:
  rx "say '97'd"
does not work. Instead it outputs,
  97D
For this it appears you must use the function,
  rx "say d2c(97)"



2)MEMORY ADDRESSES AND HEX CODE
  -----------------------------

Explanation of the memory values output by the SYS:Tools/Showconfig command

Example:

RAM:    Node type $A, Attributes $505 (FAST), at $7000000-$7FFFFFF (16.0 meg)
        Node type $A, Attributes $703 (CHIP), at $4000-$1FFFFF (~2.0 meg)

These addresses converted to decimal,

  rx "say x2d('7000000') '-' x2d('7FFFFFF')

are,
  117440512 - 134217727

Why?

***
-by Guido Mersmann <geit@gmx.de>

Date: Thu, 23 Sep 2004 10:56:06 +0100
From: Guido Mersmann <geit@gmx.de>
Subject: Re: Address numbers

First never convert them to decimal, because they become ugly and worse to
handle.

To make it simple. One megabyte is 0x100000. [Ed. note: in rexx that would be '100000'x or x2d('100000')]

Your memory ranges from 7000000 to 8000000.
                        ^          ^
So the imporant megabyte counter makes one cycle. It's like counting from 10 to 20 (in decimal). The last (right) digit makes a full count from 0 to 0. So you count by the value of 10. With hex values this is the same when counting from 0 to 0, (but) they count 16 times a cycle.

[Ed. note:
Hexadecimal counts this way:
  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 etc.
In decimal this is,
   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 etc.]

So you need 16 * 100000 to get from 7000000 to 8000000. Thats 16MB.

Re.
  > 117,440,512
  > 134,217,727

Address != Amount

It's starting at 117... and ending at 134. To get its size you simply need to subtract them and you'll get 16,777,216. If you divide by 1024 you'll get 16364 KB and if you divide again you'll get 16MB.

Using hex is more simple: 0x8000000 - 0x7000000 = 0x1000000 (see above about the 8000000). Now since 0x100000 is 1 MB: 0x1000000 / 0x100000 = 0x10. 0x10 is 16 in decimal.

BTW: 7fffffff is the last byte, so you need to add 1 to get 8000000. It's like measuring a distance. You take the distance till behind the last inch and not 'til the beginning of the last inch.

The software you used [showconfig] reports the last byte of memory and not the end of memory.

also weg und so na denn und schuesss !!!

-Guido

@ENDNODE

@NODE "Code Samples" "Code Samples"

Code Samples

1. @{" Round " LINK "Round"} -by Bernd Gollesch
@ENDNODE

@NODE "Round" "Round"

@{b}ROUND@{ub} -by Bernd Gollesch

@{b}Parse and round number to specified decimal precision...@{ub}

@{i}This super efficient method of providing a function to round a number to a specified decimal precision, either to right or left of the decimal place, was submitted by Bernd Gollesch <bgollesch@sime.at> 31-May-2005 in the AmigaOS3.9 discussion group, "AmigaOS39@yahoogroups.com". Following is Bernd's code module; he wrote:@{ui}

I found something to optimize, the "10**(-precision)" - just have to be done once.

  /* parse and round number to specified decimal precision */

  Round: PROCEDURE
  PARSE ARG number, precision
  multi = 10**(-precision)
  IF precision < 0 THEN
     number = TRUNC(number/multi + .5, 0) * multi
  ELSE
     number = TRUNC(number + .5*multi, precision)
  RETURN number

@{i}This is an improvement on Bernd's first suggestion which was as follows:@{ui}

  Round:
  procedure
  /* parse and round number to specified decimal precision */

  Number=arg(1)
  precision=arg(2)

  if precision < 0 then do
     number = number / 10**(-precision)
     number = trunc(number + .5, 0)
     number = number * 10**(-precision)
     end
  else
     number = trunc(number + .5 * 10**(-precision), precision)

  RETURN number

  *********************

Positiv number are precision right of the decimal point and negativ
numbers are for the left, eg:

rx round 76.556 -1  =>   80
rx round 76.556 -2  =>  100
rx round 76.556 -3  =>    0

hth, Bernd


@ENDNODE


