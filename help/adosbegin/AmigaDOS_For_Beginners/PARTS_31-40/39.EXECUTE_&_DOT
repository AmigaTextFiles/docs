@DATABASE "ADB39"
@INDEX "ADB:Misc/Index.Text/Main"
@HELP "ADB:Misc/Help/Main"
@NODE "Main" "AmigaDOS For Beginners - Part 39 - The EXECUTE & DOT Commands"

@{B}@{U}@{JCENTER}AMIGADOS FOR BEGINNERS

@{" COPYRIGHT © FRANK P. BUNTON 1993-1998 " LINK "ADB:Misc/Read_Me_First!!/Copyright"}

BY FRANK BUNTON

PART 39 - THE EXECUTE AND DOT COMMANDS@{UB}@{UU}
@{JLEFT}

@{B}Location@{UB}     - "C" directory - all AmigaDOS versions

@{B}Purpose@{UB}      - To allow a script of command lines to be operated.

@{B}Availability@{UB} - All AmigaDOS Versions


We have been using the EXECUTE command in these articles for a while but
have not yet looked at its full usage, so it is about time that we did so.
@{JCENTER}

@{" General Comments on Execute         " LINK "General"} All AmigaDOS Versions   
@{" The `S' Protection Bit              " LINK "Sbit"} Version 1.3 Onwards     
@{" The DOT Commands                    " LINK "DotComs"} All AmigaDOS Versions   
@{" The .KEY Command                    " LINK ".Key"} All AmigaDOS Versions   
@{" The .BRA and .KET Commands          " LINK ".Bra.Ket"} All AmigaDOS Versions   
@{" The .DEF Command                    " LINK ".Def"} All AmigaDOS Versions   
@{" Referring To Current Process Number " LINK "Referring"} Version 1.3 Onwards     
@{" The .DOT Command                    " LINK ".Dot"} All AmigaDOS Versions   
@{" The .DOLLAR Command                 " LINK ".Dollar"} All AmigaDOS Versions   
@{" Using DOT (.) as Comment Indicator  " LINK "."} All AmigaDOS Versions   
@{" Inserting Blank Lines               " LINK "Blanks"} All AmigaDOS Versions   
@{" V1.2 and earlier Users Note re T:   " LINK "Note1.2"} Versions 1.2 and @{B}earlier@{UB}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "General" "Part 39 - The EXECUTE & DOT Commands - General Comments"

@{B}@{U}General Comments on Execute@{UB}@{UU}

EXECUTE must be used with a script name, as in:-

  EXECUTE ScriptName

There are @{B}NO options@{UB}.

If the script is not in the current directory then you must specify the
full path to the script file, as in:-

  EXECUTE DiskName:DirectoryName/ScriptName

It can be also used with @{"Arguments" LINK "ADB:Misc/Glossary/Arguments"} as in:-

  EXECUTE ScriptName argument

  EXECUTE ScriptName argument-1 argument-2 .......

Whether one or more arguments, if any, are needed will depend upon how
the script file was written (See @{"The `.KEY' Command" LINK ".KEY"}).


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Sbit" "Part 39 - The EXECUTE & DOT Commands - S Protection Bit"

@{B}@{U}The "s" Protection Bit@{UU} (v1.3 and later only)@{UB}

As we have seen in previous articles, if you @{"set" LINK "ADB:Parts_21-30/23.Protect/AddSub"} the @{"`s' protection bit" LINK "ADB:Parts_21-30/23.Protect/Bits"} of
a file, it tells the system that it is a script that can be executed.
The file name can then be entered at a prompt without the EXECUTE command,
as in:-

  > filename

or, if arguments are optional or required,:-

  > filename arguments

(@{B}v1.2 and earlier@{UB} users @{B}must@{UB} use EXECUTE)

However, this does @{B}NOT@{UB} mean that the EXECUTE command is not used. All
it means is that, if "EXECUTE" is not at the start of the command line,
and "filename" is not a command, then the system looks to see if the "s"
bit is set. If it is set, then the system automatically uses the EXECUTE
command just as if it had been the first word of the command line.

@{B}This means the the command EXECUTE must be in its proper place in the "c:"
directory so that the system can find it!@{UB}

Apart from not needing to type in the EXECUTE command, another advantage
of setting the "s" bit and using the script file name on its own at the
Shell/CLI prompt is that you can place the script in the "S" directory
and not have to type in the path to it. By entering just its name without
a path, AmigaDOS will search @{B}all@{UB} directories that have been put into the
path for that name. When it finds it, it will check the "s" bit and, if
set, use EXECUTE with it. The "S:" directory is put into the path by all
standard startup-sequences.

As a matter of interest, for @{B}AmigaDOS 2.0 onwards@{UB} if an @{"ARexx" LINK "ADB:Misc/Glossary/ARexx"} script has
its "S" bit set and its name is entered at a Shell/CLI prompt, then EXECUTE
will @{B}NOT@{UB} be used. The system will detect that it is @{B}NOT@{UB} an AmigaDOS script
but an ARexx script and will automatically operate it as an ARexx program.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "DotComs"

@{B}@{U}DOT Commands With EXECUTE@{UB}@{UU}

DOT Commands are a form of KEYWORD that is unique to the EXECUTE command.

Whereas with all other AmigaDOS commands the keywords are part of the same
command line in which the command is used, with EXECUTE the DOT keywords
are @{B}NOT@{UB} part of EXECUTE's command line. They are @{B}embedded into the
script file that EXECUTE is used on.

The DOT commands that are available in @{B}All AmigaDOS Versions@{UB} are:-

@{" .KEY    " LINK ".Key"} Define argument template to accept arguments from EXECUTE command
           line
@{" .DEF    " LINK ".Def"} Give a default value to a keyword argument defined by .KEY
@{" .BRA    " LINK ".Bra.Ket"} Change the angle bracket < to another character
@{" .KET    " LINK ".Bra.Ket"} Change the angle bracket > to another character
@{" .DOT    " LINK ".Dot"} Change the dot . to another character
@{" .DOLLAR " LINK ".Dollar"} Change the $ to another character
@{" .       " LINK "."} Insert comment lines
@{" .       " LINK "Blanks"} Insert a blank line

The are called DOT commands because they all start with a "."


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE ".Key" "Part 39 - The EXECUTE & DOT Commands - The .KEY Command"

@{B}@{U}The .KEY Command@{UB}@{UU}

You all know by now that you can pass information to AmigaDOS commands.
For example, the command "DIR" on its own will show you the contents of
the current directory but if you follow it with a directory name you are
shown the contents of the specified directory. The name of the required
directory is passed to the DIR command. It is the @{"Argument" LINK "ADB:Misc/Glossary/Arguments"} for the DIR
command.

You can also pass arguments to script files by using the ".KEY" Dot
command.

This is best explained by the use of an example. Although this example is
too simple to be of practical use, its simplicity will help to illustrate
the use of DOT commands in scripts.

Have a look at the script file Example-39.1:-

  . Example-39.1
  .
  .KEY dirname
  .
  ECHO "The directory of <dirname> is*n"
  DIR <dirname>

First up note the the comment line giving the script name starts with a
@{"DOT then a space" LINK "."} instead of a semicolon. DOT commands will not work unless
the first character of the first line is a DOT.

Execute this script with:-

  > Example-39.1

(Don't forget to "CD" to its directory first.)

The contents of the current directory will be displayed. The three
occurrences of "dirname" in the script are ignored because there are no
arguments after the name "Example-39.1".

Now put the name of a directory after "Example-39.1". For example:-

  > Example-39.1 Sys:s

You will now be shown the contents of the "s" directory of your boot (Sys:)
disk.

Note that the key can be used as a @{B}keyword@{UB} in the command line, as in:-

  > Example-39.1 DIRNAME ram:

What happens is that, as soon as the script is executed, the system looks
for a dot command on the first line. If one is found, the system scans
right through the script and builds up a temporary file in the assigned
"T:" directory which is normally in RAM: (but Version 1.2 and earlier
users should @{"click here" LINK "Note1.2"}).

In the above example, the argument entered after the script name is
substituted wherever <dirname> is found. To test this out, I added this
line to the end of our "Example-39.1" script:-

   WAIT 10 MINS

and called it "Example-39.2", so that it became:-

  . Example-39.2
  .
  .KEY dirname
  .
  ECHO "The directory of <dirname> is*n"
  DIR <dirname>
  WAIT 10 MIN

EXECUTE this script with:-

  > Example-39.2 Sys:s

and, using another shell window or a directory utility, look in the "T:"
directory (usually RAM:T unless you are using @{"V1.2 or earlier" LINK "Note1.2"}) You should
find a file there with a name something like:-

  Command-00-T01

The final "01" indicates the process number for the shell in which the
script was executed. If you were using a shell with process number 3 the
file would be called "Command-00-T03"

The "00" indicates the number of the temporary file that the shell process
is currently using. If process number 1 had two temporary command files
in operation at once they would be called:-

  Command-00-T01
  Command-01-T01

Use "Type" on this file and you will see that its contents are:-

  ECHO "The directory of Sys:s is*n"
  DIR Sys:s
  WAIT 10 MINS

The argument "Sys:s" has been substituted for <dirname> wherever it appears!
Note the the unwanted comment lines have also been left out.

The temporary command file will be deleted automatically once the script
has finished. That is why you need to put in a delay with "WAIT 10 MINS"
so that it remains there long enough for you to examine it. Press CTRL-C
when you have finished with it to break the wait command.

An important aspect of these temporary command files is that they are
not created, or do not work properly, unless these conditions are met:-

- The first line of the script is a DOT command
- There is NO space before the first DOT command
- The .KEY command is found somewhere in the script file.

Now go back to "Example-39.1" and enter:-

  > Example-39.1 ?

The Shell/CLI window should give the message:-

  dirname:

with the cursor displayed to the right waiting for your input. This is
showing you the @{"template" LINK "ADB:Misc/Glossary/Format"} of the script file just like normal AmigaDOS
commands.

Now look at "Example-39.3":-

  . Example-39.3
  .
  .KEY filename
  ECHO "The contents of <filename> are*n"
  TYPE <filename>

and execute it (without arguments):-

  > Example-39.3

You will be given an error message "required argument missing" or "bad
args" depending on your AmigaDOS version. "Type" cannot be used without
a file name after it!

If you like, copy Example-39.3 to RAM: (so leaving the original example
unaltered) and change ".KEY" line in the RAM: version to:-

  .KEY filename/A

Now when you enter:-

  > Ram:Example-39.3 ?

you will get this display:-

  filename/A

The "/A" indicates to the user that the argument must always be used in the
command line and is illustrated in Example-39.4 below.

You can use more than one argument after ".KEY" by separating them with
commas. As an example, have a look at "Example-39.4":-

  . Example-39.4
  .
  .KEY filename/A,dest/A
  TYPE <filename> TO <dest>
  ECHO "The contents of <filename> have been sent to <dest>"

Now if you enter:-

  > Example-39.4 

you will get the error message:-

  EXECUTE: Parameters unsuitable for key "filename/A,dest/A"
  required argument missing

(@{B}V1.x@{UB} will display only the first of the above two error message lines.)

If you enter:-

  > Example-39.4 ?

  --> filename/A,dest/A:

telling you that both a file name and a destination must be used.

Now if you enter:-

  > Example-39.4 s:startup-sequence ram:myfile

the message you get will be:-

  The contents of s:startup-sequence have been sent to ram:myfile.

and you can look at the file "ram:myfile" and find a copy of the
"s:startup-sequence" file.

As you probably know, the last line of the above could be changed to:-

  TYPE > <dest> <filename>

This uses the redirection symbol ">" to send the output to a file instead
of to the screen. The different use of the angle brackets is confusing,
isn't it?!?!

This confusion can be overcome by using the @{".BRA and .KET" LINK   ".Bra.Ket"} commands to
replace the <> with other symbols.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE ".Bra.Ket" "Part 39 - The EXECUTE & DOT Commands - The .BRA & .KET Commands"

@{B}@{U}The .BRA and .KET Commands@{UB}@{UU}

In the @{"previous examples" LINK ".Key"17}, we used the angle brackets "<" and ">" which are
default brackets for enclosing arguments. These are the same characters
(but @{B}not@{UB} the same usage) as the AmigaDOS @{"redirection symbols" LINK "ADB:Parts_01-10/04.Using_Shell-Cli/RedirectCom"}.

To avoid confusion, you can change the brackets used for arguments with
".BRA" (for the opening bracket) and ".KET" (for the closing bracket).
The last example we had could then become:-

  . Example-39.5
  .
  .KEY filename/A,dest/A
  .BRA {
  .KET }
  TYPE > {dest} {filename}
  ECHO "The contents of {filename} have been sent to {dest}"

The characters used as replacement brackets can be any that you can enter
from the keyboard. For example:-

  .BRA X or .BRA #
  .KET Y or .KET $

but this would be too confusing!. Stick to {} or [] or () but you will
find that {} is the most commonly used.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE ".Def" "Part 39 - The EXECUTE & DOT Commands - The .DEF Command"

@{B}@{U}The .DEF Command@{UB}@{UU}

As @{"mentioned earlier" LINK ".Key"127}, if you enter "Example-39.3" without arguments you
will get an error message as "type" needs something to type!

So let's add some defaults for the arguments to it.

The following Example-39.6 is nearly the same as  @{"Example-39.5" LINK ".Bra.Ket"}.
The differences are that the "/A" is not appended to the .KEY argument
names (you cannot use defaults when you use the "/A" suffix on keys) and
two extra lines starting with ".DEF" have been added.

  . Example-39.6
  .
  .KEY filename,dest
  .DEF filename s:startup-sequence
  .DEF dest ram:myfile
  .BRA {
  .KET }
  TYPE > {dest} {filename}
  ECHO "The contents of {filename} have been sent to {dest}"

Now, if no arguments are given, the default values defined with .DEF will
be used. Try it out and look at the new file "ram:myfile".

You can still use arguments to override the defaults but if you wish to
use the argument "ram:xyz" for the second ("Dest") key while using the
default for the first ("Filename") key and tried to use:-

  > Example-39.6 ram:xyz

the "ram:xyz" would be used for the "Filename" key. You would need to
actually use the "DEST" keyword as follows:-

  > Example-39.6 DEST ram:xyz

The use of .DEF ensures that the default is used in ALL occurrences of
<keyword>. If you wish the default to be used in only an individual
occurrence of <keyword> you use the default character $ between the keyword
and the default value as in <keyword$default>. As an example, try this
(call it "Example-39.7"):-

  . Example-39.7
  .
  .KEY name
  ECHO "The directory of <name> is:-*n"
  DIR <name$ram:>

If you enter:-

  > Example-39.7

the echo would show:-

  The directory of is:-

followed by the contents of "ram:". The occurrence of <name> in the ECHO
line has not had anything substituted but "ram:" has been substituted
after "DIR".

But if you enter:-

  > Example-39.7 df0:

the message will be

  The directory of df0: is:-

followed by the contents of df0:

the "df0:" in the command line has been substituted for all occurrences
of <name> and <name$ram:>.

The use of .DEF as in:-

  .KEY name
  .DEF name S:
  DIR <name$ram:>

will over ride the "$ram:" thus making it completely useless.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Referring" "Part 39 - The EXECUTE & DOT Commands - Current Process Number"

@{B}@{U}Referring To The Current Process Number@{UU} (v1.3 onwards)@{UB}

The process number being used by the script can be referenced with <$$>.
This could be useful if you were using the same script in different
processes to write and read files and wished to ensure that each process
only used its own files. For example, try out this script:-

  . Example-39.8
  .
  .KEY name
  .BRA {
  .KET }
  ECHO >ram:Test-{$$} "Ex process {$$}"

After executing this script you should find a file in Ram: called "Test-1"
(assuming you executed it in process number 1). The contents of this file
will be:-

  Ex Process 1

Open another shell window and execute it again and (assuming it is process
number 2) the file created and its contents will be "Test-2" and
"Ex process 2".

Why the seemingly useless ".KEY name" line? The temporary command file
needs to be properly set up to substitute the process number wherever
the <$$> occurs and this does not happen unless the @{"conditions" LINK ".Key"108} outlined
earlier are met, which include the presence of a ".KEY" command - even
though it is not used!

If you do not use the ".KEY" then, in @{B}v2+@{UB}, the script will execute but the
file will be called "Test-{}" and its contents will be "Ex process {}".

If you do not use the ".KEY" in @{B}v1.x@{UB} you, you will get an error message:-

  EXECUTE: No K directive


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE ".Dot" "Part 39 - The EXECUTE & DOT Commands - The .DOT Command"

@{B}@{U}The .DOT Command@{UB}@{UU}

.DOT will change the "." to another character. For example, you could use:-

  .DOT !
  !KEY name
  !BRA {
  !KET }

However, the very first character of the script must always be ".".


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE ".Dollar" "Part 39 - The EXECUTE & DOT Commands - The .DOLLAR Command"

@{B}@{U}The .DOLLAR Command@{UB}@{UU}

.DOLLAR will change the "$" character. For example:-

  . Example-39.9
  .
  .KEY name
  .BRA {
  .KET }
  .DOLLAR #
  ECHO >ram:Test-{##} "Ex process {##}"

This is virtually the same as @{"Example-39.8" LINK "Referring"} except for:-

  The Line     .DOLLAR #

  The use of {##} instead of {$$}


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "." "Part 39 - The EXECUTE & DOT Commands - Using "." As Comment Indicator"

@{B}@{U}Using DOT (.) as Comment Indicator@{UB}@{UU}

". " (dot then a space) can be used instead of ";" to insert comment lines
into the script. For example:-

  . This script reads a directory
  .
  .KEY dir-name
  DIR <dir-name>

In fact, if a script uses the .KEY command then its first line @{"MUST" LINK ".Key"108} start
with a ". " (dot then a space) and NOT a semicolon.

However, a dot @{B}CANNOT@{UB} be used to insert a comment at the end of a normal
command line. If you used:-

  . This script reads a directory
  .
  .KEY dir-name
  DIR <dir-name> . this is the dir command

you would get an error message telling you that you used the wrong number
of arguments. Comments at the end of command lines @{B}MUST@{UB} use the semicolon.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Blanks" "Part 39 - The EXECUTE & DOT Commands - Inserting Blank Lines

@{B}@{U}Inserting Blank Lines@{UB}@{UU}

The @{B}v2+@{UB} manuals state that a blank line can be inserted with:-

  .\\

Using this literally (i.e. with the back slash character) creates an
error:-

  EXECUTE: Invalid directive

The "\\" character has been put in the manual to represent the return key,
i.e. you should type "." then press return.

The @{B}v1.2@{UB} manual defines the blank line as:-

  .<newline>

or, in other words, just press return after the dot as I have done in
all the above examples.

@{B}NOTE@{UB} that you cannot use a dot for a blank line unless you have used:-

  .KEY name

at the start of the script.

However, it is easier just to press return at the start of a line without
the dot. It does the same job of creating a blank line in the script. You
may have noticed that i have done this quite a bit in the example scripts
in this set.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Note1.2" "Part 39 - The EXECUTE & DOT Commands - Note For 1.x Users"

@{B}@{U}V1.2 and earlier Users Note re T:@{UU}@{UB}

In @{B}v1.2 and earlier@{UB} there was no assigned T: directory and a disk based
T directory was used.

@{B}V1.1@{UB} needed the T directory to already exist.

@{B}v1.2@{UB} EXECUTE created a T directory if it did not exist. When doing this
it used the root directory of the disk (or RAM:) on which the current
directory was located. Thus if the CD was df1:MyDir the T would be created
on the root of DF1:. If the CD was RAM: then T would be made in RAM:.

If these T directories were disk based and not RAM: based then the disk
needed to be write enabled and there needed to be enough room on the disk
for the temporary files.

Where I mention in the these notes to look in T: or RAM:T then you should
look for a T directory on the disk holding the CD instead.

If you are still using @{B}v1.2 or earlier@{UB} and run into problems when executing
these example (or other) scripts due to the disk being too full, then copy
them into RAM:, make RAM: the CD and then try again.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

