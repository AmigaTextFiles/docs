@DATABASE "ADB41"
@INDEX "ADB:Misc/Index.Text/Main"
@HELP "ADB:Misc/Help/Main"
@NODE "Main" "AmigaDOS For Beginners - Part41 - The EVAL Command"

@{B}@{U}@{JCENTER}AMIGADOS FOR BEGINNERS

BY FRANK BUNTON

@{" COPYRIGHT © FRANK P. BUNTON 1993-1998 " LINK "ADB:Misc/Read_Me_First!!/Copyright"}

PART 41 - THE EVAL COMMAND@{UB}@{UU}
@{JLEFT}

@{B}Location@{UB}     - "C" directory

@{B}Purpose@{UB}      - To determine the value of simple expressions.

@{B}Availability@{UB} - AmigaDOS Version 1.3 Onwards


The EVAL command will calculate the values of one or more expressions
and (unless output is redirected) display the result in the window.
@{JCENTER}

@{" The Usage of EVAL                     " LINK "Format"} Versions 1.3 Onwards
@{"   The VALUE                           " LINK "Value"} Versions 1.3 Onwards
@{"   TO Keyword - Redirect Output        " LINK "Redirection"} Versions 1.3 Onwards
@{"   LFORMAT - Format Output In A String " LINK "LFormat"} Versions 1.3 Onwards
@{" The Use of Variables                  " LINK "Variables"} Versions 2.0 Onwards
@{" Example of EVAL Giving LOOPS          " LINK "Example"} Versions 1.3 Onwards
@{" Example of EVAL For Conversions       " LINK "Example2"} Versions 1.3 Onwards
@{" Example of EVAL To Make ALARM CLOCK   " LINK "Example3"} Versions 1.3 Onwards


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Format" "Part41 - The EVAL Command - Usage of EVAL"

@{B}@{U}USAGE OF EVAL@{UB}@{UU}

EVAL can be used in one of these ways:-

  EVAL Value1

  EVAL Value1 Operator Value2

  EVAL (either of the above) TO File

  EVAL (any of above) LFORMAT String

For TO and LFORMAT please see:-

  @{" TO Keyword - Redirect Output        " LINK "Redirection"}
  @{" LFORMAT - Format Output In A String " LINK "LFormat"}

There are three keywords:-

  VALUE1
  VALUE2
  OP

and EVAL can usually be used with or without these KEYWORDS, which can be
used in either of these two ways:-

  EVAL VALUE1 number1 OP operator VALUE2 number2
  EVAL VALUE1=number1 OP=operator VALUE2=number2

Both these would be the same as:-

  EVAL number1 operator number2

(But if the arguments are not in their @{"usual positions" LINK "ADB:Parts_61-70/63.Format_&_Template/Inferred"} then the keywords
@{B}MUST@{UB} be used - an example of this given in @{"Line 5" LINK "Example"65} of the example script.)

"Number1" and "Number2" should be @{"integer numeric values" LINK "Value"}.

"Operator" is one of the following mathematical operators:-

    Addition             +
    Subtraction          -
    Multiplication       *
    Division             /

    modulo               mod
    AND                  &
    OR                   |
    NOT                  ~
    left shift           lsh
    right shift          rsh
    negation             -
    exclusive OR         xor
    bitwise equivalence  rqv

  The first four are probably the only ones that the beginner need worry
  about.

To illustrate EVAL, let's have a look at some examples. The resultant
window display is shown below each example following the symbol "-->".

The first two examples use all the keywords in two different but equivalent
ways:-

  > EVAL VALUE1 3 OP + VALUE2 5
  --> 8

  > EVAL VALUE1=3 OP=+ VALUE2=5
  --> 8

However, except when arguments are not in their @{"usual places" LINK "Format"34}, the command
lines can be simplified, by omitting the keywords, to:-

  > EVAL 3 + 5
  --> 8

Other examples, without the keywords, are:-

  > EVAL 5 - 9
  --> -4

  > EVAL 4 * 16
  --> 64

  > EVAL 16 / 3
  --> 5

(See @{"Number Values" LINK "Value"} for explanation of the 16/3 = 5.)

Values used can be negative as well as positive. For example:-

  > EVAL -4 * 5
  --> -20

  > EVAL -4 * -5
  --> 20

  > EVAL -4 + 7
  --> 3


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Value" "Part41 - The EVAL Command - The Value"

@{B}@{U}THE EVAL "VALUE"@{UU}@{UB}

@{B}EVAL uses only integer values@{UB} in the input expressions and the results.
These values can be actual numbers or @{"environmental variables" LINK "Variables"} holding
numeric values.

(Integer numbers are whole numbers without any fractional or decimal part.)

The values can be in decimal, @{"hexadecimal or octal" LINK "Value"64}.

Thus the final example shown earlier gives only the whole number part of
the result:-

  > EVAL 16 / 3
  --> 5

@{B}EVAL will not accept decimal input.@{UB} If it is used, evaluation stops when it
reaches a decimal point. In these two examples:-

  > EVAL 4.6 + 5.7
  --> 4

  > EVAL 4 + 5.7
  --> 9

the evaluation stops at the first decimal point.

In the first example the operator "+" is never reached.

In the second, the evaluation stops at after the "5" and an evaluation is
made to give 9.

Values used can be negative as well as positive. For example:-

  > EVAL -4 * 5
  --> -20

  > EVAL -4 * -5
  --> 20

  > EVAL -4 + 7
  --> 3

If any non numeric character (apart from @{"# and x" LINK "Value"64}) is found in the "Number"
then evaluation stops. This has already been referred to in the discussion
of decimals above.

This is further illustrated in these examples:-

  > EVAL 4 + Test
  --> 4

  > Eval Test + 4
  --> 0

In both cases the evaluation stops at the "T" of "Test". In the second
example, no values have been found when it stops so 0 (zero) is returned.

It is not likely that you will put non numerics into a Shell/CLI command
line as in the above examples, but it might be possible for non numerics to
be inadvertently found if @{"environmental variables" LINK "Variables"} are used in command lines
in scripts.

@{B}@{U}Hexadecimal & Octal Number Input@{UB}@{UU}

Input can be in @{"Hexadecimal" LINK "ADB:Misc/Glossary/Hexadecimal"} or @{"Octal" LINK "ADB:Misc/Glossary/Octal"} as well as @{"Decimal" LINK "ADB:Misc/Glossary/Decimal"}.

Hexadecimal input numbers are indicated by preceding them with "#x" or
"0x" (the "0" being zero). For example:-

  > EVAL #xAB
  --> 171

  > EVAL 0xC1
  --> 193

Octal input numbers are indicated by preceding them with "#" or "0" (the
"0" being zero). For example:-

  > EVAL #100
  --> 64

  > EVAL 0345
  --> 229

Thus, if you are intending to input a @{B}decimal number@{UB} (i.e. a number in
decimal format, not one with decimal places in it), you must be @{B}very
careful NOT to have a leading 0@{UB} (zero)!!!


@{JCENTER}=== End of Text ===
@{JLEFT}






















@ENDNODE

@NODE "Variables" "Part41 - The EVAL Command - Using Variables"

@{B}@{U}The Use of Variables@{UU} (Version 2+ Only)@{UB}

The expressions can be simple numbers (as @{"illustrated above" LINK "Format"62}) or, in @{B}v2+,@{UB}
they can be @{"environmental variables" LINK "ADB:Parts_31-40/40.Env-Variables/Other"} that have numeric values. For example:-

  > SETENV x 3
  > SETENV y 5
  > EVAL $x * $y
  --> 15

This is demonstrated in @{"Example-41.2" LINK "Example2"28}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Redirection" "Part41 - The EVAL Command - TO Keyword For Output Redirection"

@{B}@{U}THE EVAL TO KEYWORD - OUTPUT REDIRECTION@{UU} (Versions 1.3 Onwards)@{UB}

The output of EVAL can be diverted to a file or device with the @{B}TO @{UB}keyword.
For example:-

  > EVAL 3 * 7 TO ram:filename

This would, in effect, be the same as using a @{"redirection symbol" LINK "ADB:Parts_01-10/04.Using_Shell-CLI/Out"}:-

  > EVAL > ram:filename 3 * 7

Both examples send the result to "Filename" in "Ram:"

In this way, environmental variables can be written with one of:-

  > EVAL TO Env:varname (values and operators)
  > EVAL > Env:varname  (values and operators)

For example:-

  > EVAL 23 / 5 TO Env:Number
  > GETENV Number
  -->  4


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "LFormat" "Part41 - The EVAL Command - LFORMAT in Output"

@{B}@{U}Formatting EVAL Output - LFORMAT@{UU} (Versions 1.3 Onwards)@{UB}

It may be that you want to output a bit of text with the resultant value
that is output. To do this you use the "LFORMAT" option, as in:-

  EVAL Value1 Operator Value2 LFORMAT string.

The "String" must contain one of the following symbols if it is to show the
result of the evaluation (case of the letters does not matter):-

  @{" %N " LINK "LFormat"55}  for @{"decimal" LINK "ADB:Misc/Glossary/Decimal"} number output

  @{" %X " LINK "LFormat"60}  for @{"hexadecimal" LINK "ADB:Misc/Glossary/Hexadecimal"} number output

  @{" %O " LINK "LFormat"60}  for @{"octal" LINK "ADB:Misc/Glossary/Octal"} number output (that's O for Orange, not 0 for zero)

  @{" %C " LINK "LFormat"116}  for character with @{"ASCII code" LINK "ADB:Misc/Glossary/Ascii"} equal to the number

These are all demonstrated in @{"Example-41.2" LINK "Example2"}.

@{B}@{U}General Comments@{UB}@{UU}

The term "%?" (representing any one of %N %X %O %C) MUST be included
somewhere in the string to show where the result of the evaluation is to
go. It can be at the start, middle or end.

For example:-

  > EVAL 20 * 9 LFORMAT "The answer is %N"
  --> The answer is 180

  > EVAL 20 * 9 LFORMAT "Answer %N is correct"
  --> Answer 180 is correct

  > EVAL 20 * 9 LFORMAT "%N is the answer"
  --> 180 is the answer

More than one occurrence of %? can be included. For example:-

  > EVAL 20 * 9 LFORMAT "The answer is %N decimal which is %X2 hexadecimal"
  --> The answer is 180 decimal which is B4 hexadecimal

The use of LFORMAT causes the cursor to stay on the same line so that the
next text display is at the end of the LFORMAT output. If you try out the
above examples you will see the Shell/CLI prompt appear at the end of the
output instead of on a new line. This can be quite useful at times such as
when you wish to "ECHO" some text immediately after the EVAL output.
However, to ensure that the next output is on a new line, include "*n" at
the end of the string. (This is the same as using @{"`*n' with ECHO" LINK "ADB:Parts_21-30/21.Echo/EscapeSpacing"}.)

For example:-

  > EVAL 20 * 9 LFORMAT "The answer %N is correct*N"

@{B}@{U}LFORMAT %N@{UB}@{UU}

%N results in the evaluation output being in decimal without any of the
limitations described below for %X and %O.

@{B}@{U}LFORMAT %X and %0@{UB}@{UU}

With %X and %O only one character of the evaluation (the last or rightmost
one) will be displayed unless a number is placed immediately after the %X
or %O. For example:-

  %X4   will display 4 characters in the number starting from
        the rightmost digit

This can be demonstrated in the following lines. The decimal number 31647
is equal to the hex number 7B9F. The use of "%X" with various numbers after
the "X" will give:-

  EVAL 31647 LFORMAT "31647 = hex %X"   --> 31647 = hex F
  EVAL 31647 LFORMAT "31647 = hex %X1"  --> 31647 = hex F
  EVAL 31647 LFORMAT "31647 = hex %X2"  --> 31647 = hex 9F
  EVAL 31647 LFORMAT "31647 = hex %X3"  --> 31647 = hex B9F
  EVAL 31647 LFORMAT "31647 = hex %X4"  --> 31647 = hex 7B9F
  EVAL 31647 LFORMAT "31647 = hex %X5"  --> 31647 = hex 07B9F
  EVAL 31647 LFORMAT "31647 = hex %X6"  --> 31647 = hex 007B9F

As can be seen in the last two examples, if "number" after the %X or %O is
more than the number of characters in the resultant number, then 0 (zero)
is used on the left side of the number.

@{B}NOTE@{UB} - Only a single digit number can be used. For example, this will NOT
give 12 digits:-

  > EVAL 31647 LFORMAT "31647 = hex %X12"

  --> 31647 = hex F2

This seems to be an incorrrect result until you realise that LFORMAT has
treated the "1" and the "2" of the "12" as parts of different things:-

   %X1 --> F    treated as the numerical hexadecimal number to be output

   2   --> 2    treated as the next part of the output string but with no
                space between the "F" and the "2".

       -->   F2

@{B}NOTE@{UB} - If you want to use "*N" after a "%X" or "%O" without any number,
then you MUST leave a space. For example, this will leave the cursor on
the same line as the output:-

  > EVAL 31647 LFORMAT "31647 = hex %X*N"

The is because in "%X*N" the "*N" is treated as the number to be placed
after the "%X" and is evaluated as "0" (zero). Thus only one digit of the
result is displayed and the cursor is NOT moved down.

The correct way to do it is:-

  > EVAL 31647 LFORMAT "31647 = hex %X *N"

@{B}@{U}LFORMAT %C@{UB}@{UU}

%C causes the number resulting from the evaluation to be converted to a
character with @{"ASCII code" LINK "ADB:Misc/Glossary/Ascii"} equal to the number.

For example, the ASCII code for "B" is 66 so that:-

  EVAL 66 LFORMAT "The ASCII code number 66 represents %C"

  --> The ASCII code number 66 represents B

ASCII codes range from 0 - 255. Any number greater than 255 will produce a
null character with %C (i.e. nothing will be shown).

Normal @{"printable characters" LINK "ADB:Misc/Glossary/Printable"} have ASCII codes in the range 32-127.

If your EVALuation results in numbers outside this range then you may get:-

- @{"Non standard characters" LINK "ADB:Misc/Glossary/NonStd"} in the range 128 - 255

- @{"Non printable codes" LINK "ADB:Misc/Glossary/NonPrint"} in the range 0 - 31 which may or may not do strange
  things. For example:-

  EVAL 7 LFORMAT "This activates the alert %C *n"

  This line will display the text and activate the Workbench "Error Alert".
  In Workbench 2.0 onwards, this alert can be sound or flash or both
  depending on the settings in the SOUND preferences editor.

  This is illustrated in @{"Example-41.3" LINK "Example3"27}.

@{JCENTER}=== End of Text ===
@{JLEFT}
































@ENDNODE

@NODE "Example" "Part41 - The EVAL Command - Example Script Using Loops"

@{B}@{U}AN EXAMPLE OF EVAL USING LOOPS@{UB}@{UU}

The following script demonstrates how EVAL can be used to set up a loop
in a script. A useless script but a good demonstration!

  . Example-41.1
  .
  .KEY none ; .KEY needed to use .BRA .KET
  .BRA {
  .KET }

  SETENV loop{$$} 1 ; set starting value at 1             ; 1
  LAB Start                                               ; 2
  ECHO "Working in process {$$} loop No. " NOLINE         ; 3
  GETENV loop{$$}                                         ; 4
  EVAL >nil: <env:loop{$$} OP=+ VALUE2=1 TO=t:loop{$$} ?  ; 5
  COPY t:loop{$$} env:loop{$$}                            ; 6
  SKIP BACK Start                                         ; 7

If you open two or more shell windows and execute this script in each
one at the same time it will show how "{$$}" makes reference to the process
number (as discussed in the article @{"EXECUTE & DOT" LINK "ADB:Parts_31-40/39.Execute_&_Dot/Referring"}). If executed in process
1 then {$$} = 1. If in process 2 then {$$} = 2, and so on.

If you have a spare shell window still available, or have a
@{"directory utility" LINK "ADB:Misc/Glossary/DirUtility"} operating, you can look at "ENV:" and see the various
loop{$$} variables that have been set up by SETENV in Line 1.

If the script is running in shell processes 2, 3 and 5 then Env: should
hold the variables "Loop2", "Loop3" and "Loop5".

To exit this script you will need to activate the window (click in it)
and press CTRL-D.

@{"Line 3" LINK "Example"15} puts the message "Working in process ... Loop No." on the screen
with the process number being inserted from the {$$}. The NOLINE ensures
that Line 4 will put the value of the variable "Loop.." on the same line.

In @{"Line 4" LINK "Example"16} , the GETENV gets the variable "Loop2" for Process 2 or the
variable "Loop3" for process 3, etc.

@{"Line 5" LINK "Example"17} is the only line in this script that should need extensive
explanation. This makes use of the same principle of ending the line with
"?" that we had with "SETENV" in the last article.

You will recall that, with the @{"SETENV example" LINK "ADB:Parts_31-40/40.Env-Variables/Keyboard"26}, the "?" at the end of a
command line caused the command format to be displayed and the system
to wait for input from the keyboard but as we did not want to see the
format we sent the display to Nil:

In this example we use a similar ploy except that we do not want input
from the keyboard but from a variable so we use the @{"`<' redirection symbol" LINK "ADB:Parts_01-10/04.Using_Shell-CLI/In"}
as in:-

  <env:loop{$$}

This is a good example of using the redirection symbol "<" to INPUT data
rather than the more common ">" to output data.

As this "<env:loop{$$}" is in the position of the keyword "VALUE1" the
value of the variable "loop{$$}" becomes VALUE1.

That takes care of "VALUE1" in the "EVAL" command line.

The rest of the "EVAL" command line in @{"Line 5" LINK "Example"17} takes advantage of the fact
that KEYWORDS can be used in a command line to put numbers and operators in
positions that they would not normally be in. To explain this, consider
this "EVAL" command:-

  > EVAL 2 + 1

It could also be written with the keywords in either of these two forms:-

  > EVAL VALUE1 2 OP + VALUE2 1
  > EVAL VALUE1=2 OP=+ VALUE2=1

By using one of these two methods, we no longer need to have the expressions
or the operator in the correct places so that we can have:-

  > EVAL OP=- VALUE2=4 VALUE1=10
  --> 6

Once we use the ploy of inputting VALUE1 from a file or variable by ending
with "?" we @{B}must@{UB} use one of the above two methods. The "=" makes things a
bit clearer.

Also, we MUST use the "TO" option to tell it where to send the output.
By using:-

  TO=t:loop{$$}

we tell the system to send the output to a file in T: called loop{$$}.

In concluding the discussion of Line 5:-

  EVAL >nil: <env:loop{$$} OP=+ VALUE2=1 to=t:loop{$$} ? ; 5

It all means:-

  Evaluate using      - VALUE1 = loop{$$}
                      - VALUE2 = 1
                      - OPERATOR = +
  Send the result TO  - a file in t: called loop{$$}

Finally, in Line 6:   - COPY t:loop{$$} env:loop{$$}

we transfer the new value to the ENV: directory so that it can be used in
the next execution of Line 5.

Putting Lines 5 and 6 together, all we are doing is adding 1 to the value
of the variable!!


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Example2" "Part41 - The EVAL Command - Example Script For Conversions"

@{B}@{U}AN EXAMPLE OF EVAL FOR CONVERSIONS@{UB}@{UU}

This example script will ask the user to select whether a decimal number is
to be converted to Hexadecimal, Octal or to a Character.

Of course, this is not very useful as conversion programs should be able to
allow any type of input (decimal, hexadecimal, octal) etc. as well as any
sort of output. However, there are plenty of programs in the @{"Public Domain" LINK "ADB:Misc/Glossary/PD"}
allowing for this sort of thing. The only purpose of this script is to
demonstrate the use of the various codes used in @{"LFORMAT" LINK "LFormat"}.

The script should not need any explanations as it has all been covered in
@{"this article" LINK "Main"} and the previous on on @{"Environmental Variables" LINK "ADB:Parts_31-40/40.Env-Variables/Main"}.

; Example-41.2 - Number converter

  LAB Start

  ECHO "*nDo you want to convert a DECIMAL number to:-*n"
  ECHO "1. Hexadecimal"
  ECHO "2. Octal"
  ECHO "3. A Character"
  ECHO "*nEnter the number of your choice:- " NOLINE
  SETENV >Nil: Choice ?
  ECHO "*nEnter the number to convert:- " NOLINE
  SETENV >Nil: Number ?

  IF $Choice EQ 1
    EVAL $Number LFORMAT "Decimal %N = Hexadecimal %X4"
    SKIP End
  ENDIF

  IF $Choice EQ 2
    EVAL $Number LFORMAT "Decimal %N = Octal %O4"
    SKIP End
  ENDIF

  IF $Choice EQ 3
    EVAL $Number LFORMAT "Decimal ASCII code %N = Character %C"
    SKIP End
  ENDIF

  ECHO "*nChoice was not one of 1 2 or 3"

  LAB End

  ASK "*n*nAnother conversion? (Y/N)"
  IF WARN
    SKIP BACK Start
  ENDIF


@{JCENTER}=== End of Text ===
@{JLEFT}























@ENDNODE

@NODE "Example3" "Part41 - The EVAL Command - Alarm Clock Example Script"

@{B}@{U}AN EXAMPLE OF EVAL AND WAIT THAT GIVES AN ALARM CLOCK@{UB}@{UU}

The following script uses:-

  @{"WAIT UNTIL Time" LINK "ADB:Parts_31-40/31.Wait/Main"36}

to create a pause until the set time

It then uses:-

   EVAL 7 LFORMAT "%c"

to output the @{"system's alert" LINK "LFormat"136}.

The rest of the script should not need explanation unless you want to
reread about the line @{"SET >Nil: AlarmTime ?" LINK "ADB:Parts_31-40/40.Env-Variables/Keyboard"26} or the line or the use of
@{"$AlarmTime" LINK "ADB:Parts_31-40/40.Env-Variables/Other"}

To use the script, it would be best to open another Shell/CLI then start it
up and enter the time HH:MM at which you want the alarm to sound.

There are all sorts of things that could be added to this script to make it
more user friendly but there are plenty of good clocks in the @{"Public Domain" LINK "ADB:Misc/Glossary/PD"}
that would do the job a lot better. The only reason for this script is to
illustrate `EVAL EVAL 7 LFORMAT "%c"' and `WAIT UNTIL'.

  ; Example-41.3

  ; An Alarm Clock

  ECHO "Enter the time for the alarm using HH:MM in 24 hour format"
  SET >Nil: AlarmTime ?

  WAIT UNTIL $AlarmTime

  UNSET AlarmTime

  LAB StartLoop

  EVAL 7 LFORMAT "%c"

  ECHO "Press CTRL-D to turn off alarm"
  WAIT 1

  SKIP BACK StartLoop


@{JCENTER}=== End of Text ===
@{JLEFT}






















@ENDNODE
