@DATABASE "ADB22"
@INDEX "ADB:Misc/Index.Text/Main"
@HELP "ADB:Misc/Help/Main"
@NODE "Main" "AmigaDOS For Beginners - Part 22 - Pattern Matching"

@{B}@{U}@{JCENTER}AMIGADOS FOR BEGINNERS

BY FRANK BUNTON

@{" COPYRIGHT © FRANK P. BUNTON 1993-1998 " LINK "ADB:Misc/Read_Me_First!!/Copyright"}

PART 22 - PATTERN MATCHING@{UB}@{UU}

@{" General Comments          " LINK "General"}
@{" Simple   Pattern Matching " LINK "Simple"}
@{" Advanced Pattern Matching " LINK "Advanced"}
@{" Warning And A Tip         " LINK "Warning"}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "General" "Part 22 - Pattern Matching - General Comments"

@{B}@{U}Pattern Matching - General Comments@{UB}@{UU}

If you have played cards much you will know that some games have "wildcards"
where certain cards such as the joker can substitute for some or all other
cards.

In a similar way, some AmigaDOS commands use wildcards and pattern matching
to make the processing of multiple files easier. The AmigaDOS commands that
will recognise pattern matching will vary from AmigaDOS version to AmigaDOS
version which makes it difficult to lay down a definitive guideline.

@{B}In AmigaDOS Version 1.2 & 1.3@{UB}, pattern matching can be used to a certain
degree with:-

    COPY   DIR   LIST   DELETE

@{B}From AmigaDOS Version 2.0 onwards@{UB}, pattern matching can be used with:-

    CD        COPY       DELETE     DIR       FILENOTE   JOIN
    LIST      PROTECT    RENAME *   SEARCH    SORT       TYPE

    * Note - RENAME can only use wildcards for @{"renaming to another directory" LINK "ADB:Parts_11-20/11.Rename/Multi"32}

The Amiga uses these symbols as wildcards:-

  ? #                (Some programs also support the asterisk * )

Their use will be explained in @{"Simple Pattern Matching" LINK "Simple"}.

Other characters (which are not wildcards) used in pattern matching are:-

  |  %  ()  []  -  ~  '

Their use will be explained in @{"Advanced Pattern Matching" LINK "Advanced"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Simple" "Part 22 - Pattern Matching - Simple Pattern Matching"

@{B}@{U}Pattern Matching - Simple@{UB}@{UU}

The simple usage of pattern matching uses only the two wildcards:-

  ?  -  meaning "Any single character"

  #  -  meaning "Any number of the single character following the #"

  #? -  meaning "Any number of any characters"

Note that the case of the letters being matched is insignificant.

These characters are illustrated in these sections:-

  @{" Illustration of The ?  Wildcard  " LINK "?"}

  @{" Illustration of The #  Wildcard  " LINK "#"}

  @{" Illustration of The #? Wildcards " LINK "#?"}

  @{" Warning On Use of #? And A Tip   " LINK "Warning"}

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "?" "Part 22 - Pattern Matching - Illustration of ?"

@{B}@{U}Pattern Matching - Illustration of The ? Wildcard@{UB}@{UU}

The ? wildcard means - "Any single character"

Let's assume that we have these files in a directory:-

  testfile-v5.0
  testfile-v5.1
  testfile-v5.2
  testfile-v6.0
  testfile-v6.1

The following table shows some patterns and the matches that they will get.

  @{U}  Pattern   @{UU}     @{U} Will Match  @{UU}     @{U}         The pattern is saying         @{UU}

  testfile-v5.?    testfile-v5.0     Any single character in the last spot
                   testfile-v5.1     of the pattern
                   testfile-v5.2

  testfile-v?.1    testfile-v5.1     Any single character in the third last
                   testfile-v6.1     spot of the pattern

  testfile-?5.1    testfile-v5.1     Any single character in the fourth
                                     last spot of the pattern

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "#" "Part 22 - Pattern Matching - Illustration of #"

@{B}@{U}Illustration of The # Wildcard@{UB}@{UU}

The # wildcard means - "Any number of the single character following the #"

Let's assume that we have these files in a directory:-

  testAfile
  testAAfile
  testAAAfile
  testBfile
  testBBfile
  testBBBfile

The following table shows some patterns and the matches that they will get.

  @{U}  Pattern   @{UU}     @{U} Will Match  @{UU}     @{U}         The pattern is saying         @{UU}

  test#Afile       testAfile       Any number of the letter "A"
                   testAAfile      between "test" and "file"
                   testAAAfile

  test#Bfile       testBfile       Any number of the letter "B"
                   testBBfile      between "test" and "file"
                   testBBBfile

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "#?" "Part 22 - Pattern Matching - Illustration of #?"

@{B}@{U}Illustration of The #? Wildcards@{UB}@{UU}

The #? wildcard combination means - "Any number of any characters"

@{B}This is probably the most commonly used pattern.@{UB}

The # means "any number of the character following the #"

The ? means "any single character"

So #? means "any number of any character"

Let's assume that we have these files in a directory:-

  testAfile
  testABfile
  testABCfile
  testBfile
  testBBfile
  testBBCfile

The following table shows some patterns and the matches that they will get.

  @{U}  Pattern   @{UU}     @{U} Will Match  @{UU}     @{U}         The pattern is saying         @{UU}

  testA#?          testAfile       Any number of any characters
                   testABfile      following "testA"
                   testABCfile

  #?Bfile          testABfile      Any number of any characters
                   testBfile       before "Bfile"
                   testBBfile

  test#?Cfile      testABCfile     Any number of any characters
                   testBBCfile     after "test" and before "Cfile"

  #?               all the files!    Any number of any characters

As another example, if you used:-

  > DELETE df1:MyDirectory/#?.info

you would delete all the files ending in ".info" or, in other words, all
the ICON files.

And if you wanted to look at all files EXCEPT the ".info" files then you
could use:-

  > LIST df1:MyDirectory/~(#?.info)

See @{"Advanced Pattern Matching" LINK "Advanced"6} for the explanation of the ~ symbol which
negates the pattern following it.

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}






























@ENDNODE

@NODE "Advanced" "Part 22 - Pattern Matching - Advanced Pattern Matching"

@{B}@{U}ADVANCED PATTERN MATCHING@{UB}@{UU}

Apart from the ~ to negate a pattern, I have rarely, if ever, used these
advanced pattern matching techniques.

Symbols used and their meanings are:-

  ()  to mark start & end of patterns using | and/or % or ~ }  @{"Click here" LINK "AdvDemo1"}
  |   to separate two alternatives. (A|B) means "A" or "B"  }  to see
  %   to indicate a null string (zero bytes = "")           }  how these
  ~   to negate the pattern which follows as in ~(pattern)  }  work

  []  to mark the start and end of a pattern using -        }  @{"Click here" LINK "AdvDemo2"}
  -   to represent a range of characters                    }  to see
      e.g.  [A-F] means any single character in the         }  how these
      range A B C D E F                                     }  work
  ~   to negate the pattern which follows as in ~[pattern]  }

  '   to include a wild card or pattern indicator           } @{"Click here" LINK "AdvDemo3"}
      in the pattern.                                       } to see
      e.g. '? = ? and will find the ? character             } how these
            and  '# = #    '' = '    '( = (    ') = )       } work
                 '% = %    '| = |    '[ = [                 }

      The ~ ] characters do not need ' in front of them
      but nevertheless  '~ = ~   '] = ]

      The - character must not have ' in front of it.

NOTE that there can be many other combinations of wild cards and pattern
matching characters than are shown in the above three "Click here" links.
However, they would so numerous and probably of so little practical value
that it would not be worth while to cover them all here.

If you really think that you would use other patterns, then go ahead and
experiment with them.

@{B}But check them with LIST or DIR before you use DELETE on them!!!@{UB}
See @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}










@ENDNODE

@NODE "AdvDemo1" "Part 22 - Pattern Matching - Advanced Pattern Matching"

@{B}@{U}Advanced Pattern Matching Using | % () ~@{UB}@{UU}

To demonstrate | % ( ) ~ let's assume this set of files in a directory:-

  testfile
  testAfile
  testABfile
  testABCfile
  testBfile
  testBBfile
  testBBBfile

The following table shows some patterns and the matches that they will get.

  @{U}  Pattern   @{UU}     @{U} Will Match  @{UU}     @{U}         The pattern is saying         @{UU}

  NOTE that all these              All the following patterns will select
  patterns must be enclosed        names that start with "test" and end
  in the () brackets.              with "file". The differences will be
                                   what appears between "test" and "file"

  test(A|B)file    testAfile       Selected names have either "A" or "B"
                   testBfile       between "test" and "file"

  test~(A|B)file   testfile        Selected names have NEITHER "A" NOR "B"
                   testABfile      between "test" and "file"
                   testABCfile     NOTE that this is the exact opposite of
                   testBBfile      the first pattern and so all the files
                   testBBBfile     not shown by the first pattern are shown
                                   by this pattern

  test(A|B|%)file  testfile        Selected names have either "A" or "B"
                   testAfile       or "" between "test" and "file"
                   testBfile       The % means a null string = "" (nothing)

  test~(A|B|%)file testABfile      Selected names have NEITHER "A" NOR "B"
                   testABCfile     NOR "" between "test" and "file"
                   testBBfile      NOTE that this is the exact opposite of
                   testBBBfile     the previous pattern and so all the
                                   files not shown by the previous pattern
                                   are shown by this pattern

Note that () pattern matching can be combined with [] pattern matching as
illustrated in @{"the example in the discussion of []" LINK "AdvDemo2"46}.

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "AdvDemo2" "Part 22 - Pattern Matching - Advanced Pattern Matching"

@{B}@{U}Advanced Pattern Matching Using - [] ~@{UB}@{UU}

To demonstrate the - [] ~ let's assume this set of files in a directory:-

  testfile
  testAfile
  testCfile
  testEfile
  testVfile
  testXfile
  testZfile

The following table shows some patterns and the matches that they will get.

  @{U}  Pattern   @{UU}     @{U} Will Match  @{UU}     @{U}         The pattern is saying         @{UU}

  NOTE that all these              All the following patterns will select
  patterns must be enclosed        names that start with "test" and end
  in the [] brackets.              with "file". The differences will be
                                   what appears between "test" and "file"

  test[A-F]file    testAfile       Selected names have any single character
                   testCfile       in the range A B C D E F between the
                   testEfile       "test" and "file"

  test~[A-F]file   testfile        Selected names will NOT to have any
                   testVfile       single character in the range
                   testXfile       A B C D E F between "test" and "file"
                   testZfile       NOTE that this is the exact opposite of
                                   the first pattern and so all the files
                                   not shown by the first pattern are shown
                                   by this pattern

  test[U-Z]file    testVfile       Select names have any single character
                   testXfile       in the range U V W X Y Z between the
                   testZfile       "test" and "file"

  test~[U-Z]file   testfile        Selected names will NOT to have any
                   testAfile       single character in the range
                   testCfile       U V W X Y Z between "test" and "file"
                   testEfile       NOTE that this is the exact opposite of
                                   the previous pattern so all the files
                                   not shown by the previous pattern are
                                   shown by this pattern

Note that [] pattern matching can be combined with () pattern matching.
For example:-

  test(%|[a-f])file  testfile      Selected names will have either a null
                     testAfile     OR any single character in the range
                     testCfile     A B C D E F between "test" and "file"
                     testEfile

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}






























@ENDNODE

@NODE "AdvDemo3" "Part 22 - Pattern Matching - Advanced Pattern Matching"

@{B}@{U}Advanced Pattern Matching Using '@{UB}@{UU}

To demonstrate the ' let's assume this set of files in a directory:-

  #?
  testAfile
  testCfile
  testEfile
  testVfile
  testXfile
  testZfile

Normally AmigaDOS will not let you use the wildcards # and ? as part of a
file name. However, it is possible to get them into a file name if you
use some of the @{"directory utility" LINK "ADB:Misc/Glossary/DirUtility"} programs. The AmigaDOS ED program will
also create a file with the name #? if you use this command line:-

  > ED #?

A file with #? as part or all of its name can cause all sorts of problems.

If you use this line to see what is in the file:-

  > TYPE #?

@{B}then ALL the files in the directory will be typed!!@{UB}
(except in v1.x when only the one file will be typed as pattern matching
 is not recognised by v1.x TYPE command).

If you try to delete it with:-

  > DELETE #?

@{B}then ALL the files in the directory will be deleted!!@{UB}

This is where you can use the apostrophe ' to make the pattern recognise
the "#" and/or the "?".

To TYPE the file you would use:-

  > TYPE '#'?

To DELETE the file you would use:-

  > DELETE '#'?

Now only the one file named "#?" will be typed or deleted.

If you want to keep the file then it would be best to rename it with,
for example:-

  > RENAME '#'? MySillyFile

The same principle can be used to eliminate any of the wildcard or pattern
matching characters that have somehow crept into file names.

See also @{"Warning And A Tip" LINK "Warning"}.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Warning" "Part 22 - Pattern Matching - Warning And A Tip"

@{B}@{U}WARNING AND A TIP@{UB}@{UU}

@{B}@{U}Warning@{UB}@{UU}

You should take @{B}GREAT CARE@{UB} if you use the wildcard combination #? with the
DELETE command. Its use with other commands like COPY could also create
problems.

For example, if you used:-

  DELETE DF0:#?

you would delete @{B}EVERY FILE@{UB} on the disk in DF0: !!!

@{B}@{U}A Tip@{UB}@{UU}

If you are uncertain which files a pattern will give you, then use LIST
or DIR before COPYing or DELETEing. This is especially important if you
are going to delete files with pattern matching. For example, with our
directory containing "testfile" versions:-

    testfile-v5.0
    testfile-v5.1
    testfile-v5.2
    testfile-v6.0
    testfile-v6.1
    testfile-v6.2
    testfile-v6.5
    testfile-v6.6

If we wanted to delete all the 5.something versions and used:-

  > DELETE #?5#?

we would delete these files which include one we DID NOT WANT TO DELETE!:-

    testfile-v5.0
    testfile-v5.1
    testfile-v5.2
    testfile-v6.5

Using this first:-

  > DIR #?5#?

would soon show us that we had used a pattern that did NOT give us what
we wanted!!

Entering:-

  > DIR #?5.#?

would show us that this is the proper pattern to use.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

