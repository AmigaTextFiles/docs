@DATABASE "ADB04"
@INDEX "ADB:Misc/Index.Text/Main"
@HELP "ADB:Misc/Help/Main"
@NODE "Main" "AmigaDOS For Beginners - Part 4 - Using Shell & CLI"

@{B}@{U}@{JCENTER}AMIGADOS FOR BEGINNERS

BY FRANK BUNTON

@{" COPYRIGHT © FRANK P. BUNTON 1993-1998 " LINK "ADB:Misc/Read_Me_First!!/Copyright"}

PART 4 - USING THE SHELL AND CLI WINDOWS

CONTENTS OF THIS ARTICLE@{UB}@{UU}
@{JLEFT}
This article has grown rather large but there are some important topics
in it which are either essential to using a Shell or CLI window or that
make using the window a lot easier. If you find this rather hard going
at this stage then @{B}please@{UB} make a note to come back to it after you have
read further into the articles in this set. You will, in all likelihood,
understand these topics much better after reading them again at a later
time.

The topics in this article are:-

       @{" Symbols Used In AmigaDOS          " LINK "Symbols"} All Versions CLI and Shell
       @{" Opening a CLI or Shell Window     " LINK "Opening"} All Versions CLI and Shell
       @{" Closing a Shell/CLI Window        " LINK "Closing"} All versions CLI and Shell
       @{" The Shell/CLI Prompt              " LINK "Prompt"} All versions CLI and Shell
       @{" Explanation of Key Presses        " LINK "KeyPress"} All versions CLI and Shell
       @{" Entering Command Lines            " LINK "Entering"} All versions CLI and Shell
       @{" Editing Command Lines (Shell)     " LINK "EditingNew"} Shell Only
       @{" Editing Command Lines (Old CLI)   " LINK "EditingOld"} Old CLI v1.3 and earlier
       @{" Moving Around Command Lines       " LINK "Moving"} Shell Only
       @{" Old Command History               " LINK "History"} Shell Only
       @{" Getting a blank Line              " LINK "Blank"} Shell Only
       @{" Searching For Old Commands        " LINK "Searching"} Shell Only
       @{" Copying and Pasting               " LINK "Copying"} Version 2.0 Onwards
       @{" Getting A Command Template        " LINK "Template"} All versions CLI and Shell
       @{" Redirecting Command Input/Output  " LINK "RedirectCom"} All versions CLI and Shell
       @{" Redirecting Keyboard Output       " LINK "RedirectKey"} All versions CLI and Shell
       @{" Pausing Command Output            " LINK "Pausing"} All versions CLI and Shell
       @{" Aborting Command Output           " LINK "Aborting"} All versions CLI and Shell
       @{" Starting a Program From Shell/CLI " LINK "Starting"} All versions CLI and Shell
       @{" Enclosing One Command In Another  " LINK "Another"} Version 2.0 Onwards


@{JCENTER}=== End of File ===
@{JLEFT}
@ENDNODE

@NODE "Symbols" "Part 4 - Using Shell & CLI - Symbols Used in AmigaDOS"

@{B}@{U}SYMBOLS USED IN AMIGADOS@{UU} (All Versions CLI and Shell)@{UB}

There are certain symbols, or characters, that have special meaning within
AmigaDOS. They are:-

@{B}@{U}Mathematical Operator Symbols@{UB}@{UU}  @{"Click here" LINK "ADB:Parts_41-50/41.Eval/Format"39} for more information.

  *   Multiplication Operator     @{"*  also miscellaneous symbol" LINK "Symbols"48}
  /   Division operator           @{"/  also miscellaneous symbol" LINK "Symbols"44}
  +   Plus operator               @{"+  also miscellaneous symbol" LINK "Symbols"51}
  -   Minus operator              @{"-  also pattern matching symbol" LINK "Symbols"32}

  -   Negation
  &   Logical AND
  |   Logical OR                  @{"|  also pattern matching symbol" LINK "Symbols"26}
  ~   Logical NOT                 @{"~  also pattern matching symbol" LINK "Symbols"27}

@{B}@{U}Wildcard Symbols@{UB}@{UU}  @{"Click here" LINK "ADB:Parts_21-30/22.Pattern_Matching/Simple"} for more information

  #   Wildcard
  ?   Wildcard

@{B}@{U}Pattern Matching Symbols@{UB}@{UU}  @{"Click here" LINK "ADB:Parts_21-30/22.Pattern_Matching/Advanced"} for more information.

  |   Pattern separator           @{"|  also mathematical symbol" LINK "Symbols"16}
  ~   Pattern negation            @{"~  also mathematical symbol" LINK "Symbols"17}
  ()  Pattern enclosers
  []  Pattern enclosers
  %   Null string indicator
  '   Wildcard selector
  -   Range indicator             @{"-  also mathematical symbol" LINK "Symbols"12}

@{B}@{U}Redirection Symbols@{UB}@{UU}

  >   @{"Redirect Command Output" LINK "Out"}
  >>  @{"Redirect & ADD to a File" LINK "Add"}
  <   @{"Redirect Command Input" LINK "In"}

@{B}@{U}Miscellaneous Symbols@{UB}@{UU}

  :   @{"Path Separator" LINK "ADB:Parts_01-10/03.Dirs_Files_Paths/Path"25}
  :   @{"Move to root directory In Shell/CLI" LINK "ADB:Parts_01-10/07.CD/Main"103}
  /   @{"Path Separator" LINK "ADB:Parts_01-10/03.Dirs_Files_Paths/Path"25}                         @{"/  also mathematical symbol" LINK "Symbols"10}
  /   @{"Move CD up one level In Shell/CLI" LINK "ADB:Parts_01-10/07.CD/Main"121}
  ""  @{"String delimiters" LINK "ADB:Misc/glossary/Strings"12}
  ""  @{"Make Assignment to CD" LINK "ADB:Parts_11-20/20.Assign/Special"}
  *   @{"Refer to Current Shell/CLI window" LINK "RedirectKey"}      @{"*  also mathematical symbol" LINK "Symbols"9}
  *   @{"Special Code Indicator" LINK "ADB:Parts_21-30/21.Echo/EscapeAvailable"}                 @{"*  also mathematical symbol" LINK "Symbols"9}
  `   @{"Enclose an AmigaDOS command in String" LINK "ADB:Parts_21-30/21.Echo/Enclosing"}
  +   @{"Add command to RUN command line" LINK "ADB:Parts_01-10/09.Run/Extra"}        @{"+  also mathematical symbol" LINK "Symbols"11}
  ;   @{"Comment indicator in scripts" LINK "ADB:Parts_21-30/25.Script_Files/Comments"}
  .   @{"Comment indicator in scripts" LINK "ADB:Parts_31-40/39.Execute_&_Dot/."}
  .   @{"DOT command indicator in scripts" LINK "ADB:Parts_31-40/39.Execute_&_Dot/DotComs"}


@{JCENTER}=== End of File ===
@{JLEFT}




































@ENDNODE

@NODE "Opening" "Part 4 - Using Shell & CLI - Opening a CLI or Shell Window"

@{B}@{U}OPENING A CLI OR SHELL WINDOW@{UU} (All Versions CLI and Shell)@{UB}

Boot up with your workbench disk and double click on its disk icon. If
the SHELL or CLI icon is not in the disk window then open the SYSTEM drawer
(double click on its icon) and look for it there.

Double click on the CLI or SHELL icon and you will get a new window. You
can move it about and/or resize it the same way as any other window. If
you have @{B}v2+@{UB} it should have a close gadget, although it can be customised
not to have one (See article @{"Window Specifications" LINK "ADB:Parts_31-40/32.Window_Specs/Options"}). (See @{"later" LINK "Closing"} for
information on how close a CLI/Shell window without a close gadget)

If you are using @{B}v2+@{UB} you can also open a new Shell/CLI window by selecting
the Workbench menu item "Workbench - Execute Command" and entering in the
window that appears "NEWSHELL".

I will discuss the @{"NEWSHELL and NEWCLI" LINK "ADB:Parts_01-10/06.NewCLI-EndCLI/New"} commands in a later article but both
these commands can be used to create a new Shell or CLI from within an
existing Shell or CLI window.

@{B}Special Note v1.2@{UB}

If you have v1.2 and you can't find the CLI icon anywhere, then double
click on the Preferences Icon and look at the middle left side of the
preferences screen. There is an item there that says "CLI ON OFF" (WB
v1.3 has dispensed with this item). Select "ON" (click in that box), select
the "SAVE" box (middle right side of screen), then close the System Drawer
window, then reopen it. Your CLI icon should now be present. If this
preference item is set to "CLI OFF" then the CLI icon will not appear in
system window. If the CLI icon is taken out of the system window and put
into the disk's main window, then this preferences item will not have any
effect on the CLI icon.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Closing" "Part 4 - Using Shell & CLI - Closing the CLI/Shell window"

@{B}@{U}CLOSING THE CLI/SHELL WINDOW@{UU} (All Versions CLI and Shell)@{UB}

To get rid of a CLI window, just enter:-

  > ENDCLI

Or, if you have @{B}v2+,@{UB} just click on the "close" gadget in the top left
corner of the window (if it is there).

If the window doesn't close, then it could be that some program that was
started off from that CLI process is still working away in the background
even though you cannot see it. The window will stay open until that other
program stops.

I will discuss the @{"ENDCLI and ENDSHELL" LINK "ADB:Parts_01-10/06.NewCLI-EndCLI/End"} commands in a later article.
The above comments are just to get you under way.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Prompt" "Part 4 - Using Shell & CLI - The Shell/CLI Prompt"

@{B}@{U}THE SHELL/CLI PROMPT@{UU} (All Versions CLI and Shell)@{UB}

If you are using CLI (not Shell) in @{B}v1.3 or earlier@{UB} you will see in the
window:-

  1.>

If using SHELL in @{B}v1.3 or v2.0 onwards@{UB} you will see something like:-

  1.SYS:>
  1.Workbench1.3:>
  1.Workbench2.0:>

This is called the "Prompt". It is put there automatically (but it can
be @{"customised" LINK "ADB:Parts_41-50/45.Prompt/Main"} to your own preference) and any typing you do is to the
right of the ">".

The "SYS:" or "Workbenchx.x:" etc. indicates the name of the
@{"current directory." LINK "ADB:Parts_01-10/03.DIRS_FILES_PATHS/Current"}

The number 1 tells you that this is CLI process number 1. You will often
see the term "CLI Process". A "process" is simply a task that can
communicate with AmigaDOS. Thus a CLI or Shell window is a "process" and
the 1 says it is process number 1.

If you double click on the CLI or Shell icon again, another window will
open and it will show, for example:-

  2.Workbenchx.x:>

It is CLI window (or process) number 2.

@{B}Note@{UB} - if the first window you open shows a number higher than 1 it means
the some other program has been launched, i.e. started up, using a CLI
process, maybe while the disk was being booted. When a program is started
from CLI (including being started from the startup-sequence on boot up)
then it is assigned a CLI process number.

@{B}Note@{UB} - If your window shows, say, process 2 and you open a new window
and it shows process 1 then that means that the previous process 1 has
been shut down after process 2 was started. When looking for process numbers
to allocate, the system takes the lowest number available even if there
are other processes running that have higher numbers.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "KeyPress" "Part 4 - Using Shell & CLI - Explanation of Key Presses"

@{B}@{U}EXPLANATION OF KEY PRESSES@{UU} (All Versions CLI and Shell)@{UB}

In this series of articles, I indicate to press certain key combinations
with things like:-

   CTRL-K
   SHIFT-UP

The "CTRL" and "SHIFT" represent the qualifier keys "Ctrl" and "Shift".
They are qualifier keys as they alter, or "qualify" the way the other
keys act. The most common qualifier key is the "SHIFT" key which changes
the alphabetic keys from lower case to upper case.

Where you see something like CTRL-K it means to:-

- @{B}hold down@{UB} the qualifier key (CTRL in this case),
- @{B}press@{UB} the key shown after it (the "K" in this case)
  while still holding down the qualifier key,
- then release both keys

The cursor keys might be represented with things like this in various
texts:-

  UP     or  CursUP    - the UP cursor key
  DOWN   or  CursDOWN  - the DOWN cursor key
  RIGHT  or  CursRIGHT - the RIGHT cursor key
  LEFT   or  CursLEFT  - the LEFT cursor key

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Entering" "Part 4 - Using Shell & CLI - Entering Command Lines"

@{B}@{U}ENTERING COMMAND LINES@{UU} (All Versions CLI and Shell)@{UB}

In the article @{"AMIGADOS AND SHELL/CLI" LINK "ADB:Parts_01-10/02.AmigaDOS_&_CLI/Cli"} we talked about CLI being a "Command
Line Interface" in which you could type lines of AmigaDOS commands.

To enter a command line in a Shell or CLI window you simply type in the
whole line then press the return key. To try it out, type in this line
then press return:-

  > TYPE s:startup-sequence

When you see this sort of thing @{B}do not@{UB} type in the @{B}">"@{UB} as it represents
the @{"prompt" LINK "Prompt"} that you see in your CLI or Shell window. You just type in
the:-

   TYPE s:startup-sequence

I will not tell you to press the return key. Whenever you see something
like:-

  > TYPE s:startup-sequence

you must assume that the return key must be pressed.

AmigaDOS does not consider the command to have been completed until you
press the return key. The return key is your signal to AmigaDOS that you
have finished doing your thing and that it is AmigaDOS's turn to do
something, i.e. to accept the command line and act on it.

You will sometimes find that the command line you type takes up more than
one line in the CLI window. This does not matter at all as AmigaDOS
considers the command line to be everything typed in from the prompt up
until the return key is pressed regardless of whether the command line
takes up only a few characters or a number of window lines.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "EditingOld" "Part 4 - Using Shell & CLI - Editing command Lines - Old CLI Only"

@{B}@{U}EDITING COMMAND LINES@{UU} (Old CLI only)@{UB}

If you are using the old CLI window from @{B}v1.x@{UB} then you will find that
you cannot make corrections to the command lines that you type except
by using the back space key to delete everything up to the part you want
to correct, then retyping the part of the line deleted. This can be very
tedious. Nor can you retrieve an old command to reuse it or alter it
slightly.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "EditingNew" "Part 4 - Using Shell & CLI - Editing command Lines - Shell Only"

@{B}@{U}EDITING COMMAND LINES@{UU} (SHELL only)@{UB}

You can use the left and right cursor keys to move the cursor to any
character in the command line. Those letters that the cursor passes over
will not be deleted. Corrections can thus be made at any point of the line.
This can save a lot of typing. Press RETURN at any point on the line to
activate the full command line.

There are a number of ways of deleting characters on the command line:-

  Delete Key - Deletes one character at the cursor position
  Backspace  - Deletes one character to the left of the cursor position
  CTRL-K     - Deletes all characters from cursor to end of line
  CTRL-Y     - Replace characters removed with CTRL-K (@{B}v2+ only@{UB})
  CTRL-U     - Deletes all characters from one to left of cursor to start
                 of line
  CTRL-X     - Deletes the entire line but leaves the position within
                 the @{"command history" LINK "History"} unaltered
  CTRL-B     - Deletes the entire line and moves the position within
                 the @{"command history" LINK "History"} to after the last command in the
                 history
  CTRL-W     - Acts only on the WORD that the cursor is on.
                 It deletes that part of the word from the character to the
                 left of the cursor back to the start of the word
                 (@{B} v2+ only@{UB})

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Moving" "Part 4 - Using Shell & CLI - Moving Around Command Lines"

@{B}@{U}MOVING AROUND COMMAND LINES@{UU} (SHELL Only)@{UB}

  SHIFT-LEFT  - move cursor to @{B}start@{UB} of command line
  SHIFT-RIGHT - move cursor to @{B}end@{UB} of command line

@{B}Version 1.3 note@{UB}:-

  CTRL-W      - moves the cursor 8 spaces to the right @{B}(v1.3 only)@{UB}

  (@{B}Version 2+@{UB} note that @{"CTRL-W" LINK "EditingNew"} deletes the part of the word to the left of
   the cursor

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "History" "Part 4 - Using Shell & CLI - Old command History"

@{B}@{U}OLD COMMAND HISTORY@{UU} (SHELL Only)@{UB}

The system keeps old commands in memory so that you can reuse them later.
This is VERY useful if you are using a long command again, or you have
a command that is very similar to a previous one.

The UP cursor key will display the old commands, cycling through them
upwards towards the top of the list until you reach the first command
used. Finally, a @{"blank line" LINK "Blank"} will be displayed (unless the buffer is full
- see 3 paragraphs below). Once you have gone part or all of the way up the
list, you can use the DOWN cursor key to cycle downwards through the list
to the most recent command at the bottom of the list until you get a blank
line (unless the buffer is full).

When you find the one you want, @{"edit it" LINK "EditingNew"} if necessary then press return.

You can save an lot of typing in this way.

The memory "buffer" used to hold this command history is limited in size
(2kb). Once the buffer is full the system will start to discard the earliest
commands at the start, or top, of the list to make room for the new commands
at the end, or bottom, of the list. The number of commands it can hold
will depend on the length of the commands.

In @{B}v1.x@{UB}, using the UP or DOWN cursor keys when the buffer is full will
never give you a @{"blank line" LINK "Blank"}. The complete list will continue to be cycled
ad infinitum.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Blank" "Part 4 - Using Shell & CLI - Getting a Blank Line"

@{B}@{U}GETTING A BLANK LINE@{UU} (SHELL Only)@{UB}

After cycling upwards through old commands, you may want a blank line
to enter a completely new command (especially if the history buffer is
full!).

CTRL-X - will blank the line but leave you at the same point in the
         @{"command history" LINK "History"}. However, any new command entered will go
         to the end of the list.

CTRL-B - (or SHIFT-DOWN) will take you to a blank line at the end of
         the command history.

Of course, with @{B}V2+@{UB}, you can just keep holding down the DOWN or UP cursor
key until you reach the start or end of the @{"command history" LINK "History"}.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Searching" "Part 4 - Using Shell & CLI - Searching For Old Commands"

@{B}@{U}SEARCHING FOR OLD COMMANDS@{UU} (SHELL Only)@{UB}

If you type in the first few characters of a command then press SHIFT-UP
you will be taken back to the last command line that had those characters
at its start.

For example, enter:-

  > DIR SHIFT-UP

and you will be taken to the last command that started with "DIR".

This is one case where you @{B}do not@{UB} press the return key!!

(@{B}Don't@{UB} type in "SHIFT-UP" - don't forget that it means hold down SHIFT
and press the cursor up key. Thus the above means type in DIR then press
the SHIFT and the Cursor Up keys.)

@{B}In v2+ only,@{UB} pressing SHIFT-UP again will continue the search upwards
through the list for items starting with "DIR". For example, it might
find:-

  DIR df1:
  DIR df0:
  DIR df0:devs/printers

@{B}In v1.3,@{UB} it works a bit differently. If you enter:-

  > DIR SHIFT-UP

then, if it finds:-

  DIR df1:

and you continue to press SHIFT-UP it will look for other occurrences
of "DIR df1:" and not for the originally entered "DIR" as v2+ does.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Copying" "Part 4 - Using Shell & CLI - Copying and Pasting"

@{B}@{U}COPYING AND PASTING@{UU} (v2+ Only)@{UB}

Copying and pasting in Shell windows was introduced with v2+.

Text in any Shell window (if more than one is open) or any Text Editor
window using a console window (i.e. a window similar to the Shell window)
can be copied and pasted into the same or any other window. For example,
copy from one shell and paste into another, or copy from one script file
being edited with the "ED" program and paste into another script file
or into a Shell window.

You can even copy and paste between a Shell window and some programs such
as certain word processors provided that those programs use the same system
for storing the copied or cut text.

Point to the start of the text you wish to copy, hold down the left mouse
button, then drag the pointer to the end of the text to be copied, then
let go the button. The selected text should become highlighted.

Now press RightAMIGA-C. The highlighting will disappear and the text will
be written to a buffer for later use.

Finally, click in the window in which the text is to be pasted and, if
necessary, position the cursor to the desired insertion point. Now press
RightAMIGA-V and the text will appear again.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Template" "Part 4 - Using Shell & CLI - Getting A Command Template"

@{B}@{U}GETTING A COMMAND TEMPLATE@{UU}@{UB}

At this stage (if you are a beginner and you are still in the process of
reading through the the articles in their proper order) you should not
worry too much about @{"Command Templates" LINK "ADB:Misc/Glossary/Format"}.

However, if you want to have a quick reminder of how to use a command by
looking at its template, you can enter:-

  > CommandName ?  (press return)

and the template will be displayed with the cursor waiting at the end of
the line waiting for you input. For example, if you entered:-

  > TYPE ?

then the display would be something like:-

  FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S: #

@{B}Note@{UB} - The # represents the Shell/CLI cursor and is not part of the
       template.

@{B}Note@{UB} - You may get a different template depending on your AmigaDOS version.

@{B}Note@{UB} - If you want to know what all the symbols in the template mean then
       you can @{"click here" LINK "ADB:Parts_61-70/63.Format_&_Template/Template"}.

If you press return without any more input the command will carry on as if
you entered the command without @{"arguments" LINK "ADB:Misc/Glossary/Arguments"}. This may give an error message
if the command requires at least one argument.

If you wish to enter an argument, then you can do so at the cursor position
without reentering the command name. For example:-


  > TYPE ?                                                  (press return)
  FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S: S:startup-sequence    (press return)

The TYPE command will now display the contents of the file
"S:startup-sequence" in the window.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "RedirectCom" "Part 4 - Using Shell & CLI - Redirecting Command Input/Output"

@{B}@{U}REDIRECTING COMMAND INPUT/OUTPUT@{UU} (All Versions of SHELL & CLI)@{UB}

The symbols  >  >>  <  can be used to:-

  @{" >  Redirect Command Output             " LINK "Out"} CLI and Shell All Versions

  @{" >> Redirect to ADD to an Existing File " LINK "Add"} Shell Only Versions 1.3 & Later

  @{" <  Redirect Command Input              " LINK "In"} CLI and Shell All Versions


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Out" "Part 4 - Using Shell & CLI - Redirecting Command Output"

@{B}@{U}Redirecting Command Output@{UB}@{UU}

Output FROM a command (usually to the process window) can be redirected
elsewhere with the symbol `>'.

As an example of output redirection, to copy the contents of the current
directory to a file on df1: you would enter:-

  DIR > df1:filename

Instead of the output from DIR appearing in the window, they will be
written to the file "df1:filename". You can verify this by entering:-

  TYPE df1:filename

and you will see the directory contents that have been written to
"df1:filename".

In @{B}v2+@{UB}, with most commands the redirection can come anywhere in the command
line. For example:-

  DIR Sys: >DF1:filename OPT A

  DIR Sys: OPT A >DF1:filename

However, it is best to put it immediately after the command and before any
options or arguments. This will ensure that the command line will work with
commands that cannot cope with the above type of examples, and with earlier
version of AmigaDOS. Thus use this command line instead of the above two
examples:-

  DIR >DF1:filename Sys: OPT A

To send the directory of df1: to the printer you could enter:-

  DIR > prt: df1:

You can also redirect output from other commands. For example:-

  TYPE > prt: filename

will type the contents of "filename" to the printer instead of to the
output window.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Add" "Part 4 - Using Shell & CLI - Redirecting Output To Add"

@{B}@{U}Redirection to Add to a File@{UU} (Shell Only)@{UB}

If a file already exists, you can add to it with with a double redirection
sign, as in:-

  TYPE >> destination-file FROM source-file

For example:-

  TYPE >ram:mynewfile s:oldfile-1
  TYPE >>ram:mynewfile s:oldfile-2

"Mynewfile" now holds the contents of oldfile-1 and oldfile-2.

If the destination file does NOT exists when you use the ">>" symbol,
the result depends on your AmigaDOS version.

@{B}V1.3@{UB} will give an error message saying that the file cannot be opened.

@{B}V2+@{UB} will create the file and all will be O.K.


@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "In" "Part 4 - Using Shell & CLI - Redirecting Command Input"

@{B}@{U}Redirecting Command Input@{UB}@{UU}

Input TO a command (usually from the keyboard) can be from elsewhere
(e.g. a disk file) by using the symbol `<'.

This is a lot more uncommon than the @{"output redirection" LINK "Out"} and a little
difficult to comprehend. Don't worry if you cannot follow it now. Wait
until you have learned a bit more about AmigaDOS and then come back to it
when a cross reference brings you back here.

Some AmigaDOS manuals say that you can input data as the argument for a
command by using:-

  > CommandName < Disk:Datafile

and give the example of having a file called DateFile which contains a
date and time, such as:-

   Friday 13-Jun-97 14:06:30

Then if you use the DATE command in this way:-

  > DATE <Disk:DateFile

the date and time would be set to the file contents, i.e.:-

   Friday 13-Jun-97 14:06:30

However, with most commands, this does not work unless you use:-

  > DATE <Disk:DateFile ?

The use of the `?' at the end of the command line is explained under the
heading @{"Getting A Command Template" LINK "Template"}.

An example of using the "<" redirection symbol is contained in @{"Article 41" LINK "ADB:Parts_41-50/41.Eval/Example"51}
and in the article on @{"Clock commands" LINK "ADB:Parts_41-50/44.Clock_Commands/ExFile"}.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "RedirectKey" "Part 4 - Using Shell & CLI - Redirecting Keyboard Output"

@{B}@{U}REDIRECTING KEYBOARD OUTPUT@{UU} (All Versions of SHELL & CLI)@{UB}

The asterisk character "*" can be used to represent the current Shell
window, or "console" as it is sometimes called.

Normally you would expect that pressing keys would make their characters
appear on the screen. However, you can redirect the keyboard output
elsewhere with:-

  COPY * TO df1:filename

or

  COPY * TO prt:

The "TO" is optional. You can use these instead of the above two lines:-

  COPY * df1:filename

  COPY * prt:

For example, if you used the first of these then started typing the text
you type will be directed to the file "df1:testfile".

Press RETURN whenever you want to end a line

Press CTRL-\\ (i.e. CTRL and the BackSlash) to terminate the COPY command
and return output to the screen.

If you try this out, verify that the file has been correctly created and
written with:-

  TYPE df1:testfile

Pressing CTRL-C then RETURN (before CTRL-\\ is pressed) will abort the
procedure and remove the destination file from the disk.

To send your keyboard output to your printer, use:-

  COPY * TO prt:

or

  COPY * prt:

Then type your message as if you were using a typewriter! Although, unlike
a typewriter, you have to press the return key or CTRL-\\ before any output
appears on paper.

Finish up with the CTRL-\\ terminator. This is much better for a short
note than loading up NotePad or a Word processor! Make sure you get your
spelling right. No chance to make corrections as you have with a Word
Processor!!

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Pausing" "Part 4 - Using Shell & CLI - Pausing Command Output"

@{B}@{U}PAUSING COMMAND OUTPUT@{UU} (All Versions of SHELL & CLI)@{UB}

You can pause the command output appearing in the window by one of two
methods - mouse or keyboard. Which one you use is entirely a matter of
preference. I find that I mainly use the keyboard as I am already using
that to enter commands.

@{B}Keyboard Method@{UB}

Press any key that produces a character that can be displayed on the screen.
The output remains frozen until you press "BACKSPACE" or "CTRL-X".

I find that the most convenient stop-start combination of keys are the
back slash key "\\" and the BACKSPACE as they are next to each other and
easy to press alternately a number of times.

Output will also resume if you press "RETURN" but this will result in
an error message after the output is complete. If you used "\\" to pause,
then this message will be:-

  \\: Unknown command

This is because the system has recorded the "\\" and RETURN as a command
line.

@{B}In v2+ only,@{UB} you can also pause output with CTRL-S and restart it with
CTRL-X. However, I find this very cumbersome. (Some other CTRL-key
combinations will also stop and restart output but as they do other things
as well I would recommend you stick to the ones mentioned above.)

@{B}Mouse Method@{UB}

You can pause the output of most things by holding down the RIGHT MOUSE
BUTTON. Then just release the button to restart output.

This method is more convenient than the keyboard methods if you are already
using the mouse.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Aborting" "Part 4 - Using Shell & CLI - Aborting Command Output"

@{B}@{U}ABORTING COMMAND OUTPUT@{UU} (All Versions of SHELL & CLI)@{UB}

Sometimes you will find that the output to the screen or printer is going
on beyond a point that you want it to. You can usually abort it with:-

  CTRL-C

Output to the window should stop immediately.

Output to the printer might @{B}appear@{UB} to take quite a while to stop. In fact,
the computer stops sending to the printer but, as the printer has a buffer
to hold output from the computer, the printer will keep printing until
this buffer is empty.

@{JCENTER}=== End of Text ===
@{JLEFT}
@ENDNODE

@NODE "Starting" "Part 4 - Using Shell & CLI - Starting a Program From Shell/CLI"

@{B}@{U}STARTING A PROGRAM FROM SHELL/CLI@{UU} (All Versions of SHELL & CLI)@{UB}

O.K., so you can now use a Shell/CLI window but how to you get programs
going?

First up, you have to make sure that AmigaDOS can find the program. If
it is one of the AmigaDOS programs (e.g. a command or a preferences program,
etc.) then it is nearly 100% certain that AmigaDOS will know where to
find it (see article @{"PATH" LINK "ADB:Parts_11-20/18.Path/Main"}). However, if it is not one of AmigaDOS's
programs then you will have to tell AmigaDOS which directory it is in.
There are two ways to do this.

Firstly, you can enter the @{"full path" LINK "ADB:Parts_01-10/03.Dirs_Files_Paths/Path"} and the program name at a Shell/CLI
prompt, as in:-

  > DiskName:DirectoryName/ProgramName

For example:-

  > Games:Shoot-Em-Ups/Alien_Invasion

This will tell AmigaDOS to go to the disk called "Games", look in a
directory called "Shoot-Em-Ups" and start up the game called
"Alien_Invasion".

Secondly, and probably the best, is to make the directory that the program
is in the current directory. If you are still going to start up
"Alien_Invasion" then use:-

   > CD Games:Shoot-Em-Ups

Having done that, you can just enter

  > Alien_Invasion

The advantage of the second method is that sometimes programs look in
the same directory that they are in for other files and they will not
run if they cannot find them. Making their own directory the current
directory makes sure that they can find the other files.

Entering the program name this way usually means that the program takes
over the Shell/CLI window from which they were started and you cannot
use that window again until the program is exited (unless the program
@{"detaches itself" LINK "ADB:Parts_01-10/09.Run/General"40} from the CLI process - a few programs do do this.)

If you want to ensure that the Shell/CLI window is left for other usage,
then use the RUN command as in one of these:-

  > RUN Games:Shoot-Em-Ups/Alien_Invasion
  > RUN Alien_Invasion

The RUN command will be fully explained in the article @{"RUN" LINK "ADB:Parts_01-10/09.Run/Main"} although,
to use it, you do not need to know much more about it than to enter it
as illustrated above.


@{JCENTER}=== End of Text ===
@{JLEFT}






























@ENDNODE

@NODE "Another" "Part 4 - Using Shell & CLI - Enclosing One Command In Another"

@{B}@{U}Enclosing One Command In Another@{UU} Version 2.0 Onwards@{UB}

It is possible to include one command within another in a command line.
This is done by using the @{B}back apostrophe `@{UB}. For example:-

  > ECHO "This system has `AVAIL TOTAL` bytes of memory available"

In this example, the command:-

  @{"AVAIL TOTAL" LINK "ADB:Parts_41-50/49.Avail/Options"}

will be executed @{B}first@{UB} and its output will be inserted into the total
command line. If the AVAIL command gave a number 7115128 then the command
line would become:-

  ECHO "This system has 7115128 bytes of memory available"

and the output from ECHO would be:-

  This system has 7115128 bytes of memory available

A practical example of this concept is given in the @{"v3.1 Startup-Sequence" LINK "ADB:Parts_71-80/71.Startup-Sequence_Files/3.1"176}.


@{JCENTER}=== End of Text ===
@{JLEFT}

@ENDNODE

