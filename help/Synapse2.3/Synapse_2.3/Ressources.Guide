@DataBase Ressources.Guide

@Index "Index.Guide/Main"

@Node Main "Les Ressources de l'Amiga"
@TOC Main
@font helvetica.font 13

                         @{" Emulation d'Autres Systèmes " link Emulation}

                         @{" Les Formats de Fichiers " link Fichiers}

                         @{" Les Langages de Programmation " link LangPro}

                         @{" Shared Libraries " link Libraries}
                         @{" Device Drivers " link Device}
                         @{" Exec " link Exec}
                         @{" Inter-Process Communication " link IPC}
                         @{" Intuition " link Intuition}


                         @{" Retour Au Menu Principal " link "Synapse.Guide/Main"}

@Endnode

@Node Emulation "Emulation d'autres systèmes"


En  plus  de  son propre système d'exploitation, l'Amiga peut aussi fonctionner
avec :

@{b}UNIX@{ub}

AT\&T UNIX System V Release 4 : nécessite une MMU.

LINUX : nécessite un 68030 avec MMU, 68882, 4Mo de RAM et un disque dur.

MINIX.

NetBSD/Amiga  :  nécessite une MMU, 68882, 4Mo de RAM et 100 Mo de libre sur le
                 disque dur.


@{b}Apple et Macintosh@{ub} (émulateurs hardwares et/ou logiciels)

A-Max

Emplant (Electronic MicroProcessor Level Amiga Native Task)

ShapeShifter

Apple II


@{b}MS-DOS@{ub} (émulateurs hardwares et/ou logiciels).

Commodore Transformer pour l'Amiga 1000

Cartes Commodore 2088 2286 et 2386

Vortex Atonce, Golden Gate

KCS Power PC Board

GVP AT-500 16 Mhz

PC-Task

IBeM



@{b}Apple II@{ub} (émulateurs logiciels).


@{b}BBC Acorn@{ub} (émulateurs logiciels).


@{b}Commodore 64@{ub} (émulateurs logiciels).


@{b}Oric Atmos@{ub} (émulateur logiciel).


@{b}Ordinateurs MSX@{ub} (émulateur logiciel).


@{b}Sinclair Spectrum@{ub} (émulateur logiciel).


@{b}Sinclair QL@{ub} (émulateur logiciel).


@{b}Atari ST@{ub} (émulateur logiciels et/ou hardwares).

Chamäleon, Medusa, ST Emulator


Certains de ces systèmes peuvent fonctionner parallèlement au système Amiga.

@Endnode

@Node Libraries "Shared Libraries / Bibliothèques Partagées"

L'Amiga  possède  des  bibliothèques  (libraries)  qui peuvent être ouvertes et
utilisées  par  des  programmes  d'application.   Cela  diminue  la  taille des
programmes exécutables et du Kernel.

Une  bibliothèque  est  un  ensemble de routines de programmation réunies en un
fichier.   Les  programmeurs peuvent utiliser ces bibliothèques et les routines
qu'elles contiennent pour éviter, en fait, de faire un travail déjà réalisé.

Par  exemple,  la programmation d'un requester peut être évitée en utilisant la
routine adaptée présente dans l'Asl.library par exemple.

@Endnode

@Node Device "Device Drivers / Pilotes de Périphériques"

L'objectif  des  Devices est de contrôler des éléments périphériques en évitant
aux  programmeurs  la  nécessité d'inclure ces fonctions de contrôle dans leurs
productions.

Ils   offrent  surtout  un  standard  en  matière  de  communication  avec  les
périphériques.

Tous  les  devices  sont accessibles de manière logique par l'utilisateur ou le
programmeur.   Par exemple, envoyer une sortie vers un fichier s'effectue de la
même  façon  que  pour  l'envoyer  vers  une  fenêtre,  le  port  parallèle, le
synthétiseur  vocal,  ou  tout autre device.  Les E/S synchrones et asynchrones
sont  supportées par  tous les devices.  De nouveaux drivers peuvent facilement
être ajoutés au système sans nécessité la recompilation du Kernel.

@Endnode

@Node Fichiers "Les Formats de Fichiers"
@font helvetica.font 13

               @{" Interchange File Format " link IFF}

               @{" JPEG " link JPEG}
               @{" MPEG " link MPEG}

               @{" Le PostScript " link PostScript}
               @{" EPS " link EPS}
               @{" DCS " link DCS}

               @{" TIFF " link TIFF}


               @{" Formats d'Echantillonnage " link Echan}

@Endnode

@Node IFF "Interchange File Format"


Créé  en  1985  par  Electronic  Arts,  le format IFF offre aux applications un
format  de  fichier  standard  pour  les  graphismes,  les animations, les sons
numérisés,  les  données  MIDI  ou d'autres types de données.  Une bibliothèque
(iffparse.library) offre les fonctions pour manipuler les données.

Un  fichier  correspondant à ce standard commencera par l'entête FORM suivie un
peu plus loin par le format du fichier :

     @{"8SVX" link 8SVX}      8-bit Sampled sound Voice
      ACBM      Amiga Continuous BitMap
      ANBM      ANimated BitMap,
      ANIM      ANIMation
      FNTR      Raster FoNT
      FNTV      Vector FoNT
     @{"FTXT" link FTXT}      Formated TeXT
      GSCR      General-use musical SCoRe
     @{"ILBM" link ILBM}      InterLeaved BitMap
      PDEF      Deluxe Print page DEFinition
      PICS      Macintosh PICtureS
     @{"SMUS" link SMUS}      Simple MUsic Score
      VDEO      Deluxe Video Construction Set ViDEO

@Endnode


@Node 8SVX "8-bit Sampled sound Voice"

Date de création : 7 février 1985

Auteurs : Steve Hayes et Jerry Morrison de Electronic Arts

Avec l'aide de :    Bob "Kodiak" Burns, Commodore-Amiga
                    R. J. Mical, Commodore-Amiga
                    Greg Riker, Electronic Arts
                    Steve Shaw, Electronic Arts
                    Barry Walsh, Commodore-Amiga

Référence : Le standard "EA IFF 85"



Le 8SVX est un ensemble de données contenant un son échantillonné numériquement
sous un format 8 bits.

Le  format  8SVX  est  prévu  pour  être restitué sur du matériel utilisant des
échantillons  8  bits  et  autorisant un contrôle du volume pour obtenir un bon
rapport  signal/bruit.  Ainsi un FORM 8SVX stocke des échantillons 8 bits et un
niveau  de volume.  Pour des résolutions supérieures (12 ou 16 bits), un format
différent sera nécessaire.

Le  8SVX  peut  stocker une enveloppe, un contour d'amplitude pour enrichir des
notes musicales.


Le  8SVX  stocke  toutes  les  données de la courbe sonore dans un chunk appelé
"BODY".  Il stocke les paramètres nécessaires à son  exécution dans le chunk de
tête de fichier "VHDR".  "VHDR" et tous les chunks optionnels comme "NAME" (nom
du  fichier),"(c)J" (copyright), "AUTH" (nom de l'auteur) et "ANNO" (remarques)
doivent apparaître avant "BODY".


Il y a deux façons d'utiliser FORM 8SVX :

Comme  un  son  numérisé directement ou comme un instrument de musique numérisé
qui joue des notes.

Un  son  numérisé  directement  est une série d'échantillons de données sonores
accompagnées de leur vitesse de restitution et de leur amplitude.  Le programme
utilisant ce fichier peut ajuster ou moduler ces variables.

Pour  les  instruments  de  musiques,  l'idée  et  de  stocker  une onde sonore
échantillonnée  qui  sera  paramètrée  par le ton, la durée et l'amplitude pour
jouer  chaque note.  L'enveloppe peut aussi être stocker pour moduler la courbe
sonore.


Le  format  8SVX  peut supporter un algorithme de compression.  le plus courant
est le Fibonacci-delta écrit par Steve Hayes.  Cet algorithme code chaque delta
en  4 bits.  La donnée compressée fait la moitié de la taille du delta original
plus  2  octets de valeur initiale.  Cependant, l'utilisation de la compression
engendre  souvent  une perte de qualité de l'échantillon.  Son utilisation doit
donc être évitée en ce qui concerne les instruments de musique.

@Endnode

@Node FTXT "Formated TeXT"

Date de création : 15 novembre 1985

Auteurs : Steve Shaw et Jerry Morrison de Electronic Arts
     	Bob "Kodiak" Burns de Commodore-Amiga

Un  fichier  FTXT  est  un  principe  d'archivage et d'échange prévu pour trois
usages.   Le  plus  simple est pour une représentation minimale d'un texte avec
des caractères de positionnement espace "SP" et des fins de lignes "LF".  Il ne
tient  pas  compte  des  caractères  de  déplacement  du  curseur.  La deuxième
utilisation  est  prévue  pour  les  textes qui contiennent des informations de
formatage   explicites  comme  les  fontes  (famille,  taille,  style...).   La
troisième contient la base de la structure du document en plus des informations
de formatage.

Ces  trois  utilisations sont bien sûr facilement transférables et lisibles par
n'importe quel programme reconnaissant ce standard.


Le  texte  est  stocké dans un ou plusieurs chunks "CHRS" dans un FTXT.  Chaque
CHRS  contient  une chaîne de texte 8 bits compatible avec les standards ISO et
ANSI.  FTXT utilise le jeu de caractères central des standards ISO/ANSI.

L'apparence des caractères est stockée en séquences de contrôle dans les chunks
CHRS.

Le contenu principal du FORM FTXT se trouve dans sa chaîne de caractère "CHRS".
Des  chunks de formatage de texte peuvent aussi apparaître.  La seule propriété
de formatage définie pour le moment est "FONS",  qui précise la fonte.  Un FORM
FTXT sans CHRS représente une chaîne de caractère vide.

@Endnode

@Node ILBM "IFF Interleaved Bitmap"

Date de création : 17 janvier 1986

Auteur : Jerry Morrison de Electronic Arts

Un  fichier  ILBM  est  un  principe de stockage prévu pour trois usages.  Tout
d'abord,  une  simple  image  qui  précise  exactement  comment  elle doit être
affichée (résolution, taille, palette...).  Ensuite, une image prévue pour être
incluse dans une image plus grande qui possède ses propres résolution, palette,
etc...   Et  enfin,  une  image vide avec une palette.  ILBM est aussi une base
pour  des  fichiers  d'animations.   L'une  des  utilisations  d'ILBM  sera  de
préserver  le  plus  d'informations possible d'un environnement à l'autre.  Une
autre  utilisation  sera  de  stocker  des  données  utilisables  par plusieurs
programmes.


La  définition  "BMHD"  ainsi  que  toutes les définitions optionnelles doivent
apparaître avant le chunk "BODY".


BMHD

l'indispensable  définition  "BMHD"  contient  le  BitMapHeaDer  qui décrit les
dimensions  et l'encodage  de  l'image,  ainsi que les données nécessaires à la
compréhension du chunk BODY qui suit.


CMAP

La  définition  "CMAP"  stocke la palette de couleur sous la forme d'un trinôme
décrivant l'intensité de rouge, vert et bleu

L'intensité des composantes de couleurs sont définies par un nombre allant de 0
à 255.  le blanc correspond à (255, 255, 255) et le noir est (0, 0, 0).


GRAB

La  définition  optionnelle  "GRAB"  précise  un point relativement à son angle
supérieur  gauche.   Cela est utile pour les pointeurs de souris ou les brosses
(paint brush).


DEST

Cette  définition  optionnelle  est  une façon de dire comment répartir zéro ou
plusieurs  bitplans  dans  une  image de destination plus profonde (en terme de
nombre de bitplans).


SPRT

La  présence du chunk "SPRT" indique que cette image doit être considérée comme
un sprite.  C'est au programme qui lit le fichier d'en faire un sprite ou de le
traiter en tant qu'image.


CAMG

Le  chunk  "CAMG"  est spécifique à l'Amiga.  Il stocke le "viewport mode".  Ce
qui permet de spécifier un mode d'affichage comme "dual playfield" et "hold and
modify".


BODY

L'image  source  est  stockée dans le chunk "BODY".  Ce chunk contient tous les
bitplans et les masques optionnels.

Le  BitMapHeaDer,  dans  le  chunk  BMHD, précise les dimensions de l'image (w,
largeur  et  h,  hauteur) ainsi que les plans (nplanes).  Il contient aussi les
champs  de  masque  qui  indiquent  si il y a un plan de masque et le champs de
compression qui indique l'algorithme de compression utilisé.  Cette information
est  nécessaire  pour  interprèter  le  chunk  BODY,  donc,  le chunk BMHD doit
apparaître en premier.


CRNG

Un  chunk  "CRNG"  contient les informations sur le "color register range".  Il
est  utilisé  par  le  programme  Deluxe Paint pour identifier les registres de
couleurs  adjacents  pour  les dégradés et les cyclages de couleurs.  Il peut y
avoir  0  ou  plusieurs  chunks  CRNG  dans  un fichier ILBM, mais tous doivent
apparaître avant le chunk BODY.

@Endnode

@Node SMUS "IFF Simple Musical Score"

Date:	5 février 1986

Auteur :  Jerry Morrison de Electronic Arts

SMUS  est  un  format  de  données  destiné  à  être  utilisé pour échanger des
partitions  musicales  entre  programmes et stocker des musiques pour des jeux.
FORM  SMUS  utilise  le  time  encoding de la notation musicale commune (demies
notes, notes pointées, silences...).

Une  partition  SMUS  peut  dire  quels  intruments sont supposés jouer quelles
notes.   Mais  la  partition est indépendante du système et du logiciel utilisé
pour jouer les notes.

Comme  tous  les  formats  IFF,   SMUS  est  un  format  d'archivage.   Il  est
complètement  indépendant  de la représentation de la partition en mémoire, des
opérations  d'édition,   de  l'interface  utilisée, des graphismes affichés, du
matériel  de  traitement  et de sonorisation.  Comme tous les formats IFF, SMUS
est extensible.

La  partition  est  contenue dans des pistes (tracks).  Il peut y avoir jusqu'à
255 pistes dans un FORM SMUS.  Chaque piste est stockée dans un chunk TRAK.  Le
nombre de chunks  TRAK est  enregistré dans le chunk SHDR au début du FORM SMUS.
Les chunks TRAK apparaîssent dans leur ordre numérique 1, 2, 3...

Les différentes pistes d'une partition peuvent avoir des tailles différentes.


Un  FORM SMUS contient un "SHDR" nécessaire, suivi par n'importe quel nombre de
chunks  de données "track".  Les chunks optionnels comme "NAME", copyright "(c)
", et les références d'instruments "INS1" peuvent aussi apparaître.

Le  "SHDR"  contient un SScoreHeader qui spécifie les informations globales sur
la partition.  Il doit apparaître avant les TRAKs dans un FORM SMUS.

Le chunk optionnel "NAME" précise le nom de la partition.

Le chunk optionnel "(c)J" contient le copyright de la partition.

Le chunk optionnel "AUTH" précise le nom de l'auteur de la partition.

Le  chunk  optionnel  "ANNO"  contient  n'importe  quelle annotation voulue par
l'auteur.

Le chunk "INS1" identifie les instruments à utiliser pour cette partition.

Les  chunks  de  données TRAK contiennent le noyau de la partition.  Le contenu
d'un  chunk  TRAK  est  une  suite d'évènements codés sur 16 bits comme "note",
"rest" ou "set instrument".  Ces évènement sont des ordres stockés par ordre de
leur apparition.  Les pistes peuvent être polyphoniques.

Chaque  évènement  est  stocké   comme  un  "SEvent"  ("simple musical event").
Chacun  des  SEvent  possède  un  champ  de  8 bits appelé "sID" et un champ de
données sur 8 bits.

@Endnode

@Node JPEG "Joint Photographic Experts Group"

Le JPEG est un procédé standardisé de compression d'image.  JPEG signifie Joint
Photographic  Experts Group, le nom original du groupe qui a écrit ce standard.

Cet  algorithme  se  base entre autres sur l'échantillonnage de la chrominance,
des  transformations cosinus discrètes, et une routine de gestion de l'entropie
@{"Huffman" link "Huffman"}  (la  plus  courante) ou arithmétique (license détenue par AT&T, IBM et
Mitsubishi).

Le  JPEG est prévu pour compresser aussi bien des images numériques en couleurs
ou  en  nuances  de gris représentant des scènes "naturelles".  Le JPEG ne gère
pas le noir et blanc (1 bit par pixel) ni la compression d'animations.

Le  JPEG  est  "dégradant",  signifiant  par  là  que  l'image  résultant de la
compression  n'est  pas  exactement identique à l'originale.  L'algorithme base
l'essentiel  de sa compression sur l'exploitation des limites connues de l'oeil
humain,  principalement  le fait que les petits détails de couleurs ne sont pas
perçus aussi bien que les petites nuances de lumière.  Ainsi, le JPEG est prévu
pour compresser des images qui seront observées par des humains.  Si ces images
sont  analysées  par  une  machine, les petites erreurs introduites par le JPEG
pourront poser des problèmes, même si elles sont invisibles à l'oeil nu.

Une  possibilité très utile du JPEG est que le degré de perte peut être modifié
en ajustant les paramètres de compression.  Cela signifie que l'on peut établir
un compromis entre la taille du fichier et la qualité de l'image.  Il est ainsi
possible  d'obtenir  de  très  petits fichiers si la qualité de l'image importe
peu.

Cette  opportunité  de  pouvoir  compresser  une  image  couleurs de 2 Mo en un
fichier  de 100 Ko représente une différence énorme en terme de transmission ou
d'archivage.

Le  JPEG remplace d'ailleurs le format GIF sur les réseaux.  Tout d'abord grâce
à cette capacité de compression exceptionnelle (5 fois supérieure au GIF), mais
aussi  de  par  sa  gestion d'images en 24 bits par pixel,  soit 16 millions de
couleurs.

Cependant,  sur  des images ne comportant que quelques couleurs différentes, le
GIF  fait  mieux  que  le  JPEG, en particulier si de vastes surfaces de pixels
exactement  de la même couleur sont présentes.  Le JPEG a aussi du mal avec les
contrastes  trop prononcés comme une zone de noir adjacente à une zone blanche,
le  résultat  étant souvent un adoucissement de ce contraste.  Ce problème peut
aussi apparaître avec du texte.

@Endnode

@Node MPEG "Moving Pictures Experts Group"


Le  MPEG  (Moving  Pictures Experts Group) est le nom du groupe d'experts qui à
créé ce standard de numérisation vidéo et de compression audio.

MPEG  commence  avec  une  résolution  relativement basse d'environ 352 par 240
points  (pour  le  standard US) et un son de qualité laser.  Les images sont en
couleurs,  mais  converties  en YUV, et les deux canaux de chrominance (U et V)
sont réduits chacun à 176 par 120 pixels.

Le  principe  de base est de prévoir le mouvement d'une image à l'autre sur une
échelle  temporelle,  et d'utiliser des DCT (Transformations Cosinus Discrètes)
pour  organiser les redondances au niveau spacial.  Les DCT sont effectuées sur
des  blocs  de 8x8, et la prévision faite sur le canal de luminance (Y) sur des
blocs  de  16x16.   En d'autres mots, étant donné le bloc de 16x16 dans l'image
courante  que vous essayez de coder, vous recherchez une ressemblance proche de
ce bloc dans une image précédente ou à venir (il existe des modes de prévisions
rétroactives  où  les  dernières images sont envoyées en premier pour permettre
une  interpolation  entre  les images).  Les coefficients DCT (soit des données
présentes,  soit de la différence entre ce bloc et la ressemblance proche) sont
quantifiés,  ce  qui  signifie  qu'on les divise par des valeurs pour supprimer
quelques  bits superflus.  La quantification peut changer pour chaque macrobloc
(c'est à dire les 16x16 de Y et les 8x8 correspondants dans chaque U et V).  Le
résultat  de  tout  cela,  qui  inclus  le  coefficient  DCT,  les  vecteurs de
mouvement, et les paramètres de quantization, est codé en @{"Huffman" link "Huffman"} utilisant des
tables  fixes.   Les  coefficients  DCT  ont une table Huffman spéciale qui est
bi-dimentionnelle.


Il y a en fait 3 types de trames codées :

I  ou  Intra  frames  :   Il  s'agit  de  trames  codées  comme une image fixe,
n'utilisant aucune trame passée.

P  ou  Predicted frames :  Elles proviennent de la prévision de la plus récente
trames I ou P reconstruite.

B  ou  Bidirectional  frames :  Elles résultent des deux trames I ou P les plus
proches, une passée et une à venir.  Il s'agit en fait d'une interpolation.


Le  codage  du son joue sur un effet de masque, effaçant les parties du spectre
sonore inaudibles ou "cachées" par d'autres sons.


En  fait,  que  ce soit pour le son ou pour les images, le format MPEG joue sur
les limites de la perception de nos sens.  Tout comme le JPEG.

Mais  de  par  la  nature même de son principe, le MPEG occasionne une perte de
qualité,  certes infime, mais pourtant perceptible.  Ainsi, le Video-CD (12 cm)
contient  74  mn  de  film  dans une qualité proche ou supérieure à celle d'une
cassette  vidéo.  Cependant, le Compact Disk Video (30 cm et 1 heure par face),
avec  son enregistrement analogique de l'image, garde un net avantage au niveau
de  la  qualité  d'image et du son, surtout dans les scènes mouvementées, où le
MPEG a bien du mal à prendre ses repères.

@Endnode

@Node PostScript "Le PostScript"

Le PostScript se définit comme un langage de description de page. Son but est
de fournir à une imprimante une description extrêmement précise du document à
reproduire.

Ce  langage  à  été  mis  au  point par la firme Adobe.  Il utilise une syntaxe
complexe à base de courbes mathématiques.

L'utilisation  de  ce  langage  est garant d'une qualité de sortie proche de la
perfection.   De  plus,  il autorise la modification de la taille d'un objet ou
d'un   caractère   de   façon  proportionnelle  et  mathématique,  sans  aucune
déformation ou apparition de défaut.

La  plupart des programmes de Publication Assistée par Ordinateur sont capables
d'effectuer  des sorties en mode PostScript.  Cette sortie peut être faite soit
directement  vers une imprimante compatible PostScript soit vers un fichier qui
pourra ensuite être emmené chez un imprimeur par exemple.

L'utilisation  de  ce langage a été étendue à la définition des clip-arts grâce
au format @{"EPS" link EPS} et aux @{"polices de caractères" link PolicePS}.

Les  imprimantes  laser  compatibles  PostScript  possèdent la plupart du temps
leurs  propres  micro-processeurs  et  RAM  et  se  chargent  elles-mêmes de la
conversion du fichier PostScript en document imprimable.

@EndNode

@Node PolicePS "Les Polices PostScript"

Les polices vectorielles PostScript sont la plupart du temps définies grâce à 3
fichiers distincts et complémentaires :

Le  .PFB  (Printer  Font  Binary) est le fichier de vectorisation PostScript de
type 1.

Le .AFM (Adobe Font Metric) ou .PFM de MicroSoft (Printer Font Metric) contient
les descriptions de largeur et d'espacement.

Le .ABF (Adobe Binary Font) est la description d'affichage à l'écran.

@Endnode

@Node DCS "DCS"

Il  s'agit  d'une  variante  de  l'@{"EPS" link EPS}  contenant  l'ensemble des paramètres de
séparation  quadrichromique.   Un  fichier  dans  ce  format est constitué de 5
sous-fichiers  EPS  dont un est utilisé pour la visualisation de l'image et les
quatre autres pour définir les données des couleurs.

@Endnode

@Node EPS "EPS"

L'Encapsuled PostScript est un format de fichier permettant d'inclure une image
bitmap  dans  une  description  en langage PostScript.  Un fichier EPS est très
souvent utilisé pour décrire une illustration vectorielle comme les clip-arts.

@Endnode

@Node TIFF "TIFF"

Le  Tagged  Image  File Format définit une image bitmap en mode RVB ou CMJN (ce
dernier servant en PAO pour la séparation des couleurs).

Ce  format  est  couramment  utilisé  dans  le monde Macintosh.  La plupart des
scanners fournissent aussi des fichiers dans ce format.

@Endnode

@Node Echan "Formats d'Echantillonnage"

Le  terme  "échantillon"  (ou  sample)  correspond  au  résultat  donné  par un
convertisseur analogique/numérique, comme une numériseur sonore.

Les  données  audio sont caractérisées par des paramètres qui correspondent aux
réglages  du  convertisseurs  analogique/numérique  quand  les  données ont été
enregistrées.   Evidemment  les mêmes réglages doivent être utilisés lors de la
lecture des données.

- Taux  d'échantillonnage  (sampling   rate)  en  échantillons  par seconde par
exemple 18900 ou 44100.

- Nombre de bits par échantillon, 8 ou 16 le plus souvent.

- Nombre de canaux. 1 pour mono, 2 pour stéréo...


Le taux d'échantillonnage approximatif est souvent donné en Hz ou KHz (Hertz ou
KiloHertz),  cependant,  le terme correct devrait être échantillons par seconde
(samples/second).   Les taux d'échantillonnage sont toujours mesurés par canal,
donc pour un échantillon en stéréo enregistré à 8000 échantillons/seconde, il y
a en fait 16000 échantillons par seconde.


Taux d'échantillonnages classiques :


Echant./sec     Déscription

5500            Un quart du taux d'échantillonnage sur Mac (rare).

7333            Un tiers du taux d'échantillonnage sur Mac (rare).

8000            Un standard en téléphonie.


8012.8210513    Utilisé sur les stations de travail NeXT.


11 k            Ou 11025, un quart du taux d'échantillonnage d'un CD.
                La  moitié  du  taux d'échantillonnage sur Mac, le taux le plus
                utilisé sur Mac.

16000           Standard de compression G.722.

18.9 k          Standard pour le CD-ROM/XA.

22 k            Ou 22050, la moitié du taux d'échantillonnage d'un CD.
                taux d'échantillonnage sur Mac, en fait, 22254.545454545454.

32000           Utilisé   en   radio   numérique,   comme   le   NICAM  (Nearly
                Instantaneous  Compandable  Audio Matrix).  Utilisé sur les DAT
                long durée et la télévision HDTV japonaise.

37.8 k          Standard CD-ROM/XA pour une qualité supérieure.

44056           Utilisé par les équipements audio professionnels.

44100           Le taux  d'échantillonnage d'un CD.  Utilisé  aussi par les DAT
                enregistrant depuis un CD.

48000           Taux d'échantillonnage d'un  DAT (Digital Audio Tape)  pour une
                utilisation domestique.


Les  échantillons  utilisés sur les cartes son SoundBlaster sur PC ont des taux
d'échantillonnage multiples de 1 000 000.



Les formats de fichiers :

A l'origine, pratiquement chaque machine utilisait son propre format de fichier
pour  les  données  audio,  mais  quelques formats de fichier sont plus souvent
utilisés  et  il  est  possible  de  faire  une conversion entre la plupart des
formats de fichier.

Il  existe  deux types de format de fichier :  Les formats auto-descriptifs, où
les  paramètres  de  numérisations  sont décrits dans l'entête, et les fichiers
"raw" (bruts) où ces informations sont fixes.


Quelques formats auto-descriptifs :


Extension / Nom    Origine         Paramètres variables

.au ou .snd       NeXT, Sun       taux, #canaux, encodage, info
.aif(f) / @{"AIFF" link AIFF}    Apple, SGI      taux, #canaux, largeur d'échant., info
.aif(f) / AIFC    Apple, SGI      Extension de l'AIFF avec compression
.iff / @{"IFF/8SVX" link 8SVX}   Amiga           taux, #canaux, info sur l'instrument (8 bits)
.voc              Soundblaster    taux (8 bits/1 canal)
.wav / @{"WAVE" link WAVE}       Microsoft       taux, #canaux, largeur d'échant., info
.sf               IRCAM           taux, #canaux, encodage, info
HCOM              Mac             taux (8 bits/1 canal) avec compression @{"Huffman" link "Huffman"}
MIME              Internet



Chaque  machine  possède  ses  propres  caractéristiques  de numérisation et de
restitution du son.  Voici quelques exemples :


    Machine              bits           Taux d'échant .max    Canaux de sortie

Mac (tous types)          8              22k                   1
Mac (nouveaux modèles)   16              64k                   4 (128)
Apple IIgs                8              32k / >70k           16 (st)
PC/soundblaster pro       8              22k st, 44.1k mo      1 (st)
PC/soundblaster 16       16              44.1k                 1 (st)
PC/roland rap-10         16              44.1k                 1 (st)
PC/gravis ultrasound      8, 16          44.1k                14-32 (st)
Atari ST                  8              22k                   1
Atari STE,TT              8              50k                   2
Atari Falcon 030         16              50k                   8 (st)
Amiga                     8              29k                   4 (st)
Sun Sparcst. 10           8, 16          48k                   1 (st)
NeXT                      8, 16          44.1k                 1 (st)
SGI Indigo                8, 16          48k                   4 (st)
SGI Indigo2,Indy          8, 16          48k                  16 (st, 4 canaux)

@Endnode

@Node AIFF "Format AIFF et AIFC"

Ce  format  a  été  développé par Apple pour stocker des sons échantillonnés de
haute  qualité  ainsi que des instruments.  Il est aussi utilisé par les SGI et
divers équipement audio professionnels.

L'extension AIFC ou AIFF-C supporte un algorithme de compression.

@Endnode

@Node Wave "Format RIFF WAVE"

Le RIFF est une format créé par Microsoft et IBM similaire en philosophie et en
pratique au standard EA-IFF-85, mais non compatible.

Le  format  Wave est l'équivalent RIFF de l'AIFF et son intégration à Microsoft
Windows 3.1 l'a rendu très populaire.

@Endnode

@Node Huffman "Codage de Huffman"

Méthode  de  compression  de  données  basée  sur  la fréquence relative de ses
éléments  individuels.   Plus un élément intervient souvent, plus son codage en
bits  est  court.   Cette méthode est souvent utilisée dans les compressions de
texte, le codage étant basé sur la fréquence des lettres.

Le  codage de Huffman est l'un des plus anciens schémas de compression et reste
un des plus utilisés.

@Endnode


@Node LangPro "Les Langages de Programmation"

On trouve sur l'Amiga la plupart des langages de programmations existants. En
voici une brève présentation.


                         @{" Le Ada       " link Ada}
                         @{" Le ALGOL     " link ALGOL}
                         @{" L'APL        " link APL}
                         @{" L'Assembleur " link Assembleur}
                         @{" Le BASIC     " link BASIC}
                         @{" Le C         " link C}
                         @{" Le COBOL     " link COBOL}
                         @{" Le E         " link E}
                         @{" Le FORTH     " link FORTH}
                         @{" Le FORTRAN   " link FORTRAN}
                         @{" Le LISP      " link LISP}
                         @{" Le MODULA-2  " link MODULA}
                         @{" Le Pascal    " link Pascal}
                         @{" Le Prolog    " link Prolog}

@Endnode

@Node Ada "Le Ada"

Langage  de  programmation  développé  dans  la  fin  des  années  70  pour  le
département de la défense des USA.  Son nom vient de Augusta Ada Byron.

Le Ada est basé sur le Pascal, avec des influences du PL/I et de l'ALGOL68.

Les  sous-programmes  Ada  peuvent  être compilés séparément puis liés ensemble
avant exécution.

L'une  des motivations principales de la création de l'Ada était le besoin d'un
meilleur  langage  pour  la  programmation  en temps réel afin de contrôler des
équipements  automatiques  ou  semi-automatiques avec des ordinateurs.  Afin de
remplir  cette  tâche, l'Ada permet au programmeur de créer de multiples tâches
qui  fonctionnent  en parallèle (en temps partagé), de passer des signaux d'une
tâche à l'autre, et d'introduire des contrôles de délais.

@Endnode

@Node ALGOL "Le ALGOL"

ALGOrithmic  Language.   Il  s'agit  d'un couple de langages qui a eu un impact
très  important  sur  la conception des langages de programmation.  Le premier,
ALGOL  60,  développé  par  un  comité  international dans les années 60, était
l'ancêtre  immédiat  du  Pascal  et  a introduit de nombreuses caractéristiques
proches de celles du Pascal qui ont ensuite été adoptées par de nombreux autres
langages.

L'idée   de  base  était  qu'un  programme  BASIC  ou  FORTRAN  est  une  liste
d'instructions  numérotées,  alors qu'un programme ALGOL est un jeu de blocs de
déclarations  intégrés dans des blocs plus grands.  Une conception hiérarchique
est donc plus simple à établir et à suivre.

Mais  le standard ALGOL 60 ne spécifiait pas de déclaration pour les entrées et
les  sorties  puisqu'il était considéré comme spécifique à la machine.  L'ALGOL
60 n'était donc pas largement utilisé.

L'ALGOL 68 est un langage plus abstrait, ayant une réputation de puissance mais
aussi de complexité.

Mécontent  de  la  complexité  de  l'ALGOL  68, Niklaus Wirth conçut le premier
ALGOL W puis le Pascal qui remplace en grande partie l'ALGOL de nos jours.

@Endnode

@Node APL "L'APL"

Un langage de programmation inventé par Ken Iverson à la fin des années 60 mais
toujours   utilisé   pour  certains  travaux  mathématiques.   APL  signifie  A
Programming Language, le titre du livre de Iverson sorti en 1962.

L'APL possède son propre jeu de caractères, la plupart des opérations sont donc
représentées par des caractères spéciaux plutôt que par des mots clés.

@Endnode

@Node Assembleur "L'Assembleur"

Ce  langage  complexe permet de "parler" directement aux processeurs dans leurs
langages.   En  fait il génère des instructions en code machine.  L'Assembleur
permet de faire les programmes les plus rapides qui soient sur une machine.

L'Amiga offre principalement les Assembleurs DevPac, Macro68, ASMOne et A68K.

@Endnode

@Node BASIC "Le BASIC"

L'un des langages de programmation des plus populaires est le BASIC (Beginner's
All-purpose Symbolic Instructional Code).  Il a été créé dans les années 60 par
John  Kemeny  et  Thomas  Kurtzpour  initier  des étudiants aux principes de la
programmation.

C'est  le  langage le plus utilisé par les débutants.  Il est en effet facile à
apprendre  et  l'utilisateur  moyen  peut  de  ce  fait, rapidement générer des
programmes  simples.   Comme  son  nom l'indique, le BASIC est un langage assez
limité,  surtout  pour  les programmes longs.  Un langage évolué comme le basic
permet  d'exprimer  les  instruction de l'ordinateur sous forme de commandes en
anglais simplifié.

Le premier BASIC présenté sur Amiga était l'AmigaBASIC, de Microsoft.  Il a été
livré  avec  tous les Amiga équipés de KickStart 1.3 ou inférieurs.  La lenteur
de son éditeur et son absence de support des nouvelles capacités de la machines
furent les principales causes de sa disparition.

On trouve aussi l'AMOS, le Blitz, le HiSoft, le GFA...

@Endnode

@Node C "Le Langage C"

Développé  par  Bell Laboratories dans les années 70, basé sur les deux anciens
langages  B (1970) et BCPL (1967).  Un compilateur C est fourni avec le système
UNIX,  le C ayant d'ailleur été utilisé pour écrire la plus grande parti d'UNIX
lui-même.

Le C est un langage générique comme le Pascal et l'ALGOL, mais, contrairement à
la  plupart  des  autres  langages génériques, il donne au programmeur un accès
complet  au  représentations  internes  des  types  de  données  contenus  dans
l'ordinateur  (bit par bit).  Cela le rend très adapté pour réaliser des tâches
qui  requièrent  habituellement l'Assembleur, et pour réaliser des processus de
la manière la plus efficace pour la machine.

Plus  rapide que le Basic, plus simple que l'Assembleur, le C est le langage le
plus  populaire  toutes  plate-formes confondues.  Une grande partie du système
d'exploitation de l'Amiga est écrit en langage C.

On trouve entre autres sur Amiga le SAS et le DICE

Le  C  ANSI  est une version standardisée du langage de programmation C définie
par le American National Standards Institute en 1989.  Contrairement à l'ancien
langage  (défini  par  Kernighan  et Ritchie), le C ANSI inclut une déclaration
"void"  pour  les  fonctions  qui  ne  retournent pas de valeurs, ainsi que des
fonctions de recherche d'erreurs et d'autres extensions.

Le  C++  est un langage orienté objet développé par Bjarne Stroustrup pour Bell
Labs dans les années 80.  Il se présente comme étant le successeur du C.

@Endnode

@Node COBOL "Le COBOL"

COmmon  Business-Oriented  Language.   Un  langage  de  programmation  pour  le
traitement des données provenant des affaires, développé au début des années 60
par  différents  constructeurs d'ordinateurs ainsi que par le département de la
défense des USA.

@Endnode

@Node E "Le Langage E"

En  quelque  sorte  un  langage  C  spécifiquement  développé  en  fonction des
capacités de l'Amiga.

@Endnode

@Node FORTH "Le FORTH"

Langage  de  programmation inventé vers 1970 par Charles Moore.  Ce langage est
connu  pour  demandé  peu  de ressources à la machine et pour offrir une grande
vitesse d'exécution.

Le   programme   est  représenté  sous  la  forme  d'une  liste  d'adresses  de
sous-routines, chacunes étant composées d'adresses pour d'autres sous-routines,
et  ainsi  de  suite  jusqu'à  ce  que les opérations de base du langage soient
atteintes.

@Endnode

@Node FORTRAN "Le FORTRAN"

FORmula  TRANslation.   Développé  à  la fin des années 50 par IBM.  Le premier
grand  langage  de  programmation  qui  permit  aux programmeurs de décrire des
calculs par l'intermédiaire de formules mathématiques

@Endnode

@Node LISP "Le LISP"

LISt Processing.
Langage  interprété développé à la fin des années 50 par John McCarthy.  Adapté
aux  traitements de listes.  Il est surtout utilisé pour la mise au point et la
modification des langages évolués.

@Endnode

@Node MODULA "Le MODULA-2"

Langage  développé  par  Niklaus Wirth à la fin des années 70 pour remplacer le
Pascal.   Ce  langage  est  conçu  pour  encourager la modularité.  En fait, le
MODULA  est  très proche du Pascal mais permet de travailler sur des modules et
de diviser le programme en plusieurs tâches s'exécutant en temps partagé.

@Endnode

@Node Pascal "Le Pascal"

Langage  développé  par  Niklaus Wirth au début des années 70.  Souvent utilisé
dans  l'enseignement.   La Pascal offre une syntaxe simplifiée et des commandes
plus intuitives par rapport au langage C.  Il s'agit d'un des langages les plus
populaire.

On trouve sur Amiga le HiSpeed Pascal.

@Endnode

@Node Prolog "Le Prolog"

Langage  orienté intelligence artificielle développé au début des années 70 par
Alain  Colmerauer  à l'université de Marseille.  Se base sur des données et des
propositions  sur  ces  données, puis permet d'offrir des déroulements logiques
selon les combinaisons.

@Endnode


@Node Exec "Exec"

Au  coeur  du système d'exploitation se trouve Exec.  Il s'occupe de la gestion
des interruptions et gère donc le multitâche.  Exec est beaucoup plus petit que
le  Kernel UNIX, car de nombreuses fonctions comme les drivers se trouvent dans
une autre partie du système.

A  l'inverse  des  systèmes  "multitâches  coopératifs"  trouvés  sur  d'autres
machines, Exec est un système multitâche préemptif à part entière.

@Endnode

@Node IPC "Inter-Process Communication"


Il y a deux formes d'IPC :

- Le mécanisme interne de transfert de message (message-passing)
- ARexx

Les  processus  de  l'Amiga  communiquent par  message-passing.   Un  processus
s'inscrit  auprès  du système d'exploitation pour recevoir certaines classes de
messages, et les messages lui sont envoyés quand ils apparaîssent.
De  nombreuses  routines de messages comme le changement de taille des fenêtres
peuvent être gérées par le système plutôt que par l'application elle-même.

ARexx  (Amiga  Restructured  Extended Executer) est un langage de programmation
interprété  pour les IPC.  L'utilisateur écrit des scripts ARexx qui permettent
à des applications de communiquer entre elles.

@Endnode

@Node Intuition "Intuition"


Intuition  est une couche logicielle qui gère certaines tâches automatiquement,
libérant  les  programmes  d'application de quelques responsabilités courantes.
Les  applications  n'ont  pas besoin de savoir si les fenêtres sont changées de
taille,  rafraichies,  déplacées,  bougées  d'avant  en  arrière,   activées ou
désactivées,  iconifiées  et  ainsi  de  suite.   Evidemment,  les applications
peuvent  toujours  choisir  de  gérer  elles-mêmes ces évènements.  Ceci est en
complète  opposition avec ce qui existe sur le système du Macintosh dans lequel
l'application doit gérer chaque évènement.

@Endnode
