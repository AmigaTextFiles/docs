@DATABASE

@$VER: CoderAid.guide 2.01 (2018-02-04)
@AUTHOR Dissident
@(C) 2016-2018 by Dissident

@WIDTH 76
@FONT topaz.font 8


@NODE Main "Coder Aid"


 				  @{B}CODER AID@{UB}

         25 years of coding experience in assembler on the Amiga by

			     ---> dissident <---

                                Second edition


  @{B}Chapters			         Appendices
  --------			      	 ----------@{UB}
  1 @{" Introduction " LINK Chapter-1}                      A @{" Excerpts custom chip registers " LINK Appendix-A}
  2 @{" Peculiarities of the MC68020/60 " LINK Chapter-2}   B @{" CIA registers " LINK Appendix-B}
  3 @{" Peculiarities of the Chip Sets " LINK Chapter-3}    C @{" Excerpts Autodocs " LINK Appendix-C}
  4 @{" Optimizing & tricks " LINK Chapter-4}               D @{" Excerpts Amiga forums " LINK Appendix-D}
                                         E @{" Reference " LINK Appendix-E}
                                         F @{" List of tables " LINK Appendix-F}
@ENDNODE


@NODE Chapter-1 "Coder Aid: 1 Introduction"
@{B}1 Introduction@{UB}

After coding the Amiga for 25 years in assembler, I decided to collect
all my tips & tricks of this decade and to provide the Amiga publicity
my knowledge. I found out some things on my own, some things by analyzing
the code of demos and I read about some topics in a forum or in Amiga
magazines. Not to forget the hints of many persons, which I included as
mentioned.

For the second edition I've revised this guide completely, did many
corrections and added new experiences I've made since the last release.

I want to provide you a bound of different topics covering the peculiarities
of the Amiga hardware and music software like the @{I}Protracker@{UI}. Feel free
to browse through the paragraphs. I wish you lots of fun. :)

Many thanks go to @{I}mGGk@{UI} for checking the beta version of this guide and for
giving me a feedback.

Greetings go to the members of @{I}Resistance@{UI}, @{I}Bytebreaker@{UI}, @{I}Jasmin68k@{UI} and
@{I}Oriens@{UI}.

For any comments, hints or questions contact me at: @{B}dissident.68k@web.de@{UB}
@ENDNODE


@NODE Chapter-2 "Coder Aid: 2 Peculiarities of the MC68020/60"
@{B}2 Peculiarities of the MC68020/60@{UB}

  2-1 @{" MC68020 " LINK Chapter-2-1}
  2-2 @{" MC68060 " LINK Chapter-2-2}
@ENDNODE


@NODE Chapter-2-1 "2 Peculiarities of the MC68020/60 / MC68020"
@{B}2-1 MC68020@{UB}

    2-1-1 @{" Instruction fetch " LINK Chapter-2-1-1}
    2-1-2 @{" Bit field commands " LINK Chapter-2-1-2}
@ENDNODE


@NODE Chapter-2-1-1 "2 Peculiarities of the MC68020/60 / MC68020 / Instruction fetch"
@{B}2-1-1 Instruction fetch@{UB}

On the MC68020, 2x16 bits are fetched for instructions. These are two
commands or one command with an extension.

A longword alignment for subroutines can speed up the execution. The
longword alignment of the commands BRA, BSR, D..., B... might also help.

Strangely, this effect is only described in the MC68060 manual of MOTOROLA,
but it also applies to the MC68020. Here is an example:

;A6=CUSTOM CHIPS BASE+@{"DMACONR" LINK DMACON}

Mem-Offset wait_blitter
     0	     BTST  #6,(A6)
     4	     BNE.S wait_blitter

If the BNE command is on a longword boundary, the execution is faster. I
suppose, that the MC68020 behaves like the MC68060 when it fetches commands
like branches to a certain code position.
@ENDNODE


@NODE Chapter-2-1-2 "2 Peculiarities of the MC68020/60 / MC68020 / Bit field commands"
@{B}2-1-2 Bit field commands@{UB}

Starting with the MC68020, bit fields were introduced. You have now the
possibility to change a row of 1 to 32 bits aligned on arbitrary boundaries
anywhere in memory with a single command.

The classic logic of handling bits and bytes is changed here. There are
2^32 memory bytes in a single row numbered from left to right. A bit field
has a base byte anywhere in this row of 2^32 bytes, so that the CPU knows
where the bit field starts in memory. The beginning of a bit field within
this base byte is called a base bit, which is a field bit offset from the
leftmost bit (bit #7) of the base byte. The width of a bit field is 1 to
32 bits wide.

These are the three parameters we need for the bit field commands.

So where could we use bit fields? For example for a filled, two coloured
twister with sides of a maximum of 32 pixels.

Normally, you would have two points of the visible face, which are set
with a BSET command by the CPU line by line and then the whole outline is
filled by the blitter.

I use the command BFSET (BitFieldSET) and do both tasks with one command.
Setting the outline and filling the face line by line.

I've chosen the interleaved bitplane format raw modulo that means:
1st line plane0, 1st line plane1
2nd line plane0, 2nd line plane1
...etc...

Realizing this as a little routine could look like this:

;D0=P1(x)
;D2=P2(x)
;D7=Face colour number (1 or 2)
;A2=Pointer to first interleaved bitplane

  MOVEQ   #$7,D1		;Byte shift mask
  AND.B   D0,D1			;X-shift value = base bit
  SUB.W   D0,D2                 ;X-distance between P1&P2 = Bit field width
  LSR.W   #3,D0                 ;X1/8 = X-offset
check_plane1
  CMP.B   #1,D7			;Plane0 ?
  BNE.S   check_plane2		;No -> branch
  BFSET   (A2,D0.W){D1:D2}	;Set bit field in first bitplane
check_plane2
  CMP.B   #2,D7			;Plane1 ?
  BNE.S   no_face		;No -> branch
  BFSET   pf_plane_width(A2,D0.W){D1:D2} ;Set bit field in second bitplane
no_face
@ENDNODE


@NODE Chapter-2-2 "2 Peculiarities of the MC68020/60 / MC68060"
@{B}2-2 MC68060@{UB}

    2-2-1 @{" Instruction fetch " LINK Chapter-2-2-1}
    2-2-2 @{" Exception handling " LINK Chapter-2-2-2}
    2-2-3 @{" Proper memory alignment " LINK Chapter-2-2-3}
    2-2-4 @{" Change/use register stalls " LINK Chapter-2-2-4}
    2-2-5 @{" Creating bootable demo disks " LINK Chapter-2-2-5}
@ENDNODE


@NODE Chapter-2-2-1 "2 Peculiarities of the MC68020/60 / MC68060 / Instruction fetch"
@{B}2-2-1 Instruction fetch@{UB}

On the MC68060, we have a parallel execution with two pipelines displaced
by one word. So 2x48 bits are fetched for instructions:

sOEP (48 bit) = mem...mem+5 has a longword alignment
pOEP (48 bit) = mem+2...mem+7 has a word alignment.

Whether certain commands are longword or word aligned it has an effect of
their execution speed and the prevention of wait states. More about this
topic can be found @{"here" LINK Chapter-2-2-3}.
@ENDNODE


@NODE Chapter-2-2-2 "2 Peculiarities of the MC68020/60 / MC68060 / Exception handling"
@{B}2-2-2 Exception handling@{UB}

Parallel execution on the MC68060 causes some problems, if your code runs
out of FAST memory, exits from a supervisor exception routine and returns
to the user mode.

Let's expect that a @{"level-3-interrupt" LINK Chapter-4-4-13-1} routine looks like this:

;An=CUSTOM chips base

lev3_handler
  ...etc...
  MOVE.W  #$0020,$1E(An)	;@{"INTREQR" LINK INTREQ}: Clear Vertical-blank-Interrupt
  RTE

This code sequence may cause problems, because the RTE command could be
executed @{B}before@{UB} the vertical-blank-interrupt in the INTREQ register is
cleared and leads to an infinite loop. 

To prevent this, we do this little change:

  MOVE.W  #$0020,$1E(An)	;INTREQR: Clear Vertical-blank-Interrupt
  @{FG FILL}NOP@{FG TEXT}
  RTE

The NOP command stops all parallel pipeline activity and causes all write
cycles to complete, so the RTE is really executed @{B}after@{UB} clearing the
interrupt. This guarantees serialization of writes to I/O devices.

I hope with this hint you can save time of debugging such an error. While
I coded my double musicdisc-trackmo @{I}Music Invasion@{UI}, I spent hours finding
this very special error. On the MC68020-040 everything worked fine, but on
the MC68060 my routines froze when I enabled my vertical blank routine.
@ENDNODE


@NODE Chapter-2-2-3 "2 Peculiarities of the MC68020/60 / MC68060 / Proper memory alignment"
@{B}2-2-3 Proper memory alignment@{UB}

Remember to use a proper memory alignment of your data when accessing it or
wait cycles will appear:

  OP.W mem,Rn		;+1 wait cycle if mem is not word aligned

  OP.L mem,Rn		;+1 wait cycle if mem is not longword aligned


  OP.W Rn,mem		;+2 wait cycles if mem is not word aligned

  OP.L Rn,mem		;+2 wait cycles if mem is not longword aligned


Longword alignment in memory for certain commands may prevent wait states:

  ADDX
  ANDI to CCR
  BCC
  BCHG dy,
  BCLR dy,
  BRA
  BSET dy,
  BSR
  BTST dy,
  DBCC
  DIVS.W/L
  DIVU.W/L
  EXG
  JMP
  JSR
  MOVE from CCR
  MOVE16
  MOVEM
  MULS.W/L
  MULU.W/L
  NOP
  ORI to CCR
  ROXL
  ROXR
  RTS
  SUBX
  SWAP
  ANDI to SR
  MOVE from SR
  MOVEC
  ORI to SR
  RTE
@ENDNODE


@NODE Chapter-2-2-4 "2 Peculiarities of the MC68020/60 / MC68060 / Change/use register stalls"
@{B}2-2-4 Change/use register stalls@{UB}

There's a change/use penalty using the same register in an subsequent
instruction. Try to avoid these code sequences on the MC68060:

  MOVE.W/L  mem,A0
  ANY OP    (A0)          	;+ 1 extra cycle

  SUB.W/L   #value,A0
  ANY OP    (A0)          	;+ 2 extra cycles

  MULS.L    #value,D0
  MOVE.L    (An,D0.L),D1	;+ 2 extra cycles

  MULS.L    #value,D0
  MOVE.L    (An,D0.L*4),D1	;+ 2 extra cycles

  MULS.L    #value,D0
  MOVE.L    (An,D0.L*2),D1	;+ 3 extra cycles

  MULS.L    #value,D0
  MOVE.L    (An,D0.L*8),D1	;+ 3 extra cycles

  MULS.L    #value,D0
  MOVE.L    (An,D0.W),D1	;+ 3 extra cycles

  MOVE.L    #value,D0 / MOVEQ   #value,D0 / CLR.L    D0
  MOVE.L    (An,D0.L*2),D1	;+ 3 extra cycles

  MOVE.L    #value,D0 / MOVEQ   #value,D0 / CLR.L    D0
  MOVE.L    (An,D0.L*8),D1	;+ 3 extra cycles

  MOVE.L    #value,D0 / MOVEQ   #value,D0 / CLR.L    D0
  MOVE.L    (An,D0.W),D1	;+ 3 extra cycles

Do it better like this:

  LEA       mem,A0 / MOVE.L  #value,A0
  ANY OP    (A0)		;+ 0 extra cycles

  MOVE.L    #value,D0 / MOVEQ  #0,D0 / CLR.L  D0
  MOVE.L    (An,D0.L),D1	;+ 0 extra cycles

  MOVE.L    #value,D0 / MOVEQ  #0,D0 / CLR.L  D0
  MOVE.L    (An,D0.L*4),D1	;+ 0 extra cycles
@ENDNODE


@NODE Chapter-2-2-5 "2 Peculiarities of the MC68020/60 / MC68060 / Creating bootable demo disks"
@{B}2-2-5 Creating bootable demo disks@{UB}

Caution if your intro/demo uses the OS 2.0+ exec function @{"CacheControl()" LINK "CacheControl()"}
setting special MC68060 @{"cacheBits" LINK Chapter-4-4-9-6} and is booted from a floppy disk.

This exec function only supports CPUs up to the MC68040. For the MC68060 it
must be patched. The bit assignment of the MC68040-@{"CACR" LINK Chapter-4-4-9-4-3} differs from the
bit assignment of the MC68060-@{"CACR" LINK Chapter-4-4-9-4-4}.

Include the latest @{I}SetPatch@{UI} CLI/Shell command version 44.13 in your startup-
sequence before you run the demo and store the latest @{I}68060.library@{UI} version
46.15 in the libs directory.

Now the exec function CacheControl() will be patched and there should be no
problems anymore.
@ENDNODE


@NODE Chapter-3 "Coder Aid: 3 Peculiarities of the Chip Sets"
@{B}3 Peculiarities of the Chip Sets@{UB}

  3-1  @{" Original Chip Set (OCS) " LINK Chapter-3-1}
  3-2  @{" Advanced Graphics Architecture (AGA) " LINK Chapter-3-2}
@ENDNODE


@NODE Chapter-3-1 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS)"
@{B}3-1 Original Chip Set (OCS)@{UB}

    3-1-1 @{" Copper " LINK Chapter-3-1-1}
    3-1-2 @{" Playfields " LINK Chapter-3-1-2}
    3-1-3 @{" Sprites " LINK Chapter-3-1-3}
@ENDNODE


@NODE Chapter-3-1-1 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Copper"
@{B}3-1-1 Copper@{UB}

      3-1-1-1 @{" CWAIT horizontal position bug " LINK Chapter-3-1-1-1}
@ENDNODE


@NODE Chapter-3-1-1-1 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Copper / CWAIT horizontal position bug"
@{B}3-1-1-1 CWAIT horizontal position bug@{UB}

If want to display a colourrun by the background colour with the copper, you
do a @{"CWAIT" LINK Chapter-4-4-14} at the beginning of a scan line and change the @{"COLOR00" LINK COLORxx} register.
The copper list could look like this:

VSTART=$2C
colourrun_lines_num=15

0=<n<colourrun_lines_num

  CWAIT 0,VSTART+n
  CMOVE $0XXX,COLOR00		;Set background colour
  ...etc...

As a result you will get a step effect at the right border in the overscan
area. The reason is, that all lores horizontal positions less than $C belong
to the end of the previous scan line.

To prevent this, just wait for the lores position $C and the effect will
disappear.
@ENDNODE


@NODE Chapter-3-1-2 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Playfields"
@{B}3-1-2 Playfields@{UB}

      3-1-2-1 @{" Undocumented bitplane effect " LINK Chapter-3-1-2-1}
@ENDNODE


@NODE Chapter-3-1-2-1 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Playfields / Undocumented bitplane effect"
@{B}3-1-2-1 Undocumented bitplane effect@{UB}

When I analyzed Kefrens' @{I}Megademo 7@{UI} around 1991 I found out something
strange in the second part with the chinese dragons.

The colour cycling for the upper scroll text only changes @{"COLOR16" LINK COLORxx}. In
this part the display has 5 bitplanes. 4 ones for the background and
one bitplane for the scroll text. Normally we have to change COLOR16-31
to do the colourcycling, because the bitplane data of plane 5 overlaps
the other bitplanes of the background. It seems that there must be a
special display mode enabled.

Setting up the priority bits PF1P0-PF2P2 (bits0-5) in @{"BPLCON2" LINK BPLCON2} with the
not documented bit-combination %111111 leads to this result. Sadly this
only works on OCS and ECS. And I wonder how the guys of Kefrens found
out this phenomenon already in 1989...

Toni Wilen described this effect in @{"Undocumented Amiga hardware stuff" LINK Appendix-D-1-1-1}.
@ENDNODE


@NODE Chapter-3-1-3 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Sprites"
@{B}3-1-3 Sprites@{UB}

      3-1-3-1 @{" Border sprites hardware bug " LINK Chapter-3-1-3-1}
@ENDNODE


@NODE Chapter-3-1-3-1 "3 Peculiarities of the Chip Sets / Original Chip Set (OCS) / Sprites / Border sprites hardware bug"
@{B}3-1-3-1 Border sprites hardware bug@{UB}

Using the @{"trick for border sprites" LINK Chapter-4-6-3-1} on the OCS produces the same display
bug as the AGA chipset mentioned @{"below" LINK Chapter-3-2-3-6}.

If SPR4/5/6/7 are displayed in the left overscan area after the horizontal
blank stop (HBSTOP=$5A), parts of them are not displayed correctly at the
positions where their data is fetched by DMA:

SPR0 memory slot $15-$18 (lores xpos=$2A-$30)
SPR1 memory slot $19-$1C (lores xpos=$32-$38)
SPR2 memory slot $1D-$20 (lores xpos=$3A-$40)
SPR3 memory slot $21-$24 (lores xpos=$42-$48)
@{FG FILL}SPR4 memory slot $25-$28 (lores xpos=$4A-$50)
SPR5 memory slot $29-$2C (lores xpos=$52-$58)
SPR6 memory slot $2D-$30 (lores xpos=$5A-$60)
SPR7 memory slot $31-$34 (lores xpos=$62-$68)@{FG TEXT}

The error is visible for SPR4, because the last slot with lores position
$50 + 16 pixels = $60 which is > HBSTOP=$5A, the horizontal blank stop for
an overscan display. The error is not visible for SPR3, because $48 + 16
pixels = $58 < $5A.

Toni Wilen described this behaviour in @{"Undocumented Amiga hardware stuff" LINK Appendix-D-1-1-4}.
@ENDNODE


@NODE Chapter-3-2 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA)"
@{B}3-2 Advanced Graphics Architecture (AGA)@{UB}

    3-2-1 @{" Copper " LINK Chapter-3-2-1}
    3-2-2 @{" Playfields " LINK Chapter-3-2-2}
    3-2-3 @{" Sprites " LINK Chapter-3-2-3}
    3-2-4 @{" Blitter " LINK Chapter-3-2-4}
@ENDNODE


@NODE Chapter-3-2-1 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Copper"
@{B}3-2-1 Copper@{UB}

      3-2-1-1 @{" CWAIT horizontal position bug " LINK Chapter-3-2-1-1}
@ENDNODE


@NODE Chapter-3-2-1-1 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Copper / CWAIT horizontal position bug"
@{B}3-2-1-1 CWAIT horizontal position bug@{UB}

If want to display a colourrun by the background colour with 24 bit values
done with the copper, you do a @{"CWAIT" LINK Chapter-4-4-14} at the beginning of a scan line and
change the @{"BPLCON3" LINK BPLCON3}/@{"COLOR00" LINK COLORxx} registers. A copper list could look like this:

VSTART=$2C
colourrun_lines_num=256

0=<n<colourrun_lines_num

  CWAIT 0,VSTART+n
  CMOVE $0000,BPLCON3		;High colour values
  CMOVE $0XXX,COLOR00		;Set background colour high bits
  CMOVE $0200,BPLCON3		;Low colour values
  CMOVE $0xxx,COLOR00		;Set background colour low bits
  ...etc...

As a result you won't get a step effect at the right border in the overscan
area as mentioned @{"above" LINK Chapter-3-1-1-1}. The reason is, that the first @{"CMOVE" LINK Chapter-4-4-14} to the
BPLCON3 register takes 8 lores pixels. The CMOVE to the COLOR00 register
also takes 8 lores pixels to be executed. So the colourchange is done at
the lores position $10 and this is already the beginning of the next scan
line.

Remember that all old OCS copper lists which write 12 bit values to the
COLOR00 register will have the same display bug on ECS and AGA chipsets,
if they wait for the horizontal lores position less than $C.
@ENDNODE


@NODE Chapter-3-2-2 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Playfields"
@{B}3-2-2 Playfields@{UB}

      3-2-2-1 @{" Saving memory cycles in a display " LINK Chapter-3-2-2-1}
      3-2-2-2 @{" Table of bitplane data fetches " LINK Chapter-3-2-2-2}
      3-2-2-3 @{" Palette switching with the BPLCON4 register " LINK Chapter-3-2-2-3}
      3-2-2-4 @{" Converting 24 bit RGB values " LINK Chapter-3-2-2-4}
@ENDNODE


@NODE Chapter-3-2-2-1 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Playfields / Saving memory cycles in a display"
@{B}3-2-2-1 Saving memory cycles in a display@{UB}

For every scan line in a playfield the DMA needs several memory slots to
display the data. Every memory slot takes about 280ns or 2 lores pixels.

On the OCS/ECS for 16 lores pixels this looks like this:

1st data word / memory slots
+---------+--------+--------+--------+---------+--------+--------+--------+
|undefined|Bitplane|Bitplane|Bitplane|undefined|Bitplane|Bitplane|Bitplane|
+---------+--------+--------+--------+---------+--------+--------+--------+
|   X     |    4   |    6   |    2   |    X    |    3   |    5   |    1   |
+---------+--------+--------+--------+---------+--------+--------+--------+

2nd data word / memory slots
+---------+--------+--------+--------+---------+--------+--------+--------+
|undefined|Bitplane|Bitplane|Bitplane|undefined|Bitplane|Bitplane|Bitplane|
+---------+--------+--------+--------+---------+--------+--------+--------+
|   X     |    4   |    6   |    2   |    X    |    3   |    5   |    1   |
+---------+--------+--------+--------+---------+--------+--------+--------+
...etc...

The numbers represent the depth of a picture and the plane number.
1=bitplane1, 2=bitplane2, X=not used, free for other devices.


With AGA I assume for 16 lores pixels it looks like this, because on AGA a
display can have a maximum depth of 8 bitplanes:

1st data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   8    |    4   |    6   |    2   |    7   |    3   |    5   |    1   |
+--------+--------+--------+--------+--------+--------+--------+--------+

2nd data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   8    |    4   |    6   |    2   |    7   |    3   |    5   |    1   |
+--------+--------+--------+--------+--------+--------+--------+--------+
...etc...

Toni Wilen confirms this in @{"Interesting AGA bitplane overrun special case" LINK Appendix-D-1-2}.

On the 1x fetch mode, 16 lores pixels need 16 lores pixels memory fetch time
and 64 lores pixels the fetch time for 64 lores pixels. But what happens if
we enable the 4x burst mode in the @{"FMODE" LINK FMODE} register?

Quite simple. The data is fetched and displayed four times faster. Now
you only need the fetch time 16 lores pixels for 64 lores pixels(!). The
remaining memory slots are available for other devices (Copper, Blitter
and CPU in that order).

In a schema it looks like this:

1st data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   8    |    4   |    6   |    2   |    7   |    3   |    5   |    1   |
+--------+--------+--------+--------+--------+--------+--------+--------+

2nd data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   X    |    X   |    X   |    X   |    X   |    X   |    X   |    X   |
+--------+--------+--------+--------+--------+--------+--------+--------+

3rd data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   X    |    X   |    X   |    X   |    X   |    X   |    X   |    X   |
+--------+--------+--------+--------+--------+--------+--------+--------+

4th data word / memory slots
+--------+--------+--------+--------+--------+--------+--------+--------+
|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|Bitplane|
+--------+--------+--------+--------+--------+--------+--------+--------+
|   X    |    X   |    X   |    X   |    X   |    X   |    X   |    X   |
+--------+--------+--------+--------+--------+--------+--------+--------+
...etc...

A very simple but an effective way to save memory slots on the MC68020
without FAST memory.
@ENDNODE


@NODE Chapter-3-2-2-2 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Playfields / Table of bitplane data fetches"
@{B}3-2-2-2 Table of bitplane data fetches@{UB}

The data fetch values for register @{"DDFSTOP" LINK DDFSTRT}=$D0 for 1x mode (16 lores pixels)
and DDFSTOP=$A0 for 4x mode (64 lores pixels) can be explained like this:

+-----+----------------------------------+---------------------------------+
| DDF |	Pixels fetched 1x mode	         | Pixels fetched 4x mode          |
+-----+----------------------------------+---------------------------------+
| $38 |	 16	   		         |  64                             |
+-----+----------------------------------+---------------------------------+
| $40 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $48 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $50 |	 16                              |                                 |
+-----+----------------------------------+---------------------------------+
| $58 |	 16			         |  64                             |
+-----+----------------------------------+---------------------------------+
| $60 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $68 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $70 |	 16                              |                                 |
+-----+----------------------------------+---------------------------------+
| $78 |	 16			         |  64                             |
+-----+----------------------------------+---------------------------------+
| $80 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $88 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $90 |	 16                              |                                 |
+-----+----------------------------------+---------------------------------+
| $98 |	 16			         |  64                             |
+-----+----------------------------------+=================================+
| $A0 |	 16			         | Screen data fetch stops(DDFSTOP)|
|     |					 | here for each horizontal line   |
|     |					 | after the last quad word on the |
|     |				 	 | line has been fetched.   	   |
+-----+----------------------------------+                                 |
| $A8 |	 16                              | 256 Pixels fetched without last |
+-----+----------------------------------+     quad word. Quad word count-1|
| $B0 |	 16                              |                                 |
+-----+----------------------------------+  64 Pixels last quad word       |
| $B8 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $C0 |	 16                              |                                 |
+-----+----------------------------------+                                 |
| $C8 |	 16                              |                                 |
+========================================+                                 |
| $D0 |	Screen data fetch stops (DDFSTOP)|                                 |
|     |	here for each horizontal line 	 |                                 |
|     |	after the last word on the line  |                                 |
|     |	has been fetched.                |                                 |
|     |                                  |                                 |
|     |	304 Pixels fetched without	 |                                 |
|     |	    last word. Word count -1	 |                                 |
|     |                                  |                                 |
|     |	 16 Pixels last word		 |                                 |
|     +==================================+=================================+
|     |	320 Pixels total data fetch	 | 320 Pixels total data fetch     |
+-----+----------------------------------+---------------------------------+
@ENDNODE


@NODE Chapter-3-2-2-3 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Playfields / Palette switching with the BPLCON4 register"
@{B}3-2-2-3 Palette switching with the BPLCON4 register@{UB}

The switching of colour values for bitplanes only works in the boundaries
specified in @{"DIWSTRT" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT}/@{"DIWHIGH" LINK DIWHIGH}.

Sprites are not involved. They ignore the colourswitch, because their colour
banks can be switched separately with the @{"BPLCON4" LINK BPLCON4}.

The minimum number of bitplanes for switching is one bitplane. Colour
switching works on all non-HAM screen types up to 256 colours.

HAM-screens don't support colourswitching. HAM6 (4.096 colours) ignores
the values in BPLCON4 completely, HAM8 (262.144 colours) messes the
palette up. More details about this problem can be found @{"here" LINK Appendix-D-2-1}.

If you switch colours, you normally start with colour register @{"COLOR01" LINK COLORxx}
for the first palette/bank. So the background colour will be unaffected
if your routine changes the colour values every frame, for example a
colour cycling effect. In some cases we need to switch the whole palette
of 256 colours starting with @{"COLOR00" LINK COLORxx}.

Here's the solution: Just set the bit 5 (BRDRBLNK) in @{"BPLCON3" LINK BPLCON3} and you
will get a blanked black coloured border outside the display-window
whatever the content of COLOR00/bank 1 is.
@ENDNODE


@NODE Chapter-3-2-2-4 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Playfields / Converting 24 bit RGB values"
@{B}3-2-2-4 Converting 24 bit RGB values@{UB}

With AGA we have a larger depth for the colour values of 24 instead of
12 bits. But the @{"COLORxx" LINK COLORxx} registers still process 12 bit values. They
group it into 12 bit high values and 12 bit low values for the same
registers switching between high and low with the LOCT bit (bit9) in
@{"BPLCON3" LINK BPLCON3}.

How can we convert our internal 24 bit values into this format? Here's
an example for a four coloured display.

The copper list initializing the colour registers could look like this:

copper_list
  CMOVE $0000,BPLCON3		;1st colour bank high values
colour_bank_high
  CMOVE $0000,COLOR00		;Missing 12 high bits copied by the CPU
  CMOVE $0000,COLOR01		;into the copper list
  CMOVE $0000,COLOR02
  CMOVE $0000,COLOR03
  CMOVE $0200,BPLCON3		;1st colour bank low values
colour_bank_low
  CMOVE $0000,COLOR00		;Missing 12 low bits copied by the CPU
  CMOVE $0000,COLOR01		;into the copper list
  CMOVE $0000,COLOR02
  CMOVE $0000,COLOR03
  ...etc...

And the initializing job of the CPU could be coded this way:

;D0=$00RrGgBb (Internal 24 bit colour value format)
;A0=Pointer to the 24 bit colour table
;A1=Pointer to value written by @{"CMOVE" LINK Chapter-4-4-14} to COLORxx in your copper list

pf_colours_num=16

  CNOP 0,4			;Longword alignment for MC68020+
init_pf_colours
  LEA     colour_table(PC),A0   ;colour table
  LEA     copper_list+(colour_bank_high-copper_list)+2,A1 ;Second word @{"CMOVE" LINK Chapter-4-4-14}
  MOVE.W  #$0F0F,D4             ;Mask for colour high/low bits
  MOVEQ   #pf_colours_num-1,d7  ;Number of colours
init_pf_colours_loop
  MOVE.L  (A0)+,D0              ;Get 24 bit colour value
  MOVE.L  D0,D3			;and save it in D3
  LSR.W   #4,D0			;$0GgB
  AND.W   D4,D0			;$0G0B = mask out the high values
  MOVE.B  D0,D2			;$0B
  LSR.W   #4,D0			;$00G0
  OR.B    D0,D2			;$GB
  SWAP    D0			;$00Rr
  LSL.W   #4,D0			;$0Rr0
  AND.W   D4,D3			;$0g0b = mask out the low values
  MOVE.B  D2,D0			;$0RGB
  MOVE.B  D3,D2			;$0b
  LSR.L   #4,D3			;$r0g0
  MOVE.W  D0,(A1)		;COLORxx high bits in copper list
  OR.B    D3,D2			;$gb
  LSR.W   #4,D3			;$0r0g
  ADDQ.W  #4,A1                 ;next CMOVE in copper list
  MOVE.B  D2,D3			;$0rgb
  MOVE.W  D3,colour_bank_low-colour_bank_high-4(A1) ;COLORxx low bits in cl
  DBF     d7,init_pf_colours_loop
  RTS

  CNOP 0,4			;Longword alignment for MC68020+
colour_table
  DC.L $00F82204,$000044FF,$00FFFFFF,$00FF8800
@ENDNODE


@NODE Chapter-3-2-3 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites"
@{B}3-2-3 Sprites@{UB}

      3-2-3-1 @{" Horizontal reuse of sprites with the copper" LINK Chapter-3-2-3-1}
      3-2-3-2 @{" Horizontal reuse of sprites with scan doubling" LINK Chapter-3-2-3-2}
      3-2-3-3 @{" Wobble effect with sprites " LINK Chapter-3-2-3-3}
      3-2-3-4 @{" Switching sprite palettes " LINK Chapter-3-2-3-4}
      3-2-3-5 @{" Switching attached sprite palettes " LINK Chapter-3-2-3-5}
      3-2-3-6 @{" Border sprites hardware bug " LINK Chapter-3-2-3-6}
@ENDNODE


@NODE Chapter-3-2-3-1 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites / Horizontal reuse of sprites with the copper"
@{B}3-2-3-1 Horizontal reuse of sprites with the copper@{UB}

Like on OCS machines, we can reposition AGA-sprites horizontally with the
copper reusing the @{"SPRxPOS" LINK SPRxPOS}-register.

This can be also done with sprite data fetched by DMA with a bandwidth of
32 or 64 pixels and in all sprite resolutions (lores, hires, super hires).

This works, because in a 32 or 64 bit sprite structure, only the upper 16
bits for SPRxPOS are relevant. The rest is ignored. So writing to SPRxPOS
with the copper does the same and sets the upper 16 bits.
@ENDNODE


@NODE Chapter-3-2-3-2 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites / Horizontal reuse of sprites with scan doubling"
@{B}3-2-3-2 Horizontal reuse of sprites with scan doubling@{UB}

There is a way on the AGA chipset to reuse sprite data horizontally without
the copper. If the SSCAN2-bit in the @{"FMODE" LINK FMODE} register is set, all used
sprites are repeated 256 pixels after their first use with the same pixel
content. The sprites can be normal or attached sprites.

The trick is, that we use a feature, which was originally introduced to
display sprites on scan doubled screens like the VGA/Productivity mode.

With this method, we could a create a "third plane-background" with a depth
of 16 colours on a 320x256 screen. Four attached 64 pixels lores sprites
with a repeating 256x256 pixel pattern. The left side of the pattern should
fit the right side to have a smooth transition.

Take care that the sprites have the following horizontal positions:

xpos=0:   SPR0&1
xpos=64:  SPR2&3
xpos=128: SPR4&5
xpos=192: SPR6&7

The sprites data will be re-displayed at these horizontal positions:

xpos=256: SPR0&1
xpos=320: SPR2&3
xpos=384: SPR4&5
xpos=448: SPR6&7

As a consequence the sprites are visible on a 320x256 screen in this order:

screen-xpos=  0... 63): SPR4&5
screen-xpos= 64...127): SPR6&7
screen-xpos=128...191): SPR0&1
screen-xpos=192...255): SRP2&3
screen-xpos=256...319): SPR4&5

The 256 pixels wide pattern should be copied into the sprite structures with
the same order:

1st quad word: SPR4&5
2nd quad word: SPR6&7
3rd quad word: SPR0&1
4th quad word: SPR2&3

Toni Wilen described this effect in @{"Undocumented Amiga hardware stuff" LINK Appendix-D-1-1-3}.

I used this trick to display the background pictures for the triple-glenz
and the vector-balls parts of the Resistance demo @{I}Future Balls@{UI}.
@ENDNODE


@NODE Chapter-3-2-3-3 "4 Optimizing & tricks / AGA / Sprites / Wobble effect with sprites"
@{B}3-2-3-3 Wobble effect with sprites@{UB}

What you have to do:

-Sprite data is displayed with DMA (16/32/64 bits bandwidth, lores/hires/
 super hires resolution)

-The copper writes to the @{"SPRxPOS" LINK SPRxPOS} register at the beginning of every
 scan line in the horizontal blank area to shift the sprite data

As already mentioned @{"above" LINK Chapter-3-2-3-1} this works with all kinds of bandwidths, because
only the upper 16 bits need to be written and so the copper can write to
these registers with its bandwidth of 16 bits.
@ENDNODE


@NODE Chapter-3-2-3-4 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites / Switching sprite palettes"
@{B}3-2-3-4 Switching sprite palettes@{UB}

Just like the palettes for playfields, the palettes of the sprites can also
be switched.

This can be done separately for odd (bits0-3) and even (bits4-7) sprites
with the @{"BPLCON4" LINK BPLCON4} register. Remember that only the whole sprite palette
of 16 colours can be switched. This means only 16x16-ary steps can be done.

We can do the same effect just like a rotator/zoomer does. Changing the
non-visible colours in a scan line and displaying them in the subsequent
scan line can be done, too. For all fifteen 24-bit colour values that
couldn't be done during the horizontal blank.
@ENDNODE


@NODE Chapter-3-2-3-5 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites / Switching attached sprite palettes"
@{B}3-2-3-5 Switching attached sprite palettes@{UB}

When selecting the colour table for attached sprites, only the table for
the odd sprites must be set (bits OSPRM4-OSPRM7 of @{"BPLCON4" LINK BPLCON4}).

As a consequence, ESPRM4-ESPRM7 are ignored and can be independently set
for even non-attached sprites.

This could be used in a shoot 'em up game. The attached 32 pixels sprites
SPR0&1 (the player-spaceship) use palette 2 (COLOR16-31), the even 32
pixels sprites SPR2/4/6 (the enemy bullets) use palette 3 (COLOR36-47).
@ENDNODE


@NODE Chapter-3-2-3-6 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Sprites / Border sprites hardware bug"
@{B}3-2-3-6 Border sprites hardware bug@{UB}

There is a display bug of the AGA chipset if SPR4/5/6/7 are displayed as
16 pixels border sprites in the left overscan area after the horizontal
blank stop (HBSTOP=$5A).

Parts of them are not displayed correctly at the positions where their data
is fetched by DMA:

SPR0 memory slot $15-$18 (lores xpos=$2A-$30)
SPR1 memory slot $19-$1C (lores xpos=$32-$38)
SPR2 memory slot $1D-$20 (lores xpos=$3A-$40)
SPR3 memory slot $21-$24 (lores xpos=$42-$48)
@{FG FILL}SPR4 memory slot $25-$28 (lores xpos=$4A-$50)
SPR5 memory slot $29-$2C (lores xpos=$52-$58)
SPR6 memory slot $2D-$30 (lores xpos=$5A-$60)
SPR7 memory slot $31-$34 (lores xpos=$62-$68)@{FG TEXT}

Whether you see this effect also for SPR0/1/2/3, depends on the data fetch
width of the sprites.

For example, the error is also visible for SPR3, if it is 64 pixels wide,
because the last slot with the lores position $48 + 64 pixels = $88 which
is greater than HBSTOP=$5A, the horizontal blank stop for an overscan
display.

The error would be not visible, if SPR3 would be 16 pixels wide, because
$48 + 16 pixels = $58 < $5A.

Toni Wilen described this effect in @{"Undocumented Amiga hardware stuff" LINK Appendix-D-1-1-4}.
@ENDNODE


@NODE Chapter-3-2-4 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Blitter"
@{B}3-2-4 Blitter@{UB}

      3-2-4-1 @{" Big blits " LINK Chapter-3-2-4-1}
      3-2-4-2 @{" New register BLTCON0L " LINK Chapter-3-2-4-2}
@ENDNODE


@NODE Chapter-3-2-4-1 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Blitter / Big blits"
@{B}3-2-4-1 Big blits@{UB}

Starting with the Enhanced Chip Set (ECS) it brings us a very useful
innovation. Big blits of 32768x32768 pixels are now possible with the
registers @{"BLTSIZV" LINK BLTSIZV} and @{"BLTSIZH" LINK BLTSIZH}.

But what can we do with this extension? For example clearing a copper
chunky screen of 44x256=11.264 @{"BPLCON4" LINK BPLCON4} registers with only one blit:

;A6=CUSTOM CHIP BASE+DMACONR

blit_x_size=16			;Size of BPLCON4 register
blit_y_size=256*(44+1)		;256 lines * (44 x @{"CMOVE" LINK Chapter-4-4-14} + 1x @{"CWAIT" LINK Chapter-4-4-14})

  CNOP 0,4			;Longword alignment for MC68020+
clear_copper_list
  BTST    #6,(A6)		;@{"DMACONR" LINK DMACON} Wait for blitter to be finished
  BNE.S   clear_copper_list
  MOVE.L  #$01000000,$40-2(A6)	;@{"BLTCON0" LINK BLTCON0} Minterm = D clear
  MOVEQ   #2,D0
  MOVE.W  D0,$66-2(A6)		;@{"BLTDMOD" LINK BLTxMOD} D-Mod = clear every 2nd word
  MOVE.L  #copper_list+2,$54-2(A6) ;@{"BLTDPTH" LINK BLTxPTH} Second command word in CL
  MOVE.L  #(blit_y_size*65536)+(blit_x_size/16),$5C-2(A6) ;@{"BLTSIZV" LINK BLTSIZV} Do blit
  RTS

We display a single bitplane with 352x256 visible pixels. That means that
the registers @{"DIWSTART" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT}/@{"DIWHIGH" LINK DIWHIGH} need to be initialized with the
values HSTART=$67, HSTOP=$1C7, VSTART=$2C and VSTOP=$12C.

Take care of the @{"CWAIT" LINK Chapter-4-4-14}-command. Four lores pixels are subtracted from
HSTART, because of the BPLCON4-delay of one lores pixel.

We have to subtract four lores-pixels, because we don't reset the BPLCON4-
register at the end of the scan line to zero. That means, that the last
colour value of the previous scan line would be displayed in the first two
lores pixels at the left border.

To prevent this effect, we would require a 45th @{"CMOVE" LINK Chapter-4-4-14} to BPLCON4 for a
reset to zero, which is superfluous if we change the x-coordinate of the
@{"CWAIT" LINK Chapter-4-4-14} command like mentioned above.

Because of the left shift now two pixels are missing at the right border.
But this is not visible, because the last CMOVE command holds the colour
value until the HSTOP position. As a consequence the last copper column
is ten instead of eight lores pixels wide.

There's only one thing to consider. The blit also clears the second word
of the CWAIT command.

HSTART=$67
VSTART=$2C

0=<n<=255

Copper list before clear blit:

copper_list
  DC.W $2C31,$FFFE 		;CWAIT HSTART-4,VSTART+n First @{"CWAIT" LINK Chapter-4-4-14}
  DC.W $010C,$0000 		;CMOVE $2200,BPLCON4 Repeated 44 times
  ...etc...

and after clear blit:

copper_list
  DC.W $2C31,@{FG FILL}$0000@{FG TEXT} 		;No CWAIT maskbits -> Copper stops here
  DC.W $010C,@{FG FILL}$0000@{FG TEXT} 		;CMOVE $0000,BPLCON4 Repeated 44 times
  ...etc...

One solution could be, that after the clear blit is finished, the CPU
could restore the destroyed CWAITs in the copper list. Or we use three
copper lists as buffers. So we can have a parallel execution of clearing
and restoring. But the restoring needs a loop of 256 times and takes
raster time.

Optimizing the clear blit is much better. We just change the blit to a
copy blit with the minterm D=A. For channel A we don't have to turn on
DMA, because this value doesn't change and is only initialized once by
a single write to the @{"BLTADAT" LINK BLTxDAT} register.

Here's the code:

;A6=CUSTOM CHIP BASE+DMACONR

  CNOP 0,4			;Longword alignment for MC68020+
clear_copper_list
  BTST    #6,(A6)		;@{"DMACONR" LINK DMACON} Wait for the blitter to be finished
  BNE.S   clear_copper_list
  MOVE.L  #$09F00000,$40-2(A6)	;@{"BLTCON0" LINK BLTCON0} Minterm D=A
  MOVEQ   #-1,D0
  MOVE.L  D0,$44-2(A6)		;@{"BLTAFWM" LINK BLTAFWM} No mask
  MOVEQ   #2,D0
  MOVE.W  D0,$66-2(A6)		;@{"BLTDMOD" LINK BLTxMOD} D-Mod = copy every 2nd word
  MOVE.L  #copper_list+2,$54-2(A6) ;@{"BLTDPTH" LINK BLTxPTL} Second command word in CL
  MOVEQ   #-2,D0
  MOVE.W  D0,$74-2(A6)		;@{"BLTADAT" LINK BLTxDAT} Copy value $FFFE
  MOVE.L  #(blit_y_size*65536)+(blit_x_size/16),$5C-2(A6) ;@{"BLTSIZV" LINK BLTSIZV} Do blit
  RTS

Copper list before copy blit:

copper_list
  DC.W $2C31,$FFFE		;@{"CWAIT" LINK Chapter-4-4-14} HSTART-4,VSTART+n
  DC.W $010C,$0000		;@{"CMOVE" LINK Chapter-4-4-14} $0000,BPLCON4 Repeated 44 times
  ...etc...

and after copy blit:

copper_list
  DC.W $2C31,@{FG FILL}$FFFE@{FG TEXT} 		;CWAIT HSTART-4,VSTART+n
  DC.W $010C,@{FG FILL}$FFFE@{FG TEXT} 		;CMOVE $FFFE,BPLCON4 Repeated 44 times
  ...etc...

What does the routine do? It copies the value "$FFFE" 45*256 = 11.520
times into every second word of the copper list. At every 45th position
the second word of the CWAIT is automatically restored.

As a side effect the screen palette is switched to colour 255 to be
displayed on the screen. Just initialize colour 255 at the top of your
copper list with your desired value. This could be done like this:

  CMOVE $E000,BPLCON3		;8th palette high colour values
  CMOVE $0005,COLOR31		;COLOR255 = dark blue high bits
  CMOVE $E200,BPLCON3		;8th palette low colour values
  CMOVE $0005,COLOR31		;COLOR255 = dark blue low bits

The colour 255 is visible within the whole scan line between the defined
values HSTART=$67 and HSTOP=$1C7 in the registers @{"DIWSTART" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT} and
@{"DIWHIGH" LINK DIWHIGH}.

In case you don't use sprites, the low byte value $FE in BPLCON4 has no
effect. But if sprites are displayed, care must be taken with the sprite
palette. Odd sprites use the 15th palette with the colours 224-239 but
even sprites the 16th palette with the colours 240-255.
@ENDNODE


@NODE Chapter-3-2-4-2 "3 Peculiarities of the Chip Sets / Advanced Graphics Architecture (AGA) / Blitter / New register BLTCON0L"
@{B}3-2-4-2 New register BLTCON0L@{UB}

With the ECS chipset a new blitter register was involved. It is called
@{"BLTCON0L" LINK BLTCON0} and offers the chance to speed up the initializing of registers
for blitter operations.

In a sequence of several blits, the shift value and the enabled DMA channels
of @{"BLTCON0" LINK BLTCON0} often stay the same, but the minterm changes. Writing only to
the lower byte of BLTCON0 may speed up your routine.

This advantage could be used in conjunction with blitter operations used for
shade BOBs where only the minterm changes blit by blit between the values

$80 = ABC (Copy-blit)

and

$6A = NANBC+NABC+ANBC+ABNC (Carry-blit)
@ENDNODE


@NODE Chapter-4 "Coder Aid: 4 Optimizing & tricks"
@{B}4 Optimizing & tricks@{UB}

  4-1  @{" MC68000 " LINK Chapter-4-1}
  4-2  @{" MC68020 " LINK Chapter-4-2}
  4-3  @{" MC68060 " LINK Chapter-4-3}
  4-4  @{" MC680x0 family " LINK Chapter-4-4}
  4-5  @{" Complex Interface Adapter (CIA) " LINK Chapter-4-5}
  4-6  @{" Original Chip Set (OCS) " LINK Chapter-4-6}
  4-7  @{" Advanced Graphics Architecture (AGA) " LINK Chapter-4-7}
  4-8  @{" All Chip Sets " LINK Chapter-4-8}
  4-9  @{" Protracker " LINK Chapter-4-9}
  4-10 @{" ASM-One " LINK Chapter-4-10}
@ENDNODE


@NODE Chapter-4-1 "4 Optimizing & tricks / MC68000"
@{B}4-1 MC68000@{UB}

    4-1-1 @{" MOVE versus MOVEM command " LINK Chapter-4-1-1}
    4-1-2 @{" Cycles of MOVEM command " LINK Chapter-4-1-2}
    4-1-3 @{" Unsigned word multiplications " LINK Chapter-4-1-3}
    4-1-4 @{" Signed word multiplications " LINK Chapter-4-1-4}
    4-1-5 @{" Longword multiplications " LINK Chapter-4-1-5}
    4-1-6 @{" Peephole optimizing " LINK Chapter-4-1-6}
    4-1-7 @{" XY-offsets in bitplanes " LINK Chapter-4-1-7}
    4-1-8 @{" Y-positions in bitplanes " LINK Chapter-4-1-8}
    4-1-9 @{" Clearing bitplanes " LINK Chapter-4-1-9}
@ENDNODE


@NODE Chapter-4-1-1 "4 Optimizing & tricks / MC68000 / MOVE versus MOVEM command"
@{B}4-1-1 MOVE versus MOVEM command@{UB}

Here's a little overview of the cycles of MOVEM versus the MOVE command
on the MC68000. The timing is taken from MOTOROLA's Documentary for the
MC68000.

      4-1-1-1 @{" Reading from memory " LINK Chapter-4-1-1-1}
      4-1-1-2 @{" Writing to memory " LINK Chapter-4-1-1-2}
      4-1-1-3 @{" Unsigned extensions word to longword " LINK Chapter-4-1-1-3}
      4-1-1-4 @{" Signed extensions word to longword " LINK Chapter-4-1-1-4}
@ENDNODE


@NODE Chapter-4-1-1-1 "4 Optimizing & tricks / MC68000 / MOVE versus MOVEM command / Reading from memory"
@{B}4-1-1-1 Reading from memory@{UB}

Reading words:

 8 cy: MOVE.W (An)+,Rn1		vs. 20 cy: MOVEM.W (An)+,Rn1-Rn2
 8 cy: MOVE.W (An)+,Rn2
16 cy

12 cy: MOVE.W d16(An),Rn1	vs. 24 cy: MOVEM.W d16(An),Rn1-Rn2
12 cy: MOVE.W d16+2(An),Rn2
24 cy

14 cy: MOVE.W d8(An,Xn),Rn1	vs. 26 cy: MOVEM.W d8(An,Xn),Rn1-Rn2
14 cy: MOVE.W d8+2(An,Xn),Rn2
28 cy

Reading longwords:

12 cy: MOVE.L (An)+,Rn1		vs. 28 cy: MOVEM.L (An)+,Rn1-Rn2
12 cy: MOVE.L (An)+,Rn2
24 cy

16 cy: MOVE.L d16(An),Rn1	vs. 32 cy: MOVEM.L d16(An),Rn1-Rn2
16 cy: MOVE.L d16+4(An),Rn2
32 cy

18 cy: MOVE.L d8(An,Xn),Rn1	vs. 34 cy: MOVEM.L d8(An,Xn),Rn1-Rn2
18 cy: MOVE.L d8+4(An,Xn),Rn2
36 cy
@ENDNODE


@NODE Chapter-4-1-1-2 "4 Optimizing & tricks / MC68000 / MOVE versus MOVEM command / Writing to memory"
@{B}4-1-1-2 Writing to memory@{UB}

Writing words:

 8 cy: MOVE.W Rn1,(An)		vs. 16 cy: MOVEM.W Rn1-Rn2,(An)
12 cy: MOVE.W Rn2,2(An)
20 cy

 8 cy: MOVE.W Rn1,(An)		vs. 20 cy: MOVEM.W Rn1-Rn3,(An)
12 cy: MOVE.W Rn2,2(An)
12 cy: MOVE.W Rn3,4(An)
32 cy

12 cy: MOVE.W Rn1,d16(An)	vs. 20 cy: MOVEM.W Rn1-Rn2,d16(An)
12 cy: MOVE.W Rn2,d16+2(An)
24 cy			

12 cy: MOVE.W Rn1,d16(An)	vs. 24 cy: MOVEM.W Rn1-Rn3,d16(An)
12 cy: MOVE.W Rn2,d16+2(An)
12 cy: MOVE.W Rn3,d16+4(An)
36 cy			

Writing longwords:

12 cy: MOVE.L Rn1,(An)		vs. 24 cy: MOVEM.L Rn1-Rn2,(An)
16 cy: MOVE.L Rn2,4(An)
28 cy

12 cy: MOVE.L Rn1,(An)		vs. 32 cy: MOVEM.L Rn1-Rn3,(An)
16 cy: MOVE.L Rn2,4(An)
16 cy: MOVE.L Rn3,8(An)
44 cy

16 cy: MOVE.L Rn1,d16(An)	vs. 28 cy: MOVEM.L Rn1-Rn2,d16(An)
16 cy: MOVE.L Rn2,d16+4(An)
32 cy			

16 cy: MOVE.L Rn1,d16(An)	vs. 36 cy: MOVEM.L Rn1-Rn3,d16(An)
16 cy: MOVE.L Rn2,d16+4(An)
16 cy: MOVE.L Rn3,d16+8(An)
48 cy
@ENDNODE


@NODE Chapter-4-1-1-3 "4 Optimizing & tricks / MC68000 / MOVE versus MOVEM command / Unsigned extensions word to longword"
@{B}4-1-1-3 Unsigned extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value. The restriction for an unsigned value
is 0<=value<=32767:

 4 cy: MOVEQ  #0,Dn1		vs. 20 cy: MOVEM.W (An)+,Dn1-Dn2
 8 cy: MOVE.W (An)+,Dn1
 4 cy: MOVEQ  #0,Dn2
 8 cy: MOVE.W (An)+,Dn2
24 cy
@ENDNODE


@NODE Chapter-4-1-1-4 "4 Optimizing & tricks / MC68000 / MOVE versus MOVEM command / Signed extensions word to longword"
@{B}4-1-1-4 Signed extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value:

 8 cy: MOVE.W (An)+,Dn1		vs. 20 cy: MOVEM.W (An)+,Dn1-Dn2
 4 cy: EXT.L  Dn1
 8 cy: MOVE.W (An)+,Dn2
 4 cy: EXT.L  Dn2
24 cy
@ENDNODE


@NODE Chapter-4-1-2 "4 Optimizing & tricks / MC68000 / Cycles of MOVEM command"
@{B}4-1-2 Cycles of MOVEM command@{UB}

      4-1-2-1 @{" Reading from memory " LINK Chapter-4-1-2-1}
      4-1-2-2 @{" Writing to memory " LINK Chapter-4-1-2-2}
@ENDNODE


@NODE Chapter-4-1-2-1 "4 Optimizing & tricks / MC68000 / Cycles of MOVEM command / Reading from memory"
@{B}4-1-2-1 Reading from memory@{UB}

Reading words:

  MOVEM.W (An),Rn1-Rn2		20 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W (An)+,Rn1-Rn2		20 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W d16(An),Rn1-Rn2	24 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W d8(An,Xn),Rn1-Rn2	26 cy for two registers, every further
				   register needs four extra cycles

Reading longwords:

  MOVEM.L (An),Rn1-Rn2		28 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.L (An)+,Rn1-Rn2		28 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.L d16(An),Rn1-Rn2	32 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.L d8(An,Xn),Rn1-Rn2	34 cy for two registers, every further
				   register needs four extra cycles
@ENDNODE


@NODE Chapter-4-1-2-2 "4 Optimizing & tricks / MC68000 / Cycles of MOVEM command / Writing to memory"
@{B}4-1-2-2 Writing to memory@{UB}

Writing words:

  MOVEM.W Rn1-Rn2,(An)		16 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W Rn1-Rn2,-(An)		16 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W Rn1-Rn2,d16(An)	20 cy for two registers, every further
				   register needs four extra cycles

  MOVEM.W Rn1-Rn2,d8(An,Xn)	22 cy for two registers, every further
				   register needs four extra cycles

Writing longwords:

  MOVEM.L Rn1-Rn2,(An)		24 cy for two registers, every further
				   register needs eight extra cycles

  MOVEM.L Rn1-Rn2,-(An)		24 cy for two registers, every further
				   register needs eight extra cycles

  MOVEM.L Rn1-Rn2,d16(An)	28 cy for two registers, every further
				   register needs eight extra cycles

  MOVEM.L Rn1-Rn2,d8(An,Xn)	30 cy for two registers, every further
				   register needs eight extra cycles
@ENDNODE


@NODE Chapter-4-1-3 "4 Optimizing & tricks / MC68000 / Unsigned word multiplications"
@{B}4-1-3 Unsigned word multiplications@{UB}

You save up to 28 cycles if you code multiplications with factoring out
this way:

n*6 = (n*4)+(n*2)		n*6 = ((n*2)+(n*1))*2

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
 4 cy: ADD.W   D0,D0 		    4 cy: ADD.W   D0,D0
 4 cy: ADD.W   D0,D0		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D1		    4 cy: ADD.W   D0,D0
 4 cy: ADD.W   D1,D0		   16 cy
20 cy

In this case, the data register D1 could be replaced with an address
register, if you are out of data registers, so we could generally say:

 4 cy: MOVE.W  Dn,Rn
 4 cy: ADD.W   Dn,Dn
 4 cy: ADD.W   Rn,Dn
 4 cy: ADD.W   Dn,Dn
16 cy


n*12 = (n*8)+(n*4)		n*12 = ((n*2)+(n*1))*4

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
12 cy: LSL.W   #3,D0 		    4 cy: ADD.W   D0,D0
 4 cy: ADD.W   D1,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D1		    4 cy: ADD.W   D0,D0
 4 cy: ADD.W   D1,D0	            4 cy: ADD.W   D0,D0
28 cy                              20 cy


n*24 = (n*16)+(n*8)		n*24 = ((n*2)+(n*1))*8

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
14 cy: LSL.W   #4,D0 		    4 cy: ADD.W   D0,D0
12 cy: LSL.W   #3,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   12 cy: LSL.W   #3,D0
34 cy            		   24 cy


n*24 = (n*32)+(n*16)		n*48 = ((n*2)+(n*1))*16

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
16 cy: LSL.W   #5,D0 		    4 cy: ADD.W   D0,D0
14 cy: LSL.W   #4,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   14 cy: LSL.W   #4,D0
38 cy            		   18 cy


n*96 = (n*64)+(n*32)		n*96 = ((n*2)+(n*1))*32

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
18 cy: LSL.W   #6,D0 		    4 cy: ADD.W   D0,D0
16 cy: LSL.W   #5,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   16 cy: LSL.W   #5,D0
42 cy            		   20 cy


n*192 = (n*64)+(n*32)		n*192 = ((n*2)+(n*1))*64

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
20 cy: LSL.W   #7,D0 		    4 cy: ADD.W   D0,D0
18 cy: LSL.W   #6,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   18 cy: LSL.W   #6,D0
46 cy            		   22 cy


n*384 = (n*128)+(n*64)		n*384 = ((n*2)+(n*1))*128

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
22 cy: LSL.W   #8,D0 		    4 cy: ADD.W   D0,D0
20 cy: LSL.W   #7,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   20 cy: LSL.W   #7,D0
50 cy            		   24 cy


n*768 = (n*256)+(n*128)		n*768 = ((n*2)+(n*1))*256

 4 cy: MOVE.W  D0,D1		vs. 4 cy: MOVE.W  D0,D1
22 cy: LSL.W   #8,D0 		    4 cy: ADD.W   D0,D0
20 cy: LSL.W   #7,D1		    4 cy: ADD.W   D1,D0
 4 cy: ADD.W   D1,D0		   20 cy: LSL.W   #8,D0
 4 cy: ADD.W   D0,D0        	   26 cy
54 cy

With this method you can do nearly every multiplication.
@ENDNODE


@NODE Chapter-4-1-4 "4 Optimizing & tricks / MC68000 / Signed word multiplications"
@{B}4-1-4 Signed word multiplications@{UB}

The same as mentioned in @{"Unsigned word multiplications" LINK Chapter-4-1-3} also works for
signed word multiplications:

n*3 = (n*2)+(n*1)

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
24 cy


n*6 = ((n*2)+(n*1))*2

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
 8 cy: ADD.L   D0,D0
32 cy


n*12 = ((n*2)+(n*1))*4

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
12 cy: LSL.L   #2,D0
36 cy


n*24 = ((n*2)+(n*1))*8

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
14 cy: LSL.L   #3,D0
38 cy


n*48 = ((n*2)+(n*1))*16

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
16 cy: LSL.L   #4,D0
40 cy


n*96 = ((n*2)+(n*1))*32

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
18 cy: LSL.L   #5,D0
42 cy


n*192 = ((n*1)+(n*2))*64

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
20 cy: LSL.L   #6,D0
44 cy


n*384 = ((n*1)+(n*2))*128

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
22 cy: LSL.L   #7,D0
46 cy


n*768 = ((n*1)+(n*2))*256

 4 cy: EXT.L   D0
 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
24 cy: LSL.L   #8,D0
48 cy
@ENDNODE


@NODE Chapter-4-1-5 "4 Optimizing & tricks / MC68000 / Longword multiplications"
@{B}4-1-5 Longword multiplications@{UB}

The same as mentioned in @{"Signed word multiplications" LINK Chapter-4-1-4} works for longword
multiplications:

n*3 = (n*1)+(n*2)

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
20 cy


n*6 = ((n*1)+(n*2))*2

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
 8 cy: ADD.L   D0,D0
28 cy


n*12 = ((n*1)+(n*2))*4

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
12 cy: LSL.L   #2,D0
32 cy


n*24 = ((n*2)+(n*1))*8

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
14 cy: LSL.L   #3,D0
34 cy


n*48 = ((n*2)+(n*1))*16

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
16 cy: LSL.L   #4,D0
36 cy


n*96 = ((n*2)+(n*1))*32

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D0,D0
 8 cy: ADD.L   D1,D0
18 cy: LSL.L   #5,D0
38 cy


n*192 = ((n*1)+(n*2))*64

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
20 cy: LSL.L   #6,D0
40 cy


n*384 = ((n*1)+(n*2))*128

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
22 cy: LSL.L   #7,D0
42 cy


n*768 = ((n*1)+(n*2))*256

 4 cy: MOVE.L  D0,D1
 8 cy: ADD.L   D1,D1
 8 cy: ADD.L   D1,D0
24 cy: LSL.L   #8,D0
44 cy
@ENDNODE


@NODE Chapter-4-1-6 "4 Optimizing & tricks / MC68000 / Peephole optimizing"
@{B}4-1-6 Peephole optimizing@{UB}

      4-1-6-1 @{" Bit commands " LINK Chapter-4-1-6-1}
      4-1-6-2 @{" Initializing of values " LINK Chapter-4-1-6-2}
      4-1-6-3 @{" Masking of values " LINK Chapter-4-1-6-3}
      4-1-6-4 @{" Splitting commands " LINK Chapter-4-1-6-4}
      4-1-6-5 @{" Memory access " LINK Chapter-4-1-6-5}
@ENDNODE


@NODE Chapter-4-1-6-1 "4 Optimizing & tricks / MC68000 / Peephole optimizing / Bit commands"
@{B}4-1-6-1 Bit commands@{UB}

The testing if bit 7,15 or 31 of a data register is set, can be optimized
by the fact, that it's the signed bit of a byte, word or longword:

10 cy: BTST #7,Dn		vs. 4 cy: TST.B Dn
10 cy: BNE     		           10 cy: BMI
20 cy				   14 cy

10 cy: BTST #15,Dn		vs. 4 cy: TST.W Dn
10 cy: BNE     		           10 cy: BMI
20 cy				   14 cy

10 cy: BTST #31,Dn		vs. 4 cy: TST.L Dn
10 cy: BNE     		           10 cy: BMI
20 cy				   14 cy


And if the content of the register can be changed, we check for bit 5,6,14
or 30 by a logical shift to the left:

10 cy: BTST #5,Dn		vs. 4 cy: ADD.B Dn,Dn
10 cy: BNE			    4 cy: ADD.B Dn,Dn
20 cy				   10 cy: BMI
				   18 cy

10 cy: BTST #6,Dn		vs. 4 cy: ADD.B Dn,Dn
10 cy: BNE			   10 cy: BMI
20 cy				   14 cy

10 cy: BTST #13,Dn		vs. 4 cy: ADD.W Dn,Dn
10 cy: BNE			    4 cy: ADD.W Dn,Dn
20 cy				   10 cy: BMI
				   18 cy

10 cy: BTST #14,Dn		vs. 4 cy: ADD.W Dn,Dn
10 cy: BNE    		  	   10 cy: BMI
20 cy				   14 cy

10 cy: BTST #30,Dn		vs. 8 cy: ADD.L Dn,Dn
10 cy: BNE    		  	   10 cy: BMI
20 cy				   18 cy


Bit 0 is an exception, which is shifted to the right and uses the fact,
that the carry bit is set after this operation:

10 cy: BTST #0,Dn		vs. 8 cy: LSR.B/W #1,Dn
10 cy: BNE			   10 cy: BCS
20 cy				   18 cy


In general, we can replace a bit-command with a AND/OR command, if the
content of a register can be changed:

10 cy: BTST #n,Dn		vs. 8 cy: AND.B/W #2^n,Dn
10 cy: B...			   10 cy: B...
20 cy				   18 cy

10 cy: BSET #n,Dn		vs. 8 cy: OR.B/W  #2^n,Dn

10 cy: BCLR #n,Dn		vs. 8 cy: AND.B/W #2^n,Dn


If only bits 0-3 will be changed by BSET, we can replace it with ADDQ
if the bit we want to set is definitely zero:

Whereas 0=<n<=3

10 cy: BSET #n,Dn    		vs. 4 cy: ADDQ.B #2^n,Dn

The same technique works with BCLR replaced with SUBQW if the bit is
definitely set:

10 cy: BCLR #n,Dn    		vs. 4 cy: SUBQ.B #2^n,Dn


If only bit #7 should be set:

10 cy: BSET #7,Dn		vs. 4 cy: TAS Dn
@ENDNODE


@NODE Chapter-4-1-6-2 "4 Optimizing & tricks / MC68000 / Peephole optimizing / Initializing of values"
@{B}4-1-6-2 Initializing of values@{UB}

When initializing word values in data registers, the quick version of
commands should be preferred:

 8 cy: MOVE.W #$FF00,dn  	vs. 4 cy: MOVEQ #-1,dn
				    4 cy: CLR.B dn
				    8 cy


Initializing longword values in data registers, whereas $01=<nn<=$7F:

12 cy: MOVE.L #$00nn0000,dn	vs. 4 cy: MOVEQ #$nn,dn
				    4 cy: SWAP  Dn
				    8 cy


Initializing cleared memory with values, whereas 1=<n<=8:

4 bytes: MOVE.W #-n,(An)+	vs. 2 bytes: SUBQ.W #n,(An)+

4 bytes: MOVE.W #n,(An)+	vs. 2 bytes: ADDQ.W #n,(An)+


Initializing a data register regardless of its old content with 0=<n<=$7F:

8 cy: MOVE.B #n,Dn		vs. 4 cy: MOVEQ #n,Dn
@ENDNODE


@NODE Chapter-4-1-6-3 "4 Optimizing & tricks / MC68000 / Peephole optimizing / Masking of values"
@{B}4-1-6-3 Masking of values@{UB}

Clearing / masking out BYTELOW in a 16-Bit register:

8 cy: AND.W #$FF00,Dn		vs. 4 cy: CLR.B Dn


Clearing / masking out BYTELOW in a 32-Bit register:

14 cy: AND.L #$FFFFFF00,Dn	vs. 4 cy: CLR.B Dn


Clearing / masking out WORDLOW in a 32-Bit register:

14 cy: AND.L #$FFFF0000,Dn	vs. 4 cy: CLR.W Dn


Masking out BYTELOW and extending it to an unsigned value in a 16/32-Bit
register:

for unsigned values $01=<n<=$7F:

 8 cy: AND.W #$00FF,Dn		vs. 4 cy: EXT.W  Dn

14 cy: AND.L #$000000FF,Dn	vs. 4 cy: EXT.W  Dn
				    4 cy: EXT.L  Dn
				    8 cy

or for signed values $80=<n<=$ff:

 8 cy: AND.W #$00FF,Dn		vs. 4 cy: MOVEQ  #0,Dn2
				    4 cy: MOVE.B Dn,Dn2
				    8 cy

14 cy: AND.L #$000000FF,Dn	vs. 4 cy: MOVEQ  #0,Dn2
				    4 cy: MOVE.B Dn,Dn2
				    8 cy


Masking out WORDLOW and extending it to an unsigned value in a 32-Bit
register:

for unsigned values $0001=<n<=$7FFF:

14 cy: AND.L #$0000FFFF,Dn  	vs. 4 cy: EXT.L  Dn

or for signed values $8000=<n<=$FFFF:

14 cy: AND.L #$0000FFFF,Dn  	vs. 4 cy: MOVEQ  #0,Dn2
				    4 cy: MOVE.W Dn,Dn2
				    8 cy

Masking out the lower nibble:

12 cy: MOVE.W d16(An),Dn	vs. 4 cy: MOVEQ #$F,Dn
 8 cy: AND.W  #$F,Dn		   12 cy: AND.W d16(An),Dn
20 cy				   16 cy

Masking out the upper nibble:

12 cy: MOVE.B d16(An),Dn	vs. 4 cy: MOVEQ #-16,Dn
 8 cy: AND.B  #$F0,Dn		   12 cy: AND.B d16(An),Dn
20 cy				   16 cy


Under certain circumstances when shifting bits, an AND command can be
omitted or replaced by MOVE commands:

 8 cy: AND.B   #$0F,D0		vs. 14 cy: LSL.B   #4,D1
14 cy: LSL.B   #4,D0
22 cy

 8 cy: AND.B   #$F0,D0		vs. 14 cy: LSR.B   #4,D1
14 cy: LSR.B   #4,D0
22 cy		

 8 cy: AND.W   #$000F,D0	vs.  4 cy: MOVEQ   #0,D1
14 cy: LSL.B   #4,D0		     4 cy: MOVE.B  D0,D1
22 cy				    14 cy: LSL.B   #4,D1
				    22 cy

 8 cy: AND.W   #$00F0,D0	vs. 14 cy: LSR.B   #4,D0
14 cy: LSR.B   #4,D0		     4 cy: EXT.W   D0
22 cy				    18 cy

 8 cy: AND.W   #$00FF,Dn	vs. 22 cy: LSL.W   #8,Dn
22 cy: LSL.W   #8,Dn
30 cy

 8 cy: AND.W   #$FF00,Dn	vs. 22 cy: LSR.W   #8,Dn
22 cy: LSR.W   #8,Dn
30 cy
@ENDNODE


@NODE Chapter-4-1-6-4 "4 Optimizing & tricks / MC68000 / Peephole optimizing / Splitting commands"
@{B}4-1-6-4 Splitting commands@{UB}

Splitting one command into the quick version of commands:

9=<n<=16

 8 cy: ADD.W   #n,Dn		vs. 4 cy: ADDQ.W   #8,Dn
                                    4 cy: ADDQ.W   #n-8,Dn
				    8 cy

 8 cy: SUB.W   #n,Dn		vs. 4 cy: SUBQ.W   #8,Dn
                                    4 cy: SUBQ.W   #n-8,Dn
				    8 cy

whereas 0=<n<=$7F

16 cy: MOVE.B #n,d16(An)	vs.  4 cy: MOVEQ  #n,Dn
				    12 cy: MOVE.B Dn,d16(An)
				    16 cy
@ENDNODE


@NODE Chapter-4-1-6-5 "4 Optimizing & tricks / MC68000 / Peephole optimizing / Memory access"
@{B}4-1-6-5 Memory access@{UB}

Using the MOVEM command or summarizing two word memory accesses to a
longword access:

32 cy: MOVE.L d16(An1),d16(An2)	  vs. 18 cy: MOVE.L  d16(An1),An3
32 cy: MOVE.L d16(An1),d16+4(An2)      4 cy: MOVE.L  An3,An4
64 cy				      28 cy: MOVEM.L An3-An4,d16(An2)
				      50 cy

				  vs. 18 cy: MOVE.L  d16(An1),An3
				      16 cy: MOVE.L  A3,d16(a2)
				      16 cy: MOVE.L  A3,d16+4(a2)
				      50 cy

16 cy: CLR.W d16(An)		vs.  4 cy: MOVEQ  #0,Dn
16 cy: CLR.W d16+2(An)		    16 cy: MOVE.L Dn,d16(An)
24 cy: CLR.L d16+4(An)              16 cy: MOVE.L Dn,d16+4(An)
56 cy				    36 cy


 8 cy: MOVE.W (An)+,Dn1	    	vs. 12 cy: MOVE.L (An)+,Dn
 4 cy: ADD.W  Dn1,Dn1          	     8 cy: ADD.L  Dn,Dn	;Bits0-15=Dn1.W
 8 cy: MOVE.W (An)+,Dn2	 	     other operations...
 4 cy: ADD.W  Dn2,Dn2	 	     4 cy: SWAP   Dn	;Bits0-15=Dn2.W
24 cy				    24 cy
@ENDNODE


@NODE Chapter-4-1-7 "4 Optimizing & tricks / MC68000 / XY-offsets in bitplanes"
@{B}4-1-7 XY-offsets in bitplanes@{UB}

Let's have a look at the following code calculating the x and y position in
a bitplane for a blitter operation:

;D0=xpos
;D1=ypos
;plane.width=40
;depth=3

 4 cy: MOVEQ   #$F,D2
 4 cy: AND.W   D0,D2            ;Mask out the shift-bits
12 cy: LSR.W   #3,D0		;Calculate byte-x-offset
14 cy: ROR.W   #4,D2		;Put the shift bits into bit-position 15-12
 4 cy: MOVE.W  D1,D3		;Save ypos
14 cy: LSL.W   #4,D1		;(y*16-y)*8 = (Y*128)-(y*8) = y*120 =
 4 cy: SUB.W   D3,D1		;y*plane.width*depth
12 cy: LSL.W   #3,D1
 4 cy: ADD.W   D0,D1		;xy-offset
72 cy

Very smart coders do the following:

 4 cy: MOVE.W  D1,D2		;Save ypos
14 cy: LSL.W   #4,D1		;(y*16-y)*8 = y*plane.width*depth
 4 cy: EXT.L   D0		;Clear upper word
 4 cy: SUB.W   D2,D1		;y*plane.width*depth
16 cy: ROR.L   #4,D0		;Put the shift bits into bit-position 31-28
12 cy: LSL.W   #3,D1
 4 cy: ADD.W   D0,D0		;Calculate byte-x-offset
 4 cy: ADD.W   D0,D1		;XY-offset
 4 cy: SWAP    D0		;Get shift-bits to bit-position 15-12
66 cy

Well, not bad so far. But we can speed up this routine a little bit more:

 4 cy: MOVE.W  D1,D2		;Save ypos
14 cy: LSL.W   #4,D1		;(y*16-y)*4 = y*plane.width*(depth/2)
 4 cy: EXT.L   D0		;Clear upper word
 4 cy: SUB.W   D2,D1
16 cy: ROR.L   #4,D0		;Put the shift bits into bit-position 31-28
 4 cy: ADD.W   D1,D1
 4 cy: ADD.W   D1,D1
 4 cy: ADD.W   D0,D1		;XY-offset/2
 4 cy: SWAP    D0		;Get shift-bits to bit-position 15-12
 4 cy: ADD.W   D1,D1		;XY-offset
62 cy
@ENDNODE


@NODE Chapter-4-1-8 "4 Optimizing & tricks / MC68000 / Y-positions in bitplanes"
@{B}4-1-8 Y-positions in bitplanes@{UB}

Let's take a 320x256 pixels display with a depth of 1 bitplane for
example. To get the y-position you may calculate y*(320/8) -> Y*40.
The easiest way in assembler is the command

74 cy: MULU.W #40,Dn

which takes many cycles.

A better way is:

 4 cy: MOVE.W  Dn1,Dn2
16 cy: LSL.W   #5,Dn1		;(y*32)+(y*8)
12 cy: LSL.W   #3,Dn2
 4 cy: ADD.W   Dn2,Dn1
36 cy

Or much better:

 4 cy: MOVE.W  Dn1,Dn2
 4 cy: ADD.W   Dn1,Dn1      	;(y*4+y*1)*8
 4 cy: ADD.W   Dn1,Dn1
 4 cy: ADD.W   Dn2,Dn1
12 cy: LSL.W   #3,Dn1
28 cy

It seems we reached the top of optimizing. But there is another trick. Let's
expand the width of the playfield to 512 pixels. Now we calculate the y-
position this way: y*(512/8) -> y*64

Or in assembler:

12 cy: LSL.W   #6,Dn

That's it. A single LSL-command to calculate the y-position. For the depth
of 2 or 4 bitplanes we shift 7 or 8 bits to the left.
@ENDNODE


@NODE Chapter-4-1-9 "4 Optimizing & tricks / MC68000 / Clearing bitplanes"
@{B}4-1-9 Clearing bitplanes@{UB}

The CPU can clear bitplanes with the MOVEM.L command very fast. Let's
expect that we have a bitplane of 40x256 bytes. On the MC68000 this
could look like this:

  CNOP 0,4			;Longword alignment for MC68020+
clear_pic
  MOVE.L  A7,save_A7
  MOVEQ   #0,D0
  MOVE.L  bitplane_adr(PC),A7
  MOVEQ   #0,D1
  LEA     end_of_bitplane(A7),A7
  MOVEQ   #0,D2
  MOVEQ   #0,D3
  MOVEQ   #0,D4
  MOVEQ   #0,D5
  MOVEQ   #0,D6
  MOVEQ   #0,D7
  MOVE.L  D0,A1
  MOVE.L  D0,A2
  MOVE.L  D0,A3
  MOVE.L  D0,A4
  MOVE.L  D0,A5
  MOVE.L  D0,A6
  REPT 170
  MOVEM.L D0-D7/A0-A6,-(A7)	;Clear 60 bytes
  ENDR
  MOVEM.L D0-D7/A0-A1,-(A7)	;Clear the remaining 40 bytes
  MOVE.L  save_A7(PC),A7
  RTS

  CNOP 0,4
save_A7 DC.L 0
@ENDNODE


@NODE Chapter-4-2 "4 Optimizing & tricks / MC68020"
@{B}4-2 MC68020@{UB}

    4-2-1  @{" MOVE versus MOVEM command " LINK Chapter-4-2-1}
    4-2-2  @{" Cycles of MOVEM command in cache case mode " LINK Chapter-4-2-2}
    4-2-3  @{" Avoiding wait-states " LINK Chapter-4-2-3}
    4-2-4  @{" Peephole optimizing " LINK Chapter-4-2-4}
    4-2-5  @{" Address registers multiplications " LINK Chapter-4-2-5}
    4-2-6  @{" Reading tables " LINK Chapter-4-2-6}
    4-2-7  @{" Rotator/Zoomer optimizing " LINK Chapter-4-2-7}
    4-2-8  @{" Clearing bitplanes " LINK Chapter-4-2-8}
    4-2-9  @{" Radius-calculations with sine tables " LINK Chapter-4-2-9}
@ENDNODE


@NODE Chapter-4-2-1 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command"
@{B}4-2-1 MOVE versus MOVEM command@{UB}

Here's a little overview of the cycles of MOVEM versus the MOVE command
on the MC68020. The timing is taken from MOTOROLAS's Documentary for the
MC68020.

      4-2-1-1 @{" Reading from memory " LINK Chapter-4-2-1-1}
      4-2-1-2 @{" Writing to memory " LINK Chapter-4-2-1-2}
      4-2-1-3 @{" Unsigned extensions word to longword " LINK Chapter-4-2-1-3}
      4-2-1-4 @{" Signed extensions word to longword " LINK Chapter-4-2-1-4}
      4-2-1-5 @{" Signed and unsigned extensions word to longword " LINK Chapter-4-2-1-5}
@ENDNODE


@NODE Chapter-4-2-1-1 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command / Reading from memory"
@{B}4-2-1-1 Reading from memory@{UB}

All cycles are for cache case.

Reading words:

 6 cy: MOVE.W (An)+,Rn1		vs. 20 cy: MOVEM.W (An)+,Rn1-Rn2
 6 cy: MOVE.W (An)+,Rn2
12 cy

 7 cy: MOVE.W d16(An),Rn1	vs. 20 cy: MOVEM.W d16(An),Rn1-Rn2
 7 cy: MOVE.W d16+2(An),Rn2
14 cy

 9 cy: MOVE.W d8(An,Xn),Rn1	vs. 22 cy: MOVEM.W d8(An,Xn),Rn1-Rn2
 9 cy: MOVE.W d8+2(An,Xn),Rn2
18 cy


Reading longwords:

 6 cy: MOVE.L (An)+,Rn1		vs. 22 cy: MOVEM.L (An)+,Rn1-Rn2
 6 cy: MOVE.L (An)+,Rn2
12 cy

 7 cy: MOVE.L d16(An),Rn1	vs. 22 cy: MOVEM.L d16(An),Rn1-Rn2
 7 cy: MOVE.L d16+4(An),Rn2
14 cy

 9 cy: MOVE.L d8(An,Xn),Rn1	vs. 24 cy: MOVEM.L d8(An,Xn),Rn1-Rn2
 9 cy: MOVE.L d8+4(An,Xn),Rn2
18 cy
@ENDNODE


@NODE Chapter-4-2-1-2 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command / Writing to memory"
@{B}4-2-1-2 Writing to memory@{UB}

All cycles are for cache case.

Writing words:

 5 cy: MOVE.W Rn1,d16(An)	vs. 14 cy: MOVEM.W Rn1-Rn2,d16(An)
 5 cy: MOVE.W Rn2,d16+2(An)
10 cy			

 5 cy: MOVE.W Rn1,d16(An)	vs. 17 cy: MOVEM.W Rn1-Rn3,d16(An)
 5 cy: MOVE.W Rn2,d16+2(An)
 5 cy: MOVE.W Rn3,d16+4(An)
15 cy			


Writing longwords:

 5 cy: MOVE.L Rn1,d16(An)	vs. 16 cy: MOVEM.L Rn1-Rn2,d16(An)
 5 cy: MOVE.L Rn2,d16+4(An)
10 cy			

 5 cy: MOVE.L Rn1,d16(An)	vs. 19 cy: MOVEM.L Rn1-Rn3,d16(An)
 5 cy: MOVE.L Rn2,d16+4(An)
 5 cy: MOVE.L Rn3,d16+8(An)
15 cy			

 5 cy: MOVE.L Rn1,d16(An)	vs. 22 cy: MOVEM.L Rn1-Rn4,d16(An)
 5 cy: MOVE.L Rn2,d16+4(An)
 5 cy: MOVE.L Rn3,d16+8(An)
 5 cy: MOVE.L Rn4,d16+12(An)
20 cy			
@ENDNODE


@NODE Chapter-4-2-1-3 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command / Unsigned extensions word to longword"
@{B}4-2-1-3 Unsigned extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value. The restriction for an unsigned value
is 0<=value<=32767. All cycles are for cache case:

 2 cy: MOVEQ  #0,Dn1		vs. 20 cy: MOVEM.W (An)+,Dn1-Dn2
 6 cy: MOVE.W (An)+,Dn1
 2 cy: MOVEQ  #0,Dn2
 6 cy: MOVE.W (An)+,Dn2
16 cy			

 2 cy: MOVEQ  #0,Dn1		vs. 24 cy: MOVEM.W (An)+,Dn1-Dn3
 6 cy: MOVE.W (An)+,Dn1
 2 cy: MOVEQ  #0,Dn2
 6 cy: MOVE.W (An)+,Dn2
 2 cy: MOVEQ  #0,Dn3
 6 cy: MOVE.W (An)+,Dn3
24 cy		

 2 cy: MOVEQ  #0,Dn1		vs. 22 cy: MOVEM.W d8(An,Xn)+,Dn1-Dn2
 9 cy: MOVE.W d8(An,Xn),Dn1
 2 cy: MOVEQ  #0,Dn2
 9 cy: MOVE.W d8+2(An,Xn),Dn2
22 cy
@ENDNODE


@NODE Chapter-4-2-1-4 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command / Signed extensions word to longword"
@{B}4-2-1-4 Signed extensions word to longword@{UB}

When reading from memory unsigned values, the MOVEM command is slower than
several MOVE commands. But if we read signed values from memory and extend
them to 32 bits, then the MOVEM command is faster or equal. All cycles are
for cache case:

 6 cy: MOVE.W (An)+,Dn1		vs. 20 cy: MOVEM.W (An)+,Dn1-Dn2
 4 cy: EXT.L  Dn1
 6 cy: MOVE.W (An)+,Dn2
 4 cy: EXT.L  Dn2
20 cy

 6 cy: MOVE.W (An)+,Dn1		vs. 24 cy: MOVEM.W (An)+,Dn1-Dn3
 4 cy: EXT.L  Dn1
 6 cy: MOVE.W (An)+,Dn2
 4 cy: EXT.L  Dn2
 6 cy: MOVE.W (An)+,Dn3
 4 cy: EXT.L  Dn3
30 cy	

 9 cy: MOVE.W d8(An,Xn),Dn1	vs. 22 cy: MOVEM.W d8(An,Xn),Dn1-Dn2
 4 cy: EXT.L  Dn1
 9 cy: MOVE.W d8+2(An,Xn),Dn2
 4 cy: EXT.L  Dn2
26 cy
@ENDNODE


@NODE Chapter-4-2-1-5 "4 Optimizing & tricks / MC68020 / MOVE versus MOVEM command / Signed and unsigned extensions word to longword"
@{B}4-2-1-5 Signed and unsigned extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value.

 2 cy: MOVEQ  #0,Dn1		vs. 26 cy: MOVEM.W d8(An,Xn),Dn1-Dn3
 9 cy: MOVE.W d8(An,Xn),Dn1
 2 cy: MOVEQ  #0,Dn2
 9 cy: MOVE.W d8+2(An,Xn),Dn2
 9 cy: MOVE.W d8+4(An,Xn),Dn3
 4 cy: EXT.L  Dn3
35 cy
@ENDNODE


@NODE Chapter-4-2-2 "4 Optimizing & tricks / MC68020 / Cycles of MOVEM command in cache case mode"
@{B}4-2-2 Cycles of MOVEM command in cache case mode@{UB}

      4-2-2-1 @{" Reading from memory " LINK Chapter-4-2-2-1}
      4-2-2-2 @{" Writing to memory " LINK Chapter-4-2-2-2}
@ENDNODE


@NODE Chapter-4-2-2-1 "4 Optimizing & tricks / MC68020 / Cycles of MOVEM command in cache case mode / Reading from memory"
@{B}4-2-2-1 Reading from memory@{UB}

All cycles are for cache case.

Reading words:

  MOVEM.W (An),Rn1-Rn2		18 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.W (An)+,Rn1-Rn2		20 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.W d16(An),Rn1-Rn2	20 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.W d8(An,Xn),Rn1-Rn2	22 cy for two registers, every further
				      register needs 4 extra cycles

Reading longwords:

  MOVEM.W (An),Rn1-Rn2		20 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.L (An)+,Rn1-Rn2		22 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.L d16(An),Rn1-Rn2	22 cy for two registers, every further
				      register needs 4 extra cycles

  MOVEM.L d8(An,Xn),Rn1-Rn2	24 cy for two registers, every further
				      register needs 4 extra cycles
@ENDNODE


@NODE Chapter-4-2-2-2 "4 Optimizing & tricks / MC68020 / Cycles of MOVEM command in cache case mode / Writing to memory"
@{B}4-2-2-2 Writing to memory@{UB}

All cycles are for cache case.

Writing words:

  MOVEM.W Rn1-Rn2,(An)		12 cy for two registers, every further
 			      	      register needs 3 extra cycles

  MOVEM.W Rn1-Rn2,-(An)		14 cy for two registers, every further
 			      	      register needs 3 extra cycles

  MOVEM.W Rn1-Rn2,d16(An)	14 cy for two registers, every further
				      register needs 3 extra cycles

  MOVEM.W Rn1-Rn2,d8(An,Xn)	16 cy for two registers, every further
				      register needs 3 extra cycles

Writing longwords:

  MOVEM.L Rn1-Rn2,(An)		14 cy for two registers, every further
			      	      register needs 3 extra cycles

  MOVEM.L Rn1-Rn2,-(An)		16 cy for two registers, every further
			      	      register needs 3 extra cycles

  MOVEM.L Rn1-Rn2,d16(An)	16 cy for two registers, every further
				      register needs 3 extra cycles

  MOVEM.L Rn1-Rn2,d8(An,Xn)	18 cy for two registers, every further
				      register needs 3 extra cycles
@ENDNODE


@NODE Chapter-4-2-3 "4 Optimizing & tricks / MC68020 / Avoiding wait-states"
@{B}4-2-3 Avoiding wait-states@{UB}

      4-2-3-1 @{" Initializing variables in memory " LINK Chapter-4-2-3-1}
      4-2-3-2 @{" Clearing variables in memory " LINK Chapter-4-2-3-2}
@ENDNODE


@NODE Chapter-4-2-3-1 "4 Optimizing & tricks / MC68020 / Avoiding wait-states / Initializing variables in memory"
@{B}4-2-3-1 Initializing variables in memory@{UB}

The way of initializing variables as shown below is useful, if you have a
sequence of commands writing to memory to initialize several variables,
whereas 1=<n<=127:

3/ 7/ 7 cy: MOVE.W  #n,var1(An)	vs. 0/ 2/ 3 cy: MOVEQ   #n,Dn
3/ 7/ 7 cy: MOVE.W  #n,var2(An)     3/ 5/ 7 cy: MOVE.W  dx,var1(An)
6/14/14	cy			    0/ 2/ 3 cy: MOVEQ   #n,Dn
				    3/ 5/ 7 cy: MOVE.W  dx,var2(An)
				    6/14/20

Between the memory accesses there is always a simple write to a register
command. While writing to memory and perhaps waiting for a free cycles,
the CPU does something else instead.
@ENDNODE


@NODE Chapter-4-2-3-2 "4 Optimizing & tricks / MC68020 / Avoiding wait-states / Clearing variables in memory"
@{B}4-2-3-2 Clearing variables in memory@{UB}

If you avoid using the CLR command, variables can be initialized faster:

An=Base of your variables in memory

1=<x<=127

 5/ 6/ 9 cy: CLR.W d16(An)	vs. 0/ 2/ 3 cy: MOVEQ   #0,Dn
 5/ 6/ 9 cy: CLR.L d16+2(An)	    3/ 5/ 7 cy: MOVE.W  Dn,d16(An)
 5/ 6/ 9 cy: CLR.W d16+6(An)	    3/ 5/ 7 cy: MOVE.L  Dn,d16+2(An)
15/18/27 cy		            3/ 5/ 7 cy: MOVE.W  Dn,d16+6(An)
				    9/17/24 cy

				vs. 0/ 2/ 3 cy: MOVEQ   #0,Dn
                                    3/ 5/ 7 cy: MOVE.L  Dn,d16(An)
                                    3/ 5/ 7 cy: MOVE.L  Dn,d16+4(An)
				    6/12/17 cy
@ENDNODE


@NODE Chapter-4-2-4 "4 Optimizing & tricks / MC68020 / Peephole optimizing"
@{B}4-2-4 Peephole optimizing@{UB}

      4-2-4-1 @{" Adding values to address registers " LINK Chapter-4-2-4-1}
      4-2-4-2 @{" Initializing of values " LINK Chapter-4-2-4-2}
      4-2-4-3 @{" Masking of values " LINK Chapter-4-2-4-3}
      4-2-4-4 @{" Splitting commands " LINK Chapter-4-2-4-4}
@ENDNODE


@NODE Chapter-4-2-4-1 "4 Optimizing & tricks / MC68020 / Peephole optimizing / Adding values to address registers"
@{B}4-2-4-1 Adding values to address registers@{UB}

If possible, avoid the usage of the LEA command on the MC68020, because
there is no full instruction execution overlap possible and in most cases
the worst case execution is slower:

(best/cache/worst case cycles)

3/6/8 cy: LEA   (A0,D0.L),A1	vs. 0/2/3 cy: MOVE.L  A0,A1
				    0/2/3 cy: ADD.L   D0,A1
				    0/4/6 cy


Remember that 16 bit immediate values are always extended to signed 32 bit
values if written to an address register:

0=<n<=65535

4/4/6 cy: LEA   n.W,An		vs. 0/4/3 cy: MOVE.W  #n,An

1=<n<=8

4/4/6 cy: LEA   n(An),An	vs. 0/2/3 cy: ADDQ.W  #n,An

9=<n<=16

4/4/6 cy: LEA   n(An),An	vs. 0/2/3 cy: ADDQ.W  #8,An  @{"see also" LINK Chapter-4-2-4-4}
				    0/2/3 cy: ADDQ.W  #n-8,An
				    0/4/6
17=<n<=65535

4/4/6 cy: LEA   n(An),An	vs. 0/4/6 cy: ADD.W   #n,An


And for 32 bit immediate values:

3/6/8 cy: LEA   n.L,An		vs. 0/6/5 cy: MOVE.L  #n,An


The logic of signed extension also applies to word values read from memory
and written to address registers:

4/ 6/ 7 cy: MOVE.W  (A0)+,D0
3/ 6/ 8 cy: LEA     (A1,D0.W),A2
7/12/15 cy

can be optimized to

4/6/ 7 cy: MOVE.W  (A0)+,A2	;Automatic extension to 32 signed bits
0/2/ 3 cy: ADD.L   A1,A2
4/8/10 cy


Or using instruction overlap with 32 bit values:

4/ 6/ 7 cy: MOVE.L  (A0)+,D0
3/ 6/ 8 cy: LEA     (A1,D0.L),A2
7/12/15 cy

can be optimized to

4/6/ 7 cy: MOVE.L  (A0)+,A2	;If the value is > 32767
0/2/ 3 cy: ADD.L   A1,A2
4/8/10 cy
@ENDNODE


@NODE Chapter-4-2-4-2 "4 Optimizing & tricks / MC68020 / Peephole optimizing / Initializing of values"
@{B}4-2-4-2 Initializing of values@{UB}

(best/cache/worst case cycles)

0/6/5 cy: MOVE.L  #$80,Dn	vs. 0/2/3 cy: MOVEQ   #$7F,Dn
				    0/2/3 cy: NEG.B   Dn
				    0/4/6 cy

				vs. 0/2/3 cy: MOVEQ   #$40,Dn
				    0/2/3 cy: ADD.W   Dn,Dn
				    0/4/6 cy
@ENDNODE


@NODE Chapter-4-2-4-3 "4 Optimizing & tricks / MC68020 / Peephole optimizing / Masking of values"
@{B}4-2-4-3 Masking of values@{UB}

(best/cache/worst case cycles)

0/4/6 cy: AND.W   #$FF00,Dn	vs. 0/2/3 cy: CLR.B   Dn

1/6/8 cy: AND.L   #$FFFF0000,Dn vs. 0/2/3 cy: CLR.W   Dn

3/ 7/ 9 cy: MOVE.W d16(An),Dn	vs. 0/ 2/ 3 cy: MOVEQ #$F,Dn1
0/ 4/ 6 cy: AND.W  #$F,Dn	    3/ 7/10 cy: AND.W d16(An),Dn
3/11/15 cy			    3/10/13 cy

3/ 7/ 9 cy: MOVE.B d16(An),Dn	vs. 0/ 2/ 3 cy: MOVEQ #-16,Dn
0/ 4/ 6 cy: AND.B  #$F0,Dn	    3/ 7/10 cy: AND.B d16(An),Dn
3/11/15 cy			    3/10/13 cy

0/ 4/ 6 cy: AND.B   #$0F,Dn	vs. 3/6/6 cy: LSL.B   #4,Dn
3/ 6/ 6 cy: LSL.B   #4,Dn
3/10/12 cy

0/ 4/ 6 cy: AND.B   #$F0,Dn	vs. 3/6/6 cy: LSR.B   #4,Dn
3/ 6/ 6 cy: LSR.B   #4,Dn
3/10/12 cy

0/ 4/ 6 cy: AND.W   #$00FF,Dn	vs. 3/6/6 cy: LSL.W   #8,Dn
3/ 6/ 6 cy: LSL.W   #8,Dn
3/10/12 cy

0/ 4/ 6 cy: AND.W   #$FF00,Dn	vs. 3/6/6 cy: LSR.W   #8,Dn
3/ 6/ 6 cy: LSR.W   #8,Dn
3/10/12 cy

1/ 6/ 8 cy: AND.L  #$0000FFFF,Dn vs. 1/4/4 cy: SWAP    Dn
1/ 4/ 4 cy: SWAP   Dn		     0/2/3 cy: CLR.W   Dn
2/10/12 cy                           1/6/7 cy
                                                
1/ 6/ 8 cy: AND.L  #$FFFF0000,Dn vs. 0/2/3 cy: CLR.W   Dn
1/ 4/ 4 cy: SWAP   Dn		     1/4/4 cy: SWAP    Dn
2/10/12 cy                           1/6/7 cy


Only for values < $7F

0/4/6 cy: AND.W   #$00FF,Dn	vs. 1/4/4 cy: EXT.W   Dn

For values > $7F

0/4/6 cy: AND.W   #$00FF,Dn	vs. 0/2/3 cy: MOVEQ   #0,Dn2
				    0/2/3 cy: MOVE.B  Dn,Dn2
				    0/4/6 cy

Only for values < $7FFF

1/6/8 cy: AND.L   #$0000FFFF,Dn	vs. 1/4/4 cy: EXT.L   Dn

For values > $7FFF

0/4/6 cy: AND.L   #$0000FFFF,Dn	vs. 0/2/3 cy: MOVEQ   #0,Dn2
				    0/2/3 cy: MOVE.W  Dn,Dn2
				    0/4/6 cy
@ENDNODE


@NODE Chapter-4-2-4-4 "4 Optimizing & tricks / MC68020 / Peephole optimizing / Splitting commands"
@{B}4-2-4-4 Splitting commands@{UB}

Splitting one command into the quick version of commands:

(best/cache/worst case cycles)

9=<n<=16

4/4/6 cy: LEA     n(An),An	vs. 0/2/3 cy: ADDQ.W   #8,An
                                    0/2/3 cy: ADDQ.W   #n-8,An
				    0/4/6 cy

0/4/6 cy: ADD.W   #n,An		vs. 0/2/3 cy: ADDQ.W   #8,An
                                    0/2/3 cy: ADDQ.W   #n-8,An
				    0/4/6 cy

0/6/8 cy: ADD.L   #n,An		vs. 0/2/3 cy: ADDQ.W   #8,An
                                    0/2/3 cy: ADDQ.W   #n-8,An
				    0/4/6 cy


0/4/6 cy: ADD.W   #n,Dn		vs. 0/2/3 cy: ADDQ.W   #8,Dn
                                    0/2/3 cy: ADDQ.W   #n-8,Dn
				    0/4/6 cy

1/6/8 cy: ADD.L   #n,Dn		vs. 0/2/3 cy: ADDQ.L   #8,Dn
                                    0/2/3 cy: ADDQ.L   #n-8,Dn
				    0/4/6 cy


4/4/6 cy: LEA     -n(An),An	vs. 0/2/3 cy: SUBQ.W   #8,An
                                    0/2/3 cy: SUBQ.W   #n-8,An
                                    0/4/6 cy

0/4/6 cy: SUB.W   #n,An		vs. 0/2/3 cy: SUBQ.W   #8,An
                                    0/2/3 cy: SUBQ.W   #n-8,An
				    0/4/6 cy

0/6/8 cy: SUB.L   #n,An		vs. 0/2/3 cy: SUBQ.W   #8,An
                                    0/2/3 cy: SUBQ.W   #n-8,An
				    0/4/6 cy

0/4/6 cy: SUB.W   #n,Dn		vs. 0/2/3 cy: SUBQ.W   #8,Dn
                                    0/2/3 cy: SUBQ.W   #n-8,Dn
				    0/4/6 cy

1/6/8 cy: SUB.L   #n,Dn		vs. 0/2/3 cy: SUBQ.L   #8,Dn
                                    0/2/3 cy: SUBQ.L   #n-8,Dn
				    0/4/6 cy
@ENDNODE


@NODE Chapter-4-2-5 "4 Optimizing & tricks / MC68020 / Address registers multiplications"
@{B}4-2-5 Address registers multiplications@{UB}

And now to something weird that I found out lately. In some cases it may
be useful to multiplicate the value in an address register with a constant.
For example:

  ADD.W   A0,A0			;*2 for 16 bit

  ADD.L   A0,A0			;*2 for 32 bit

or

  ADD.W   A0,A0			;*4 for 16 bit
  ADD.W   A0,A0

  ADD.L   A0,A0			;*4 for 32 bit
  ADD.L   A0,A0

or

  ADD.W   A0,A0			;*8 for 16 bit
  ADD.W   A0,A0	
  ADD.W   A0,A0

  ADD.L   A0,A0			;*8 for 32 bit
  ADD.L   A0,A0
  ADD.L   A0,A0

Let's expand these calculations with the mode address register indirect
with index. Now we can multiplicate with the constants 3,5,6,9,10 and 18:

  LEA     (A0,A0.W*2),A0	;*3 for 16 bit

  LEA     (A0,A0.L*2),A0	;*3 for 32 bit


  LEA     (A0,A0.W*4),A0	;*5 for 16 bit

  LEA     (A0,A0.L*4),A0	;*5 for 32 bit


  LEA     (A0,A0.W*2),A0	;*6 for 16 bit
  ADD.W   A0,A0

  LEA     (A0,A0.L*2),A0	;*6 for 32 bit
  ADD.L   A0,A0


  LEA     (A0,A0.W*8),A0	;*9 for 16 bit

  LEA     (A0,A0.L*8),A0	;*9 for 32 bit


  LEA     (A0,A0.W*4),A0	;*10 for 16 bit
  ADD.W   A0,A0

  LEA     (A0,A0.L*4),A0	;*10 for 32 bit
  ADD.L   A0,A0


  LEA     (A0,A0.W*8),A0	;*18 for 16 bit
  ADD.W   A0,A0

  LEA     (A0,A0.L*8),A0	;*18 for 32 bit
  ADD.L   A0,A0


Nice idea or not? And finally you can add the constant -128=<n<=+127:

  LEA     n(A0,A0.W*2),A0	;(*3)+n for 16 bit

  LEA     n(A0,A0.L*2),A0	;(*3)+n for 32 bit


And for -32768=<n<=+32767:

  LEA     (n,A0,A0.W*2),A0	;(*3)+n for 16 bit

  LEA     (n,A0,A0.L*2),A0	;(*3)+n for 32 bit
@ENDNODE


@NODE Chapter-4-2-6 "4 Optimizing & tricks / MC68020 / Reading tables"
@{B}4-2-6 Reading tables@{UB}

Imagine we have a table with 256 word-entries. To read a certain value
out of this table we could code the following sequence:

  MOVE.W  (An,D1.W*2),D0	;Read the value
  ADDQ.W  #1,D1			;Next entry
  CMP.W   #256,D1		;End of table?
  BLT.S   no_reset		;No -> branch
  SUB.W   #256,D1		;Reset table-offset
no_reset

A smart coder would write the following sequence:

  MOVE.W  (An,D1.W*2),D0	;Read the value
  ADDQ.W  #1,D1			;Next entry
  AND.W   #255,D1		;Reset table-offset if overflow happens

Well fine you could say. But I say there is a faster way:

  MOVE.W  (An,D1.W*2),D0	;Read the value
  ADDQ.B  #1,D1			;Next entry @{B}and@{UB} reset table-offset if
				;overflow happens
@ENDNODE


@NODE Chapter-4-2-7 "4 Optimizing & tricks / MC680x0 family / Rotator/Zoomer optimizing"
@{B}4-2-7 Rotator/Zoomer optimizing@{UB}

If you work with Zoomers/Rotators on AGA machines and you use the copper
for the chunky mode, then you have to skip the @{"CMOVE" LINK Chapter-4-4-14} for the colour bank
switching while writing colour values with the CPU into the copper list.

Let's expect this copper command sequence:

  CWAIT 0,$2C
  CMOVE $XXXX,BPLCON4		;Switch palette
  CMOVE $0000,BPLCON3		;Bank0, High values
  CMOVE $0XXX,COLOR00
  ...etc...
  CMOVE $0XXX,COLOR31
  CMOVE $0200,BPLCON3		;Bank1, High values (should be skipped)
  CMOVE $0XXX,COLOR00
  ...etc...
  CMOVE $0XXX,COLOR31
  CMOVE $0400,BPLCON3		;Bank2, High values (should be skipped)
  ...etc...

That means that you count your writes per scan line. If the value 32 is
reached you have to skip 4 bytes (1 @{"CMOVE" LINK Chapter-4-4-14}). The code could look like
this:

;An=Pointer to the copper list

  ADDQ.W  #1,D4                 ;Increase the colour entries-counter
  CMP.W   #32,D4                ;Maximum entries number reached?
  BNE.S   no_new_bank           ;No -> branch
  MOVEQ   #0,d4			;Reset colour entries-counter
  ADDQ.W  #4,An                 ;Skip CMOVE in copper list
no_new_bank

To do a little optimizing, the value 32 can be kept in a data or address
register that is initialized outside the loop:

  ADDQ.W  #1,D4                 ;Increase the colour entries-counter
  CMP.W   Rn,D4                 ;Maximum entries number reached?
  BNE.S   no_new_bank           ;No -> branch
  MOVEQ   #0,d4			;Reset colour entries-counter
  ADDQ.W  #4,An                 ;Skip CMOVE in copper list
no_new_bank

But there is a faster way to check this. We use the fact that adding
an immediate byte values to a data register resets the register
automatically if a value >255 is reached. If we only want to check
the value 32, just multiply it with 8 to get the value 256 and increase
the counter with the step 8 instead of 1.

  ADDQ.B  #8,D4                 ;Increase the colour entries counter @{B}and@{UB}
				;reset it if >255
  BNE.S   no_new_bank           ;No -> branch
  ADDQ.W  #4,An                 ;Skip @{"CMOVE" LINK Chapter-4-4-14} in copper list
no_new_bank

So we save two commands at the end.

Apart from this example this method generally works with the max-values
32 (32*8), 64 (64*4), 128 (128*2) and 256. See also @{"Reading tables" LINK Chapter-4-2-6}.
@ENDNODE


@NODE Chapter-4-2-8 "4 Optimizing & tricks / MC68020 / Clearing bitplanes"
@{B}4-2-8 Clearing bitplanes@{UB}

Let's expect a bitplane of 40x256 bytes. On the MC68020 ignoring the
cache is not the best way. The MC68020 has a powerful instruction cache
with a size of 256 bytes. Use it! The code could look like this:

  CNOP 0,4			;Longword alignment for MC68020+
clear_pic
  MOVE.L  bitplane_adr(PC),A6
  MOVEQ   #0,D0
  ADD.W   #end_of_bitplane,A6	;If end_of_bitplane<=$7FFF
  ADD.L   #end_of_bitplane,A6   ;If end_of_bitplane>=$8000
  MOVEQ   #0,D1
  MOVEQ   #0,D2
  MOVEQ   #0,D3
  MOVEQ   #0,D4
  MOVEQ   #0,D5
  MOVEQ   #0,D6
  MOVE.L  D0,A1
  MOVE.L  D0,A2
  MOVE.L  D0,A3
  MOVE.L  D0,A4
  MOVE.L  D0,A5
  MOVEQ   #4-1,D7		;Loop 4 times
clear_loop
  REPT 60
  MOVEM.L D0-D6/A0-A5,-(A6)	;Clear 56 bytes
  ENDR
  DBF     D7,clear_loop
  MOVEM.L D0-D6/A0-A5,-(A6)	;Clear
  MOVEM.L D0-D6/A0-A5,-(A6)	;the remaining
  MOVEM.L D0-D6/A0-A4,-(A6)	;160 bytes
  RTS

After the first execution, the loop to clear the bitplane is in the cache,
because the commands in it only need 242 bytes of memory. 240=60x4 bytes for
the MOVEM.L commands and two bytes for the DBF command.

On the MC68040/060 with its larger instruction caches we can surely use
larger loops.
@ENDNODE


@NODE Chapter-4-2-9 "4 Optimizing & tricks / MC68020 / Radius-calculations with sine tables"
@{B}4-2-9 Radius-calculations with sine tables@{UB}

On the MC68020 as a 32-bit CPU it could be useful to use 32-bit sine-tables
instead of 16-bit tables as on the MC68000 and then extending the value to
32 bits:

radius=64

  MOVE.W  (An,Dn2),Dn1		;sin(w)
  EXT.L   Dn1                   ;Extend to 32 bits
  LSL.L   #7,Dn1               	;(sin(w)*radius*2
  SWAP    Dn1                   ;/2^16
  ADD.W   #centre,Dn1           ;+ centre

can be optimized to:
  
  MOVE.L  (An,Dn2),Dn1		;sin(w)
  LSL.L   #7,Dn1		;(sin(w)*radius*2
  SWAP    Dn1			;/2^16
  ADD.W   #centre,Dn1           ;+ centre

Take care that your sine-table is always longword aligned in memory with
a CNOP 0,4 command.
@ENDNODE


@NODE Chapter-4-3 "4 Optimizing & tricks / MC68060"
@{B}4-3 MC68060@{UB}

    4-3-1 @{" MOVE versus MOVEM command " LINK Chapter-4-3-1}
    4-3-2 @{" Cycles of MOVEM command " LINK Chapter-4-3-2}
@ENDNODE


@NODE Chapter-4-3-1 "4 Optimizing & tricks / MC68060 / MOVE versus MOVEM command"
@{B}4-3-1 MOVE versus MOVEM command@{UB}

Here's a little overview of the cycles of the MOVEM command on the MC68060.
The timing is taken from MOTOROLA's Documentary for the MC68060.

      4-3-1-1 @{" Reading from memory " LINK Chapter-4-3-1-1}
      4-3-1-2 @{" Writing to memory " LINK Chapter-4-3-1-2}
      4-3-1-3 @{" Unsigned extensions word to longword " LINK Chapter-4-3-1-3}
      4-3-1-4 @{" Signed extensions word to longword " LINK Chapter-4-3-1-4}
@ENDNODE


@NODE Chapter-4-3-1-1 "4 Optimizing & tricks / MC68060 / MOVE versus MOVEM command / Reading from memory"
@{B}4-3-1-1 Reading from memory@{UB}

1 cy: MOVE.W/L (An)+,Rn1	vs. 2 cy: MOVEM.W/L (An)+,Rn1-Rn2
1 cy: MOVE.W/L (An)+,Rn2
2 cy

1 cy: MOVE.W/L d16(An),Rn1	vs. 2 cy: MOVEM.W/L d16(An),Rn1-Rn2
1 cy: MOVE.W/L d16+2/4(An),Rn2
2 cy

1 cy: MOVE.W/L d8(An,Xn),Rn1	vs. 3 cy: MOVEM.W/L d8(An,Xn),Rn1-Rn2
1 cy: MOVE.W/L d8+2/4(An,Xn),Rn2
2 cy
@ENDNODE


@NODE Chapter-4-3-1-2 "4 Optimizing & tricks / MC68060 / MOVE versus MOVEM command / Writing to memory"
@{B}4-3-1-2 Writing to memory@{UB}

1 cy: MOVE.W/L Rn1,(An)		vs. 2 cy: MOVEM.W/L Rn1-Rn2,(An)
1 cy: MOVE.W/L Rn2,2/4(An)
2 cy			

1 cy: MOVE.W/L Rn1,d16(An)	vs. 2 cy: MOVEM.W/L Rn1-Rn2,d16(An)
1 cy: MOVE.W/L Rn2,d16+2/4(An)
2 cy                        

1 cy: MOVE.W/L Rn1,d8(An,Xn)	vs. 3 cy: MOVEM.W/L Rn1-Rn2,d8(An,Xn),Rn1
1 cy: MOVE.W/L Rn2,d8+2/4(An,Xn)
2 cy            
@ENDNODE


@NODE Chapter-4-3-1-3 "4 Optimizing & tricks / MC68060 / MOVE versus MOVEM command / Unsigned extensions word to longword"
@{B}4-3-1-3 Unsigned extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value. The restriction for an unsigned value
is 0<=value<=32767:

1 cy: MOVEQ  #0,Dn1		vs. 2 cy: MOVEM.W (An)+,Dn1-Dn2
1 cy: MOVE.W (An)+,Dn1
1 cy: MOVEQ  #0,Dn2
1 cy: MOVE.W (An)+,Dn2	
4 cy
@ENDNODE


@NODE Chapter-4-3-1-4 "4 Optimizing & tricks / MC68060 / MOVE versus MOVEM command / Signed extensions word to longword"
@{B}4-3-1-4 Signed extensions word to longword@{UB}

The MOVEM command automatically extends a read word access from memory to a
register into a signed longword value.

1 cy: MOVE.W (An)+,Dn1		vs. 2 cy: MOVEM.W (An)+,Dn1-Dn2
1 cy: EXT.L  Dn1
1 cy: MOVE.W (An)+,Dn2
1 cy: EXT.L  Dn2
4 cy
@ENDNODE


@NODE Chapter-4-3-2 "4 Optimizing & tricks / MC68060 / Cycles of MEVEM command"
@{B}4-3-2 Cycles of MOVEM command@{UB}

      4-3-2-1 @{" Reading from memory " LINK Chapter-4-3-2-1}
      4-3-2-2 @{" Writing to memory " LINK Chapter-4-3-2-2}
@ENDNODE


@NODE Chapter-4-3-2-1 "4 Optimizing & tricks / MC68060 / Cycles of MOVEM command / Reading from memory"
@{B}4-3-2-1 Reading from memory@{UB}

  MOVEM.W/L (An),Rn1-Rn2	2 cy for two registers, every further
				     register needs one extra cycle

  MOVEM.W/L (An)+,Rn1-Rn2	2 cy for two registers, every further
				     register needs one extra cycle

  MOVEM.W/L d16(An),Rn1-Rn2	2 cy for two registers, every further
				     register needs one extra cycle

  MOVEM.W/L d8(An,Xn),Rn1-Rn2	3 cy for two registers, every further
				     register needs one extra cycle
@ENDNODE


@NODE Chapter-4-3-2-2 "4 Optimizing & tricks / MC68060 / Cycles of MOVEM command / Writing to memory"
@{B}4-3-2-2 Writing to memory@{UB}

  MOVEM.W/L Rn1-Rn2,(An)	2 cy for two registers, every further
				     register needs one extra cycle

  MOVEM.W/L Rn1-Rn2,-(An)	2 cy for two registers, every further
				     register needs one extra cycle

  MOVEM.W/L Rn1-Rn2,d16(An)	2 cy for two registers, every further
			             register needs one extra cycle

  MOVEM.W/L Rn1-Rn2,d8(An,Xn)	3 cy for two registers, every further
				     register needs one extra cycle
@ENDNODE


@NODE Chapter-4-4 "4 Optimizing & tricks / MC680x0 family"
@{B}4-4 MC680x0 family@{UB}

    4-4-1  @{" Peephole optimizing " LINK Chapter-4-4-1}
    4-4-2  @{" Radius-calculations with sine tables " LINK Chapter-4-4-2}
    4-4-3  @{" Display double buffering in interlace " LINK Chapter-4-4-3}
    4-4-4  @{" Using the blitter in an optimal way " LINK Chapter-4-4-4}
    4-4-5  @{" Loading blitter registers more efficiently " LINK Chapter-4-4-5}
    4-4-6  @{" Searching key codes in an ASCII table " LINK Chapter-4-4-6}
    4-4-7  @{" Clock delay when turning off interrupts " LINK Chapter-4-4-7}
    4-4-8  @{" Real Time Clock handler " LINK Chapter-4-4-8}
    4-4-9  @{" Caches handling " LINK Chapter-4-4-9}
    4-4-10 @{" Setting dots for area filling " LINK Chapter-4-4-10}
    4-4-11 @{" Crunching data sections " LINK Chapter-4-4-11}
    4-4-12 @{" Generating random values " LINK Chapter-4-4-12}
    4-4-13 @{" Detecting active TCP/IP stacks " LINK Chapter-4-4-13}
    4-4-14 @{" Using macros for a better readability " LINK Chapter-4-4-14}
@ENDNODE


@NODE Chapter-4-4-1 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing"
@{B}4-4-1 Peephole optimizing@{UB}

      4-4-1-1  @{" Branch commands " LINK Chapter-4-4-1-1}
      4-4-1-2  @{" True and false conditions " LINK Chapter-4-4-1-2}
      4-4-1-3  @{" Saving register contents " LINK Chapter-4-4-1-3}
      4-4-1-4  @{" Initializing addresses " LINK Chapter-4-4-1-4}
      4-4-1-5  @{" Blitter shift value " LINK Chapter-4-4-1-5}
      4-4-1-6  @{" Logical operations " LINK Chapter-4-4-1-6}
      4-4-1-7  @{" Unsigned extensions word to longword " LINK Chapter-4-4-1-7}
      4-4-1-8  @{" Signed extensions word to longword " LINK Chapter-4-4-1-8}
      4-4-1-9  @{" Initializing values " LINK Chapter-4-4-1-9}
      4-4-1-10 @{" Nibble/byte swap " LINK Chapter-4-4-1-10}
      4-4-1-11 @{" Adding immediates to data registers " LINK Chapter-4-4-1-11}
      4-4-1-12 @{" Automatic address register 32 bit sign extension " LINK Chapter-4-4-1-12}
@ENDNODE


@NODE Chapter-4-4-1-1 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Branch commands"
@{B}4-4-1-1 Branch commands@{UB}

The following code sequence can be shortened:

  BSR.S/W/L label
  RTS

to

  BRA.S/W/L label

and calling a library function, too:

  JSR   -LVO_xx(A6)
  RTS

to

  JMP   -LVO_xx(A6)
@ENDNODE


@NODE Chapter-4-4-1-2 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / True and false conditions"
@{B}4-4-1-2 True and false conditions@{UB}

If you only work with TRUE($00000000) or FALSE($FF/$FFFF/$FFFFFFFF) states
and you want to change definitely a FALSE to a TRUE state of a variable in
memory:

  NOT.B/W/L d16(An)

can be replaced with

  CLR.B/W/L d16(An)
@ENDNODE


@NODE Chapter-4-4-1-3 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Saving register contents"
@{B}4-4-1-3 Saving register contents@{UB}

Saving the WORDLOW of a data register can be done without using the
stack, if the upper 16 bits won't be trashed by other operations:

  MOVE.W Dn,-(A7)		vs. SWAP Dn
  .				.
other operations		other operations
  .				.
  MOVE.W (A7)+,Dn		vs. SWAP Dn
@ENDNODE


@NODE Chapter-4-4-1-4 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Initializing addresses"
@{B}4-4-1-4 Initializing addresses@{UB}

Initializing the base addresses of the CIAs in address registers can be
shortened:

  LEA    $BFE001,An1		vs. MOVE.L  #$BFD000,An2
  LEA    $BFD000,An2    	    LEA     $1001(An2),An1
@ENDNODE


@NODE Chapter-4-4-1-5 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Blitter shift value"
@{B}4-4-1-5 Blitter shift value@{UB}

Calculating the blitter shift value for BLTCON0 can be optimized if the
upper bits 16-31 are zero:

  ROR.W  #4,Dn			vs. ROR.L   #4,Dn
  AND.W  #$F000,Dn		    SWAP    Dn
@ENDNODE


@NODE Chapter-4-4-1-6 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Logical operations"
@{B}4-4-1-6 Logical operations@{UB}


If only bit #7 in a data register should be set, the TAS command is faster:

  OR.B #$80,Dn			vs. TAS Dn


Setting several bits in a data register by the OR command can be replaced
by the ADD command if the bits are therefore zero:

For bits 0-3:

  OR.B/W/L #n,Dn		vs. ADDQ.B #n,Dn

and for the bits 4-6:

  OR.B #n,Dn			vs. ADD.B #n,Dn

and for the bits 8-15:

  OR.W #n,Dn			vs. ADD.W #n,Dn

and for the remaining bits 16-31:

  OR.L #n,Dn			vs. ADD.L #n,Dn

With this method in mind we can also OR values in address registers which
replace data registers:

  ADD.W/L #n,An


Masking out bit0 can be optimized if it is previously always set:

  AND.B #$FE,Dn			vs. SUBQ.B #1,Dn

With the same technique we can mask out a set bit0 in an address register
to get an even value:

  SUBQ.W #1,An
@ENDNODE


@NODE Chapter-4-4-1-7 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Unsigned extensions word to longword"
@{B}4-4-1-7 Unsigned extensions word to longword@{UB}

Unsigned extension of word values <32768 to longword values can be optimized,
because the MOVEM command does this for us automatically:

  MOVEQ  #0,Dn1			vs. MOVEM.W (An)+,Dn1-Dn2
  MOVE.W (An)+,Dn1
  MOVEQ  #0,Dn2
  MOVE.W (An)+,Dn2

The commands MOVEQ and CLR.W are faster than EXT.L if we only work with
unsigned values. Let's see how this looks like:

  SWAP    D0			vs. CLR.W   D0
  EXT.L   D0		   	    SWAP    D0

or another example:

  MOVE.W  (A0)+,D0		vs. MOVEQ   #0,D0
  EXT.L   D0			    MOVE.W  (A0)+,D0
@ENDNODE


@NODE Chapter-4-4-1-8 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Signed extensions word to longword"
@{B}4-4-1-8 Signed extensions word to longword@{UB}

Signed extension of word values >=32768 to longword values can be optimized,
because the MOVEM command does this for us automatically:

  MOVE.W (An)+,Dn1		vs. MOVEM.W (An)+,Dn1-Dn2
  EXT.L  Dn1
  MOVE.W (An)+,Dn2
  EXT.L  Dn2
@ENDNODE


@NODE Chapter-4-4-1-9 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Initializing values"
@{B}4-4-1-9 Initializing values@{UB}

The MOVEQ and the ROR command can be used to write values to data registers:

  MOVEQ   #3,Dn
  ROR.B   #1,Dn			;= $81

  MOVEQ   #3,Dn
  ROR.W   #1,Dn			;= $8001

  MOVEQ   #3,Dn
  ROR.L   #1,Dn			;= $80000001
@ENDNODE


@NODE Chapter-4-4-1-10 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Nibble/byte swap"
@{B}4-4-1-10 Nibble/byte swap@{UB}

There is no command for swapping the low/high order nibble or byte content
of data registers. Using the ROR command is a solution:

  ROR.B   #4,Dn                 ;Swap the low-order nibble (bits 0-3) with
				;the high-order nibble (bits 4-7)

  ROR.W   #8,Dn			;Swap the low-order byte (bits 0-7) with
				;the high-order byte (bits 8-15)
@ENDNODE


@NODE Chapter-4-4-1-11 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Adding immediates to data registers"
@{B}4-4-1-11 Adding immediates to data registers@{UB}

Adding an immediate value to a data register can be optimized:

  MOVE.L  (An),Dn 		vs. MOVEQ   #$40,Dn
  ADD.L   #$200,Dn                  LSL.W   #3,Dn
                                    ADD.L   (An),Dn
@ENDNODE


@NODE Chapter-4-4-1-12 "4 Optimizing & tricks / MC680x0 family / Peephole optimizing / Automatic address register 32 bit sign extension"
@{B}4-4-1-12 Automatic address register 32 bit sign extension@{UB}

When we write a word value into an address register there is an automatic
sign extension from 16 to 32 bits:

1=<An2<=32767

  MOVE.L  (An1)+,An2		vs. MOVE.W  (An1)+,An2

See also

1<=n<=8

  ADDQ.L  #n,An			vs. ADDQ.W  #n,An

1=<n<=32767

  ADD.L   #n,An			vs. ADD.W   #n,An
@ENDNODE


@NODE Chapter-4-4-2 "4 Optimizing & tricks / MC680x0 family / Radius-calculations with sine tables"
@{B}4-4-2 Radius-calculations with sine tables@{UB}

Let's assume we want to read angles from a sine table and calculate
a radius:

  MOVE.W  (An,Dn3),Dn1		vs. MOVE.W  (An,Dn2),Dn1
  MULS.W  #radius,Dn1               MULS.W  #radius*2,Dn1
  ADD.L   Dn1,Dn1                   SWAP    Dn1
  SWAP    Dn1                       ADD.W   #centre,Dn1
  ADD.W   #centre,Dn1

When we calculate a double-radius we can do it like this:

  MOVE.W  (An,Dn3),Dn1		vs. MOVE.W  (An,Dn3),Dn1
  MULS.W  #radius,Dn1               MULS.W  #radius*4,Dn1
  ADD.L   Dn1,Dn1                   SWAP    Dn1
  SWAP    Dn1                       MULS.W  (An,Dn4),Dn1
  MULS.W  (An,Dn4),Dn1              SWAP    Dn1
  ADD.L   Dn1,Dn1                   ADD.W   #centre,Dn1
  SWAP    Dn1                             
  ADD.W   #centre,Dn1

Or we replace the slow MULS command by a LSL command and use a radius of 2^n:

radius=128

  MOVE.W  (An,Dn3),Dn1		vs. MOVE.W  (An,Dn2),Dn1	(good)
  EXT.L   Dn1			    EXT.L   Dn1
  LSL.L   #7,Dn1               	    LSL.L   #8,Dn1
  ADD.L   Dn1,Dn1                   SWAP    Dn1
  SWAP    Dn1                       ADD.W   #centre,Dn1
  ADD.W   #centre,Dn1
				vs. MOVE.W  (An,Dn2),Dn1	(better)
                                    EXT.L   Dn1
                                    LSR.L   #8,Dn1
                                    ADD.W   #centre,Dn1

				vs. MOVE.W  (An,Dn2),Dn1	(best)
                                    ASR.W   #8,Dn1
                                    ADD.W   #centre,Dn1

And for a double-radius:

radius=64

  MOVE.W  (An,Dn3),Dn1		vs. MOVE.W  (An,Dn3),Dn1	(good)
  EXT.L   Dn1			    EXT.L   Dn1
  LSL.L   #6,Dn1		    LSL.L   #8,Dn1
  ADD.L   Dn1,Dn1                   SWAP    Dn1
  SWAP    Dn1                       MULS.W  (An,Dn4),Dn1
  MULS.W  (An,Dn4),Dn1              SWAP    Dn1
  ADD.L   Dn1,Dn1                   ADD.W   #centre,Dn1
  SWAP    Dn1                             
  ADD.W   #centre,Dn1
				vs. MOVE.W  (An,Dn3),Dn1	(better)
                                    EXT.L   Dn1
				    LSR.L   #8,Dn1
				    MULS.W  (An,Dn4),Dn1
				    SWAP    Dn1
				    ADD.W   #centre,Dn1

				vs. MOVE.W  (An,Dn3),Dn1	(best)
				    ASR.W   #8,Dn1
				    MULS.W  (An,Dn4),Dn1
				    SWAP    Dn1
				    ADD.W   #centre,Dn1
@ENDNODE


@NODE Chapter-4-4-3 "4 Optimizing & tricks / MC680x0 family / Display double buffering in interlace"
@{B}4-4-3 Display double buffering in interlace mode@{UB}

Double buffering in conjunction with interlace screens is only used in a
few demos/intros. But in some cases it might be useful. Well, how do we
code this?

Quite simple. Every frame we swap the picture and we decide if the odd or
the even lines are displayed. We don't need two copper lists for that! Just
one copper list is enough.

I've chosen the interleaved bitplane format raw modulo that means:
1st line plane0, 1st line plane1, 1st line plane2,...
2nd line plane0, 2nd line plane1, 2nd line plane2,...
...etc...

For this format, the offset to the next plane is the plane_width*pf_depth.

The normal bitplane format plane after plane could be also used.

So here we go:

;D0=BPL_Adr
;A0=BPL1PT position in the copper list
;A6=CUSTOM-CHIP base

  MOVE.W  $4(A6),D1		;@{"VPOSR" LINK VPOSR} Get the LOF-Bit
  BPL.S   short_frame		;If bit not set -> branch
  ADD.L   #plane_width*1*pf_depth,D0 ;Odd lines
short_fame
  MOVE.W  D0,4(A0)		;Low bits of the bitplane address
  SWAP    D0			;Get high-word
  MOVE.W  D0,(a0)		;High bits of the bitplane address
...etc...

Remember that this routine should be executed at the bottom of the display
(for PAL at scan line $136, for NTSC at scan line $104) just before the
next display will be started and the copper list will be restarted.
@ENDNODE


@NODE Chapter-4-4-4 "4 Optimizing & tricks / MC680x0 family / Using the blitter in an optimal way"
@{B}4-4-4 Using the blitter in an optimal way@{UB}

"Let the copper do the dirty work". A simple statement but not often
transferred. Why wasting CPU-cycles running code out of CHIP memory
and waiting for the blitter when the copper does nearly the same for
free.

While waiting for the blitter, the copper is against the CPU off bus.
The copper-wait command only needs 6 cycles to wake up. Side effect:
The blitter is not disturbed while waiting for him.

While the CPU waits for the blitter to be finished, this would steal
the blitter memory cycles, if the blitter hasn't priority over the CPU
(BLTPRI, Bit10, in @{"DMACON" LINK DMACON} is not set). This fact applies to any
processor of the MOTOROLA family MC68000-MC68060 if the code runs out
of CHIP memory.

Only waiting for the blitter differs on different machines. On the A1000
and the A2000-A models with OCS, you have to read a custom chip address,
or CHIP memory, before the real blitter wait.

;A6=CUSTOM CHIPS BASE+DMACONR

  TST.W   (A6)			;For A1000/A2000-A
wait_blitter
  BTST    #6,(A6)		;@{"DMACONR" LINK DMACON} Wait for blitter to be finished
  BNE.S   wait_blitter

For the rest of the OCS/ECS/AGA models, the TST.W command isn't necessary.

The copper could handle this problem, if it waits two times for the blitter:

  DC.W $0001,$0000		;@{"CWAITBLIT" LINK Chapter-4-4-14} only for A1000/A2000-A
  DC.W $0001,$0000              ;CWAITBLIT

And analogous for the rest of the OCS/ECS/AGA models, the first CWAITBLIT
command isn't necessary.

This phenomen is based on a hardware bug. On the A1000/A2000-A the blitter-
finished bit is cleared after the first memory cycle catched by the blitter.

On a lores display with more than four bitplanes or a hires display with
more than two bitplanes, there will be wait states. Your code may run
out of FAST memory or out of the CPU's cache and will continue to have
memory cycles and may manipulate blitter registers for the next blit.

In a sequence of consecutive operations the blitter would be "ready" for the
next job while waiting on the bus. On the bug fixed chipsets, the blitter
busy bit is cleared immediately after the @{"BLTSIZE" LINK BLTSIZE} register on OCS/ECS/AGA
or the @{"BLTSIZH" LINK BLTSIZH} register on ECS/AGA are written and the operation starts
regardless on wait states.

So you see using the copper as a "blitter-slave" is very useful to avoid
wait states for the CPU or the blitter in case you don't have FAST memory
available for your code.
@ENDNODE


@NODE Chapter-4-4-5 "4 Optimizing & tricks / MC680x0 family / Loading blitter registers more efficiently"
@{B}4-4-5 Loading blitter registers more efficiently@{UB}

Let's assume the following:
                                    
;A6=CUSTOM-CHIP base

mem+0  MOVE.L  An,$54(A6)	;@{"BLTDPTH" LINK BLTxPTH}
mem+6  MOVE.W  Dn1,$40(A6)	;@{"BLTCON0" LINK BLTCON0}
mem+12 MOVE.W  Dn2,$58(A6)	;@{"BLTSIZE" LINK BLTSIZE}
mem+18 ADD.W   #10,Dn3
mem+22 DBF     Dn4,loop
...etc...

To reduce possible wait states a clever coder would do the following:

mem+0  MOVE.L  An,$54(A6)	;BLTDPTH
mem+6  MOVE.W  Dn1,$40(A6)	;BLTCON0
mem+12 ADD.W   #10,Dn3
mem+16 MOVE.W  Dn2,$58(A6)	;BLTSIZE
mem+22 DBF     Dn4,loop

Always remember to do something else when you write to CHIP/CUSTOM
memory. Well fine you think. But that's not all:

mem+0  MOVE.L  An,$54(A6)	;BLTDPTH
mem+6  ADDQ.W  #8,Dn3
mem+8  MOVE.W  Dn1,$40(A6)	;BLTCON0
mem+14 ADDQ.W  #2,Dn3
mem+16 MOVE.W  Dn2,$58(A6)	;BLTSIZE
mem+22 DBF     Dn4,loop

Now the code runs perfect on the MC68040/60. Every memory access is
longword aligned. That might help in many cases. And last but not
least between every access to the custom-chips the CPU has time to
do something else.
@ENDNODE


@NODE Chapter-4-4-6 "4 Optimizing & tricks / MC680x0 family / Searching key codes in an ASCII table"
@{B}4-4-6 Searching key codes in an ASCII table@{UB}

One of the most used routines on the Amiga is a scroll text or a kind of
typewriter. To display the right characters you have to find the right
ASCII codes in your text table. Here we go:

chars_pic_x_size=320
chars_pic_width=chars_pic_width/8
chars_pic_depth=2
char_x_size=16
char_y_size=16
ASCII_len=27

  CNOP 0,4			;Longword alignment for MC68020+
get_char_image
  LEA     ASCII_tab(PC),A0	;Table with ASCII codes
  LEA     chars_offsets(PC),A1	;Table with xy-offsets where to find the
				;Image of the character in the characters
				;picture, here 16x16 pixels characters
  MOVEQ   #ASCII_len-1,D7	;Length of the ASCII-Table
search_loop
  CMP.B   (A0)+,D0		;Get ASCII code
  BEQ.S   ASCII_found		;Branch if found
  ADDQ.W  #2,A1			;Next entry in characters offset table
  DBF     D7,search_loop
ASCII_not_found
  MOVEQ   #-1,D0		;Error
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
ASCII_found
  MOVEQ   #0,D0
  MOVE.W  (a1),d0		;Get xy-offset
  ADD.L   #characters_pic,D0	;Add characters picture address = Pointer to
				;the character image
  RTS

ASCII_tab
  DC.B "ABCDEFGHIJKLMNOPQRSTUVWXYZ "
  EVEN

  CNOP 0,2
chars_offsets
  DC.W 0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38
  DC.W 0*char_y_size*chars_pic_depth,2*char_y_size*chars_pic_depth,...


This could be a solution but ignores a very special command, the DBEQ.
What's the difference between DBF and DBEQ?

Quite simple. DBF counts the value in D7 down to -1. While counting, the
loop is executed. The loop stops at the value -1. The DBEQ does nearly
the same. The value in D7 is counted down to -1. The loop stops at -1
@{B}or@{UB} if the zero bit of the condition code is set by a previous command.

With this knowledge we can code this:

  CNOP 0,4			;Longword alignment for MC68020+
get_char_image
  LEA     ASCII_tab(PC),A0	;Table with ASCII codes
  LEA     chars_offsets-2(PC),A1 ;Table with xy-offsets where to find the
				;Image of the character in the characters
				;picture, here 16x16 pixels characters
  MOVEQ   #ASCII_len-1,D7	;Length of the ASCII-Table
search_loop
  ADDQ.W  #2,A1			;Next entry in characters offset table
  CMP.B   (A0)+,D0              ;Get ASCII code
  DBEQ    search_loop           ;Branch if not found
  MOVEQ   #0,D0
  MOVE.W  (a1),D0               ;Get xy-offset
  ADD.L   #characters_pic,D0	;Add characters picture address = Pointer to
				;the character image
  RTS

If we place our "space bar" empty image at the end of the characters pic,
we don't have to check, if a character is found or not. The last character
will be always the "space bar" which is also an "unknown" character.
@ENDNODE


@NODE Chapter-4-4-7 "4 Optimizing & tricks / MC680x0 family / Clock delay when turning off interrupts"
@{B}4-4-7 Clock delay when turning off interrupts@{UB}

When we turn off the @{"interrupts" LINK Chapter-4-4-13-1} taking over the machine in an intro or
a demo, the system clock is stopped. If it's not refreshed when we return
to the system, the clock has a delay of the time you watched the intro/
demo. There are two ways to solve this problem:

      4-4-7-1 @{" Battery Clock Resource " LINK Chapter-4-4-7-1}
      4-4-7-2 @{" Time Of Day Clock " LINK Chapter-4-4-7-2}
@ENDNODE


@NODE Chapter-4-4-7-1 "Battery Clock Resource"
4-4-7-1 @{B}Battery Clock Resource@{UB}

Here's a way to read the RTC time under OS 2.0+ with the battclock resource
and update the system time with the given RTC time:

  CNOP 0,4			;Longword alignment for MC68020+
read_batt_clock
  MOVE.L  $4.W,A6               ;Exec base
  MOVE.L  A6,A5
  LEA     battresname(PC),A1	;battclock.resource
  JSR     -498(A6)		;@{"OpenResource()" LINK OpenResource()}
  TST.L   D0			;No battclock?
  BEQ.S   no_battclock_found    ;Yes -> branch
  MOVE.L  D0,A4			;battclockbase -> A4
  MOVEQ	  #40,D0		;Allocate 40 bytes for timer-request-struc
  MOVE.L  #$10001,D1		;@{"Memory options" LINK Chapter-4-4-8-2}: ANY, PUBLIC, CLEAR
  JSR     -198(A6)		;@{"AllocMem()" LINK AllocMem()}
  TST.L   D0                    ;Error?
  BEQ.S	  no_memory             ;Yes -> branch
  MOVE.L  D0,A3			;Allocated memory -> A3
  MOVE.L  D0,A1                 ;Pointer to timer-request-struc
  LEA     timerdevname(PC),A0
  MOVEQ   #0,D0			;Unit 0 = UNIT_MICROHZ
  MOVEQ   #0,D1			;No flags
  JSR     -444(A6)		;@{"OpenDevice()" LINK OpenDevice()}
  TST.L	  D0			;Equal 0?
  BNE.S   device_error          ;No -> branch
  MOVEQ	  #0,D0			;Start building IORequest/TimerRequest struc
  MOVE.B  D0,8(A3)              ;LN_Type = NULL
  MOVE.B  D0,9(A3)		;LN_Pri = NULL
  MOVE.L  D0,$A(A3)		;LN_Name = No pointer
  MOVE.L  D0,$E(A3)		;MN_ReplyPort = No pointer
  MOVE.L  A4,A6			;battclockbase -> A6
  MOVE.L  d0,$24(A3)		;TV_micro = 0 microseconds
  JSR     -12(A6)		;@{"ReadBattClock()" LINK ReadBattClock()}
  MOVE.L  A3,A1
  MOVE.L  D0,$20(A3)		;TV_secs = UNIX time in seconds
  BEQ.S   no_sys_time_refresh	;Equal 0 (Invalid value) ?
  MOVE.L  A5,A6			;Exec base -> A6
  MOVE.W  #$B,$1C(A3)		;IO_Command = TR_SETSYSTIME
  JSR     -456(a6)		;@{"DoIO()" LINK DoIO()}
no_sys_time_refresh
  MOVE.L  A3,A1
  JSR     -450(a6)		;@{"CloseDevice()" LINK CloseDevice()}
device_error
  MOVE.L  A3,A1                 ;Pointer to memory block
  MOVEQ   #40,D0		;Free the 40 bytes
  JSR     -210(A6)		;@{"FreeMem()" LINK FreeMem()}
  MOVEQ   #0,D0                 ;Return code = OK
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
no_battclock_found
  MOVEQ   #-1,D0		;Return code = FALSE
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
no_memory
  MOVEQ   #-1,D0		;Return code = FALSE
  RTS

battresname  DC.B "battclock.resource",0
timerdevname DC.B "timer.device",0
  EVEN

But this method is not the best way, because the battclock resource has
a bug. Working with OS 3.0 on a real A1200 without a RTC, the return value
of @{"OpenResource()" LINK OpenResource()} is always nonzero. That means that the system thinks
that there's always a RTC available.

Apart from this bug OpenResource() works right on a MiST which doesn't
have a RTC and returns a zero value. Thanks to @{I}kolla@{UI} for this important
hint. The missing clock port seems to cause this behavior.

So it's better to use this @{"solution" LINK Chapter-4-4-7-2} for refreshing the system time.
@ENDNODE


@NODE Chapter-4-4-7-2 "4 Optimizing & tricks / MC680x0 family / Clock delay when turning off interrupts / Time Of Day Clock"
@{B}3-4-7-2 Time Of Day Clock@{UB}

Using the timer device and the Time of Day Clock (TOD) of the CIA we can
also prevent the clock delay. This is an alternative to the method mentioned
@{"above" LINK Chapter-4-4-7-1} and works on every operating system. The TOD runs independently from
any @{"interrupts" LINK Chapter-4-4-13-1} so, they can be all turned off.

The TOD registers doesn't have to be changed. We just get the actual system
time before turning off the interrupts and after that we get the current TOD
counter value before starting the intro/demo.

When the intro/demo is finished, we read the TOD counter again and calculate
the period of the intro/demo. That means that we calculate the difference
from TOD before and after the execution of the demo/intro. While we do this,
it is important to check a potential TOD overflow.

The result of the difference calculation is added to the saved system time
and the internal clock works without any delay after it is set with the new
value.

Here's the code:

  MOVE.L  $4.W,A6		;Exec base
  LEA     timer_request_struc(PC),A1 ;Timer-request-structure
  MOVEQ   #0,D0			;Unit 0 (UNIT_MICROHZ) & NULL for struc
  MOVE.B  D0,8(A1)		;LN_Type: Entry type = NULL
  MOVE.B  D0,9(A1)		;LN_Pri: Priority of the struc. = NULL
  MOVEQ   #0,D1			;No Flags for device
  MOVE.L  D0,$A(A1)		;LN_Name: No name for the structure
  LEA     timer_device_name(PC),A0 ;Pointer to name of Timer-Device
  MOVE.L  D0,$E(A1)		;MN_ReplyPort: No Reply-Port
  JSR     -444(A6)		;@{"OpenDevice()" LINK OpenDevice()}
  TST.L   D0
  BNE.S   open_timer_device_error
  LEA     timer_request_struc(PC),A1
  MOVE.W  #$A,$1C(A1)		;IO_Command = TR_GETSYSTIME
  JSR     -456(A6)		;@{"DoIO()" LINK DoIO()}
  JSR     -120(A6)		;@{"Disable()" LINK Disable()}

;Here we take over the machine...

  MOVE.L  #$BFE001,A4		;CIA-A base address
  MOVEQ   #0,D0
  MOVE.B  $A00(A4),D0		;TOD-clock bits 23-16
  SWAP    D0			;Shift bits to the right position
  MOVE.B  $900(A4),D0		;TOD-clock bits 15-8
  LSL.W   #8,D0			;Shift bits to the right position
  MOVE.B  $800(A4),D0		;TOD-clock bits 7-0
  MOVE.L  D0,TOD_time_save	;Save time before demo/intro starts

  MOVEM.L D0-D7/A0-A6,-(A7)
  BSR     demo			;start intro/demo
  MOVEM.L (A7)+,D0-D7/A0-A6

  MOVE.L  TOD_time_save(PC),D0	;Time before starting demo/intro
  MOVEQ   #0,D1
  MOVE.B  $A00(A4),D1		;TOD-clock Bits 23-16
  SWAP    D1
  MOVE.B  $900(A4),D1		;TOD-clock Bits 15-8
  LSL.W   #8,D1
  MOVE.B  $800(A4),D1		;TOD-clock Bits 7-0
  CMP.L   D0,D1			;TOD overflow?
  BEQ.S   no_TOD_overflow	;No -> branch
  MOVE.L  #$FFFFFF,D2		;Max TOD value
  SUB.L   D0,D2			;Difference until overflow
  ADD.L   D2,D1			;+ value after overflow
  BRA.S   TOD_okay
  CNOP 0,4			;Longword alignment for 68020+
no_TOD_overflow
  SUB.L   D0,D1			;Get normal difference without overflow
TOD_okay
  MOVE.L  D1,TOD_time_save	;Save period of demo/intro

;Restoring system...

  MOVE.L  $4.W,A6		;Exec base
  JSR     -126(A6)		;@{"Enable()" LINK Enable()}
  MOVE.L  TOD_time_save(PC),D0	;Period of demo/intro
  MOVEQ   #0,D1
  MOVE.B  212(A6),D1		;Get VBlankFrequency
  LEA     timer_request_struc(PC),A1
  DIVU.W  D1,D0			;Calculate seconds
  MOVE.W  #$B,$1C(A1)		;IO_command = TR_SETSYSTIME
  MOVE.L  D0,D1			;Save seconds in D1
  EXT.L   D0			;Word to longword
  ADD.L   D0,$20(A1)		;TV_SECS: Set UNIX time seconds
  SWAP    D1			;Remainder of division
  MULU.W  #10000,D1		;*10000 = s
  ADD.L   D1,$24(A1)		;TV_MICRO: Set UNIX time microseconds
  JMP     -456(A6)		;DoIO()
  CNOP 0,4			;Longword alignment for MC68020+
open_timer_device_error
  RTS

  CNOP 0,4			;Longword alignment for MC68020+
TOD_time_save	    DC.L 0
timer_request_struc DS.B 40
timer_device_name   DC.B "timer.device",0
  EVEN

Read more about this very interesting discussion on:
@{I}English Amiga Board > Coders > Coders. Asm / Hardware /
non-system startup code time/clock problem@{UI}

And many thanks go to the members of this discussion @{I}daxb, modrobert,
Photon, phx@{UI} and @{I}Toni Wilen@{UI}.
@ENDNODE


@NODE Chapter-4-4-8 "4 Optimizing & tricks / MC680x0 family / Real Time Clock handler"
@{B}4-4-8 Real Time Clock Handler@{UB}

The Real Time Clock (RTC) is based on UNIX time. This standard is used on
the Amiga and on the PC to obtain the actual date and time for the system.
But there are some differences between the Amiga and the PC UNIX time. The
Amiga uses as a reference the start date 01.01.1978 00:00:00 for its RTC
counter. The PC uses the start date 01.01.1970 00:00:00.

If the leap years are calculated, care must be taken. Use the year 1976 on
the Amiga instead of 1968 on the PC. The distance between the start year
and the previous leap year should be 2 years or there will be a wrong UNIX
time as a result.

After analyzing SetClock1.2 & 1.3 and @{"ReadBattClock()" LINK ReadBattClock()} in ROM I wrote this
RTC-handler. It supports the most commonly used RTC model @{"OKI MSM6242 B" LINK Chapter-4-4-8-1}
which is used in the Amiga models A2000-A, A1000 (if available on memory
expansion or turbo card), A2000-B/A500+/A2500 and A500/A600/A1200 (if
available on memory expansion or turbo card).

The handler checks if a RTC is available, reads the RTC, converts the
date/time to Amiga UNIX time and sets the system time. As a bonus, I've
included an alternative subroutine to seek&reset the RTC.

The code was tested on an A1200 without a RTC and with a MC68030 turbo
card containing a RTC.

Examples:
+-----------------+-----------------+-----------------------------+
| UNIX time (dec) | UNIX time (hex) | date/time (UTC)             |
+-----------------+-----------------+-----------------------------+
|               0 |	          0 |  1. January   1978 00:00:00 |
+-----------------+-----------------+-----------------------------+
|      1189457656 |	   46E5B218 | 10. September 2015 20:54:16 |
+-----------------+-----------------+-----------------------------+

  CNOP 0,4			;Longword alignment for MC68020+
RTC_handler
  BSR.S   read_RTC_date_time
  TST.W   D0			;Error?
  BNE.S   no_RTC		;Yes -> branch
  BSR.S   refresh_sys_clock
  MOVEQ   #0,D0			;Everything fine
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
no_RTC
  MOVEQ   #-1,D0		;RTC not found, Return code = FALSE
  rts

;Check for RTC & read RTC date and time
  CNOP 0,4			;Longword alignment for MC68020+
read_RTC_date_time
  MOVE.L  #$DC0000,A0		;RTC base address for A2000-B,A500+,2500
				;(A500,A600,A1200 with ext-memory/turbo card)
  MOVEQ   #1,D0			;Set HOLD-Bit in @{"Control D-register" LINK Chapter-4-4-8-1}
  MOVE.B  D0,$37(A0)		;to prevent register-carry during
				;reading by freezing counter pulse
  NOP				;Prevent parallel execution on the MC68060
  MOVE.B  $37(A0),D1		;Check if Control D-register exists
  MOVEQ   #$F,D2
  AND.B   D2,D1			;Mask out unimportant bits
  CMP.B   D1,D0			;Read = Write?
  BEQ.S   RTC_wait_loop         ;Yes -> branch
  MOVE.L  #$D80000,A0		;RTC base address for A2000-A (A1000)
  MOVEQ   #1,D0			;Set HOLD-Bit in Control D-register
  MOVE.B  D0,$37(A0)		;to prevent register-carry during
  				;reading by freezing counter pulse
  NOP				;Prevent parallel execution on the MC68060
  MOVE.B  $37(A0),D1		;Check if Control D-register exists
  AND.B   D2,D1			;Mask out unimportant bits
  CMP.B   D1,D0			;Read <> Write?
  BNE.S   no_RTC_found          ;Yes -> branch

RTC_wait_loop
  BTST    D0,$37(A0)		;BUSY-Bit cleared ?
  BNE.S   RTC_wait_loop		;No -> RTC not ready for reading

;Get BCD-values of seconds, minutes, hours, days, months and years and
;convert them to real numbers
  LEA     RTC_data_struc(PC),A1	;Buffer for RTC date and time data
  LEA     3(A0),A2		;secs/mins/hours/days/months/years unit
				;position
  MOVEQ   #$F,D3		;Mask for Bits 0-3
  MOVEQ   #6-1,D7		;Number of date/time positions to read
RTC_read_loop
  MOVE.B  (A2),D0		;Unit position
  AND.W   D3,D0			;Only Bits 0-3
  MOVE.B  4(A2),D1		;Decade
  AND.W   D3,D1			;Only Bits 0-3
  MOVE.W  D1,d2			;Decade*10
  ADD.W   D1,D1
  ADD.W   D1,D1
  ADD.W   D2,D1
  ADD.W   D1,D1
  ADD.W   D1,D0			;Add unit position = real number
  ADDQ.W  #8,A2			;Next date/time RTC registers
  MOVE.W  D0,(A1)+		;Save secs/mins/hours/days/months/years
  DBF     D7,RTC_read_loop
  MOVEQ   #0,D0			;Clear HOLD-Bit in @{"Control D-register" LINK Chapter-4-4-8-1}
  MOVE.B  D0,$37(A0)		;so that the counter pulse proceeds
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
no_RTC_found
  MOVEQ   #-1,D0		;Buy memory expansion incl. RTC or turbo card
  RTS

;Refresh the system clock by the timer device
  CNOP 0,4			;Longword alignment for MC68020+
refresh_sys_clock
  MOVE.L  $4.W,A6		;Exec base
  MOVEQ   #40,D0		;Alloc. 40 bytes for TimerRequest struc.
  MOVE.L  #$10001,D1		;@{"Memory options" LINK Chapter-4-4-8-2}: ANY, PUBLIC, CLEAR
  JSR     -198(A6)		;@{"AllocMem()" LINK AllocMem()}
  MOVE.L  D0,A3			;Allocated memory in a3
  TST.L   D0
  BEQ.S   memory_error		;Strange...
  MOVE.L  D0,A1
  LEA     timerdevname(PC),A0	;Pointer to device name
  MOVEQ   #0,D0			;Unit 0 = UNIT_MICROHZ
  MOVEQ   #0,D1			;No flags
  JSR     -444(A6)		;@{"OpenDevice()" LINK OpenDevice()}
  TST.L   D0			;Equal 0 ?
  BNE.S   timerdev_error        ;Yes -> branch
  MOVEQ   #0,D0			;Start building TimerRequest struc.
  MOVE.B  D0,8(A3)		;LN_Type = NULL
  MOVE.B  D0,9(A3)		;LN_Pri = NULL
  MOVE.L  D0,$A(A3)		;LN_Name = No pointer
  MOVE.L  D0,$E(A3)		;MN_ReplyPort = No pointer
  MOVE.L  D0,$24(A3)		;TV_micro = 0 microseconds
  BSR.S   RTC_2_UNIX_timestamp
  MOVE.L  A3,A1			;Pointer to TimerRequest structure
  MOVE.L  D0,$20(A3)		;TV_secs = UNIX time in seconds
  BEQ.S   no_sys_time_refresh	;Equal 0 (Invalid value) ?
  MOVE.W  #$B,$1C(A3)		;IO_Command = TR_SETSYSTIME
  JSR     -456(A6)		;@{"DoIO()" LINK DoIO()}
no_sys_time_refresh
  MOVE.L  A3,A1			;Pointer to TimerRequest structure
  JSR     -450(A6)		;@{"CloseDevice()" LINK CloseDevice()}
timerdev_error
  MOVE.L  A3,A1			;Pointer to requested memory
  MOVEQ   #40,D0		;Free the 40 bytes
  JMP     -210(A6)		;@{"FreeMem()" LINK FreeMem()}
  CNOP 0,4			;Longword alignment for MC68020+
memory_error
  RTS

;Convert the date/time to Amiga UNIX timestamp
;D0 = Seconds 0...59
;D1 = Minutes 0...59
;D2 = Hours 0...23
;D3 = Days 1...31
;D4 = Months 1...12
;D5 = Years 1978...2038
;A0 = Pointer to days-table
;D0 = Returns Amiga UNIX time
  CNOP 0,4			;Longword alignment for MC68020+
RTC_2_UNIX_timestamp
  MOVEM.W RTC_data_struc(PC),D0-D5 ;secs,mins,hours,days,months,years
  LEA     days_until_beginning_of_the_year(PC),A0 ;Days-table
  ADD.W   #1900,D5		;Add 20th century
  CMP.W   #1978,D5		;21st century? (OS 2.0+ sets year+100 in
				;RTC if 21st century, OS 1.x does not)
  BGE.S   century_ok
  ADD.W   #100,D5		;Add 100 years for 21st century (OS 1.x)
century_ok

;Calculate the leap years
  MOVE.L  D5,D6			;Fetch year
  SUBQ.W  #1,D6			;Year-1
  MOVE.L  D6,D7			;Save in D7
  SUB.W   #1976,D6		;(year-1)-1976
  LSR.W   #2,D6			;((year-1)-1976)/4
  MOVE.W  D6,A1			;Result in a1
  MOVE.L  D7,D6			;Fetch year-1
  SUB.W   #1900,D6		;(year-1)-1900
  DIVU.W  #100,D6		;((year-1)-1900)/100
  SUB.W   D6,A1			;-((year-1)-1900)/100
  SUB.W   #1600,D7		;(year-1)-1600
  DIVU.W  #400,D7		;((year-1)-1600)/400
  ADD.W   D7,A1			;+((year-1)-1600)/400 = leap_years in A1

;Calculate the days until 1978
  MOVE.L  D5,D6			;Fetch year
  SUB.W   #1978,D6		;year-1978
  MULU.W  #365,D6		;(year-1978)*365
  ADD.W   A1,D6			;(year-1978)*365+leap_years
  MOVE.L  D4,D7			;Fetch month
  SUBQ.W  #1,D7			;month-1
  ADD.W   D7,D7			;*2 = word size
  ADD.W   (A0,D7.W),D6		;+days_until_beginning_of_the_year[month-1]
  MOVE.L  D3,D7			;Fetch day
  SUBQ.W  #1,D7			;day-1
  ADD.W   D7,D6			;+day-1 = D6 = days_since_1978

;Check if leap day should be added
  CMP.W   #2,D4			;month>2 ?
  BLE.S   no_leap_day		;No -> branch
  MOVE.L  D5,D7			;Fetch year
  DIVU.W  #100,D7		;year MOD 100
  SWAP    D7
  TST.W   D7			;Remainder of division <> NULL ?
  BNE.S   okay			;Yes -> branch
  MOVE.L  D5,D7			;Fetch year
  DIVU.W  #400,D7		;year MOD 400
  SWAP    D7
  TST.W   D7			;Remainder of division = NULL ?
  BNE.S   no_leap_day		;No -> branch
okay
  MOVE.L  D5,D7			;Fetch year
  DIVU.W  #4,D7			;year MOD 4
  SWAP    D7
  TST.W   D7			;Remainder of division = NULL ?
  BNE.S   no_leap_day		;No -> branch
  ADDQ.W  #1,D6			;days_since_1978+leap day if year=leap year
no_leap_day
  EXT.L   D6			;Word to longword
  MOVE.L  D6,D7			;days_since_1978*24
  ADD.L   D6,D6
  ADD.L   D7,D6
  LSL.L   #3,D6
  ADD.L   D2,D6			;days_since_1978*24+hours
  MOVE.L  D6,D7			;60*(days_since_1978*24+hours)
  LSL.L   #4,D6
  SUB.L   D7,D6
  LSL.L   #2,D6
  ADD.L   D1,D6			;minutes+60*(days_since_1978*24+hours)
  MOVE.L  D6,D7			;60*(minutes+60*(days_since_1978*24+hours))
  LSL.L   #4,D6
  SUB.L   D7,D6
  LSL.L   #2,D6
  ADD.L   D6,D0			;seconds+60*(minutes+60*(days_since_1978*24+hours))
  RTS

;Buffer for RTC date/time
  CNOP 0,4			;Longword alignment for MC68020+
RTC_data_struc
  DS.W 6

;Days until the beginning of the year without the days of the actual
;month and without leap day
  CNOP 0,2
days_until_beginning_of_the_year
  DC.W 0,31,59,90,120,151,181,212,243,273,304,334

timerdevname
  DC.B "timer.device",0
  EVEN


@{B}Resetting the Control F register@{UB}

And here's another routine for seeking the RTC and resetting the Control F
register. This is a saver way to detect the RTC because of three checks.
The reset could be necessary, because some nasty demos mess up this RTC
register.

;A0 = $DC0000 or $D80000
;D0 = Return value: TRUE = RTC available, FALSE = no RTC
  CNOP 0,4			;Longword alignment for MC68020+
seek_and_reset_RTC
  MOVEQ   #1,D0			;Reset RTC-Counter
  MOVE.B  D0,$3F(A0)		;Set RSET-Bit in @{"Control D-register" LINK Chapter-4-4-8-1}
  NOP				;Prevent parallel execution on the MC68060
  MOVE.B  $3F(A0),D1		;1st check: Read to check whether
  				;Control F register exists
  MOVEQ   #$F,D2
  AND.B   D2,D1			;Only Bits 0-3
  CMP.B   D1,D0                 ;Read <> Write ?
  BNE.S   reg_check_failed	;Yes -> branch
  MOVEQ   #5,D0			;Reset RTC-Counter, set 24 hours
  MOVE.B  D0,$3F(A0)
  NOP				;Prevent parallel execution on the MC68060
  MOVE.B  $3F(A0),D1		;2nd Control F register check
  AND.B   D2,D1			;Only Bits 0-3
  CMP.B   D1,D0                 ;Read <> Write ?
  BNE.S   reg_check_failed	;Yes -> branch
  MOVEQ   #4,D0			;Set 24 hours
  MOVE.B  D0,$3F(A0)
  NOP				;Prevent parallel execution on the MC68060
  MOVE.B  $3F(A0),D1		;3rd Control F register check
  AND.B   D2,D1			;Only Bits 0-3
  CMP.B   D1,D0                 ;Read <> Write ?
  BNE.S   reg_check_failed	;Yes -> branch
  MOVEQ   #0,D0			;Everything fine
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
reg_check_failed
  MOVEQ   #-1,D0		;Buy memory expansion incl. RTC or turbo card
  RTS
@ENDNODE


@NODE Chapter-4-4-8-1 "RTC registers"
@{B}4-4-8-1 RTC registers@{UB}

This is the documentation of the OKI MSM6242 B RTC registers.
x=8 means RTC of A2000-A, (A1000 if available on memory expansion or
turbo card)
x=C means RTC of A2000-B,A500+,A2500, (A500,A600,A1200 if available on
memory expansion or turbo card)

+--------+--------+--------+-----+------+------+------+--------------------+
| Address|Register|Bit31-04|Bit03|Bit02 |Bit01 |Bit00 | Description        |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0000|  S1    |       | S8  |  S4  |  S2  |  1   | 0-9 seconds unit   |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0004|  S10   |       | *   |  S40 |  S20 |  S10 | 0-5 seconds decade |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0008|  MI1   |       | M8  |  M4  |  M2  |  M1  | 0-9 minutes unit   |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx000C|  MI10  |       | *   |  M40 |  M20 |  M10 | 0-5 minutes decade |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0010|  H1    |       | H8  |  H4  |  H2  |  H1  | 0-9 hours unit     |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0014|  H10   |       | *   | PM/AM|  H20 |  H10 | 0-2/0-1 hours dec. |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0018|  D1    |       | D8  |  D4  |  D2  |  D1  | 0-9 days unit      |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx001C|  D10   |       | *   |  *   |  D20 |  D10 | 0-3 days decade    |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0020|  MO1   |       | M8  |  M4  |  M2  |  M1  | 0-9 months unit    |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0024|  MO10  |       | *   |  *   |  *   |  M10 | 0-1 months decade  |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0028|  Y1    |       | Y8  |  Y4  |  Y2  |  Y1  | 0-9 years unit     |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx002C|  Y10   |       | Y80 |  Y40 |  Y20 |  Y10 | 0-9 years decade   |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0030|  W     |       | *   |  W4  |  W2  |  W1  | 0-6 weekday        |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0034|  CD    |       | ADJ |  IRQ | BUSY | HOLD | Control register D |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx0038|  CE    |       | T1  |  T0  | ITR  | MASK | Control register E |
+--------+--------+--------+-----+------+------+------+--------------------+
| $Dx003C|  CF    |       | TEST| 24/12| STOP | RSET | Control register F |
+--------+--------+--------+-----+------+------+------+--------------------+

REST = "1" Reset counter pulse

STOP = "1" Stop counter pulse

TR  = INTERRUPT/STANDARD

Weekday: Sunday="0", Monday="1", Tuesday="2",..., Saturday="6"

Bit * does not exist (unrecognized during a write and held at "0"
during a read).

Be sure to mask the AM/PM bit when processing 10's of hour's data.

BUSY bit is read only. The IRQ FLAG bit can only be set to a "0".

Setting the IRQ FLAG to a "1" is done by hardware.

PM at "1" and AM at "0" for PM/AM bit

Bits 31-20 and 15-4 are not used. Accessing the lowest byte (bits3-0)
 automatically sets bits 19-16. Writing to the highest byte (bits 27-24)
 also sets the bits 3-0 of the lowest byte. Accessing the bits of the
 lowest byte is recommended.
@ENDNODE


@NODE Chapter-4-4-8-2 "AllocMem() Memory options"
@{B}4-4-8-2 AllocMem() Memory options@{UB}

    +-----------+------------+-------------------------------------------+
    | HEXVALUE  | FUNCTION   | DESCRIPTION                               |
    +-----------+------------+-------------------------------------------+
    | $00000000 | ANY        | Any type of memory will do                |
    | $00000001 | PUBLIC     | Memory that must not be mapped, swapped,  |
    |           |            | or otherwise made non-addressable         |
    | $00000002 | CHIP       | Memory for Amiga custom chips             |
    | $00000004 | FAST       | Non-chip memory                           |
    | $00000100 | LOCAL      | Memory that does not go away at RESET     |
    | $00000200 | 24BITDMA   | DMAable memory within 24 bits of address  |
    | $00000400 | KICK       | Memory that can be used for KickTag stuff |
    | $00010000 | CLEAR      | NULL out area before return               |
    | $00040000 | REVERSE    | Allocate from the top down                |
    | $80000000 | NO_EXPUNGE | Do not cause expunge on failure           |
    +-----------+------------+-------------------------------------------+
@ENDNODE


@NODE Chapter-4-4-9 "4 Optimizing & tricks / MC680x0 family / Caches handling"
@{B}4-4-9 Caches handling@{UB}

One of the biggest obstacles coding on the Amiga are the caches of the
MC68020+. There is lots of book ware and tutorials how to code the MC68000
but the rest of the family is neglected.

       4-4-9-1 @{" Turning caches off " LINK Chapter-4-4-9-1}
       4-4-9-2 @{" Turning caches on " LINK Chapter-4-4-9-2}
       4-4-9-3 @{" Flushing caches " LINK Chapter-4-4-9-3}
       4-4-9-4 @{" Cache Control Register " LINK Chapter-4-4-9-4}
@ENDNODE


@NODE Chapter-4-4-9-1 "4 Optimizing & tricks / MC680x0 family / Caches handling / Turning caches off"
@{B}4-4-9-1 Turning caches off@{UB}

If you write self modifying code and you want your OCS demos also run on
the A1200/A4000 or an Amiga with an accelerated card, turning the caches
off is better.

So here's some code that makes the handling easier. This routine works on
OS 1.2/1.3/MC680020+ directly accessing the @{"CACR" LINK Chapter-4-4-9-4} via @{"Supervisor()" LINK Supervisor()} or
on OS 2.0+/MC68020+ using the @{"CacheControl()" LINK CacheControl()} function turning off the
instruction cache, the data cache and the branch cache if available:

  CNOP 0,4			;Longword alignment for MC68020+
caches_off
  MOVE.L  $4.W,A6		;Get exec-base
  BTST    #1,$129(A6)		;@{"AttnFlags" LINK Chapter-4-4-9-5}: MC68020 or better available ?
  BEQ.S   no_680x0		;MC68000 -> branch
  CMP.W   #36,$14(A6)		;LIB_VERSION: OS 2.0 or better available ?
  BLT.S   no_new_os		;Old OS -> branch

; Turn off caches on OS 2.0+
  MOVEQ   #TRUE,D0		;Clear the selected bits in D1
  MOVE.L  #$C0000101,D1		;@{"cacheBits" LINK Chapter-4-4-9-6}: CACRF_EnableI+CACRF_EnableD+
				;CACRF_EnableE+CACRF_CopyBack
  JSR     -$288(A6)		;@{"CacheControl()" LINK CacheControl()} flush caches&turn them off
  MOVE.L  D0,old_CACR		;Save content of OS-CACR
no_680x0
  RTS

; Turn off caches off OS 1.2/1.3
  CNOP 0,4			;Longword alignment for MC68020+
no_new_os
  LEA     caches_off_old(PC),a5 ;Supervisor-Routine for manual code
  JSR     -$1E(A6)		;@{"Supervisor()" LINK Supervisor()} turn caches off
  MOVE.L  D0,old_CACR		;Save content of real CACR
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
caches_off_old
  OR.W    #$0700,SR		;@{"Level-7-interrupt" LINK Chapter-4-4-13-1} priority
  MOVEC   CACR,D0		;(DC.L $4E7A0002) Read CACR
  BTST    #3,$129(A6)		;@{"AttnFlags" LINK Chapter-4-4-9-5}: MC68040 or better available ?
  BEQ.S   no_68040_60		;No -> branch
  CPUSHA  BC			;(DC.W $F4F8) Flush Instruction+Data-Cache
  MOVEQ   #0,D1			;@{"CACR" LINK Chapter-4-4-9-4-4}: Turn off Instr.+Data+Branch-Cache
  BRA.S   write_cacr
  CNOP 0,4			;Longword alignment for MC68020+
no_68040_60
  MOVE.L  #$0E0E,D1		;@{"CACR" LINK Chapter-4-4-9-4-2}: Turn off, freeze&clear caches
write_cacr
  MOVEC   D1,CACR		;(DC.L $4E7B1002) New content of real CACR
  NOP                           ;Prevent parallel execution on the MC68060
  RTE

  CNOP 0,4
oldCACR	DC.L 0
@ENDNODE


@NODE Chapter-4-4-9-2 "4 Optimizing & tricks / MC680x0 family / Caches handling / Turning caches on"
@{B}4-4-9-2 Turning caches on@{UB}

This routine works on OS 1.2/1.3/MC680020+ directly accessing the @{"CACR" LINK Chapter-4-4-9-4}
via @{"Supervisor()" LINK Supervisor()} or on OS 2.0+/MC68020+ using the @{"CacheControl()" LINK CacheControl()} function.

It's the opposite of the previous routine @{"Turning caches off" LINK Chapter-4-4-9-1} which turns
on the formerly activated caches again:

  CNOP 0,4			;Longword alignment for MC68020+
caches_on
  MOVE.L  $4.W,A6		;Get exec-base
  BTST    #1,$129(A6)		;@{"AttnFlags" LINK Chapter-4-4-9-5}: MC68020 or better available?
  BEQ.S   no_680x0_2		;MC68000 -> branch
  MOVE.L  old_CACR(PC),D0 	;Old content of CACR
  CMP.W   #36,$14(A6)		;LIB_VERSION: OS 2.0 or better available ?
  BLT.S   no_new_os2		;Old OS -> branch

; Turn caches on OS 2.0+
  MOVEQ   #-1,D1		;Consider all bits in D0 = Mask
  JMP     -$288(A6)		;@{"CacheControl()" LINK CacheControl()} flush & activate caches
  CNOP 0,4			;Longword alignment for MC68020+
no_680x0_2
  RTS

; Turn caches on OS 1.2/1.3
  CNOP 0,4			;Longword alignment for MC68020+
no_new_os2
  LEA     caches_on_old(PC),a5	;Supervisor-Routine for manual code
  JMP     -$1E(A6)		;@{"Supervisor()" LINK Supervisor()} turn caches on

; D0=old content of real CACR
  CNOP 0,4			;Longword alignment for MC68020+
caches_on_old
  OR.W    #$0700,SR		;@{"Level-7-interrupt" LINK Chapter-4-4-13-1} priority
  MOVEC   D0,CACR		;(DC.L $4E7B0002) New content of real CACR
  NOP                           ;Prevent parallel execution on the MC68060
  RTE

  CNOP 0,4			;Longword alignment for MC68020+
oldCACR	DC.L 0

This is one way but not the optimum. Using the caches and its benefits
is much better even if you only write OCS-demos. There could be maybe
an extended version of an effect (more stars, BOBs, etc.) if a MC68020+
is detected. Think about it...
@ENDNODE


@NODE Chapter-4-4-9-3 "4 Optimizing & tricks / MC680x0 family / Caches handling / Flushing caches"
@{B}4-4-9-3 Flushing caches@{UB}

When you made the decision to use the caches instead of turning them off,
don't forget to flush them after the following operations:

- Self modifying code
- Run-time code patches
- Relocating code for use at different addresses
- Loading code from disk: After you read data from disk into CHIP memory
  and converted the MFM data into a different portion of memory
- Changing/building jump tables: The best example is changing one of the
  @{"Interrupts Autovectors" LINK Chapter-4-4-9-7} or copying and moving the @{"Exception Vectors table" LINK Chapter-4-4-9-7}
  with the VBR register into FAST memory
- Patching library functions

After these operations it is useful to call @{"CacheClearU()" LINK "CacheClearU()"} (Offset -636)
under OS 2.0+.

But what do we do on OS 1.2/1.3 which don't provide this way of cache
flushing?

Let's examine what the routine CacheClearU() of the OS 3.0/3.1 does. I've
modified it a little bit for the code running out of FAST memory:

;A6=Pointer to Exec-base

  CNOP 0,4			;Longword alignment for MC68020+
CacheClearU
  MOVE.L  #$00000808,D1 	;@{"CACR" LINK Chapter-4-4-9-4-2}: Clear Data&Intruction Cache
  MOVE.L  A5,A0
  LEA     supervisor_rout(PC),A5 ;Supervisor-Routine for manual code
  JMP     -$1E(A6)		;@{"Supervisor()" LINK Supervisor()}
  CNOP 0,4			;Longword alignment for MC68020+
supervisor_rout
  BTST    #3,$129(A6)		;@{"AttnFlags" LINK Chapter-4-4-9-5}: MC68040 or better?
  BNE.S   cpu_68040_60		;Yes -> branch
  AND.L   #$00000808,D1		;CACR: Only bits CI+CD
  OR.W    #$0700,SR		;@{"Level-7-interrupt" LINK Chapter-4-4-13-1} priority
  MOVEC   CACR,D0		;(DC.L $4E7A0002) Get CACR content
  OR.L    D1,D0			;CACR: Clear intruction&data cache
  MOVEC   D0,CACR		;(DC.L $4E7B0002) new content
  MOVE.L  A0,A5
  RTE
  CNOP 0,4			;Longword alignment for MC68020+
cpu_68040_60
  BTST    #3,D1			;CACR: CI-Bit set?
  BNE.S   clear_both_caches 	;Yes -> branch
  CPUSHA  DC			;(DC.W $F478) Clear Data cache of MC68040/60
  MOVE.L  A0,A5
  NOP                           ;Prevent parallel execution on the MC68060
  RTE
  CNOP 0,4			;Longword alignment for MC68020+
clear_both_caches
  CPUSHA  BC			;(DC.W $F4F8) Clear instr&data cache of the
				;MC68040/60
  MOVE.L  A0,A5
  NOP                           ;Prevent parallel execution on the MC68060
  RTE

Hmm, looks good, but this can be optimized:

;CacheClearU for OS 1.2/1.3

;A6=Pointer to Exec-base

  CNOP 0,4			;Longword alignment for MC68020+
CacheClearU
  MOVE.L  A5,A0
  LEA     supervisor_rout(PC),A5 ;Supervisor-Routine for manual code
  JMP     -$1E(A6)		;@{"Supervisor()" LINK Supervisor()}
  CNOP 0,4			;Longword alignment for MC68020+
supervisor_rout
  BTST    #3,$129(A6)		;@{"AttnFlags" LINK Chapter-4-4-9-5}: MC68040 or better?
  BNE.S   cpu_68040_60		;Yes -> branch
  OR.W    #$0700,SR		;@{"Level-7-interrupt" LINK Chapter-4-4-13-1} priority
  MOVEC   CACR,D0		;(DC.L $4E7A0002) Get CACR content
  OR.W    #$0808,D0		;@{"CACR" LINK Chapter-4-4-9-4-2}: Clear Data&Intruction Cache
  MOVEC   D0,CACR		;(DC.L $4E7B0002) new content
  MOVE.L  A0,A5
  RTE
  CNOP 0,4			;Longword alignment for MC68020+
cpu_68040_60
  CPUSHA  BC			;(DC.W $F4F8) Clear instr&data cache of the
				;MC68040/60
  MOVE.L  A0,A5
  NOP                           ;Prevent parallel execution on the MC68060
  RTE
@ENDNODE


@NODE Chapter-4-4-9-4 "4 Optimizing & tricks / MC680x0 family / Caches handling / Cache Control Register"
@{B}4-4-9-4 Cache Control Register@{UB}

         4-4-9-4-1 @{" CACR of the MC68020 " LINK Chapter-4-4-9-4-1}
         4-4-9-4-2 @{" CACR of the MC68030 " LINK Chapter-4-4-9-4-2}
         4-4-9-4-3 @{" CACR of the MC68040 " LINK Chapter-4-4-9-4-3}
         4-4-9-4-4 @{" CACR of the MC68060 " LINK Chapter-4-4-9-4-4}
@ENDNODE


@NODE Chapter-4-4-9-4-1 "4 Optimizing & tricks / MC680x0 family / Caches handling / Cache Control Register / CACR of the MC68020"
NAME  CPU      type  Description
----------------------------------------------------------------------------
CACR  MC68020  R/W   Cache Control Register

      The CACR controls the on-chip instruction cache of the MC68020/EC020.

         +------+----------+----------------------------------+
         | BIT# | FUNCTION | DESCRIPTION                      |
         +------+----------+----------------------------------+
         |  31  |    X     | Reserved                         |
         |  30  |    X     | Reserved                         |
         |  29  |    X     | Reserved                         |
         |  28  |    X     | Reserved                         |
         |  27  |    X     | Reserved                         |
         |  26  |    X     | Reserved                         |
         |  25  |    X     | Reserved                         |
         |  24  |    X     | Reserved                         |
         |  23  |    X     | Reserved                         |
         |  22  |    X     | Reserved                         |
         |  21  |    X     | Reserved                         |
         |  20  |    X     | Reserved                         |
         |  19  |    X     | Reserved                         |
         |  18  |    X     | Reserved                         |
         |  17  |    X     | Reserved                         |
         |  16  |    X     | Reserved                         |
         |  15  |    X     | Reserved                         |
         |  14  |    X     | Reserved                         |
         |  13  |    X     | Reserved                         |
         |  12  |    X     | Reserved                         |
         |  11  |    X     | Reserved                         |
         |  10  |    X     | Reserved                         |
         |  09  |    X     | Reserved                         |
         |  08  |    X     | Reserved                         |
         |  07  |    X     | Reserved                         |
         |  06  |    X     | Reserved                         |
         |  05  |    X     | Reserved                         |
         |  04  |    X     | Reserved                         |
         |  03	|    C     | Clear Instruction Cache          |
         |  02	|    CE    | Clear entry in Instruction Cache |
         |  01	|    F     | Freeze Instruction Cache         |
         |  00	|    E     | Enable Instruction Cache         |
         +------+----------+----------------------------------+

C-Clear Cache
The C-bit is set to clear all entries in the instruction cache. Operating
systems and other software set this bit to clear instructions from the
cache prior to a context switch. The processor clears all valid bits in
the instruction cache when a MOVEC instruction sets the C-bit. The C-bit
is always read as a zero.

CE-Clear Entry In Cache
The CE bit is set to clear an entry in the instruction cache. The index
field of the CAAR, corresponding to the index and long-word select portion
of an address, specifies the entry to be cleared. The processor clears
only the specified long word by clearing the valid bit for the entry when
a MOVEC instruction sets the CE bit, regardless of the states of the E and
F bits. The CE bit is always read as a zero.

F-Freeze Cache
The F-bit is set to freeze the instruction cache. When the F-bit is set
and a cache miss occurs, the entry (or line) is not replaced. When the
F-bit is clear, a cache miss causes the entry (or line) to be filled.
A reset operation clears the F-bit.

E-Enable Cache
The E-bit is set to enable the instruction cache. When it is clear, the
instruction cache is disabled. A reset operation clears the E-bit. The
supervisor normally enables the instruction cache, but it can clear the
E-bit for system debugging or emulation, as required. Disabling the
instruction cache does not flush the entries. If the cache is re-enabled,
the previously valid entries remain valid and may be used.
@ENDNODE


@NODE Chapter-4-4-9-4-2 "4 Optimizing & tricks / MC680x0 family / Caches handling / Cache Control Register / CACR of the MC68030"
NAME  CPU      type  Description
----------------------------------------------------------------------------
CACR  MC68030  R/W   Cache Control Register

      The Cache Control register (CACR) controls the on-chip instruction
      and data caches of the MC68030.

         +------+----------+----------------------------------+
         | BIT# | FUNCTION | DESCRIPTION                      |
         +------+----------+----------------------------------+
         |  31  |   X      | Reserved                         |
         |  30  |   X      | Reserved                         |
         |  29  |   X      | Reserved                         |
         |  28  |   X      | Reserved                         |
         |  27  |   X      | Reserved                         |
         |  26  |   X      | Reserved                         |
         |  25  |   X      | Reserved                         |
         |  24  |   X      | Reserved                         |
         |  23  |   X      | Reserved                         |
         |  22  |   X      | Reserved                         |
         |  21  |   X      | Reserved                         |
         |  20  |   X      | Reserved                         |
         |  19  |   X      | Reserved                         |
         |  18  |   X      | Reserved                         |
         |  17  |   X      | Reserved                         |
         |  16  |   X      | Reserved                         |
         |  15  |   X      | Reserved                         |
         |  14  |   X      | Reserved                         |
         |  13  |   WA     | Write Allocate                   |
         |  12  |   DBE    | Data Burst Enable                |
         |  11  |   CD     | Clear Data Cache                 |
         |  10  |   CED    | Clear Entry in Data Cache        |
         |  09  |   FD     | Freeze Data Cache                |
         |  08  |   ED     | Enable Data Cache                |
         |  07  |   X      | Reserved                         |
         |  06  |   X      | Reserved                         |
         |  05  |   X      | Reserved                         |
         |  04  |   IBE    | Instruction Burst Enable         |
         |  03	|   CI     | Clear Instruction Cache          |
         |  02	|   CEI    | Clear entry in Instruction Cache |
         |  01	|   FI     | Freeze Instruction Cache         |
         |  00	|   EI     | Enable Instruction Cache         |
         +------+----------+----------------------------------+

WRITE ALLOCATE
Bit 13, the WA bit, is set to select the write-allocation mode for write
cycles. Clearing this bit selects the no-write-allocation mode. A reset
operation clears this bit. The supervisor should set this bit when it
shares data with the user task or when any task maps multiple logical
addresses to one physical address. If the data cache is disabled or
frozen, the WA bit is ignored.

DATA BURST ENABLE
Bit 12, the DBE bit, is set to enable burst filling of the data cache.
Operating systems and other software set this bit when burst filling of
the data cache is desired. A reset operation clears the DBE bit.

CLEAR DATA CACHE
Bit 11, the CD bit, is set to clear all entries in the data cache.
Operating systems and other software set this bit to clear data from the
cache prior to a context switch. The processor clears all valid bits in
the data cache at the time a MOVEC instruction loads a one into the CD
bit of the CACR. The CD bit is always read as a zero.

CLEAR ENTRY IN DATA CACHE
Bit 10, the CED bit, is set to clear an entry in the data cache. The
index field of the CAAR corresponding to the index and long-word select
portion of an address specifies the entry to be cleared. The processor
clears only the specified long word by clearing the valid bit for the
entry at the time a MOVEC instruction loads a one into the CED bit of
the CACR, regardless of the states of the ED and FD bits. The CED bit
is always read as a zero.

FREEZE DATA CACHE
Bit 9, the FD bit, is set to freeze the data cache. When the FD bit is
set and a miss occurs during a read or write of the data cache, the
indexed entry is not replaced. However, write cycles that hit in the
data cache cause the entry to be updated even when the cache is frozen.
When the FD bit is clear, a miss in the data cache during a read cycle
causes the entry (or line) to be filled, and the filling of entries on
writes that miss are then controlled by the WA bit. A reset operation
clears the FD bit.

ENABLE DATA CACHE
Bit 8, the ED bit, is set to enable the data cache. When it is cleared,
the data cache is disabled. A reset operation clears the ED bit. The
supervisor normally enables the data cache, but it can clear ED for
system debugging or emulation, as required. Disabling the data cache
does not flush the entries. If it is enabled again, the previously
valid entries remain valid and can be used.

INSTRUCTION BURST ENABLE
Bit 4, the IBE bit, is set to enable burst filling of the instruction
cache. Operating systems and other software set this bit when burst
filling of the instruction cache is desired. A reset operation clears
the IBE bit.

CLEAR INSTRUCTION CACHE
Bit 3, the CI bit, is set to clear all entries in the instruction cache.
Operating systems and other software set this bit to clear instructions
from the cache prior to a context switch. The processor clears all valid
bits in the instruction cache at the time a MOVEC instruction loads a one
into the CI bit of the CACR. The CI bit is always read as a zero.

CLEAR ENTRY IN INSTRUCTION CACHE
Bit 2, the CEI bit, is set to clear an entry in the instruction cache.
The index field of the CAAR corresponding to the index and long-word
select portion of an address specifies the entry to be cleared. The
processor clears only the specified long word by clearing the valid
bit for the entry at the time a MOVEC instruction loads a one into
the CEI bit of the CACR, regardless of the states of the EI and FI
bits. The CEI bit is always read as a zero.

FREEZE INSTRUCTION CACHE
Bit 1, the FI bit, is set to freeze the instruction cache. When the
FI bit is set and a miss occurs in the instruction cache, the entry
(or line) is not replaced. When the FI bit is cleared to zero, a miss
in the instruction cache causes the entry (or line) to be filled. A
reset operation clears the FI bit.

ENABLE INSTRUCTION CACHE
Bit 0, the EI bit, is set to enable the instruction cache. When it is
cleared, the instruction cache is disabled. A reset operation clears
the EI bit. The supervisor normally enables the instruction cache, but
it can clear EI for system debugging or emulation, as required. Disabling
the instruction cache does not flush the entries. If it is enabled again,
the previously valid entries remain valid and may be used.
@ENDNODE


@NODE Chapter-4-4-9-4-3 "4 Optimizing & tricks / MC680x0 family / Caches handling / Cache Control Register / CACR of the MC68040"
NAME  CPU      type  Description
----------------------------------------------------------------------------
CACR  MC68040  R/W   Cache Control Register

      The Cache Control register (CACR) controls enabling of the on-chip
      instruction and data caches of the MC68040.

         +------+----------+----------------------------------+
         | BIT# | FUNCTION | DESCRIPTION                      |
         +------+----------+----------------------------------+
         |  31  |    DE    | Enable Data Cache                |
         |  30  |    X     | Reserved                         |
         |  29  |    X     | Reserved                         |
         |  28  |    X     | Reserved                         |
         |  27  |    X     | Reserved                         |
         |  26  |    X     | Reserved                         |
         |  25  |    X     | Reserved                         |
         |  24  |    X     | Reserved                         |
         |  23  |    X     | Reserved                         |
         |  22  |    X     | Reserved                         |
         |  21  |    X     | Reserved                         |
         |  20  |    X     | Reserved                         |
         |  19  |    X     | Reserved                         |
         |  18  |    X     | Reserved                         |
         |  17  |    X     | Reserved                         |
         |  16  |    X     | Reserved                         |
         |  15  |    IE    | Enable Instruction Cache         |
         |  14  |    X     | Reserved                         |
         |  13  |    X     | Reserved                         |
         |  12  |    X     | Reserved                         |
         |  11  |    X     | Reserved                         |
         |  10  |    X     | Reserved                         |
         |  09  |    X     | Reserved                         |
         |  08  |    X     | Reserved                         |
         |  07  |    X     | Reserved                         |
         |  06  |    X     | Reserved                         |
         |  05  |    X     | Reserved                         |
         |  04  |    X     | Reserved                         |
         |  03  |    X     | Reserved                         |
         |  02  |    X     | Reserved                         |
         |  01  |    X     | Reserved                         |
         |  00  |    X     | Reserved                         |
         +------+----------+----------------------------------+
@ENDNODE


@NODE Chapter-4-4-9-4-4 "4 Optimizing & tricks / MC680x0 family / Caches handling / Cache Control Register / CACR of the MC68060"
NAME  CPU      type  Description
----------------------------------------------------------------------------
CACR  MC68060  R/W   Cache Control Register

      The Cache Control register (CACR) controls enabling of the on-chip
      instruction and data caches of the MC68060.

       +------+----------+-------------------------------------------------+
       | BIT# | FUNCTION | DESCRIPTION                                     |
       +------+----------+-------------------------------------------------+
       |  31  | EDC      | Enable Data Cache                               |
       |  30  | NAD      | No Allocate Mode (Data Cache)                   |
       |  29  | ESB      | Enable Store Buffer                             |
       |  28  | DPI      | Disable CPUSH Invalidation                      |
       |  27  | FOC-1/2  | Cache Operation Mode Enable (Data Cache)        |
       |  26  | X        | Reserved                                        |
       |  25  | X        | Reserved                                        |
       |  24  | X        | Reserved                                        |
       |  23  | EBC      | Enable Branch Cache                             |
       |  22  | CABC     | Clear All Entries in the Branch Cache           |
       |  21  | CUBC     | Clear All User Entries in the Branch Cache      |
       |  20  | X        | Reserved                                        |
       |  19  | X        | Reserved                                        |
       |  18  | X        | Reserved                                        |
       |  17  | X        | Reserved                                        |
       |  16  | X        | Reserved                                        |
       |  15  | EIC      | Enable Instruction Cache                        |
       |  14  | NAI      | No Allocate Mode (Instruction Cache)            |
       |  13  | FIC-1/2  | Cache Operation Mode Enable (Instruction Cache) |
       |  12  | X        | Reserved                                        |
       |  11  | X        | Reserved                                        |
       |  10  | X        | Reserved                                        |
       |  09  | X        | Reserved                                        |
       |  08  | X        | Reserved                                        |
       |  07  | X        | Reserved                                        |
       |  06  | X        | Reserved                                        |
       |  05  | X        | Reserved                                        |
       |  04  | X        | Reserved                                        |
       |  03  | X        | Reserved                                        |
       |  02  | X        | Reserved                                        |
       |  01  | X        | Reserved                                        |
       |  00  | X        | Reserved                                        |
       +------+----------+-------------------------------------------------+

EDC-Enable Data Cache
0 = Data cache is disabled.
1 = Data cache is enabled.

NAD-No Allocate Mode (Data Cache)
0 = Read and write misses will allocate in the data cache.
1 = Read and write misses will not allocate in the data cache.

ESB-Enable Store Buffer
0 = All writes to writethrough or cache-inhibited imprecise pages will
    bypass the store buffer and generate bus cycles directly.
1 = The four entry first-in-first-out (FIFO) store buffer to the MC68060
    is enabled. This buffer is used to defer pending writes to writethrough
    or cache-inhibited imprecise pages to maximize performance. Locked
    write accesses and accesses to cache-inhibited precise pages always
    bypass the store buffer.

DPI-Disable CPUSH Invalidation
0 = Each cache line is invalidated as it is pushed. Affects only the data
    cache.
1 = CPUSHed lines remain valid in the cache.

FOC-1/2 Cache Operation Mode Enable (Data Cache)
0 = The data cache operates in normal, full-cache mode.
1 = The data cache operates in 1/2-cache mode.

Bits 26-24-Reserved.

EBC-Enable Branch Cache
0 = The branch cache is disabled and branch cache information is not used
    in the branch prediction strategy.
1 = The on-chip branch cache is enabled. Branches are cached. A predicted
    branch executes more quickly, and often can be folded onto another
    instruction.

CABC-Clear All Entries in the Branch Cache
This bit is always read as zero.
0 = No operation is done on the branch cache.
1 = The entire content of the MC68060 branch cache is invalidated.

CUBC-Clear All User Entries in the Branch Cache
This bit is always read as zero.
0 = No operation is performed on the branch cache.
1 = All user-mode entries in the MC68060 branch cache are invalidated;
    supervisor-mode branch cache entries remain valid.

Bits 20-16-Reserved.

EIC-Enable Instruction Cache
0 = Instruction cache is disabled.
1 = Instruction cache is enabled.

NAI-No Allocate Mode (Instruction Cache)
0 = Accesses that miss in the instruction cache will allocate.
1 = The instruction cache will continue to supply instructions to the
    processor, but an access that misses will not allocate.

FIC-1/2 Cache Operation Mode Enable (Instruction Cache)
0 = The instruction cache operates in normal, full-cache mode.
1 = The instruction cache operates in 1/2-cache mode
@ENDNODE


@NODE Chapter-4-4-9-5 "4 Optimizing & tricks / MC680x0 family / Caches handling / AttnFlags"
@{B}4-4-9-5 Attn Flags@{UB}

       +------+----------+--------------------+
       | BIT# | FUNCTION | DESCRIPTION        |
       +------+----------+--------------------+
       |  15  | X        | Private            |
       |  14  | X        | Reserved           |
       |  13  | X        | Reserved           |
       |  12  | X        | Reserved           |
       |  11  | X        | Reserved           |
       |  10  | X        | Reserved           |
       |  09  | X        | Reserved           |
       |  08  | X        | Reserved           |
       |  07  | 68060    |                    |
       |  06  | FPU40    | Set if 68040 FPU  |
       |  05  | 68882    |                    |
       |  04  | 68881    | also set for 68882 |
       |  03  | 68040    | also set for 68060 |
       |  02  | 68030    | also set for 68040 |
       |  01  | 68020    | also set for 68030 |
       |  00  | 68010    | also set for 68020 |
       +------+----------+--------------------+

The AFB_FPU40 bit is set when a working 68040 FPU is in the system.
 If this bit is set and both the AFB_68881 and AFB_68882 bits are not
 set, then the 68040 math emulation code has not been loaded and only
 68040 FPU instructions are available.  This bit is valid *ONLY* if
 the AFB_68040 bit is set.
@ENDNODE


@NODE Chapter-4-4-9-6 "4 Optimizing & tricks / MC680x0 family / Caches handling / CacheControl() cacheBits"
@{B}4-4-9-6 CacheControl() cacheBits@{UB}

   +------+---------------+------------------------------------------------+
   | BIT# | FUNCTION      | DESCRIPTION                                    |
   +------+---------------+------------------------------------------------+
   |  31  | CopyBack      | Master enable for copyback caches              |
   |  30  | EnableE       | Master enable for external caches             |
   |  29  | X             | Reserved                                       |
   |  28  | X             | Reserved                                       |
   |  27  | X             | Reserved                                       |
   |  26  | X             | Reserved                                       |
   |  25  | X             | Reserved                                       |
   |  24  | X             | Reserved                                       |
   |  23  | X             | Reserved                                       |
   |  22  | X             | Reserved                                       |
   |  21  | X             | Reserved                                       |
   |  20  | X             | Reserved                                       |
   |  19  | X             | Reserved                                       |
   |  18  | X             | Reserved                                       |
   |  17  | X             | Reserved                                       |
   |  16  | X             | Reserved                                       |
   |  15  | X             | Reserved                                       |
   |  14  | X             | Reserved                                       |
   |  13  | WriteAllocate | 68030 Write-Allocate mode (must always be set) |
   |  12  | DBE           | 68030 Data burst enable                        |
   |  11  | ClearD        | 68030 Clear data cache                         |
   |  10  | X             | Reserved                                       |
   |  09  | FreezeD       | 68030 Freeze data cache                        |
   |  08  | EnableD       | 68030 Enable data cache                        |
   |  07  | X             | Reserved                                       |
   |  06  | X             | Reserved                                       |
   |  05  | X             | Reserved                                       |
   |  04  | IBE           | Instruction burst enable                       |
   |  03  | ClearI        | Clear instruction cache                        |
   |  02  | X             | Reserved                                       |
   |  01  | FreezeI       | Freeze instruction cache                       |
   |  00  | EnableI       | Enable instruction cache                       |
   +------+---------------+------------------------------------------------+

External caches should track the state of the internal caches such that
 they do not cache anything that the internal cache turned off for.
@ENDNODE


@NODE Chapter-4-4-9-7 "4 Optimizing & tricks / MC680x0 family / Caches handling / Exception Vectors table"
@{B}4-4-9-7 Exception Vectors table@{UB}

      +----------------+------------+--------------------------------+
      | Vectors Number | Address    |                                |
      +-------+--------+------+-----+                                |
      | Hex   | Dec    | Dec  | Hex | Assignment                     |
      +-------+--------+------+-----+--------------------------------+
      | 0     | 0      | 0    | 000 | Reset: Initial SSP            |
      +-------+--------+------+-----+--------------------------------+
      | 1     | 1      | 4    | 004 | Reset: Initial PC             |
      +-------+--------+------+-----+--------------------------------+
      | 2     | 2      | 8    | 008 | Bus Error                      |
      +-------+--------+------+-----+--------------------------------+
      | 3     | 3      | 12   | 00C | Address Error                  |
      +-------+--------+------+-----+--------------------------------+
      | 4     | 4      | 16   | 010 | Illegal Instruction            |
      +-------+--------+------+-----+--------------------------------+
      | 5     | 5      | 20   | 014 | Zero Divide                    |
      +-------+--------+------+-----+--------------------------------+
      | 6     | 6      | 24   | 018 | CHK Instruction                |
      +-------+--------+------+-----+--------------------------------+
      | 7     | 7      | 28   | 01C | TRAPV Instruction              |
      +-------+--------+------+-----+--------------------------------+
      | 8     | 8      | 32   | 020 | Privilege Violation            |
      +-------+--------+------+-----+--------------------------------+
      | 9     | 9      | 36   | 024 | Trace                          |
      +-------+--------+------+-----+--------------------------------+
      | A     | 10     | 40   | 028 | Line 1010 Emulator             |
      +-------+--------+------+-----+--------------------------------+
      | B     | 11     | 44   | 02C | Line 1111 Emulator             |
      +-------+--------+------+-----+--------------------------------+
      | C     | 12    | 48   | 030 | (Unassigned, Reserved)         |
      +-------+--------+------+-----+--------------------------------+
      | D     | 13    | 52   | 034 | (Unassigned, Reserved)         |
      +-------+--------+------+-----+--------------------------------+
      | E     | 14     | 56   | 038 | Format Error~                  |
      +-------+--------+------+-----+--------------------------------+
      | F     | 15     | 60   | 03C | Uninitialized Interrupt Vector |
      +-------+--------+------+-----+--------------------------------+
      | 10-17 | 16-23 | 64   | 040 | (Unassigned, Reserved)         |
      |       |        | 92   | 05C | ---                            |
      +-------+--------+------+-----+--------------------------------+
      | 18    | 24     | 96   | 060 | Spurious Interrupt            |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}19@{FG TEXT}    | @{FG FILL}25@{FG TEXT}     | @{FG FILL}100@{FG TEXT}  | @{FG FILL}064@{FG TEXT} | @{FG FILL}Level 1 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1A@{FG TEXT}    | @{FG FILL}26@{FG TEXT}     | @{FG FILL}104@{FG TEXT}  | @{FG FILL}068@{FG TEXT} | @{FG FILL}Level 2 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1B@{FG TEXT}    | @{FG FILL}27@{FG TEXT}     | @{FG FILL}108@{FG TEXT}  | @{FG FILL}06C@{FG TEXT} | @{FG FILL}Level 3 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1C@{FG TEXT}    | @{FG FILL}28@{FG TEXT}     | @{FG FILL}112@{FG TEXT}  | @{FG FILL}070@{FG TEXT} | @{FG FILL}Level 4 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1D@{FG TEXT}    | @{FG FILL}29@{FG TEXT}     | @{FG FILL}116@{FG TEXT}  | @{FG FILL}074@{FG TEXT} | @{FG FILL}Level 5 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1E@{FG TEXT}    | @{FG FILL}30@{FG TEXT}     | @{FG FILL}120@{FG TEXT}  | @{FG FILL}078@{FG TEXT} | @{FG FILL}Level 6 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}1F@{FG TEXT}    | @{FG FILL}31@{FG TEXT}     | @{FG FILL}124@{FG TEXT}  | @{FG FILL}07C@{FG TEXT} | @{FG FILL}Level 7 Interrupt Autovector@{FG TEXT}   |
      +-------+--------+------+-----+--------------------------------+
      | @{FG FILL}20-2F@{FG TEXT} | @{FG FILL}32-47@{FG TEXT}  | @{FG FILL}128@{FG TEXT}  | @{FG FILL}080@{FG TEXT} | @{FG FILL}TRAP Instruction Vectors@{FG TEXT}      |
      |       |        | @{FG FILL}188@{FG TEXT}  | @{FG FILL}0BC@{FG TEXT} | @{FG FILL}---@{FG TEXT}                            |
      +-------+--------+------+-----+--------------------------------+
      | 30-3F | 48-63 | 192  | 0C0 | (Unassigned, Reserved)         |
      |       |        | 255  | 0FF | ---                            |
      +-------+--------+------+-----+--------------------------------+
      | 40-FF | 64-255 | 256  | 100 | User Interrupt Vectors         |
      |       |        | 1020 | 3FC | ---                            |
      +-------+--------+------+-----+--------------------------------+
      
NOTES:
Vector numbers 12, 13, 16-23, and 48-63 are reserved for future
 enhancements by Motorola. No user peripheral devices should be
 assigned these numbers.
Reset vector (0) requires four words, unlike the other vectors which only
 require two words, and is located in the supervisor program space.
The spurious interrupt vector is taken when there is a bus error
 indication during interrupt processing.
@{FG FILL}TRAP #n uses vector number 32+ n.@{FG TEXT}
~MC68010 only. This vector is unassigned, reserved on the MC68000
 and MC68008.
@ENDNODE


@NODE Chapter-4-4-10 "4 Optimizing & tricks / MC680x0 family / Setting dots for area filling"
@{B}4-4-10 Setting dots for area filling@{UB}

For a twister-routine with filled faces, it might be useful to let the CPU
and the blitter do different tasks parallel. The blitter would fill the
bitplanes and the CPU would set the border-dots of the faces line by line.
In this case, faces with colour number 1 and faces with colour number 3 for
example have an overlap in the first bitplane.

These dots can't be normally ORed into the bitplane by the CPU with the
BSET command. They must be XORed with the BCHG command. Otherwise the
blitter couldn't fill the faces properly.

This could look like this:

;D0 = Start point xpos
;D1 = Endpoint xpos
;D7 = Face colour number 1...3
;A0 = Pointer to bitplane1

plane_width = 40		;For 320 pixels

set_dots
  MOVE.W  D0,D1			;Save xp1
  NOT.B   D0			;Bit-nr.
  LSR.W   #3,D1			;/8 = x-offset
  MOVE.W  D2,D3			;Save xp2
  NOT.B   D2			;Bit-nr.
  LSR.W   #3,D3			;/8 = x-offset
check_plane1
  BTST    #0,D7			;Plane1 ?
  BEQ.S   check_plane2		;No -> branch
  BCHG    D0,(A0,D1.w)		;Set start point
  BCHG    D2,(A0,D3.w)		;Set end point
check_plane2
  BTST    #1,D7			;Plane2 ?
  BEQ.S   no_face		;No -> branch
  BCHG    D0,plane_width(A0,D1.w) ;Set start point
  BCHG    D2,plane_width(A0,D3.w) ;Set end point
no_face
...etc...
@ENDNODE


@NODE Chapter-4-4-11 "4 Optimizing & tricks / MC680x0 family / Crunching data sections"
@{B}4-4-11 Crunching data sections@{UB}

Writing intros or demos often is a fight against the elements, in this case
the hunt for free memory. You want to show the audience what you can do on
this machine, but the graphics and the sound need too much memory, or the
exe-file is too long.

I had this problem while I coded my production @{I}COPPERrulez.AGAin@{UI}. By that
time I had no experience in crunching/decrunching code sections or what
cruncher to use for it.

Later while I coded the Resistance production @{I}Future Balls@{UI}, I got a very
important hint from @{I}Sachy@{UI} of Resistance. He told me to use the program
@{I}Stonecracker@{UI}. Many thanks for that, Sachy. It's a good cruncher. You can use
it for exefiles, for your graphics or modules to be crunched. The decrunch
routine written in assembler is fast, even on stock MC68000/MC68020 Amigas.

I use it only for the pictures and modules of a production. To save memory,
I point a @{"TRAP Instruction Vector" LINK Chapter-4-4-9-7} to this decrunch routine. Though I can
call this routine from every demo-part with the TRAP #n command.

On MC68020+ machines, especially the MC68040/60, it is important to flush
the caches after decrunching your data, as I already mentioned @{"here" LINK Chapter-4-4-9-3}.
@ENDNODE


@NODE Chapter-4-4-12 "4 Optimizing & tricks / MC680x0 family / Generating random values"
@{B}4-4-12 Generating random values@{UB}

If you need random values within a certain range, this formula might help
you:

@{I}f(x+1) = [(f(x)*a)+b]/MOD m@{UI}

whereas

f(x) = start value, for example the contents of @{"VHPOSR" LINK VHPOSR}
a    = constant
b    = constant
m    = maximum random value

The rest of a division is the random value and the start value for the next
formula.

A routine could look like this:

const_a=467			;Just some example values
const_b=2048
random_max_value=336
random_values_num=128

  CNOP 0,4			;Longword alignment for MC68020+
get_random_values
  LEA     random_values_tab(PC),A0 ;Table to store your random values
  MOVE.W  $DFF006,D0		;f(x)=@{"VHPOSR" LINK VHPOSR}=start value
  MOVE.W  #const_a,D1
  MOVE.L  #const_b,D2
  MOVE.W  #random_max_value,D3
  MOVEQ   #random_values_num-1,D7;The number of values you need
random_values_loop
  MULU.W  D1,D0			;f(x)*a
  ADD.L   D2,D0			;(f(x)*a)+b
  DIVU.W  D3,D0			;f(x+1)=[(f(x)*a)+b]/mod m
  SWAP    D0			;Rest of division
  MOVE.W  D0,(A0)+		;Store the value
  DBF     D7,random_values_loop
  RTS
 
  CNOP 0,2			;Word alignment
random_values_tab
  DS.W random_values_num


If you want a larger variety of values, so that they are not so close at
each other, then set the constant a = @{"VHPOSR" LINK VHPOSR}.

Just play a little bit with the constant values. For example, I use this
method to produce random x-values for a horizontal star scrolling.
@ENDNODE


@NODE Chapter-4-4-13 "4 Optimizing & tricks / MC680x0 family / Detecting active TCP/IP stacks"
@{B}4-4-13 Detecting active TCP/IP stacks@{UB}

Recently I got aware of a problem running intros/demos on Amigas with an
active TCP/IP stack. The TCP/IP stack generates @{"level-2-interrupts" LINK Chapter-4-4-13-1}, which
made my demo freeze after some time when I enabled the @{"PORTS" LINK Chapter-4-4-13-1} interrupt,
using a CIA-A timer as a delay counter for the tracker replay routine.

Ironically the music kept playing, while the main routine running in user
mode froze. This confirmed my theory, that the TCP/IP application only
generates level-2-interrupts.

I only replied the PORTS interrupt if the source is not a CIA-A timer but
didn't reset the interrupt source on the card hardware plugged in. It is
impossible to know, how to reply the interrupts of these external cards,
as there is no common interface.

So the best way would be to detect if a TCP/IP stack is active and running
to give the user the chance to close his TCP/IP application and proceed with
the intro/demo.

TCP/IP stack applications normally generate the @{I}bsdsocket.library@{UI} and remove
it out of the system after they are closed.

After some tries @{I}mark_k@{UI} on the English Amiga Board had a smart idea to solve
this problem: Searching in the exec-libraries list, if there is an existing
@{I}bsdsocket.library@{UI} and checking if it is opened:

  CNOP 0,4			;Longword alignment for MC68020+
detect_tcp_stack
  MOVE.L  $4.W,A6		;Get exec-base
  JSR     -132(A6)		;@{"Forbid()" LINK Forbid()} Multitasking off
  LEA     $17A(A6),A0		;LibList: Pointer to Libraries used
  LEA     bsdsocket_name(PC),A1 ;Pointer to name of the  Bsdsocket-Library
  JSR     -276(A6)		;@{"FindName()" LINK FindName()} Search for the library
  TST.L   D0
  BEQ.S   no_tcp_stack_found	;If NULL -> branch
  MOVE.L  D0,A0                 ;Save pointer to the node structure
  TST.W   $20(A0)		;LIB_OPENCNT
  BEQ.S   no_tcp_stack_found	;If library is not open -> branch
  JSR     -138(A6)		;@{"Permit()" LINK Permit()} Multitasking on
  MOVEQ   #0,D0			;Return code = OK = active TCP/IP-stack
  RTS
  CNOP 0,4			;Longword alignment for MC68020+
no_tcp_stack_found
  JSR     -138(A6)		;@{"Permit()" LINK Permit()} Multitasking on
  MOVEQ   #-1,D0		;Return code = FALSE = NO TCP/IP-stack found
  rts

There is no 100% guarantee that in the case of an opened TCP/IP application
external @{"interrupts" LINK Chapter-4-4-13-1} will be generated. There could be for example no open
connections or the network cable could be not connected. Thus giving the
user the chance to run the demo in spite of an open TCP/IP application could
be the solution.

Read more about this very interesting discussion on:
@{I}English Amiga Board > Coders > Coders. Asm / Hardware External interrupts
generated by TCP/IP stacks@{UI}

Many thanks go to the members of this discussion @{I}DrCinicus, frost242,
galahad/FLT, mark_k, McTrinsic, meynaf, nogginthenog, phx, StingRay and
Toni Wilen@{UI}.
@ENDNODE


@NODE Chapter-4-4-13-1 "4 Optimizing & tricks / MC680x0 family / Detecting active TCP/IP stacks / Interrupt Priorities"
@{B}4-4-13-1 Interrupt Priorities@{UB}

         +----------+-----------------------------------------+
         | Hardware | Exec software priority        |         |
         | priority |    +--------------------------+         |
         |          |    | Description              |         |
         +----------+----+--------------------------+---------+
         |          |  1 | software interrupt       | SOFTINT |
         |          +----+--------------------------+---------+
         |     1    |  2 | disk block complete      | DSKBPK  |
         |          +----+--------------------------+---------+
         |          |  3 | transmitter buffer empty | TBE     |
         +----------+----+--------------------------+---------+
         |     2    |  4 | external INT2 & CIAA     | PORTS   |
         +----------+----+--------------------------+---------+
         |          |  5 | graphics coprocessor     | COPER   |
         |          +----+--------------------------+---------+
         |     3    |  6 | vertical blank interval  | VERTB   |
         |          +----+--------------------------+---------+
         |          |  7 | blitter finished         | BLIT    |
         +----------+----+--------------------------+---------+
         |          |  8 | audio channel 0          | AUD0    |
         |          +----+--------------------------+---------+
         |          |  9 | audio channel 1          | AUD1    |
         |     4    +----+--------------------------+---------+
         |          | 10 | audio channel 2          | AUD2    |
         |          +----+--------------------------+---------+
         |          | 11 | audio channel 3          | AUD3    |
         +----------+----+--------------------------+---------+
         |          | 12 | receive buffer full      | RBF     |
         |     5    +----+--------------------------+---------+
         |          | 13 | disk sync pattern found  | DSKSYNC |
         +----------+----+--------------------------+---------+
         |          | 14 | external INT6 & CIAB     | EXTER   |
         |     6    +----+--------------------------+---------+
         |          | 15 | special (master enable)  | INTEN   |
         +----------+----+--------------------------+---------+
         |     7    | -- | non-maskable interrupt   | NMI     |
         +----------+----+--------------------------+---------+
@ENDNODE


@NODE Chapter-4-4-14 "4 Optimizing & tricks / MC680x0 family / Using macros for a better readability"
@{B}4-4-14 Using macros for a better readability@{UB}

In some cases it might be useful to use macros in your sourcecode to get
a better readability. The @{"instructions" LINK COPINS} for a copper list in their raw
format look a little bit strange:

  DC.W $2C01,$FFFE		;CWAIT x=$00,y=$2C
  DC.W $0180,$0F80              ;CMOVE value=$0F80,dest=COLOR00
  DC.W $0001,$0000              ;CWAITBLIT
  ...etc...
  DC.W $FFFF,$FFFE		;CEND


To make things clearer, you could use the cutom chip register equals from
@{I}include3.X/hardware/custom.i@{UI} and the following macros:

CMOVE MACRO \1,\2 		;Format: CMOVE value,dest
  DC.W \2,(\1&$FFFF)
  ENDM

CWAIT MACRO \1,\2 		;Format: CWAIT x,y
  DC.W (\2*256)+(((\1/4)*2)+1),$FFFE
  ENDM

CWAITBLIT MACRO 		;Format: CWAITBLIT
  DC.W $0001,$0000
  ENDM

CEND MACRO 			;Format: CEND
  DC.W $FFFF,$FFFE
  ENDM

Remember that the copper can wait for a horizontal beam position every 4th
even pixel. This means four pixels in low resolution and eight pixels in
high resolution. The macro CWAIT expects a lores x-value.

So the example from above would look like this:

  CWAIT $00,$2C
  CMOVE $0F80,COLOR00
  ...etc...
  CEND

I will use this format in all of my copper list examples.
@ENDNODE


@NODE Chapter-4-5 "4 Optimizing & tricks / CIA"
@{B}4-5 Complex Interface Adapter (CIA)@{UB}

    4-5-1 @{" Proper CIA registers access " LINK Chapter-4-5-1}
    4-5-2 @{" Faster access to CIA registers " LINK Chapter-4-5-2}
    4-5-3 @{" Diskready bug of HD floppies " LINK Chapter-4-5-3}
    4-5-4 @{" Detecting external floppies " LINK Chapter-4-5-4}
@ENDNODE


@NODE Chapter-4-5-1 "4 Optimizing & tricks / CIA / Proper CIA registers access"
@{B}4-5-1 Proper CIA registers access@{UB}

      4-5-1-1 @{" Disk registers " LINK Chapter-4-5-1-1}
      4-5-1-2 @{" Timer registers " LINK Chapter-4-5-1-2}
@ENDNODE


@NODE Chapter-4-5-1-1 "4 Optimizing & tricks / CIA / Proper CIA registers access / Disk registers"
@{B}4-5-1-1 Disk registers@{UB}

        4-5-1-1-1 @{" Turning on drive motor " LINK Chapter-4-5-1-1-1}
        4-5-1-1-2 @{" Moving the drive head " LINK Chapter-4-5-1-1-2}

@ENDNODE


@NODE Chapter-4-5-1-1-1 "4 Optimizing & tricks / CIA / Proper CIA registers access / Disk registers / Turning on drive motor"
@{B}4-5-1-1-1 Turning on drive motor@{UB}

As we know, the CIA registers are read/write registers. Normally, when
writing to them, we would do something like this to control the floppy
drive, expecting An=$BFD100 (@{"CIA-B PRA" LINK Appendix-B}):

1) AND.B  #%11110111,(An)	;Deactivate DF0:
2) AND.B  #%01111111,(An)	;Turn motor on generally
3) OR.B   #%00001000,(An)	;Activate DF0: and turn its motor on

This works fine on MC68000-MC68040 machines. But on a MC68060 there may
be some problems while executing these commands. It executes instructions
parallel and it could happen, that instruction 2) is executed before 1).

So what could we do? Well, we use the NOP command, which prevents a parallel
execution on the MC68060. Look at his code:

  AND.B  #%11110111,(An)	;Deactivate DF0:
  @{FG FILL}NOP@{FG TEXT}				;Prevent parallel execution
  AND.B  #%01111111,(An)	;Turn motor on generally
  @{FG FILL}NOP@{FG TEXT}
  OR.B   #%00001000,(An)	;Activate DF0: and turn its motor on

But a NOP takes cycles to be executed. Yes, doing nothing is expensive,
even on slower machines like the MC68000. So what's the solution?

We use the fact, that the MC68060 in some cases can't execute instructions
parallel if there are registers used. If consecutive instructions must
wait for the result of the previous instruction, there is no parallel
execution possible. With this knowledge we can code the following:

  MOVE.B  (An),D0		;Read content of CIA-B PRA
  AND.B   #%11110111,D0		;Deactivate DF0:
  MOVE.B  D0,(An)		;Write after AND command is finished
  AND.B   #%01111111,D0		;Turn motor on generally
  MOVE.B  D0,(An)		;Write after AND command is finished
  OR.B    #%00001000,D0		;Activate DF0: and turn its motor on
  MOVE.B  D0,(An)		;Write after OR command is finished

This code is faster and it also executes sequentially. To decrease the
wait states on the MC68020+, the CPU executes instructions between the
memory accesses. And the MC68060 can't execute the instructions parallel,
because every instruction must wait for the result of the previous one,
if we always use the same data register. This has the same effect as
using NOPs.

A good coder does this little optimizing. He replaces

  OR.B    #%00001000,D0

with

  ADDQ.B  #%00001000,D0

This works fine, because bit3 was cleared before by the AND command.
@ENDNODE


@NODE Chapter-4-5-1-1-2 "4 Optimizing & tricks / CIA / Proper CIA registers access / Disk registers / Moving the drive head"
@{B}4-5-1-1-2 Moving the drive head@{UB}

If the disk hardware is accessed by moving the head for seeking a certain
track on a disk, this could cause problems on the MC68060:

;An=$BFD100 (@{"CIA-B PRA" LINK Appendix-B})

1) BSET  #1,(An)		;Direction to the outside of the disc
2) BCLR  #0,(An)		;Low
3) BSET  #0,(An)		;High

There is no guarantee that the commands are executed in the right order 1),
2) and 3).

Like mentioned in @{"Turning on drive motor" LINK Chapter-4-5-1-1-1} we can put a NOP between the
bit commands:

  BSET  #1,(An)			;Direction to the outside of the disc
  @{FG FILL}NOP@{FG TEXT}                           ;Prevent parallel execution
  BCLR  #0,(An)			;Low
  @{FG FILL}NOP@{FG TEXT}
  BSET  #0,(An)			;High

But this way is much faster:

  MOVE.B  (An),D0               ;Read content of CIA-B PRA
  OR.B    #%00000010,D0		;Direction to the outside of the disc
  MOVE.B  D0,(An)               ;Write after OR command is finished
  AND.B   #%11111110,D0		;Low
  MOVE.B  D0,(An)               ;Write after AND command is finished
  OR.B    #%00000001,D0		;High
  MOVE.B  D0,(An)               ;Write after OR command is finished

and the command

  OR.B    #%00000001,D0

can be replaced with

  ADDQ.B  #%00000001,D0

this does the same.
@ENDNODE


@NODE Chapter-4-5-1-2 "4 Optimizing & tricks / CIA / Proper CIA registers access / Timer registers"
@{B}4-5-1-2 Timer registers@{UB}

Setting the @{"CIA timers" LINK Appendix-B} could cause problems on the MC68060 with its
parallel execution, so we add some NOPs between the CIA register writes and
the timer is started with the correct values. See also @{"here" LINK Chapter-4-5-1-1-1}.

  MOVE.B  #timervalue&$FF,$400(An) ;CIATALO: Low value
  @{FG FILL}NOP@{FG TEXT}				;Prevent parallel execution
  MOVE.B  #timervalue>>8,$500(An) ;CIATAHI: High value
  @{FG FILL}NOP@{FG TEXT}
  OR.B    #1,$E00(An)		;CIACRA: Start timer-A

Well, you guessed it. The optimization looks like this:

  MOVEQ   #timervalue&$FF,D0	;Low value
  MOVE.B  D0,$400(An)		;CIATALO: Write after MOVEQ command is finished
  MOVEQ   #timervalue>>8,D0	;High value
  MOVE.B  D0,$500(An)		;CIATAHI: Write after MOVEQ command is finished
  MOVEQ   #1,D0			;Start timer-A
  OR.B    D0,$E00(An)		;CIACRA: Write after MOVEQ command is finished
@ENDNODE


@NODE Chapter-4-5-2 "4 Optimizing & tricks / CIA / Faster access to CIA registers"
@{B}4-5-2 Faster access to CIA registers@{UB}

For example, if you want to turn off the audio filter, most people do
the following:

  OR.B    #2,$BFE001		;@{"CIA-A PRA" LINK Appendix-B}

A smart coder does this:

  MOVE.L  #$BFE001,An		;Get CIA-A PRA as base address
  OR.B    #2,(An)		;Turn audio filter off

This version speeds up the access to the register @{"CIAPRA" LINK Appendix-B} because of
indirect memory access. This is important, because any access to the
CIA registers is slowed down to 1/10 of the CPU clock.

Another optimizing:

  MOVE.L  #$BFE001,An		;Get CIA-A PRA as base address
  MOVEQ   #2,Dn			;Turn audio filter off
  OR.B    Dn,(An)		;Write after MOVEQ command is finished

In this version we do the fastest way to access the CIA memory and use the
address register indirect without displacement and register access.

See @{"below" LINK Chapter-4-9-1-3-1} for a complete example how to optimize the CIA register's access
in the protracker filter command routine.
@ENDNODE


@NODE Chapter-4-5-3 "4 Optimizing & tricks / CIA / Diskready bug of HD floppies"
@{B}4-5-3 Diskready bug of HD floppies@{UB}

If you access the disk-hardware directly, you have to wait for the disk
motor until it runs at full speed. This could be coded like this:

;A4=$BFE001 (@{"CIA-A PRA" LINK Appendix-B})

wait_disk_motor
  BTST    #5,(a4)		;Wait for DSKRDY signal
  BNE.S   wait_disk_motor	;Loop until signal goes low

This method worked fine, until ESCOM started to build in their A1200 models
PC-HD-drives which didn't support the @{"DSKRDY" LINK Appendix-B-1} signal anymore and thus
didn't pull this signal low.

The fatal consequence was, that all custom disk loaders, using this method
to wait for the motor, mine too :(, crashed and went into an infinite
waitloop.

What's the solution? Quite simple. Doing both. Checking the DSKRDY signal
@{B}and@{UB} if it's not low, doing a wait of 500 ms with a programmed CIA timer.
This could look like this:

;A4=$BFE001 (@{"CIA-A PRA" LINK Appendix-B})

init_CIA_A_timer_B
  MOVEQ   #8,D0			;RUNMODE=one-shot mode, Stop Timer-B
  MOVE.B  D0,$F00(A4)		;CIACRB: Init CIA-A Timer-B after MOVEQ
				;command is finished
...etc...

  CNOP 0,4			;Longword alignment for MC68020+
motor_wait
  MOVEQ   #10-1,D7           	;Wait 10 x 50 ms = 500 ms
motor_wait_loop
  BTST    #5,(A4)		;CIAPRA: Motor runs at full speed ?
  BEQ.S   motor_full_speed	;Yes, it's a DD-drive running at full speed
  MOVE.W  #35469,D5		;50 ms (PAL clock frequency)
  BSR.S   loader_delay
  DBF     D7,motor_wait_loop
motor_full_speed
...etc...

;D5=Delay in milliseconds
  CNOP 0,4			;Longword alignment for MC68020+
loader_delay
  MOVE.B  D5,$600(A4)		;CIATBLO: Low timer value
  LSR.W   #8,D5			;Get high bits
  MOVE.B  D5,$700(A4)		;CIATBHI: Write High timer value after the LSR
				;command is finished
CIA_A_timer_B_wait
  BTST    #1,$D00(A4)		;CIAICR: Wait until Timer-B is finished
  BEQ.S   CIA_A_timer_B_wait
  RTS
@ENDNODE


@NODE Chapter-4-5-4 "4 Optimizing & tricks / CIA / Detecting external floppies"
@{B}4-5-4 Detecting external floppies@{UB}

Ever wondered how to detect an external floppy? In the Hardware Reference
Manual (HRM) the read sequence is described and here's the routine for it.

In this case the @{"DSKRDY" LINK Appendix-B-1} signal is read while the motor is off so there's
no bug when a HD-drive is accessed:

;A3=Variable-Base
;A4=$BFE001 (@{"CIA-A PRA" LINK Appendix-B})
;A5=$BFD100 (@{"CIA-B PRA" LINK Appendix-B})

;D0=Return value Drive-ID can be:
;$00000000 = no drive
;$FFFFFFFF = 3.5"-DD drive
;$55555555 = 5.25" drive
;$AAAAAAAA = HD drive

  CNOP 0,4			;Longword alignment for MC68020+
detect_ext_drives
  LEA     detected_drives(pc),a3 ;PC-Relative access
  MOVEQ   #%00010000,D1		;Start with DF1:
  CLR.W   (a3)			;Clear variable
  MOVEQ   #%01111111,D3         ;Motor on
  MOVEQ   #3-1,D7		;Check for all 3 external drives
detect_drives_loop
  MOVE.B  (A5),D2		;Get CIA-B PRB content
  OR.B    D1,D2			;Deactivate DFx:
  MOVE.B  D2,(A5)               ;Write after OR command is finished
  AND.B   D3,D2		        ;Motor on
  MOVE.B  D2,(A5)               ;Write after AND command is finished
  EOR.B   D1,D2                 ;Activate DFx:
  MOVE.B  D2,(A5)		;Write after EOR command is finished
  OR.B    D1,D2                 ;Deactivate DFx:
  MOVE.B  D2,(A5)		;Write after OR command is finished
  TAS     D2                    ;Motor off
  MOVE.B  D2,(a5)		;Write after TAS command is finished
  EOR.B   D1,D2                 ;Activate DFx:
  MOVE.B  D2,(a5)		;Write after EOR command is finished
  OR.B    D1,D2                 ;Deactivate DFx:
  MOVE.B  D2,(a5)		;Write after OR command is finished
  MOVEQ   #0,D0			;Clear Drive-ID
  MOVEQ   #32-1,D6		;Number of bits to read
read_ID_loop
  EOR.B   D1,D2                 ;Activate DFx:
  MOVE.B  D2,(A5)		;Write after EOR command is finished
  BTST    #5,(A4)		;DSKRDY-Bit set?
  BEQ.S   bit_not_set		;No -> branch
  BSET    D6,D0			;Set ID-bit
bit_not_set
  OR.B    D1,D2			;Deactivate DFx:
  MOVE.B  D2,(A5)		;Write after OR command is finished
  DBF     D6,read_ID_loop
  NOT.L   D0			;Invert ID, because DSKRDY is active low
  BEQ.S   no_detect_ext_drives	;If NULL then skip = no drive connected
  ADDQ.W  #1,(A3)		;Increase number of drives
  ADD.B   D1,D1			;next drive unit
  DBF     D7,detect_drives_loop
no_detect_ext_drives
  RTS

  CNOP 0,2
detected_drive DC.W 0		;Number of drives available
@ENDNODE


@NODE Chapter-4-6 "4 Optimizing & tricks / OCS"
@{B}4-6 Original Chip Set (OCS)@{UB}

    4-6-1 @{" Copper " LINK Chapter-4-6-1}
    4-6-2 @{" Playfields " LINK Chapter-4-6-2}
    4-6-3 @{" Sprites " LINK Chapter-4-6-3}
@ENDNODE


@NODE Chapter-4-6-1 "4 Optimizing & tricks / OCS / Copper"
@{B}4-6-1 Copper@{UB}

      4-6-1-1 @{" Four-pixels COLORxx-chunky screens " LINK Chapter-4-6-1-1}
@ENDNODE


@NODE Chapter-4-6-1-1 "4 Optimizing & tricks / OCS / Copper / Four-pixels COLORxx-chunky screens"
@{B}4-6-1-1 Four-pixels COLORxx-chunky screens@{UB}

As I watched the demo @{I}Copper orgasm@{UI} by Cerberos for the first time, I
wondered how they managed it to switch between an eight-pixels chunky screen
and a four-pixels chunky screen with the @{"COLOR00" LINK COLORxx} register.

The four-pixels chunky screen is an optical illusion. The copper still needs
eight lores-pixel to execute a @{"CMOVE" LINK Chapter-4-4-14} command if the number of displayed
bitplanes is <=4.

Here's the explanation how this effect works: As we know, the copper can
execute a sequence of CMOVE commands changing the background colour within
a scan line up to 56 times (227 cycles for a short line / 4 cycles).

But we have about two unused memory cycles left for each scan line. If we
would use them, a CMOVE would be split. One half (4 lores pixel) would
be executed at the end of the line and the other half at the beginning of
the next scan line. If we would do a sequence of more than 56 commands like
171 commands without any @{"CWAIT" LINK Chapter-4-4-14} between them, this would look like this:

Scan line #1: 56,5 commands
Scan line #2: 0,5(from previous command)+56 commands
Scan line #3: 56,5 commands
Scan line #4: 0,5(from previous command)+1 command
...etc...

What happens, if we use a vertical pattern like a bar colourrun? There are
lots of OCS copper effects, for example Rebels @{I}Megademo 2@{UI} with the part
@{I}Made in Sweden@{UI}, which display a column of 8 lores pixels with a vertical
colourrun and for the next eight pixels column using the same colourrun with
a different start-offset, calculated by a sine function.

I won't use a sine function, as I will use a linear one.

So the colourrrun for a blue bar should be:
$001,$003,$005,...$00f,$00f,...,$005,$003,$001

Copying this pattern vertically into a column looks like this:

-C1-
$001
$003
$005
$007
$009
$00b
$00d
$00f
$00f
$00d
$00b
$009
$007
$005
$003
$001

For the next column, we just start to read the pattern from the second line
l+1 and do a vertical shift of +1 and so on...

     -C1--C2--C3-...
-L01-$001$003$005
-L02-$003$005$007
-L03-$005$007$009
-L04-$007$009$00b
-L05-$009$00b$00d
-L06-$00b$00d$00f
-L07-$00d$00f$00f
-L08-$00f$00f$00d
-L09-$00f$00d$00b
-L10-$00d$00b$009
-L11-$00b$009$007
-L12-$009$007$005
-L13-$007$005$003
-L14-$005$003$001
-L15-$003$001
-L16-$001

This vertical shift is important, otherwise the optical illusion doesn't
work.

It is also important, that we do a vertical shift which seamlessly blends
into each other after 57 columns, putting together the horizontally repeated
pattern. This could be done in a linear way with 29 step-shifts (+1) up and
then 28 step-shifts (-1) down.

If we use a sine table with 512 entries for 360 degrees, we could use the
y-angle step-value 512/57 = 8,98 rounded to 9 for every new column.

With the combination of a vertical shift, column by column and a horizontal
shift of four lores pixels, line by line, we get a pattern which seems to
consist of four lores pixels wide colour changes.
@ENDNODE


@NODE Chapter-4-6-2 "4 Optimizing & tricks / OCS / Playfields"
@{B}4-6-2 Playfields@{UB}

      4-6-2-1 @{" Screen splitting with multiple horizontal viewports " LINK Chapter-4-6-2-1}
      4-6-2-2 @{" OCS playfields compatible to AGA " LINK Chapter-4-6-2-2}
@ENDNODE


@NODE Chapter-4-6-2-1 "4 Optimizing & tricks / OCS / Playfields / Screen splitting with multiple horizontal viewports"
@{B}4-6-2-1 Screen splitting with multiple horizontal viewports@{UB}

In spite of COMMODORE's documentation a vertical screen splitting with
multiple horizontal viewports is possible and we don't need a blank
column between them.

The different viewports use the same memory block for their playfields.
As in the first example, two viewports, one with 256x256 pixels and the
other with 128x256 pixels, are seen as a large memory block of 384x256
pixels. The viewport with the highest depth of bitplanes determines the
number of planes of the whole memory block.

I've chosen the interleaved bitplane format raw modulo that means:
1st line plane0, 1st line plane1, 1st line plane2, 1st line plane3
2nd line plane0, 2nd line plane1, 2nd line plane2, 2nd line plane3
...etc...

For this format the plane moduli have to be calculated like this:

  @{I}Moduli=plane_width*(depth-1)@{UI}

The normal bitplane format plane after plane could be also used.

To display the viewports with the copper, every visible scan line of the
screen, the content of the @{"BPLCON0" LINK BPLCON0} register must be changed twice. This
could be done in three different ways of vertical screen splitting:


@{B}1. Two viewports with the same screen depth and palette and different
   resolutions (lores/hires)@{UB}

1st viewport (256x256 pixels, lores, 4 bitplanes depth)
2nd viewport (128x256 pixels, hires, 4 bitplanes depth)

depth=4
plane_width=(256+128)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard Window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch with lores value
  CMOVE $00D4,DDFSTOP		;End data fetch with hires value
  CMOVE $0000,BPLCON1		;No horizontal shift
  CMOVE $0000,BPLCON2		;Bitplanes have priority over sprites
  CMOVE $0C00,BPLCON3		;AGA: PF2OF=8, lores sprite (OCS mode)
  CMOVE $0011,BPLCON4		;AGA: 2nd colour table odd&even sprites
				;(OCS mode)
  CMOVE (plane_width*(depth-1))-2,BPL1MOD ;Subtract 2 bytes for
  CMOVE (plane_width*(depth-1))-2,BPL2MOD ;a correct display
  CMOVE $2100,DIWHIGH		;ECS/AGA additional window limits
  CMOVE $0000,FMODE		;AGA: 1x data fetch 16 bits (OCS mode)
  ...etc...

Just repeat this command sequence changing the @{"BPLCON0" LINK BPLCON0} register twice per
scan line for a display with a height of 256 lines:

0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE $4200,BPLCON0,		;4 bitplanes depth, lores
  CWAIT HSTART+246,VSTART+n	;Xpos=246 for 4 bitplanes value may
				;change if more bitplanes are used
  CMOVE $C200,BPLCON0		;4 bitplanes depth, hires
  ...etc...

In this case, no extra @{"CWAIT" LINK Chapter-4-4-14} $1C0,$FF for the line wrap is needed, because
the hires display with a depth of four bitplanes takes all memory slots and
blocks the copper from the memory-bus. The command CWAIT $00,VSTART+212
automatically waits for line $100.


@{B}2. Two viewports with different screen depths, same palette and
   resolution (lores/lores)@{UB}

1st viewport (256x256 pixels, lores, 5 bitplanes)
2nd viewport (64x256 pixels, lores, 4 bitplanes)

The copper list can be coded like this:

depth=5
plane_width=(256+64)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard Window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch with lores value
  CMOVE $00D0,DDFSTOP		;End data fetch with lores value
  CMOVE $0000,BPLCON1		;No horizontal shift
  CMOVE $0000,BPLCON2		;Bitplanes have priority over sprites
  CMOVE $0C00,BPLCON3		;AGA: PF2OF=8, lores sprite (OCS mode)
  CMOVE $0011,BPLCON4		;AGA 2nd colour table odd&even sprites
				;(OCS mode)
  CMOVE plane_width*(depth-1),BPL1MOD
  CMOVE plane_width*(depth-1),BPL2MOD
  CMOVE $2100,DIWHIGH		;ECS/AGA additional window limits
  CMOVE $0000,FMODE		;AGA: 1x data fetch 16 bits (OCS mode)
  ...etc...

0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE (bp5_start+(plane_width*n))/65536,BPL5PTH
  CMOVE (bp5_start+(plane_width*n))&65535,BPL5PTL
  CMOVE $5200,BPLCON0		;5 bitplanes depth, lores
  CWAIT HSTART+246,VSTART+n 	;xpos=246 for 5/4 bitplanes value may
				;change if less bitplanes are used
  CMOVE $4200,BPLCON0		;4 bitplanes depth, lores
  ...etc...

At the beginning of each scan line the bitplane pointer of the fifth
bitplane must be refreshed, so that it points to the beginning of the
current bitplane data to be fetched by DMA. This is necessary, because
after turning off bitplane 5 with the @{"BPLCON0" LINK BPLCON0} register by reducing the
display down to 4 bitplanes, the bitplane pointer of the fifth plane is
not longer increased by DMA.

Keep in mind to do an extra @{"CWAIT" LINK Chapter-4-4-14} $1C0,$FF for the line wrap, because with
4 bitplanes in lores display mode, all memory cycles are free and available
for the copper.


@{B}3. Two viewports with different screen depths and resolutions (lores/hires)
   and same palette@{UB}

1st viewport (256x256 pixels, lores, 3 bitplanes)
2nd viewport (128x256 pixels, hires, 2 bitplanes)

depth=3
plane_width=(256+128)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard Window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch with lores value
  CMOVE $00D0,DDFSTOP		;End data fetch with lores value
  CMOVE $0000,BPLCON1		;No horizontal shift
  CMOVE $0000,BPLCON2		;Bitplanes have priority over sprites
  CMOVE $0C00,BPLCON3		;AGA: PF2OF=8, lores sprite (OCS mode)
  CMOVE $0011,BPLCON4		;AGA: 2nd colour table odd&even sprites
				;(OCS mode)
  CMOVE (plane_width*(depth-1))-2,BPL1MOD ;Subtract 2 bytes for
  CMOVE (plane_width*(depth-1))-2,BPL2MOD ;a correct display
  CMOVE $2100,DIWHIGH		;ECS/AGA additional window limits
  CMOVE $0000,FMODE		;AGA: 1x data fetch 16 bits (OCS mode)
  ...etc...

0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE (bp3_start+(plane_width*n))/65536,BPL3PTH
  CMOVE (bp3_start+(plane_width*n))&65535,BPL3PTL
  CMOVE $3200,BPLCON0		;3 bitplanes depth, lores
  CWAIT HSTART+246,VSTART+n	;xpos=246, for 5/4 bitplanes this value may
				;change if more bitplanes are used
  CMOVE $A200,BPLCON0		;2 bitplanes depth, hires
  ...etc...

Like already mentioned above, the bitplane pointer of the third bitplane
must be refreshed at the beginning of every scan line so that it points to
the beginning of the current bitplane data.

Don't forget to do an extra @{"CWAIT" LINK Chapter-4-4-14} $1C0,$FF for the line wrap, because all
memory cycles are free and available for the copper.
@ENDNODE


@NODE Chapter-4-6-2-2 "4 Optimizing & tricks / OCS / Playfields / OCS playfields compatible to AGA"
@{B}4-6-2-2 OCS playfields compatible to AGA@{UB}

If you write intro or demos for the OCS, don't forget to initialize the
following ECS/AGA registers with the right values or your display may be
distorted by strange effects, running on an AGA machine after the @{I}SetPatch@{UI}
command in the @{I}startup-sequence@{UI} was executed:

@{"BPLCON3" LINK BPLCON3}=%0000110000000000	;PF2OF=%011=8 so 2nd playfield in dual mode
				;uses COLOR08-15, lores sprites resolution,
				;12 bit values used for loaded colour values
@{"BPLCON4" LINK BPLCON4}=$0000000000010001	;2nd colour table (COLOR16-31) for odd&even
				;sprites
@{"DIWHIGH" LINK DIWHIGH}=%0010000100000000	;Setting this register is optional, because
				;writing to @{"DIWSTART" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT} already sets
				;the display window dimensions. To display a
				;window with 320x256 pixels and the values
				;DIWSTRT=$2C81 and DIWSTOP=$2CC1 you can
				;set bits 8&13.
@{"FMODE" LINK FMODE}  =%0000000000000000	;1x data fetch 16 bits for bitplanes&sprites

An AGA Amiga boots in ECS mode and all these registers are set to NULL. But
in this case, the registers BPLCON3 and BPLCON4 are not initialized with the
right values and so the wrong palettes for a dual-playfield (2nd playfield)
and the sprites would be displayed. This specifically concerns bootblock
intros.

Maybe this is not the case, if the Workbench screen with the CLI window is
opened, but don't rely on an any values in these registers.

At the latest after the @{I}SetPatch@{UI} command is executed, the new capabilities
(greater datafetch bandwidth) of the AGA chipset are enabled.

These ECS/AGA registers only have to be initialized once before you start
your own display. There are two ways to do this. You could initialze them by
the CPU or in your copper list.
@ENDNODE


@NODE Chapter-4-6-3 "4 Optimizing & tricks / OCS / Sprites"
@{B}4-6-3 Sprites

      4-6-3-1 @{" Bordersprites " LINK Chapter-4-6-3-1}
@ENDNODE


@NODE Chapter-4-6-3-1 "4 Optimizing & tricks / OCS / Sprites / Bordersprites"
@{B}4-6-3-1 Bordersprites@{UB}

When I analyzed Andromeda's @{I}Sequential@{UI} I found out something remarkable in
the part with the rotating magnet. A very small data fetch window but the
sprites were displayed outside this region on OCS!

Like on AGA machines, displaying sprites outside the bitplane data fetch
dimensions defined in @{"DDFSTRT" LINK DDFSTRT}/@{"DDFSTOP" LINK DDFSTRT}/@{"DIWSTRT" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT} is possible. It's
not so easy like on AGA (Setting BRDSPRT, bit1, in @{"BPLCON3" LINK BPLCON3}) but it works
if the copper is used.

Just wait at the beginning of each scan line where the border sprites should
be displayed in the blanked area for the horizontal lores position >=$C and
<=$24 and do a write to the @{"BPL0DAT" LINK BPLxDAT} register with the copper.

The lores position >=$C for the first position in the scan line, because all
values less than that belong to the end of the previous line. For this topic
see also @{"CWAIT horizontal position bug" LINK Chapter-3-1-1-1}.

The lores position <=$24, because the earliest data fetch for bitplanes
starts at the DMA slot $18 which is multiplied by two the lores position
$30 and the BPL0DAT should be written before that. Remember that a @{"CMOVE" LINK Chapter-4-4-14}
needs 4 DMA slots or 8 lores pixels to be executed.

Another side effect for a position >$24 would be a display error of the
sprites in the left region.

Set the horizontal overscan value HSTRT=$5B in @{"DIWSTRT" LINK DIWSTRT} and the overscan
value HSTOP=$1C7 in @{"DIWSTOP" LINK DIWSTRT}. This is important, because border sprites
are only visible within HSTRT und HSTOP.

Set VSTART in DIWSTRT to the line where your bitplanes should start to be
displayed and VSTOP=VSTART+viewport_height. The values VSTRT and VSTOP don't
have any influence whether the border sprites are displayed in the vertical
overscan region or not.

Optionally set the additional window limits in @{"DIWHIGH" LINK DIWHIGH}.

Toni Wilen described this in @{"Undocumented Amiga hardware stuff" LINK Appendix-D-1-1-2}.

For example we've got a centered viewport of 192x192 pixels and we want to
display sprites outside this area in the dimension of 364x256 pixels.

The copper list could be like this:

  CMOVE $4C5B,DIWSTRT 		;Display with horizontal overscan values and
  CMOVE $0CC7,DIWSTOP           ;starting at scan line $4C, 192 lines high
  CMOVE $0058,DDFSTRT 		;Start centered lores data fetch
  CMOVE $00B0,DDFSTOP		;End centered lores data fetch
  CMOVE $XXXX,BPLCON0		;Depth, resolution
  CMOVE $0000,BPLCON1		;No horizontal shift
  CMOVE $0024,BPLCON2		;Sprites have priority over bitplanes
  CMOVE $0C00,BPLCON3		;AGA: PF2OF=8, lores sprite  mode (OCS mode)
  CMOVE $0011,BPLCON4		;AGA: 2nd colour table odd&even sprites
				;(OCS mode)
  CMOVE $XXXX,BPL1MOD           ;Plane moduli
  CMOVE $XXXX,BPL2MOD
  CMOVE $2100,DIWHIGH 		;ECS/AGA additional window limits
  CMOVE $0000,FMODE		;AGA: 1x mode data fetch (OCS mode)
  ...etc...

Just repeat the following command sequence with the copper for 256 scan
lines and you'll see, that within these scan lines the sprites are visible
outside the datafech region of 192x192 pixels in the whole overscan area of
364x256 pixels:

HSTART=$0C
VSTART-$2C

0=<n<=255

  CWAIT HSTART,VSTART+n		;Wait for the beginning of a scan line
  CMOVE $0000,BPL0DAT		;Enable bitplane shift register
  ...etc...

Keep in mind to do an extra @{"CWAIT" LINK Chapter-4-4-14} $1C0,$FF for the line wrap. To use the
whole right overscan area, set HSTOP >$1C7 in @{"DIWSTOP" LINK DIWSTRT}.

Another usage could be a background picture of 320x256 pixels consisting
of a repeated 128 pixels pattern in 4 colours or a repeated 64 pixels
pattern in 16 colours with the help of the @{"SPRxPOS" LINK SPRxPOS} register using
@{"horizontal reused sprites" LINK Chapter-4-8-1-1}. With this method you could display a screen
with standard dimensions, but your routine only has to handle a viewport
of 192x192 pixels.
@ENDNODE


@NODE Chapter-4-7 "4 Optimizing & tricks / AGA"
@{B}4-7 Advanced Graphics Architecture (AGA)@{UB}

    4-7-1 @{" Copper " LINK Chapter-4-7-1}
    4-7-2 @{" Playfields " LINK Chapter-4-7-2}
    4-7-3 @{" Sprites " LINK Chapter-4-7-3}
@ENDNODE


@NODE Chapter-4-7-1 "4 Optimizing & tricks / AGA / Copper"
@{B}4-7-1 Copper@{UB}

      4-7-1-1 @{" Initializing playfield colours " LINK Chapter-4-7-1-1}
      4-7-1-2 @{" Copper bars " LINK Chapter-4-7-1-2}
      4-7-1-3 @{" Background effects on BPLCON4-chunky screens " LINK Chapter-4-7-1-3}
      4-7-1-4 @{" Four-pixels BPLCON4-chunky screens " LINK Chapter-4-7-1-4}
      4-7-1-5 @{" Saving data fetch cycles on BPLCON4-chunky screens " LINK Chapter-4-7-1-5}
@ENDNODE


@NODE Chapter-4-7-1-1 "4 Optimizing & tricks / AGA / Copper / Initializing playfield colours"
@{B}4-7-1-1 Initializing playfield colours@{UB}

Let's expect the following copper list initializing the colour registers
for two separate viewports, ignoring the other display registers:

;1st viewport has 16 colours and a height of 100 lines
;2nd viewport has  8 colours and a height of 152 lines
;Vertical blank between the two viewport has a height of 4 lines

VSTART=$2C

;--- init 1st viewport ---
  ...etc...
  CMOVE $0000,BPLCON3		;1st colour bank high colour values
  CMOVE $0XXX,COLOR00
  ...etc...
  CMOVE $0XXX,COLOR15
  CMOVE $0200,BPLCON3		;1st colour bank low colour values
  CMOVE $0xxx,COLOR00
  ...etc...
  CMOVE $0xxx,COLOR15
  ...etc...
;--- init 2nd viewport ---
  CWAIT $00,VSTART+100		;Beginning vertical blank 2nd viewport
  ...etc...
  CMOVE $0000,BPLCON3		;1st colour bank high colour values
  CMOVE $0XXX,COLOR00
  ...etc...
  CMOVE $0XXX,COLOR07
  CMOVE $0200,BPLCON3		;1st colour bank low colour values
  CMOVE $0xxx,COLOR00
  ...etc...
  CMOVE $0xxx,COLOR07
  ...etc...

So where can we optimize the copper list? Quite simple, we use the fact,
that we can switch a whole palette with a single write to the @{"BPLCON4" LINK BPLCON4}
register. We load the colour values just in one step in the vertical
blank area. Let's see how the copper list looks like:

  ...etc...
  CMOVE $0000,BPLCON3		;1st colour bank high colour values
;--- init 1st viewport ---
  CMOVE $0XXX,COLOR00
  ...etc...
  CMOVE $0XXX,COLOR15
;--- init 2nd viewport ---
  CMOVE $0XXX,COLOR16
  ...etc...
  CMOVE $0XXX,COLOR23
  CMOVE $0200,BPLCON3		;1st colour bank low values
;--- init 1st viewport ---
  CMOVE $0xxx,COLOR00
  ...etc...
  CMOVE $0xxx,COLOR15
;--- init 2nd viewport ---
  CMOVE $0XXX,COLOR16
  ...etc...
  CMOVE $0XXX,COLOR23
  ...etc...
  CWAIT $00,VSTART+100		;Beginning vertical blank 2nd viewport
  CMOVE $1022,BPLCON4		;Swap the palette with the value 16 ($10)
				;and activate the colours for 2nd viewport
				;as COLOR00-COLOR07 formerly COLOR16-COLOR23
				;The sprites use the third colour bank ($22)
				;with the colours COLOR32-COLOR47

This example expects that the sprite palette starts at a colour number
greater than 31.

As a side effect, we minimize the blank lines needed between two viewports,
if we for example switch 32 or 64 colours.

Loading a palette of 32 colours normally requires 1 scan line. 64 colours
require 2 scan lines. Just one @{"CMOVE" LINK Chapter-4-4-14} command loads the new palette as all
colours were already initialized during the vertical blank.

Thus the height of the vertical blank area between the two viewports can
be decreased to 1 scan line.

Take care that the sum of used colours for the palettes of both viewports
is not greater than 256.
@ENDNODE


@NODE Chapter-4-7-1-2 "3 Optimizing & tricks / AGA / Copper / Copper bars"
@{B}3-7-1-2 Copper bars@{UB}

Here's another example of optimizing a copper list: Guess we have a copper
bar with a monocolour font mapped on it. To get a 3d-effect, the font colour
is also a bar, but in a different colour. The mapped bar is blue and the
font-bar is yellow. Each bar should have 15 colors.

Here's the repeated copper list sequence to initialize the bars colours:

bar_height=30

0=<n<=bar_height-1

  CWAIT $00,y+n
  CMOVE $0000,BPLCON3		;High colour values
  CMOVE $000X,COLOR00		;Bar
  CMOVE $0XX0,COLOR01		;Font
  CMOVE $0200,BPLCON3  		;Low colour values
  CMOVE $000x,COLOR00		;Bar
  CMOVE $0xx0,COLOR01		;Font
  ...etc...

As we learned in @{"Initializing playfield colours" LINK Chapter-4-7-1-1}, we can initialize the
colour registers during the vertical blank in a much better way:

bar_height1=30
bar_height2=30

0=<n<=((bar_height1/2)-1)+((bar_height2/2)-1)

  CMOVE $0000,BPLCON3		;High values
  CMOVE $0XXX,COLORn
  ...etc...
  CMOVE $0200,BPLCON3		;Low values
  CMOVE $0xxx,COLORn
  ...etc...

and then display the bars colours with only one @{"CWAIT" LINK Chapter-4-4-14} and one @{"CMOVE" LINK Chapter-4-4-14} line
by line:

0=<n<=bar_height1-1

  CWAIT $00,y+n
  CMOVE n*2*256,BPLCON4		;Swap palette of 2 colours
  ...etc...

That's real copper madness :)
@ENDNODE


@NODE Chapter-4-7-1-3 "4 Optimizing & tricks / AGA / Copper / Background effects on BPLCON4-chunky screens"
@{B}4-7-1-3 Background effects on BPLCON4-chunky screens@{UB}

Lets expect a 44x256 @{"BPLCON4" LINK BPLCON4}-chunky screen with a single bitplane with
352x256 visible pixels. That means that the registers @{"DIWSTART" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT}/
@{"DIWHIGH" LINK DIWHIGH} need to be initialized with the values HSTART=$67, HSTOP=$1C7,
VSTART=$2C and VSTOP=$12C.

We want to add a line oriented background effect, which only changes the
first column and for the rest it's always the same value. The CPU could
copy what's written into the first column also into the rest of the 43
columns. But this method takes much raster time.

There is a better way. As mentioned in @{"Big blits" LINK Chapter-3-2-4-1}, we can clear a whole
BPLCON4-chunky screen with a single clearblit @{B}and@{UB} a certain colour. In
that example it was colour 255.

To include our line oriented effect, e.g. a vertical colourscroll, we
just extend our copper list with this command sequence:

HSTART=$67
VSTART=$2C

0=<n<=255

  CWAIT HSTART-(4+(4*8)),VSTART+n ;Wait for horizontal blank
  @{FG FILL}CMOVE $E000,BPLCON3@{FG TEXT}		;8th colour bank high colour values
  @{FG FILL}CMOVE $0XXX,COLOR31@{FG TEXT}           ;Set the higher bits in register 255
  @{FG FILL}CMOVE $E200,BPLCON3@{FG TEXT}		;8th colour bank low colour values
  @{FG FILL}CMOVE $0xxx,COLOR31@{FG TEXT}           ;Set the lower bits in register 255
  CMOVE $XXXX,BPLCON4		;44 times
  ...etc...

Every scan line, we change the value of colour 255 in the horizontal
blanking area. That's why the value 4+(8*4) is subtracted from HSTART.
Four lores pixels because of the BPLCON4-delay of 1 lores pixel and 32
lores pixels for the execution of the additional four @{"CMOVEs" LINK Chapter-4-4-14}.

We have to subtract 4 lores-pixels, because we don't reset the BPLCON4-
register at the end of the scan line to zero. That means, that the last
colour value of the previous scan line is displayed in the first two lores
pixels at the left border of the display window.

To prevent this effect, we would require a 45th CMOVE which is superfluous,
if we change the x-coordinate of the @{"CWAIT" LINK Chapter-4-4-14} command. The "missing" two lores
pixels of the left border appear on the right border, because the last CMOVE
command holds the colour value until the HSTOP position. As a consequence
the last copper column is 10 instead of 8 lores pixels wide.

Because of our clearblit, the colour 255 is visible in the whole scan line
between the defined values HSTART=$67 and HSTOP=$1C7 in the registers
@{"DIWSTART" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT}/@{"DIWHIGH" LINK DIWHIGH}.

It is important to extend our clearblit to 49 words (1 CWAIT, 48x CMOVEs)
and 256 lines instead of 45 words (1 CWAIT, 44x CMOVEs) and 256 lines. As
a consequence the CMOVE for the @{"BPLCON3" LINK BPLCON3} and @{"COLOR255" LINK COLORxx} must be restored,
because the second command word is written over by the value $FFFE:

HSTART=$67
VSTART=$2C

0=<n<=255

Copper list before clear blit:

copper_list
  DC.W $2C21,$FFFE ;CWAIT HSTART-(4+(4*8)),VSTART+n First @{"CWAIT" LINK Chapter-4-4-14}
  DC.W $0106,$E000 ;CMOVE $E000,BPLCON3 8th colour bank high colour values
  DC.W $01BE,$0xxx ;CMOVE $0XXX,COLOR31 Set the higher bits in register 255
  DC.W $0106,$E200 ;CMOVE $E000,BPLCON3 8th colour bank low colour values
  DC.W $01BE,$0xxx ;CMOVE $0xxx,COLOR31 Set the lower bits in register 255
  DC.W $010C,$0000 ;CMOVE $2200,BPLCON4 Repeated 44 times
  ...etc...

and after clear blit:

copper_list
  DC.W $2C21,$FFFE ;CWAIT HSTART-(4+(4*8)),VSTART+n First CWAIT
  DC.W $0106,@{FG FILL}$FFFE@{FG TEXT} ;CMOVE @{FG FILL}$FFFE@{FG TEXT},BPLCON3	8th colour bank high colour values
  DC.W $01BE,@{FG FILL}$FFFE@{FG TEXT} ;CMOVE @{FG FILL}$FFFE@{FG TEXT},COLOR31	Set the higher bits in register 255
  DC.W $0106,@{FG FILL}$FFFE@{FG TEXT} ;CMOVE @{FG FILL}$FFFE@{FG TEXT},BPLCON3	8th colour bank low colour values
  DC.W $01BE,@{FG FILL}$FFFE@{FG TEXT} ;CMOVE @{FG FILL}$FFFE@{FG TEXT},COLOR31	Set the lower bits in register 255
  DC.W $010C,@{FG FILL}$FFFE@{FG TEXT} ;CMOVE @{FG FILL}$FFFE@{FG TEXT},BPLCON4	Repeated 44 times
  ...etc...

Your backround effect routine can do this on the fly as you already have to
write the new colour values into the copper list.

The increase of the blitter window takes much less cycles than initializing
all 44 BPLCON4-values for every scan line by the CPU.

There is another positive aspect. Your background effect can use the full
palette of 16,7 million 24-bit colour values. There is no restriction like
using the BPLCON4 which restricts the palette to a maximum of 256 pre-
initialized 24-bit colour values in the vertical blank area.
@ENDNODE


@NODE Chapter-4-7-1-4 "4 Optimizing & tricks / AGA / Copper / Four-pixels BPLCON4-chunky screens"
@{B}4-7-1-4 Four-pixels BPLCON4-chunky screens@{UB}

As already mentioned @{"above" LINK Chapter-4-6-1-1}, this effect is also possible on the AGA chipset
with up to 255 colour values in 24 bits.

We just replace the register @{"COLOR00" LINK COLORxx} with the register @{"BPLCON4" LINK BPLCON4} and define
a colourrun of 255 colour palette entries by the copper at the top of the
screen in the vertical blank area.

The BPLCON4 register then switches between the BPLAM-value 1-255 to display
the defined colours from COLOR01-COLOR255. That's all.
@ENDNODE


@NODE Chapter-4-7-1-5 "4 Optimizing & tricks / AGA / Copper / Saving data fetch cycles on BPLCON4-chunky screens"
@{B}4-7-1-5 Saving data fetch cycles on BPLCON4-chunky screens@{UB}

We know that the @{"BPLCON4" LINK BPLCON4} colourswitch works with a minimum of one bitplane
and within the boundaries defined in @{"DIWSTRT" LINK DIWSTRT}, @{"DIWSTOP" LINK DIWSTRT} and @{"DIWHIGH" LINK DIWHIGH}.

If we just use an empty monocolour plane, we don't need a data fetch for the
whole visible line. Normally 320 visible pixels need the data fetch values
@{"DDFSTRT" LINK DDFSTRT}=$38 and @{"DDFSTOP" LINK DDFSTRT}=$A0 for a 4x data fetch.

Using the 4x data fetch mode, we only have to fetch the minimum of 128
pixels. That means DDFSTRT=$38 and DDFSTOP=$40, because we can't use the
same value for DDFSTRT and DDFSTOP. At DMA slot $38 the first quad word
(64 pixels) is fetched and at slot $40 the last quad word.

Once the data fetch started, the BPLCON4-switching is possible until HSTOP
which is defined in the registers DIWSTOP and DIWHIGH.
@ENDNODE


@NODE Chapter-4-7-2 "4 Optimizing & tricks / AGA / Playfields"
@{B}4-7-2 Playfields@{UB}

      4-7-2-1 @{" Screen splitting with multiple horizontal viewports " LINK Chapter-4-7-2-1}
      4-7-2-2 @{" Setting horizontal scroll bits" LINK Chapter-4-7-2-2}
      4-7-2-3 @{" Setting display window background colour" LINK Chapter-4-7-2-3}
      4-7-2-4 @{" A programmed NTSC & PAL display" LINK Chapter-4-7-2-4}
@ENDNODE


@NODE Chapter-4-7-2-1 "4 Optimizing & tricks / AGA / Playfields / Screen splitting with multiple horizontal viewports"
@{B}4-7-2-1 Screen splitting with multiple horizontal viewports@{UB}

With AGA and the @{"BPLCON4" LINK BPLCON4} register we have the possibility to change the
palette at a certain horizontal screen position during every scan line.

This gives us the chance to display two horizontal viewports with separate
palettes. It's an extention of the possibilities already described @{"here" LINK Chapter-4-6-2-1}
for the OCS. Every horizontal viewport can have its own palette, different
resolutions and depths.

In this example we use the colours COLOR00-COLOR127 for the first viewport
and COLOR128-COLOR255 for the second viewport and swap these palettes by the
BPLAM=$00 for the first 128 colours palette and BPLAM=$80 for the second 128
colours palette.

Due to the fact that BPLCON4 colour changes are delayed by one lores pixel
compared to direct @{"COLORxx" LINK COLORxx} colour changes, a shift with the H1-bit set
in @{"BPLCON1" LINK BPLCON1} is needed.

I've chosen the interleaved bitplane format raw modulo that means:
1st line plane0, 1st line plane1, 1st line plane2,...
2nd line plane0, 2nd line plane1, 2nd line plane2,...
...etc...

For this format the plane moduli have to be calculated like this:

  @{I}Moduli=plane_width*(depth-1)@{UI}

The normal bitplane format plane after plane could be also used.

Here are the different ways of screen splitting:


@{B}1. Two viewports with the same screen depth and resolution (lores/lores)
   and different palettes@{UB}

1st viewport (160x256 pixels, lores, 7 bitplanes)
2nd viewport (160x256 pixels, lores, 7 bitplanes)

depth=7
plane_width=(160+160)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch
  CMOVE $00A0,DDFSTOP		;End data fetch for 4x mode
  CMOVE $7200,BPLCON0		;7 bitplanes depth, lores
  CMOVE $2200,BPLCON1		;Shift with H1-bit is needed, because
				;changing the palette with BPLCON4 has a 
				;delay of 1 pixel delay versus COLORxx
  CMOVE $0200,BPLCON2		;Kill EHB because of bitplane depth > 5
  CMOVE $1000,BPLCON3		;PF2OF=16, lores sprite
  CMOVE $0011,BPLCON4		;2nd colour table odd&even sprites (standard)
  CMOVE plane_width*(depth-1),BPL1MOD ;Plane moduli
  CMOVE plane_width*(depth-1),BPL2MOD
  CMOVE $2100,DIWHIGH		;Additional window limits
  CMOVE $0003,FMODE		;4x data fetch (64 bits)
  ...etc...

Just repeat this command sequence changing the @{"BPLCON4" LINK BPLCON4} register twice per
scan line for a display with a height of 256 lines:

0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE $0000,BPLCON4		;Palette colours 0-127
  CWAIT HSTART+158,VSTART+n
  CMOVE $8000,BPLCON4  		;Palette colours 128-255
  ...etc...

Don't forget to do an extra @{"CWAIT" LINK Chapter-4-4-14} $1C0,$FF for the line wrap, because with
a 4x bandwidth, memory cycles are free and available for the copper even in
hires displays with >=4 bitplanes.


@{B}2. Two viewports with same resolution (lores/lores) and different screen
   depths and palettes@{UB}

1st viewport (160x256 pixels, lores, 7 bitplanes)
2nd viewport (160x256 pixels, lores, 5 bitplanes)

To code this, we need a blank-column of eight lores pixels between the
viewports, because we change the content of @{B}two@{UB} registers (@{"BPLCON0" LINK BPLCON0}&@{"BPLCON4" LINK BPLCON4})
every scan line twice.

A single @{"CMOVE" LINK Chapter-4-4-14} instruction needs eight lores pixels to be executed as a
minimum. Changing two consecutive registers need this blank-column.

After changing the content of BPLCON0, we can switch the palette eight
pixels later. This means, that one of the viewports has a loss of eight
pixels in its width.

The bitplane pointers for bitplane 6&7 must also be refreshed as mentioned
@{"here" LINK Chapter-4-6-2-1} for the OCS.

depth=7
plane_width=(160+160)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch
  CMOVE $00A0,DDFSTOP		;End data fetch for 4x mode
  CMOVE $7200,BPLCON0		;7 bitplanes depth, lores
  CMOVE $2200,BPLCON1		;Shift with H1-bit is needed, because
				;changing the palette with BPLCON4 has a 
				;delay of 1 pixel delay versus COLORxx
  CMOVE $0200,BPLCON2		;Kill EHB because of bitplane depth > 5
  CMOVE $1000,BPLCON3		;PF2OF=16, lores sprite
  CMOVE $0011,BPLCON4		;2nd colour table odd&even sprites (standard)
  CMOVE plane_width*(depth-1),BPL1MOD ;Plane moduli
  CMOVE plane_width*(depth-1),BPL2MOD
  CMOVE $2100,DIWHIGH		;Additional window limits
  CMOVE $0003,FMODE		;4x data fetch (64 bits)


0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE (bp6_start+((plane_width*depth*n)))/65536,BPL6PTH
  CMOVE (bp6_start+((plane_width*depth*n)))&65535,BPL6PTL
  CMOVE (bp7_start+((plane_width*depth*n)))/65536,BPL7PTH
  CMOVE (bp7_start+((plane_width*depth*n)))&65535,BPL7PTL
  CMOVE $7200,BPLCON0		;7 bitplanes depth,lores
  CMOVE $0000,BPLCON4		;Palette colours 0-127
  CWAIT HSTART+158,VSTART+n
  CMOVE $5200,BPLCON0		;5 bitplanes depth, lores
  CMOVE $8000,BPLCON4		;Palette colours 128-159
  ...etc...


@{B}3. Two viewports with a different screen depths, resolutions (lores/hires)
   and palettes@{UB}

1st viewport (256x256 pixels, lores, 7 bitplanes)
2nd viewport (128x256 pixels, hires, 2 bitplanes)

To code this, we need a blank-column of eight lores pixels between the
viewports, because we change the content of @{B}two@{UB} registers (@{"BPLCON0" LINK BPLCON0}&@{"BPLCON4" LINK BPLCON4})
every scan line twice.

A single @{"CMOVE" LINK Chapter-4-4-14} instruction needs eight lores pixels to be executed as a
minimum. Changing two consecutive registers need this blank-column.

After changing the content of BPLCON0, we can switch the palette eight
pixels later. This means, that one of the viewports has a loss of eight
pixels in its width.

The bitplane pointers for bitplane 3,4,5,6&7 must also be refreshed as
mentioned @{"here" LINK Chapter-4-6-2-1} for the OCS.

depth=7
plane_width=(256+128)/8
HSTART=$81
VSTART=$2C

  CMOVE $2C81,DIWSTRT		;Standard window dimensions
  CMOVE $2CC1,DIWSTOP
  CMOVE $0038,DDFSTRT		;Start data fetch
  CMOVE $00C0,DDFSTOP		;and end data fetch for hires 4x mode
  CMOVE $7200,BPLCON0		;7 bitplanes depth, lores
  CMOVE $2200,BPLCON1		;Shift with H1-bit is needed, because
				;changing the palette with BPLCON4 has a 
				;delay of 1 pixel delay versus COLORxx
  CMOVE $0200,BPLCON2		;Kill EHB because of bitplane depth > 5
  CMOVE $1000,BPLCON3		;PF2OF=16, lores sprite
  CMOVE $0011,BPLCON4		;2nd colour table odd&even sprites (standard)
  CMOVE plane_width*(depth-1),BPL1MOD ;Plane moduli
  CMOVE plane_width*(depth-1),BPL2MOD
  CMOVE $2100,DIWHIGH		;Additional window limits
  CMOVE $0003,FMODE		;4x data fetch (64 bits)


0=<n<=255

  CWAIT $00,VSTART+n
  CMOVE (bp3_start+(plane_width*depth*n))/65536,BPL3PTH
  CMOVE (bp3_start+(plane_width*depth*n))&65535,BPL3PTL
  CMOVE (bp4_start+(plane_width*depth*n))/65536,BPL4PTH
  CMOVE (bp4_start+(plane_width*depth*n))&65535,BPL4PTL
  CMOVE (bp5_start+(plane_width*depth*n))/65536,BPL5PTH
  CMOVE (bp5_start+(plane_width*depth*n))&65535,BPL5PTL
  CMOVE (bp6_start+(plane_width*depth*n))/65536,BPL6PTH
  CMOVE (bp6_start+(plane_width*depth*n))&65535,BPL6PTL
  CMOVE (bp7_start+(plane_width*depth*n))/65536,BPL7PTH
  CMOVE (bp7_start+(plane_width*depth*n))&65535,BPL7PTL
  CMOVE $7200,BPLCON0		;7 bitplanes depth, lores
  CMOVE $0000,BPLCON4		;Palette colours 0-127
  CWAIT HSTART+238,VSTART+n	;May change with other depths
  CMOVE $A200,BPLCON0		;2 bitplanes depth, hires
  CMOVE $8000,BPLCON4		;Palette colours 128-131
  ...etc...
@ENDNODE


@NODE Chapter-4-7-2-2 "4 Optimizing & tricks / AGA / Playfields / Setting horizontal scroll bits"
@{B}4-7-2-2 Setting horizontal scroll bits@{UB}

Normally setting the horizontal shift value in @{"BPLCON1" LINK BPLCON1} could be done with
the BTST/BSET commands or with LSR/ADD and branch-commands.

But there is a much faster way:

;D0=xpos
;D1=Shift-bits in return

  MOVEQ   #FALSE,D1
  SUB.W   D0,D1              ;shift value=-1-(xpos)
  LSL.W   #2,D1              ;-- -- -- -- -- -- H7 H6 H5 H4 H3 H2 H1 H0 -- --
  ROR.B   #4,D1              ;-- -- -- -- -- -- H7 H6 H1 H0 -- -- H5 H4 H3 H2
  LSL.W   #2,D1              ;-- -- -- -- H7 H6 H1 H0 -- -- H5 H4 H3 H2 -- --
  LSR.B   #2,D1              ;-- -- -- -- H7 H6 H1 H0 -- -- -- -- H5 H4 H3 H2
  MOVE.W  D1,D0              ;-- -- -- -- H7 H6 H1 H0 -- -- -- -- H5 H4 H3 H2
  LSL.W   #4,D0              ;H7 H6 H1 H0 -- -- -- -- H5 H4 H3 H2 -- -- -- --
  OR.W    D0,D1              ;H7 H6 H1 H0 H7 H6 H1 H0 H5 H4 H3 H2 H5 H4 H3 H2
@ENDNODE


@NODE Chapter-4-7-2-3 "4 Optimizing & tricks / AGA / Playfields / Setting display window background colour"
@{B}4-7-2-3 Setting display window background colour@{UB}

If you want to define the backround colour within a display window defined
in @{"DIWSTRT" LINK DIWSTRT}, @{"DIWSTOP" LINK DIWSTRT} and @{"DIWHIGH" LINK DIWHIGH} on the OCS chipset, you had to use the
copper for it.

For a standard 320x256 screen with the display window values HSTART=$81
and HSTOP=$1C1, you wait 256 times for the horizontal lores position
HSTART=$80, change the background colour and do a 2nd @{"CWAIT" LINK Chapter-4-4-14} at HSTOP=$1C0
to set the old background colour outside the display window.

Starting with the AGA chipset, this effect is much easier to handle. You
don't have to wait 2x256 times with the copper, you just once set in the
vertical blank area the BPLAM-bits of @{"BPLCON4" LINK BPLCON4}=@{B}BPLAM0*pf_colors_num@{UB} to
switch between the two palettes.

For example a screen with eight colours needs two palettes. COLOR00-07 are
the colours outside the display window and COLOR08-15 are the colours inside
the display window. These palettes could be initialized by the copper in the
vertical blank area. The switch value for this case is @{B}BPLAM0*8@{UB}.

So for a background colour change, you define COLOR00 of the first palette
outside the window and COLOR08 for the second palette inside the window.
@ENDNODE


@NODE Chapter-4-7-2-4 "4 Optimizing & tricks / AGA / Playfields / A programmed NTSC & PAL display"
@{B}4-7-2-4 A programmed NTSC & PAL display@{UB}

Did you ever want to know with which values the hardware works to display
a NTSC or a PAL screen?

Well, here's the answer. On the ECS/AGA chipset you could program a standard
NTSC display with these values:

@{"HTOTAL" LINK HTOTAL}   = $00E3
@{"HSSTOP" LINK HSSTOP}   = $0023
@{"HBSTRT" LINK HBSTOP}   = $0008
@{"HBSTOP" LINK HBSTOP}   = $002B
@{"VTOTAL" LINK VTOTAL}   = $0106
@{"VSSTOP" LINK VSSTOP}   = $0006
@{"VBSTRT" LINK VBSTOP}   = $0000
@{"VBSTOP" LINK VBSTOP}   = $0014
@{"HSSTRT" LINK HSSTOP}   = $0012
@{"VSSTRT" LINK VSSTOP}   = $0003
@{"HCENTER" LINK HCENTER}  = $0071
@{"BEAMCON0" LINK BEAMCON0} = $1380

@{"DIWSTRT" LINK DIWSTRT}  = $2C81
@{"DIWSTOP" LINK DIWSTRT}  = $F4C1
@{"DIWHIGH" LINK DIWHIGH}  = $2000


And a standard PAL display with these values:

@{"HTOTAL" LINK HTOTAL}   = $00E3
@{"HSSTOP" LINK HSSTOP}   = $0023
@{"HBSTRT" LINK HBSTOP}   = $0008
@{"HBSTOP" LINK HBSTOP}   = $002B
@{"VTOTAL" LINK VTOTAL}   = $0138
@{"VSSTOP" LINK VSSTOP}   = $0005
@{"VBSTRT" LINK VBSTOP}   = $0000
@{"VBSTOP" LINK VBSTOP}   = $0019
@{"HSSTRT" LINK HSSTOP}   = $0012
@{"VSSTRT" LINK VSSTOP}   = $0002
@{"HCENTER" LINK HCENTER}  = $0071
@{"BEAMCON0" LINK BEAMCON0} = $13A0

@{"DIWSTRT" LINK DIWSTRT}  = $2C81
@{"DIWSTOP" LINK DIWSTRT}  = $2CC1
@{"DIWHIGH" LINK DIWHIGH}  = $2100
@ENDNODE


@NODE Chapter-4-7-3 "4 Optimizing & tricks / AGA / Sprites"
@{B}4-7-3 Sprites@{UB}

      4-7-3-1 @{" Setting sprite position " LINK Chapter-4-7-3-1}
      4-7-3-2 @{" Bordersprites " LINK Chapter-4-7-3-2}
@ENDNODE


@NODE Chapter-4-7-3-1 "4 Optimizing & tricks / AGA / Sprites / Setting sprite position"
@{B}4-7-3-1 Setting sprite position@{UB}

Setting the sprite's horizontal and vertical position in the sprite
structure could be done with the BTST/BSET or with LSR/ADD and branch
commands.

But there is a much faster way using the ADDX command without BTST/BSET
and branch commands:

;A0=Sprite header
;D0=xpos
;D1=ypos
;D4=height

  MOVE.W  D1,D2	   ;Save ypos
  ROL.W   #8,D1	   ; SV7 SV6 SV5 SV4 SV3 SV2 SV1 SV0 --- --- --- --- --- --- --- SV8
  MOVEQ   #TRUE,D3 ;SPRxCTL low byte
  MOVE.B  D1,D3	   ; --- --- --- --- --- --- --- SV8
  ADD.W   D4,D2	   ;Add sprite height
  ADD.B   D3,D3	   ; --- --- --- --- --- --- SV8 ---
  ROL.W   #8,D2	   ; EV7 EV6 EV5 EV4 EV3 EV2 EV1 EV0 --- --- --- --- --- --- --- EV8
  OR.B    D2,D3	   ; --- --- --- --- --- --- SV8 EV8
  LSL.W   #5,D0	   ;SH10 SH9 SH8 SH7 SH6 SH5 SH4 SH3 SH2 SH1 SH0 --- --- --- --- ---
  ADD.B   D0,D0	   ; SH1 SH0 --- --- --- --- --- ---: X-Flag = SH2-Bit
  ADDX.B  D3,D3	   ; --- --- --- --- --- SV8 EV8 SH2: Add SH2-Bit
  LSR.B   #3,D0	   ; --- --- --- SH1 SH0 --- --- ---
  OR.B    D0,D3	   ; --- --- --- SH1 SH0 SV8 EV8 SH2
  LSR.W   #8,D0	   ; --- --- --- --- --- --- --- --- SH10 SH9 SH8 SH7 SH6 SH5 SH4 SH3 = SPRxPOS low byte
  MOVE.B  D0,D1	   ; SV7 SV6 SV5 SV4 SV3 SV2 SV1 SV0 SH10 SH9 SH8 SH7 SH6 SH5 SH4 SH3 = SPRxPOS
  MOVE.W  D1,(A0)  ;@{"SPRxPOS" LINK SPRxPOS}
  MOVE.B  D3,D2	   ; SV7 SV6 SV5 SV4 SV3 SV2 SV1 SV0 SH10 SH9 SH8 SH7 SH6 SH5 SH4 SH3 --- --- --- SH1 SH0 SV8 EV8 SH2 = SPRxCTL low byte
  MOVE.W  D2,8(A0) ;@{"SPRxCTL" LINK SPRxCTL} (Offset 8 = 4x data fetch, offset 4= 2x data fetch, offset 2 = 1x data fetch)
@ENDNODE


@NODE Chapter-4-7-3-2 "4 Optimizing & tricks / AGA / Sprites / Bordersprites"
@{B}4-7-3-2 Bordersprites@{UB}

You can blank the visible area for border sprites, if you set the BRDRBLNK
bit of @{"BPLCON3" LINK BPLCON3} additionally to the BRDSPRT bit.

This blanks the overscan border area and the sprites will be only visible
within @{"DDFSTRT" LINK DDFSTRT} and HSTOP defined in @{"DIWSTOP" LINK DIWSTRT} and @{"DIWHIGH" LINK DIWHIGH}.

For example you could display a lores 256x256 pixels viewport and use some
normal sprites or @{"scan doubled attached sprites" LINK Chapter-3-2-3-2} for a background graphic
which covers 320x256 pixels.

This would speed up your effect routine, as you only have to handle a narrow
256x256 pixels memory block instead of a wider 320x256 pixels memory block,
but it will all appear as a standard 320x256 pixels display.
@ENDNODE


@NODE Chapter-4-8 "4 Optimizing & tricks / All Chip Sets"
@{B}4-8 All Chip Sets@{UB}

    4-8-1 @{" Copper " LINK Chapter-4-8-1}
    4-8-2 @{" Playfields " LINK Chapter-4-8-2}
    4-8-3 @{" Blitter " LINK Chapter-4-8-3}
@ENDNODE


@NODE Chapter-4-8-1 "4 Optimizing & tricks / All Chip Sets / Copper"
@{B}4-8-1 Copper@{UB}

      4-8-1-1 @{" Horizontal reuse of custom chip registers " LINK Chapter-4-8-1-1}
      4-8-1-2 @{" Faster access to pointer registers " LINK Chapter-4-8-1-2}
@ENDNODE


@NODE Chapter-4-8-1-1 "4 Optimizing & tricks / All Chip Sets / Copper / Horizontal reuse of custom chip registers"
@{B}4-8-1-1 Horizontal reuse of custom chip registers@{UB}

In a sequence of consecutive @{"CMOVE" LINK Chapter-4-4-14} commands the copper can change the
content of a register in a lores display with up to four bitplanes depth
or a hires display with up to two bitplanes within eight lores pixels.

If there are more bitplanes, the copper execution increases up to 16
lores pixels (6 bitplanes, lores) or more.

Here are some custom chip registers where a horizontal reuse with the
copper every scan line might be useful:


@{"BPLCON1" LINK BPLCON1}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For reducing the width of bitplane data up to 8 lores pixels from left
and right on OCS and up to 16 lores pixels from left and right on AGA.

Take care that the distance between the shiftvalues of a scan line
is not greater than 1 or you will have a distorted display:

  CMOVE $00EE,BPLCON1		;Distance=1 is okay
  CMOVE $00DD,BPLCON1

  CMOVE $00EE,BPLCON1		;Distance>1 don't do this!
  CMOVE $00CC,BPLCON1

And keep in mind that the first shift value of the line is set in the
previous line to have a correct shift at the beginning.

A copper list for the OCS could look like this:

HSTART=$81
VSTART=$2C

  CMOVE $00EE,BPLCON1		;First shift in previous line
  CWAIT HSTART,VSTART
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00EE,BPLCON1
  CMOVE $00DD,BPLCON1
  CMOVE $00DD,BPLCON1
  CMOVE $00CC,BPLCON1
  CMOVE $00CC,BPLCON1
  CMOVE $00BB,BPLCON1
  CMOVE $00BB,BPLCON1
  CMOVE $00AA,BPLCON1
  CMOVE $00AA,BPLCON1
  CMOVE $0099,BPLCON1
  CMOVE $0088,BPLCON1
  CMOVE $0088,BPLCON1
  CMOVE $0077,BPLCON1
  CMOVE $0066,BPLCON1
  CMOVE $0055,BPLCON1
  CMOVE $0055,BPLCON1
  CMOVE $0044,BPLCON1
  CMOVE $0044,BPLCON1
  CMOVE $0033,BPLCON1
  CMOVE $0033,BPLCON1
  CMOVE $0022,BPLCON1
  CMOVE $0022,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $0011,BPLCON1
  CMOVE $00EE,BPLCON1		;A distance>1 is okay because it's the
  CWAIT HSTART,VSTART+1		;first shift of next line
  CMOVE $00EE,BPLCON1
  ...etc...

With the ACTION REPLAY module I found out, that Kefrens used this method to
scale their realtime zoomer (texture cube) in @{I}Desert Dream@{UI} and Sanity
used it to display their Star Wars scroller and the texture menu-box in
@{I}Jesterday@{UI}.


@{"BPLCON2" LINK BPLCON2}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For a horizontal change of the priority of sprites against playfields
where sprites could vanish behind certain background areas for example
some vertical bars with a width of 8 lores pixels.

A copper list could look like this:

HSTART=$81
VSTART=$2C

  CWAIT HSTART,VSTART
  CMOVE $0000,BPLCON2		;40 x @{"CMOVE" LINK Chapter-4-4-14} for a 320/640 pixels display
  CMOVE $0024,BPLCON2		;Sprites have priority over bitplanes
  CMOVE $0000,BPLCON2		;Bitplanes have priority over sprites
  ...etc...
  CWAIT HSTART,VSTART+1
  ...etc...


@{"BPLCON4" LINK BPLCON4}  [ - /@{FG FILL} - @{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For horizontal switching of the palette of a playfield or odd/even sprites.
See also under @{"Switching sprite palettes" LINK Chapter-3-2-3-4} or the palette of bitplanes
see also under @{"Initializing playfield colours" LINK Chapter-4-7-1-1}. This effect can be
used for horizontal shading effects.

A copper list for a mono display with only the background colour displayed
could look like this:

depth=1
HSTART=$81
VSTART=$2C

  CWAIT HSTART-4,VSTART		;HSTART-4 because of BPLCON4 delay
  CMOVE $0000,BPLCON4		;40 x @{"CMOVE" LINK Chapter-4-4-14} for a 320/640 pixels display
  CMOVE $0100,BPLCON4		;Use COLOR01 as COLOR00
  CMOVE $0200,BPLCON4		;Use COLOR02 as COLOR00
  ...etc...
  CWAIT HSTART-4,VSTART+1
  ...etc...


@{"COLORxx" LINK COLORxx}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For a horizontal change of the 12 bits of a special colour on OCS or on
AGA 12 high bits if LOCT-bit=0 in @{"BPLCON3" LINK BPLCON3}. Could be used for a horizontal
shading effect.

A copper list could look like this:

HSTART=$81
VSTART=$2C


  CMOVE $0000,BPLCON3		;LOCT-Bit cleard for AGA colour register
  ...etc...			;access (change of 12 high @{B}and@{UB} low bits)
  CWAIT HSTART,VSTART
  CMOVE $0001,COLOR00		;40 x @{"CMOVE" LINK Chapter-4-4-14} for a 320/640 pixels display
  CMOVE $0002,COLOR00
  CMOVE $0003,COLOR00
  ...etc...
  CWAIT HSTART,VSTART+1
  ...etc...


@{"SPRxDAT" LINK SPRxDAT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For a horizontal change of sprite data only for 16 pixels sprites, because
the copper has only a word bandwidth. Sprite-DMA should be turned off.
Remember to initialize the @{"SPRxCTL" LINK SPRxCTL} register first, because it disables
the sprite.

A copper list could look like this:

HSTART=$81
VSTART=$2C

  CWAIT HSTART-24,VSTART	;Manipulation before sprite display start
  CMOVE $2C40,SPR0POS		;X=HSTART, Y=VSTART
  CMOVE $XXXX,SPR0DATB		;Data plane1
  CMOVE $XXXX,SPR0DATA		;Data plane0 This write arms the sprite
  CWAIT HSTART+40,VSTART	;Manipulation before sprite display start
  CMOVE $2C60,SPR0POS		;X=193/2, Y=VSTART
  CMOVE $XXXX,SPR0DATB		;Data plane1
  CMOVE $XXXX,SPR0DATA		;Data plane0
  ...etc...

Take care that the sprite dataregisters are written @{B}before@{UB} the data is
displayed.


@{"SPRxPOS" LINK SPRxPOS}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]

For horizontal reusing a sprite every time the horizontal comparator
matches with the horizontal beam position and the last sprite data is
displayed again.

This method works with all kind of sprites (16/32/64 pixels). See also
under @{"Horizontal reuse of sprites" LINK Chapter-3-2-3-1}.

It is useful, that you display the sprites by DMA especially if you use
32 or 64 pixels sprites. If you turn the DMA off, you have to initialize
the @{"SPRxCTL" LINK SPRxCTL} and @{"SPRxDAT" LINK SPRxDAT} registers by yourself. Only for 16 pixels sprites
this non-DMA way really works, because with the copper or the MC680x0 you
can only write with a word bandwidth to these registers.


@{B}Background patterns with non-attached sprites (OCS)@{UB}

If you display a background display pattern (32 pixels) with 16 pixels
sprites this could be done by using two sprites which appear alternately.

Take care that the @{"SPRxPOS" LINK SPRxPOS} register is writen every 16th lores pixels
on a 4 bitplanes lores or a 2 bitplanes hires display. You have to
put a NOOP write between your SPRxPOS changes to increase the copper
execution for a proper timing.

A copper list could look like this:

HSTART=$81
VSTART=$2C

  CWAIT HSTART-16,VSTART	;Manipulation before sprite display starts
  CMOVE $2C40,SPR0POS		;X=HSTART/2, Y=VSTART
  CMOVE $0000,NOOP		;Increase copper execution
  CMOVE $2C48,SPR1POS		;(X=HSTART+16)/2, Y=VSTART
  CMOVE $0000,NOOP
  CMOVE $2C50,SPR0POS		;(X=HSTART+32)/2, Y=VSTART
  CMOVE $0000,NOOP
  CMOVE $2C58,SPR1POS		;(X=HSTART+48)/2, Y=VSTART
  CMOVE $0000,NOOP
  CMOVE $2C60,SPR0POS		;(X=HSTART+64)/2, Y=VSTART
  ...etc...


If you have a 6 bitplanes lores display (with a 1x data fetch on AGA), the
NOOP is superfluous, because a CMOVE needs 16 lores pixels for execution:

  CWAIT HSTART-8,VSTART		;Manipulation before sprite display start
  CMOVE $2C40,SPR0POS		;X=HSTART/2, Y=VSTART
  CMOVE $2C48,SPR1POS		;(X=HSTART+16)/2, Y=VSTART
  CMOVE $2C50,SPR0POS		;(X=HSTART+32)/2, Y=VSTART
  CMOVE $2C58,SPR1POS		;(X=HSTART+48)/2, Y=VSTART
  CMOVE $2C60,SPR0POS		;(X=HSTART+64)/2, Y=VSTART
  CMOVE $2C68,SPR1POS		;(X=HSTART+80)/2, Y=VSTART
  ...etc...

With the help of the ACTION REPLAY module I found out, that this method is
used in the OCS game @{I}Jim Power@{UI} for the background with a 3+3 planes
lores dual playfield.


@{B}Background patterns with attached sprites (OCS)@{UB}

If you want to display a background display pattern (32 pixels) with
attached 16 pixels sprites in 16 colours this could be done by using 2x2
sprites which appear alternately.

This method only works on 4 bitplanes lores/2 bitplanes hires displays
because otherwise the copper execution lasts too long.

A copper list could look like this:

HSTART=$81
VSTART=$2C

  CWAIT HSTART-16,VSTART	;Manipulation before sprite display start
  CMOVE $2C40,SPR0POS		;X=HSTART/2, Y=VSTART
  CMOVE $2C40,SPR1POS		;X=HSTART/2, Y=VSTART
  CMOVE $2C48,SPR2POS		;(X=HSTART+16)/2, Y=VSTART
  CMOVE $2C48,SPR3POS		;(X=HSTART+16)/2, Y=VSTART
  CMOVE $2C50,SPR0POS		;(X=HSTART+32)/2, Y=VSTART
  CMOVE $2C50,SPR1POS		;(X=HSTART+32)/2, Y=VSTART
  ...etc...


@{B}Background patterns with attached sprites (AGA)@{UB}

In case you want to use a background display pattern (64 pixels) with
attached sprites on a 3+3 bitplanes dual playfield display you can use 32-
pixels sprites on AGA.

Just set the 1x fetch mode (16 pixels data fetch, BPAGEM=0,BPL32=0) for
bitplanes and the 2x fetch mode (32 pixels data fetch, SPR32=1) for sprites
in the @{"FMODE" LINK FMODE} register to get the correct timing for the copper execution.

You will have enough time to change the @{"SPRxPOS" LINK SPRxPOS} register, because the
copper needs 2x16=32 lores pixels to execute the @{"CMOVE" LINK Chapter-4-4-14} command.

A copper list could look like this:

HSTART=$81
VSTART=$2C

  CWAIT HSTART-16,VSTART	;Manipulation before sprite display start
  CMOVE $2C40,SPR0POS		;X=HSTART/2, Y=VSTART
  CMOVE $2C40,SPR1POS		;X=HSTART/2, Y=VSTART
  CMOVE $2C50,SPR2POS		;(X=HSTART+32)/2, Y=VSTART
  CMOVE $2C50,SPR3POS		;(X=HSTART+32)/2, Y=VSTAkRT
  CMOVE $2C60,SPR0POS		;(X=HSTART+64)/2, Y=VSTART
  CMOVE $2C60,SPR1POS		;(X=HSTART+64)/2, Y=VSTART
  ...etc...
@ENDNODE


@NODE Chapter-4-8-1-2 "4 Optimizing & tricks / All Chip Sets / Copper / Faster access to pointer registers"
@{B}4-8-1-2 Faster access to pointer registers@{UB}

When the copper list accesses pointers @{"COP1LCH" LINK COP1LCH}/@{"COP1LCL" LINK COP1LCH} or @{"COP2LCH" LINK COP1LCH}/@{"COP2LCL" LINK COP1LCH}
in a copper list for example in a loop, the LCH registers don't have to be
always initialized again.

Let's assume two simple copper list-loops which wait for a certain scan
line and repeat the two @{"CMOVEs" LINK Chapter-4-4-14} changing the background colour until the
vertical beam position is equal or greater VSTART+16. In this case the the
@{"CMOVE" LINK Chapter-4-4-14} with @{"COPJMP1" LINK COPJMP1} is skipped:

;COP1LCH/L were initialized by the MC680x0 and point to the copper list

VSTART1=$2C
VSTART2=$5C

  CMOVE cl1_loop1/65536,COP1LCH ;Initialize first loop entry
  CMOVE cl1_loop1&65535,COP1LCL
  CWAIT 0,VSTART1
cl1_loop1
  CMOVE $0F0F,COLOR00		;Do some colourchanges
  CMOVE $0000,COLOR00
  CSKIP 0,VSTART1+16		;Loop until ypos>= $3C
  CMOVE $0000,COPJMP1		;Jump to first loop entry
  CMOVE cl1_loop2/65536,COP1LCH ;Initialize second loop entry
  CMOVE cl1_loop2&65535,COP1LCL
  CWAIT 0,VSTART2
cl1_loop2
  CMOVE $000F,COLOR00		;Do some colourchanges
  CMOVE $0000,COLOR00
  CSKIP 0,VSTART2+16		;Loop until ypos>= $6C
  CMOVE $0000,COPJMP1		;Jump to second loop entry
  ...etc...

In this case, we could optimize this copper list a little bit. COP1LCH was
already initialized by the MC680x0. So the two @{"CMOVEs" LINK Chapter-4-4-14} for the COP1LCH could
be deleted, if the copper list is aligned so that it starts from $XXXX0000
on a 64k-boundary.

Normally this could be done allocating an absolute address with the system
call @{"AllocAbs()" LINK AllocAbs()}. But this is not necessary. Just add 65536 bytes to the
memory size of the copper list when allocating the memory with @{"AllocMem()" LINK AllocMem()}.

After that, add 65535 bytes to the returned address, then clear the low 16
bits of the address. The result is a 64k aligned address without a need for
absolute allocations.

Just remember to use the original memory address when freeing the allocated
block with @{"FreeMem()" LINK FreeMem()}.

This method can be also used, if the MC680x0 accesses the blitter registers
in a sequence of several blits whereas the memory blocks would be aligned on
64k boundaries.

Many thanks to @{I}Toni Wilen@{UI} for this very useful hint.
@ENDNODE


@NODE Chapter-4-8-2 "4 Optimizing & tricks / All Chip Sets / Playfields"
@{B}4-8-2 Playfields@{UB}

      4-8-2-1 @{" Screen splitting with multiple vertical viewports " LINK Chapter-4-8-2-1}
@ENDNODE


@NODE Chapter-4-8-2-1 "4 Optimizing & tricks / All Chip Sets / Playfields / Screen splitting with multiple vertical viewports"
@{B}4-8-2-1 Screen splitting with multiple vertical viewports@{UB}

Let's expect we've got two viewports (320x96 pixels and 320x158 pixel) and
the copper list looks like this:

--- init 1st viewport ---
  CMOVE $2C81,DIWSTRT		;Standard display window 320x256 pixel
  CMOVE $2CC1,DIWSTOP		;for both viewports
  CMOVE $2100,DIWHIGH
  CMOVE $3201,BPLCON0 		;Turn on display 1st viewport which starts
				;at scan line $2C
  ...etc...           		;Init all other display registers
--- init 2nd viewport ---
  CWAIT $00,$8C
  CMOVE $0201,BPLCON0 		;Turn off display 1st viewport and start the
				;vertical blank area between the viewports
				;at scan line $8C
  ...etc...           		;Init all other display registers
  CWAIT $00,$8E
  CMOVE $2201,BPLCON0 		;Turn on display 2nd viewport which starts
				;at scan line $8E

The commands @{"CMOVE" LINK Chapter-4-4-14} $0201,BPLCON0 and @{"CWAIT" LINK Chapter-4-4-14} $00,$8E can be replaced by the
commands CMOVE $8E81,DIWSTRT and CMOVE $2CC1,DIWSTOP, because the bitplane
data is only displayed within the border specified in the @{"DIWSTRT" LINK DIWSTRT}/@{"DIWSTOP" LINK DIWSTRT}/
@{"DIWHIGH" LINK DIWHIGH} registers. Everything outside these limits is a blanked area.

So we initialize the window display limits for every viewport separatly:

--- init 1st viewport ---
  CMOVE $2C81,DIWSTRT           ;1st viewport diplay window limits 320x96
  CMOVE $8CC1,DIWSTOP		;pixel
  CMOVE $0100,DIWHIGH           ;ECS/AGA additional window limits
  CMOVE $3201,BPLCON0           ;Turn on display 1st viewport which starts
				;at scan line $2C
  ...etc...          		;Init other display registers of 2nd viewport
--- init 2nd viewport ---
  CWAIT $00,$8C                 ;At scan line $8C vertical blanking starts
  CMOVE $8E81,DIWSTRT           ;2nd viewport diplay window limits 320x158
  CMOVE $2CC1,DIWSTOP 		;pixel
  CMOVE $2100,DIWHIGH           ;ECS/AGA additional window limits
  CMOVE $2201,BPLCON0           ;Turn on display 2nd viewport which starts
				;at scan line $8E
  ...etc...          		;Init all other display registers

So we must initialize the @{"BPLCON0" LINK BPLCON0} register of the 2nd viewport only once
because the display starts at DIWSTRT_VSTART and all bitplane registers
are initialized in the blanked area $8C-$8D.
@ENDNODE


@NODE Chapter-4-8-3 "4 Optimizing & tricks / All Chip Sets / Blitter"
@{B}4-8-3 Blitter@{UB}

      4-8-3-1 @{" Copy blits with cleared sources " LINK Chapter-4-8-3-1}
@ENDNODE


@NODE Chapter-4-8-3-1 "4 Optimizing & tricks / All Chip Sets / Blitter / Copy blits with cleared sources"
@{B}4-8-3-1 Copy blits with cleared sources@{UB}

When you use concave filled vectors in conjunction with z-buffers, each
face is seen as a mono coloured face drawn into a buffer. The face colour
is derived from this buffer as a source for a "1", or if needed, for a "0"
a source pointing to an empty bitplane.

The copy blit with the minterm=$CA, or in other words D=(A&B)+(NOTA&C),
copies an empty bitplane (0) or the buffer (1) into the displayed picture,
starting from the depth sorted face with the biggest distance from the
viewer.

For example the face colour number 5 has the binary bit combination %101.
This means there are two copy blits that copy the moncolour filled face
from the buffer into the first and the third bitplane of the destination
and one copy blit with an empty bitplane as a source into the second
bitplane of the destination.

In this case, it is not necessary to point source channel B to an empty
plane. Just turn off the DMA for source channel B, remain the minterm
unchanged and set the @{"BLTBDAT" LINK BLTxDAT}=NULL.

As a consequnce you can save memory cycles, because the DMA for channel B
is turned off but the minterm-logic is unchanged.

Thanks to @{I}Jasmin68k@{UI} for the hint reusing a mono coloured face several times.
@ENDNODE


@NODE Chapter-4-9 "4 Optimizing & tricks / Protracker"
@{B}4-9 Protracker@{UB}

    4-9-1 @{" Replay routine " LINK Chapter-4-9-1}
    4-9-2 @{" Using fx commands " LINK Chapter-4-9-2}
    4-9-3 @{" Playing notes without updating " LINK Chapter-4-9-3}
    4-9-4 @{" Splitting tracker modules " LINK Chapter-4-9-4}
@ENDNODE


@NODE Chapter-4-9-1 "4 Optimizing & tricks / Protracker / Replay routine"
@{B}3-9-1 Replay routine@{UB}

      4-9-1-1 @{" New effect Tremolo+Volume Slide" LINK Chapter-4-9-1-1}
      4-9-1-2 @{" Triggering fx-routines " LINK Chapter-4-9-1-2}
      4-9-1-3 @{" Optimizing fx-routines " LINK Chapter-4-9-1-3}
@ENDNODE


@NODE Chapter-4-9-1-1 "4 Optimizing & tricks / Protracker / Replay routine / New effect Tremolo+Volume Slide"
@{B}4-9-1-1 New effect Tremolo+Volume Slide@{UB}

I've extended the protracker effect commands in the replay routine
version 2.1A a little bit. The command @{FG FILL}Tremolo+Volume Slide@{FG TEXT} was
missing. To do this, we use the unused effect command 8:

Protracker V2.1A Effect Commands (extended)
+---------+------------------------------------------------+
| Command | Name                 | Description / Arguments |
+---------+----------------------+-------------------------+
|   @{FG FILL}8xy@{FG TEXT}	  | @{FG FILL}Tremolo+Volume Slide@{FG TEXT} | @{FG FILL}x-upspeed, y-downspeed@{FG TEXT}  |
+---------+----------------------+-------------------------+

The effects-check is extended as you can see at the coloured text
position:

pt_CheckEffects
  ...etc...
pt_SetBack
  MOVE.W  n_period(a2),6(A6)	;AUDxPER
  CMP.B	  #7,d0                 ;Fx command 7xy (Tremolo) ?
  BEQ	  pt_Tremolo            ;Yes -> branch
  @{FG FILL}CMP.B   #8,d0@{FG TEXT}		        ;Fx command 8xy (Tremolo+VolSlide) ?
  @{FG FILL}BEQ     pt_TremoloPlusVolSlide@{FG TEXT} ;Yes -> branch
  CMP.B	  #$A,d0
  BEQ	  pt_VolumeSlide
  RTS
  ...etc...

And here's the new routine for tremolo+volume slide:

  @{FG FILL}CNOP 0,4			;Longword alignment for MC68020+
pt_TremoloPlusVolSlide
  BSR	  pt_VolumeSlide
  BRA     pt_Tremolo2@{FG TEXT}
@ENDNODE


@NODE Chapter-4-9-1-2 "4 Optimizing & tricks / Protracker / Replay routine / Triggering fx-routines"
@{B}4-9-1-2 Triggering fx-routines@{UB}

In some cases it might be useful to trigger your fx-routines by the tracker
module so that graphics and sound match perfect all the time, regardless of
CIA timing differences with accelerator boards.

We use the unused effect command 8. While the patterns are played by the
replay-routine, everytime the 8 command is found, a low level interrupt is
generated. We use the @{"SOFT" LINK INTENA} interrupt for this. The fx-routine could wait
for this interrupt or could be activated by it.

Let's see how this looks like and which changes are made in the tracker
replay routine.

In the pattern you just set the command 800:

Pos Note Track

xx   -   000@{FG FILL}800@{FG TEXT}

We nest our extension in the routine @{I}CheckMoreEffects@{UI}, because we don't
want, that the interrupt is generated every frame. Instead, it should be
only generated every tick when the pattern moves to the next position:

  CNOP 0,4			;Longword alignment for MC68020+
pt_CheckMoreEffects
  BSR	  pt_Updatefunk
  MOVEQ   #$F,D0
  AND.B   n_cmd(A2),D0		:We only need the lower nibble
@{FG FILL}  CMP.B   #$8,D0@{FG TEXT}		;Fx-cmd 8 SetSoftInt found ?
@{FG FILL}  BEQ.S   pt_SetSoftInt@{FG TEXT}  	;Yes -> branch
  CMP.B	  #$9,D0		;Fx-cmd 9 (Set SampleOffset) found ?
  BEQ.S	  pt_SampleOffset	;Yes -> branch
  ...etc...

And here's the routine to set the interrupt:

@{FG FILL}  CNOP 0,4			;Longword alignment for MC68020+
pt_SetSoftInt
  MOVE.W  #$8004,$DFF09C@{FG TEXT}	;@{"INTREQ" LINK INTREQ}: Set @{"SOFT" LINK INTENA}-Interrupt
@{FG FILL}  RTS@{FG TEXT}

Our effect routine must only wait for this interrupt to be set:

;A6=CUSTOM CHIP BASE

  CNOP 0,4			;Longword alignment for MC68020+
wait_softint
  LEA     $1E(A6),A0		;@{"INTREQR" LINK INTREQ} zero-offset is faster
  MOVEQ   #4,D1                 ;Mask for @{"SOFT" LINK INTENA}-Interrupt
wait_softint_loop
  MOVE.W  (A0),D0		;Get Interrupts
  AND.W   D1,D0			;Did the interrupt happen ?
  BEQ.S   wait_softint_loop	;No -> branch
  MOVE.W  D1,$9C(A6)		;@{"INTREQ" LINK INTREQ}: Clear SOFT-Interrupt
  RTS

As an alternative, the effect could be activated only, if the interrupt was
set:

;A3=Variables base for a relative write access
;A6=CUSTOM CHIP BASE

  CNOP 0,4			;Longword alignment for MC68020+
check_softint
  MOVEQ   #4,D0			;Mask for @{"SOFT" LINK INTENA}-Interrupt
  AND.W   $1E(A6),D0	        ;@{"INTREQR" LINK INTREQ}: Did the interrupt happen?
  BEQ.S   no_softint            ;No -> branch
  MOVE.W  D0,$9C(A6)		;@{"INTREQ" LINK INTREQ}: Clear SOFT-Interrupt
  CLR.W   effect_state(a3)      ;Set variable = TRUE = turn on effect
no_softint
  RTS

You see there are different ways to handle the interrupt generated by the
module.
@ENDNODE


@NODE Chapter-4-9-1-3 "4 Optimizing & tricks / Protracker / Replay routine / Optimizing fx-routines"
@{B}4-9-1-3 Optimizing fx-routines@{UB}

        4-9-1-3-1 @{" The filter command " LINK Chapter-4-9-1-3-1}
@ENDNODE


@NODE Chapter-4-9-1-3-1 "4 Optimizing & tricks / Protracker / Replay routine / Optimizing fx-routines / The filter command"
@{B}4-9-1-3-1 The filter command@{UB}

With the knowledge from @{"above" LINK Chapter-4-5-2} about CIA register access by the MC680x0, we
can optimize the filter command routine of the tracker replay routine.

Here's the original routine:

;A6=Pointer to the channel pattern

  CNOP 0,4           		;Longword alignment for MC68020+
pt_FilterOnOff
  MOVE.B  n_cmdlo(A6),D0	;Get low byte of the filter command
  AND.B   #1,D0			;Only bit #0, if =0 filter on, =1 filter off
  ASL.B   #1,D0			;Move bit #0 into the right position
  AND.B   #$FD,$BFE001		;@{"CIA-A PRA" LINK Appendix-B} NOT(CIAF_LED) = Clear bit #1
  OR.B    D0,$BFE001		;Turn filter on or off
  RTS                                 

This one a little bit optimized looks like this:

;A4=$BFE001

  CNOP 0,4			;Longword alignment for MC68020+
pt_FilterOnOff
  MOVEQ   #1,d0
  AND.B   n_cmdlo(A6),D0        ;Only bit #0, if =0 filter on, =1 filter off
  BNE.S   pt_FilterOff          ;If <>0 -> branch
  MOVEQ   #-3,D0  	     	;NOT(CIAF_LED) = Clear bit #1
  AND.B   D0,(a4)	        ;@{"CIA-A PRA" LINK Appendix-B}: Turn filter on
  RTS                         
  CNOP 0,4			;Longword alignment for MC68020+
pt_FilterOff
  MOVEQ   #2,D0        		;CIAF_LED = Set bit #1
  OR.B    D0,(a4)		;Turn filter off
  RTS

Now we access the CIA-A PRA register using address register indirect without
displacement and register access only once for turning the filter on or off.
@ENDNODE


@NODE Chapter-4-9-2 "4 Optimizing & tricks / Protracker / Using fx commands"
@{B}4-9-2 Using fx commands@{UB}

      4-9-2-1 @{" Tone portamento " LINK Chapter-4-9-2-1}
      4-9-2-2 @{" VolumeSlide " LINK Chapter-4-9-2-2}
      4-9-2-3 @{" Pulse Tremolo " LINK Chapter-4-9-2-3}
@ENDNODE


@NODE Chapter-4-9-2-1 "4 Optimizing & tricks / Protracker / Using fx commands / Tone portamento"
@{B}4-9-2-1 Tone portamento@{UB}

If you have a sequence of tone portamento commands in your pattern for a
slight period change, it might be useful to have a formula, which calculates
the slide value for these commands.

At first, you need to know the delta period value between note1 and note2.
The protracker uses three octaves and the tuning 0, normal period values
for each note can be found @{"here" LINK Chapter-4-9-2-1-1}.

After calculating the delta period, you need to know the speed of your
module and the number of commands used.

If you work with BPM instead of the speed in your module, the conversion
formula is:

  @{I}module_speed=RND(750/BPM)@{UI}

So the final formula is:

  @{I}porta_slide_value=RND(((delta_period/(module_speed-1))/commands_num)@{UI}

Just an example:

Pos Note Track
00  C-2  000000
01       000000
02       000000
03       000000
04  G-2  00030@{FG FILL}?@{FG TEXT}
05       00030@{FG FILL}?@{FG TEXT}
06       00030@{FG FILL}?@{FG TEXT}
07       000000
...etc...

If we lookup in our @{"period table" LINK Chapter-4-9-2-1-1}, C-2 has the period value 428 and G-2
the value 285. So the delta_period = 428-285 = 143. The module_speed = 6
and the commands_num = 3.

  porta_slide_value=RND(((143/(6-1))/3)=9,53 rounded to 10

So the linear slide value for every portamento command is hex A (dec 10).
@ENDNODE


@NODE Chapter-4-9-2-1-1 "3 Optimizing & tricks / Protracker / Using fx commands / Tone portamento / Three ocataves periods table tuning 0, normal"
@{B}4-9-2-1-1 Three ocataves periods table tuning 0, normal@{UB}

          +------+--------+
          | Note | Period |
          +------+--------+
          | C1   | 856    |
          +------+--------+
          | C#1  | 808    |
          +------+--------+
          | D1   | 762    |
          +------+--------+
          | D#1  | 720    |
          +------+--------+
          | E1   | 678    |
          +------+--------+
          | F1   | 640    |
          +------+--------+
          | F#1  | 604    |
          +------+--------+
          | G1   | 570    |
          +------+--------+
          | G#1  | 538    |
          +------+--------+
          | A1   | 508    |
          +------+--------+
          | A#1  | 480    |
          +------+--------+
          | H1   | 453    |
          +======+========+
          | @{FG FILL}C2@{FG TEXT}   | @{FG FILL}428@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}C#2@{FG TEXT}  | @{FG FILL}404@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}D2@{FG TEXT}   | @{FG FILL}381@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}D#2@{FG TEXT}  | @{FG FILL}360@{FG TEXT}    |
          +------+--------+                                                                              
          | @{FG FILL}E2@{FG TEXT}   | @{FG FILL}339@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}F2@{FG TEXT}   | @{FG FILL}320@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}F#2@{FG TEXT}  | @{FG FILL}302@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}G2@{FG TEXT}   | @{FG FILL}285@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}G#2@{FG TEXT}  | @{FG FILL}269@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}A2@{FG TEXT}   | @{FG FILL}254@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}A#2@{FG TEXT}  | @{FG FILL}240@{FG TEXT}    |
          +------+--------+
          | @{FG FILL}H2@{FG TEXT}   | @{FG FILL}226@{FG TEXT}    |
          +======+========+
          | @{FG HIGHLIGHT}C3@{FG TEXT}   | @{FG HIGHLIGHT}214@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}C#3@{FG TEXT}  | @{FG HIGHLIGHT}202@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}D3@{FG TEXT}   | @{FG HIGHLIGHT}190@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}D#3@{FG TEXT}  | @{FG HIGHLIGHT}180@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}E3@{FG TEXT}   | @{FG HIGHLIGHT}170@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}F3@{FG TEXT}   | @{FG HIGHLIGHT}160@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}F#3@{FG TEXT}  | @{FG HIGHLIGHT}151@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}G3@{FG TEXT}   | @{FG HIGHLIGHT}143@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}G#3@{FG TEXT}  | @{FG HIGHLIGHT}135@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}A3@{FG TEXT}   | @{FG HIGHLIGHT}127@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}A#3@{FG TEXT}  | @{FG HIGHLIGHT}120@{FG TEXT}    |
          +------+--------+
          | @{FG HIGHLIGHT}H3@{FG TEXT}   | @{FG HIGHLIGHT}113@{FG TEXT}    |
          +------+--------+
@ENDNODE


@NODE Chapter-4-9-2-2 "4 Optimizing & tricks / Protracker / Using fx commands / VolumeSlide"
@{B}4-9-2-2 VolumeSlide@{UB}

If you want to know how many VolumeSlide commands are necessary for a
certain volume slide value, you need the volume maximum of the sample,
the speed of your module and the volume slide value.

If you work with BPM instead of the speed in your module, the conversion
formula is:

  @{I}module_speed=RND(750/BPM)@{UI}

So the final formula is:

  @{I}volslide_cmd_num = RND((sample_vol_max/(module_speed-1))/volslide_value)@{UI}

An example: For sample_vol_max = 64, a module_speed=6 and a volslide_value
of 1 it looks like this:

  volslide_cmd_num = RND((64/(6-1))/1) = 12,8 rounded to 13

We need 13 consecutive Axx commands for a volume slide up or down.
@ENDNODE


@NODE Chapter-4-9-2-3 "4 Optimizing & tricks / Protracker / Using fx commands / Pulse Tremolo"
@{B}4-9-2-3 Pulse Tremolo@{UB}

A nice effect to make your looped string samples sound much better, is
generating a Pulse Tremolo with the VolumeSlide command. I first saw this
kind of effect in the module @{I}1989 -a number@{UI} by Romeo Knight from 1989.

We use the fact, that in a pattern, a sample can be played without a given
note, if only the sample number is set. In this case, the last played note
is reused and only the sample variables @{I}length@{UI}, @{I}volume@{UI}, @{I}loop@{UI} and @{I}replen@{UI}
are updated.

An example pattern could look like this:

Pos Note Track
00  F-2  020A08
01       @{FG FILL}02@{FG TEXT}0A0F
02       @{FG FILL}02@{FG TEXT}0A08
03       @{FG FILL}02@{FG TEXT}0A0F
...etc...

Let's assume that our sample number 2 has the volume of $40. At the
position 00, the sample is played with the note F-2 and with the volume
$40-$08=$38. At the position 01, it is played with the reused note F-2 and
the volume $40-$0F=$31. At the position 02, this sequence repeats reusing
the note F-2 with the volume $38.
@ENDNODE


@NODE Chapter-4-9-3 "4 Optimizing & tricks / Protracker / Playing notes without updating"
@{B}4-9-3 Playing notes without updating@{UB}

If we set a note in the pattern without a sample number, then the last
sample number that was played is the one with the new period. In this case
the sample variables @{I}length@{UI}, @{I}volume@{UI}, @{I}loop@{UI}, and @{I}replen@{UI} are not updated.

Here's an example:

Pos Note Track
00  F-2  @{FG FILL}02@{FG TEXT}0000
01       000000
02       000000
03       000000
04  A-2  @{FG FILL}00@{FG TEXT}0000
05       000000
06       000000
...etc...

At position 00 the sample number 2 is played with the note F-2. At position
04 the same sample is played with the note A-2.

This is very useful, if we want to produce a volume slide but consecutive
notes of a looped string sampe are played:

00  F-2  @{FG FILL}02@{FG TEXT}0A01
01       000A01
02       000A01
03       000A01
04  A-2  @{FG FILL}00@{FG TEXT}0A01
05       000A01
06       000A01
...etc...

The volume slide isn't disturbed by playing the next note A-2, because the
current volume isn't updated.
@ENDNODE


@NODE Chapter-4-9-4 "4 Optimizing & tricks / Protracker / Splitting tracker modules"
@{B}4-9-4 Splitting tracker modules@{UB}

It might be useful to split the content of a tracker module to load the
patterns into FAST memory if availible and the samples into CHIP memory.
This may speed up the replay routine a little bit on systems with FAST
memory.

But how to manage this split? Quite easy. I wrote a little CLI/Shell tool
called @{I}SplitMOD@{UI}. With this tool you just load a non-crunched 31-samples
module you want to convert and the program does the rest for you.

The program splits the module called @{I}MOD.filename@{UI} into a songfile called
@{I}MOD.filename.song@{UI} and a samples-file called @{I}MOD.filename.smps@{UI}.

You can use these files in your assembler and load them into the memory
sections you wish.

The tool is released on @{I}aminet.net@{UI}.
@ENDNODE


@NODE Chapter-4-10 "4 Optimizing & tricks / ASM-One"
@{B}4-10 ASM-One@{UB}

     4-10-1 @{" Generating sine tables " LINK Chapter-4-10-1}
@ENDNODE


@NODE Chapter-4-10-1 "4 Optimizing & tricks / ASM-One / Generating sine tables"
@{B}4-10-1 Generating sine tables@{UB}

In case you need a sine table for 2d or 3d calculations, @{I}ASM-One@{UI} is a very
powerful tool to create such a table.

The command for it is called @{I}I@{UI}(nsert)@{I}S@{UI}(inus) and has the following
parameters:

BEG              = 0 (first angle)
END              = 360 (last angle)
AMOUNT           = for example 256,360,512,... (number of entries)
AMPLITUDE        = for example $7FFF (=2^15) (for integer values)
YOFFSET          = 0 for positive and negative curve values (y-centre)
SIZE             = B(yte), W(ord) or L(ongword) (entries size)
MULTIPLIER       = -1 that the generated curve begins with negative values
HALF CORRECTON   = N(o)
ROUND CORRECTION = N(o)

The sine-values are automatically generated in the source window as DC.x
values.

Using the amplitude 2^15 is a smart way to calculate a sine function very
quickly. You just need an ADD.L and a SWAP command to get the right values.
Or in other words a shift 1 bit to the left and 16 bits to the right to
divide by 2^15.

Here's the code:

;A0     = pointer to a sinetab with WORD entries
;D1     = angle
;radius = 64

  ADD.W   D1,D1			;angle*2
  MOVE.W  (A0,D1.W),D0		;sin(w)
  EXT.L   D0			;Extend to 32 bits signed
  LSL.L   #7,D0                 ;sin(w)*radius*2
  SWAP    D0			;/2^16

or for the MC68020+

  MOVE.W  (A0,D1.W*2),D0	;sin(w)
  EXT.L   D0			;Extend to 32 bits signed
  LSL.L   #7,D0                 ;sin(w)*radius*2
  SWAP    D0			;/2^16

or faster with LONGWORD entries on the MC68020+

  MOVE.L  (A0,D1.W*4),D0	;sin(w)
  LSL.L   #7,D0                 ;sin(w)*radius*2
  SWAP    D0			;/2^16

Many thanks to @{I}Jasmin68k@{UI} for this hint that generating sine tables with
ASM-One is possible with the command @{I}IS@{UI}.
@ENDNODE


@NODE Appendix-A "Coder Aid / A Excerpts custom chip registers"
@{B}A Excerpts custom chip registers@{UB}

An excerpt of some custom chip registers listed in alphabetical order and
the note on which chipset they appear:

  @{" ADKCON " LINK ADKCON}   [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" AUDxDAT " LINK AUDxDAT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" AUDxPER " LINK AUDxPER}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" AUDxVOL " LINK AUDxVOL}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BEAMCON0 " LINK BEAMCON0} [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTAFWM " LINK BLTAFWM}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTALWM " LINK BLTALWM}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTCON0 " LINK BLTCON0}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTCON0L " LINK BLTCON0} [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTCON1 " LINK BLTCON0}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTSIZE " LINK BLTSIZE}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTSIZH " LINK BLTSIZH}  [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTSIZV " LINK BLTSIZH}  [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTxDAT " LINK BLTxDAT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTxMOD " LINK BLTxMOD}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTxPTH " LINK BLTxPTH}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BLTxPTL " LINK BLTxPTL}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLCON0 " LINK BPLCON0}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLCON1 " LINK BPLCON1}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLCON2 " LINK BPLCON2}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLCON3 " LINK BPLCON3}  [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLCON4 " LINK BPLCON4}  [ - /@{FG FILL} - @{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" BPLxDAT " LINK BPLxDAT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" COLORxx " LINK COLORxx}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" COPJMP1 " LINK COPJMP1}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" COPJMP2 " LINK COPJMP2}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" COP1LCH " LINK COP1LCH}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" COPINS " LINK COPINS}   [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" DDFSTRT " LINK DDFSTRT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" DIWSTRT " LINK DIWSTRT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" DIWHIGH " LINK DIWHIGH}  [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" DMACON " LINK DMACON}   [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" DSKSYNC " LINK DSKSYNC}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" FMODE " LINK FMODE}    [ - /@{FG FILL} - @{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HBSTOP " LINK HBSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HBSTRT " LINK HBSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HCENTER " LINK HCENTER}  [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HHPOSR " LINK HHPOSR}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HHPOSW " LINK HHPOSR}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HSSTOP " LINK HSSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HSSTRT " LINK HSSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" HTOTAL " LINK HTOTAL}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" INTENA " LINK INTENA}   [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" INTREQ " LINK INTREQ}   [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" SPRxCTL " LINK SPRxCTL}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" SPRxDAT " LINK SPRxDAT}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" SPRxPOS " LINK SPRxPOS}  [OCS/@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VBSTOP " LINK VBSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VBSTRT " LINK VBSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VPOSR " LINK VPOSR}    [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VPOSW " LINK VPOSR}    [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VHPOSR " LINK VHPOSR}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VHPOSW " LINK VHPOSR}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VSSTOP " LINK VSSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VSSTRT " LINK VSSTOP}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
  @{" VTOTAL " LINK VTOTAL}   [ - /@{FG FILL}ECS@{FG TEXT}/@{FG HIGHLIGHT}AGA@{FG TEXT}]
@ENDNODE


@NODE ADKCON "A Excerpts custom chip registers / ADKCON"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
ADKCON     09E   W   P    Audio,Disk,Uart,Control write
ADKCONR    010   R   P    Audio,Disk,Uart,Control read

         +-------+-------------+-------------------------------------------+
         | BITS  | USE         | DESCRIPTION                               |
         +-------+-------------+-------------------------------------------+
         | 15    | SET/CLEAR   | Set/clear control bit.determines if bits  |
         |       |             | written with a 1 get set or cleared.bits  |
         |       |             | written with a zero are always unchanged. |
         |       |             |                                           |
         |       |             | +------+---------------+                  |
         | 14-13 | PRECOMP 1-0 | | CODE | PRECOMP VALUE |                  |
         |       |             | +------+---------------+                  |
         |       |             | | 00   | none          |                  |
         |       |             | | 01   | 140 ns        |                  |
         |       |             | | 10   | 280 ns        |                  |
         |       |             | | 11   | 560 ns        |                  |
         |       |             | +------+---------------+                  |
         |       |             |                                           |
         | 12    | MFMPREC     | (1 = MFM precomp / 0 = GCR precomp)       |
         | 11    | UARTBRK     | Forces a UART break (clears TXD) if true  |
         | 10    | WORDSYNC    | Enables disk read synchronizing on a word |
         |       |             | equal to DISK SYNC CODE, Located in       |
         |       |             | address @{"DSKSYNC" link DSKSYNC} (7E).                     |
         | 09    | MSBSYNC     | Enables disk read synchrinizing on the    |
         |       |             | MSB (most signif bit) appl type GCR       |
         | 08    | FAST        | Disk data clock rate control 1=fast(2us)  |
         |       |             | 0=slow(4us)                               |
         |       |             | (Fast for MFM or 2us,slow for 4us GCR)    |
         | 07    | USE3PN      | Use audio channel 3 to modulate nothing   |
         | 06    | USE2P3      | Use audio channel 2 to modulate period    |
         |       |             | of channel 3                              |
         | 05    | USE1P2      | Use audio channel 1 to modulate period    |
         |       |             | of channel 2                              |
         | 04    | USE0P1      | Use audio channel 0 to modulate period    |
         |       |             | of channel 1                              |
         | 03    | USE3VN      | Use audio channel 3 to modulate nothing   |
         |       |             |                                           |
         | 02    | USE2V3      | Use audio channel 2 to modulate volume    |
         |       |             | of channel 3                              |
         | 01    | USE1V2      | Use audio channel 1 to modulate volume    |
         |       |             | of channel 2                              |
         | 00    | USE0V1      | Use audio channel 0 to modulate volume    |
         |       |             | of channel 1                              |
         +-------+-------------+-------------------------------------------+

   Note: If both period and volume aremodulated on the same channel,
         the period and volume will be alternated. First @{"AUDxDAT" link AUDxDAT} word
         is used for V6-V0 of @{"AUDxVOL" link AUDxVOL}. Second AUDxDAT word is used for
         P15-P0 of @{"AUDxPER" link AUDxPER}. This alternating sequence is repeated.
@ENDNODE


@NODE AUDxDAT "A Excerpts custom chip registers / AUDxDAT
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
AUDxDAT   0AA    W   P    Audio channel x data

         This reg is the audio channel x (x=0,1,2,3) DMA
         data buffer. It contains 2 bytes of data (each
         byte is a twos complement signed integer) that
         are outputed sequentially (with digital to analog
         conversion)to the audio output pins. With maximum
         volume, each byte can drive the audio outputs
         with 0.8 volts(peak to peak,typ). The audio DMA
         channel controller automatically transfers data
         to this reg from RAM. The processor can also
         write directly to this reg. When the DMA data is
         finished (words outputted=lentgh)and the data in
         this reg has been used, an audio channel interrupt
         request is set.
@ENDNODE


@NODE AUDxPER "A Excerpts custom chip registers / AUDxPER"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
AUDxPER h 0A6    W   P    Audio channel x period

         This reg contains the period (rate) of audio channel
         x DMA data transfer.
         The minimum period is 124 clocks. This means that
         the smallest number that should be placed in this
         reg is 124.
@ENDNODE


@NODE AUDxVOL "A Excerpts custom chip registers / AUDxVOL
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
AUDxVOL   0A8    W   P    Audio channel x volume

         This reg contains the volume setting for audio channel x.
         Bits 6,5,4,3,2,1,0 specify 65 linear volume levels as shown below.

         +--------+--------------------------------------------------+
         | BITS   | USE                                              |
         +--------+--------------------------------------------------+
         | -15-07 | Not used                                         |
         |  06    | Forces volume to max (64 ones,no zeros)          |
         | 05-00  | Sets one of the 64 levels (000000 = no output,   |
         |        | 111111 = 63 ones, one zero)                      |
         +--------+--------------------------------------------------+
@ENDNODE


@NODE BEAMCON0 "A Excerpts custom chip registers / BEAMCON0"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BEAMCON0 h 1DC  W    A            Beam counter control bits

          +-------+----------------------------+
          | BIT#  | FUNCTION                   |
          +-------+----------------------------+
          | 15    | (unused)                   |
          | 14    | HARDDIS                    |
          | 13    | LPENDIS                    |
          | 12    | VARVBEN                    |
          | 11    | LOLDIS                     |
          | 10    | CSCBEN                     |
          | 9     | VARVSYEN                   |
          | 8     | VARHSYEN                   |
          | 7     | VARBEAMEN                  |
          | 6     | DUAL                       |
          | 5     | PAL                        |
          | 4     | VARCSYEN                   |
          | 3     | (unused, formerly BLANKEN) |
          | 2     | CSYTRUE                    |
          | 1     | VSYTRUE                    |
          | 0     | HSYTRUE                    |
          +-------+----------------------------+

HARDDIS = This bit is used to disable the hardwire vertical horizontal
          window limits. It is cleared upon reset.

LPENDIS = When this bit is a low and LPE (@{"BPLCON0" LINK BPLCON0},BIT 3) is enabled, the
          light-pen latched value(beam hit position) will be read by
          @{"VHPOSR" LINK VHPOSR}, @{"VPOSR" LINK VPOSR} and @{"HHPOSR" LINK HHPOSR}. When
          the bit is a high the light-pen latched value is ignored and
          the actual beam counter position is read by VHPOSR, VPOSR, and
          HHPOSR.

VARVBEN = Use the comparator generated vertical blank (from @{"VBSTRT" LINK VBSTOP}, @{"VBSTOP" LINK VBSTOP})
          to run the internal chip stuff-sending RGA signals to Denise,
          starting sprites,resetting light pen. It also disables the hard
          stop on the vertical display window.

LOLDIS  = Disable long line/short toggle. This is useful for DUAL mode
          where even multiples are wanted, or in any single display
          where this toggling is not desired.

CSCBEN  = The variable composite sync comes out on the HSY pin, and the
          variable conosite blank comes out on the VSY pin. The idea is
          to allow all the information to come out of the chip for a
          DUAL mode display. The normal monitor uses the normal composite
          sync, and the variable composite sync &blank come out the HSY &
          VSY pins. The bits VARVSTEN & VARHSYEN (below) have priority over
          this control bit.

VARVSYEN= Comparator VSY -> VSY pin. The variable VSY is set vertically on
          @{"VSSTRT" LINK HSSTRT}, reset vertically on @{"VSSTOP" LINK VSSTOP}, with the horizontal position
          for set set & reset @{"HSSTRT" LINK HSSTRT} on short fields (all fields are short
          if LACE = 0) and @{"HCENTER" LINK HCENTER} on long fields (every other field if
          LACE = 1).

VARHSYEN= Comparator HSY -> HSY pin. Set on HSSTRT value, reset on @{"HSSTOP" LINK HSSTOP}
          value.

VARBEAMEN=Enables the variable beam counter comparators to operate
          (allowing diffrent beam counter total values) on the main horiz
          counter. It also disables hard display stops on both horizontal
          and vertical.

DUAL    = Run the horizontal comparators with the alternate horizontal beam
          counter, and starts the UHRES pointer chain with the reset of
          this counter rather than the normal one. This allows the UHRES
          pointers to come out more than once in a horizontal line,
          assuming there is some memory bandwidth left (it doesn`t work in
          640*400*4 interlace mode) also, to keep the two displays synced,
          the horizontal line lentghs should be multiples of each other.
          If you are amazingly clever, you might not need to do this.

PAL     = Set appropriate decodes (in normal mode) for PAL. In variable
          beam counter mode this bit disables the long line/short line
          toggle- ends up short line.

VARCSYEN= Enables CSY from the variable decoders to come out the CSY
          (VARCSY is set on @{"HSSTRT" LINK HSSTRT} match always, and also on @{"HCENTER" LINK HCENTER}
          match when in vertical sync. It is reset on @{"HSSTOP" LINK HSSTOP} match when VSY
          and on both @{"HBSTRT" LINK HBSTOP} & @{"HBSTOP" LINK HBSTOP} matches during VSY. A reasonable
          composite can be generated by setting HCENTER half a horiz line
          from @{"HSSTRT" LINK HSSTRT}, and HBSTOP at (HSSTOP-HSSTRT) before HCENTER, with
          HBSTRT at (HSSTOP-HSSTRT) before HSSTRT.
          HSYTRUE, VSYTRUE, CSYTRUE = These change the polarity of the
          HSY*, VSY*, & CSY* pins to HSY, VSY, & CSY respectively for
          input & output.
@ENDNODE


@NODE BLTAFWM "A Excerpts custom chip registers / BLTAFWM"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTAFWM     044 W    A    Blitter first word mask for source A

See also: @{"BLTALWM" LINK BLTALWM}
@ENDNODE


@NODE BLTALWM "A Excerpts custom chip registers / BLTALWM"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTALWM    046  W    A    Blitter last word mask for source A

         The patterns in these two registers (see also: @{"BLTAFWM" LINK BLTAFWM})
         are "anded" with the first and last words of each line of data
         from Source A into the Blitter. A zero in any bit overrides
         data from Source A. These registers should be set to all
         "ones" for fill mode or for line drawing mode.
@ENDNODE


@NODE BLTCON0 "A Excerpts custom chip registers / BLTCON0"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTCON0    040  W    A    Blitter control register 0
BLTCON0L H 05A  W    A    Blitter control register 0 (lower 8 bits)
                          This is to speed up software - the upper bits are
                          often the same.
BLTCON1  h 042  W    A    Blitter control register 1

         These two control registers are used together to control blitter
         operations. There are 2 basic modes, are and line, which are
         selected by bit 0 of BLTCON1, as show below.

         +--------------------------+---------------------------+
         | AREA MODE ("normal")     | LINE MODE (line draw)     |
         +------+---------+---------+------+---------+----------+
         | BIT# | BLTCON0 | BLTCON1 | BIT# | BLTCON0 | BLTCON1  |
         +------+---------+---------+------+---------+----------+
         | 15   | ASH3    | BSH3    | 15   | ASH3    | BSH3     |
         | 14   | ASH2    | BSH2    | 14   | ASH2    | BSH2     |
         | 13   | ASH1    | BSH1    | 13   | ASH1    | BSH1     |
         | 12   | ASA0    | BSH0    | 12   | ASH0    | BSH0     |
         | 11   | USEA    | 0       | 11   | 1       | 0        |
         | 10   | USEB    | 0       | 10   | 0       | 0        |
         | 09   | USEC    | 0       | 09   | 1       | 0        |
         | 08   | USED    | 0       | 08   | 1       | 0        |
         | 07   | LF7     | DOFF    | 07   | LF7     | DPFF     |
         | 06   | LF6     | 0       | 06   | LF6     | SIGN     |
         | 05   | LF5     | 0       | 05   | LF5     | OVF      |
         | 04   | LF4     | EFE     | 04   | LF4     | SUD      |
         | 03   | LF3     | IFE     | 03   | LF3     | SUL      |
         | 02   | LF2     | FCI     | 02   | LF2     | AUL      |
         | 01   | LF1     | DESC    | 01   | LF1     | SING     |
         | 00   | LF0     | LINE(=0)| 00   | LF0     | LINE(=1) |
         +------+---------+---------+------+---------+----------+

         ASH3-0    Shift value of A source
         BSH3-0    Shift value of B source and line texture
         USEA      Mode control bit to use source A
         USEB      Mode control bit to use source B
         USEC      Mode control bit to use source C
         USED      Mode control bit to use destination D
         LF7-0     Logic function minterm select lines
         EFE       Exclusive fill enable
         IFE       Inclusive fill enable
         FCI       Fill carry input
         DESC      Descending (dec address)control bit
         LINE      Line mode control bit
         SIGN      Line draw sign flag
         OVF       Line/draw r/l word overflow flag
         SUD       Line draw, Sometimes up or down (=AUD)
         SUL       Line draw, Sometimes up or left
         AUL       Line draw, Always up or left
         SING      line draw, Single bit per horiz line
         DOFF      Disables the D output- for external ALUs
                   The cycle occurs normally, but the data
                   bus is tristate (hires chips only)
@ENDNODE


@NODE BLTSIZE "A Excerpts custom chip registers / BLTSIZE"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTSIZE    058   W    A   Blitter start and size (win/width, height)

         This register contains the width and height of the blitter
         operation (in line mode width must = 2, height = line length).
         Writing to this register will start the Blitter, and should be
         done last, after all pointers and control registers have been
         initialized.

         BIT# 15,14,13,12,11,10,09,08,07,06,05,04,03,02,01,00
              H9 H8 H7 H6 H5 H4 H3 H2 H1 H0 W5 W4 W3 W2 W1 W0

         H=Height=Vertical lines (10 bits=1024 lines max)
         W=Width=Horiz pixels (6 bits=64 words=1024 pixels max)
@ENDNODE


@NODE BLTSIZH "A Excerpts custom chip registers / BLTSIZH"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTSIZH h  05E   W    A   Blitter H size & start (11 bit width)

         BIT# 15 14 13 12 11 10  09 08 07 06 05 04 03 02 01 00
               x  x  x  x  x w10 w9 w8 w7 w6 w5 w4 w3 w2 w1 w0

         See also: @{"BLTSIZV" LINK BLTSIZV}
@ENDNODE


@NODE BLTSIZV "A Excerpts custom chip registers / BLTSIZV"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTSIZV h  05C   W    A   Blitter V size (15 bit height)

         BIT# 15  14  13  12  11  10  09 08 07 06 05 04 03 02 01 00
               x  h14 h13 h12 h11 h10 h9 h8 h7 h6 h5 h4 h3 h2 h1 h0

         These are the blitter size regs for blits larger than the earlier
         chips could accept. The original commands are retained for
         compatibility. BLTSIZV should be written first, followed by @{"BLTSIZH" LINK BLTSIZH},
         which starts the blitter. BLTSIZV need not be rewritten for
         subsequent bits if the vertical size is the same. Max size of
         blit 32k pixels * 32k lines, x's should be written to 0 for
         upward compatibility.
@ENDNODE


@NODE BLTxDAT "A Excerpts custom chip registers / BLTxDAT"
NAME    rev ADDR type chip Description
---------------------------------------------------------------------------
BLTxDAT     074  W    A    Blitter source x data reg.

         This register holds Source x (x=A,B,C) data for use by the Blitter.
         It is normally loaded by the Blitter DMA channel, however it
         may also be preloaded by the microprocessor.
@ENDNODE


@NODE BLTxMOD "A Excerpts custom chip registers / BLTxMOD"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTxMOD    064  W    A    Blitter Modulo x

         This register contains the Modulo for Blitter source (x=A,B,C)
         or Dest (X=D). A Modulo is a number that is automatically
         added to the address at the end of each line, in order that
         the address then points to the start of the next line. Each
         source or destination has it's own Modulo, allowing each
         to be a different size, while an identical area of each is
         used in the Blitter operation.
@ENDNODE


@NODE BLTxPTH "A Excerpts custom chip registers / BLTxPTH"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTxPTH  h 050  W    A    Blitter Point to x (High 5 bits)

See also: @{"BLTxPTL" LINK BLTxPTL}
@ENDNODE


@NODE BLTxPTL "A Excerpts custom chip registers / BLTxPTL"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BLTxPTL  h 052  W    A    Blitter Pointer to x (Low 15 bits)

         This pair of registers (see also: @{"BLTxPTH" LINK BLTxPTH})
         contains the 20 bit address of Blitter source (X=A,B,C) or dest.
         (x=D) DMA data. This pointer must be preloaded with the
         starting address of the data to be processed by the blitter. After
         the Blitter is finished it will contain the last data address
         (plus increment and modulo).
@ENDNODE


@NODE BPLCON0 "A Excerpts custom chip registers / BPLCON0"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLCON0 p  100   W    D   Bit plane control reg. (misc, control bits)

+------+---------+---------------------------------------------------------+
| BIT# | BPLCON0 | DESCRIPTION                                             |
+------+---------+---------------------------------------------------------+
| 15   | HIRES   | HIRES = High resolution (640*200/640*400 interlace)     |
|      |         | mode                                                    |
| 14   | BPU2    | Bit plane use code 0000-1000 (NONE thru 8 inclusive)    |
| 13   | BPU1    |                                                         |
| 12   | BPU0    |                                                         |
| 11   | HAM     | Hold and modify mode, now using either 6 or 8 bit       |
|      |         | planes.                                                 |
| 10   | DPF     | Double playfield (PFI=odd FP2= even bit planes)         |
|      |         | now available in all resolutions.                       |
|      |         | (If BPU=6 and HAM=0 and DPF=0 a special mode is         |
|      |         | defined that allows bitplane 6 to cause an intensity    |
|      |         | reduction of the other 5 bitplanes. The color           |
|      |         | register output selected by 5 bitplanes is shifted      |
|      |         | to half intensity by the 6th bit plane. This is         |
|      |         | called EXTRA-HALFBRITE Mode.                            |
| 09   |  COLOR  | Enables color burst output signal                       |
| 08   |  GAUD   | Genlock audio enable. This level appears on the ZD      |
|      |         | pin on denise during all blanking periods, unless ZDCLK |
|      |         | bit is set.                                             |
| @{FG FILL}07@{FG TEXT}   |  @{FG FILL}UHRES@{FG TEXT}  | @{FG FILL}Ultrahi res enables the UHRES pointers (for 1k*1k) (also@{FG TEXT}|
|      |         | @{FG FILL}needs bits in @{FG TEXT}@{"DMACON" link DMACON} @{FG FILL}(hires chips only).@{FG TEXT}               |
|      |         | @{FG FILL}Disables hard stops for vert, horiz display windows.@{FG TEXT}    |
| @{FG FILL}06@{FG TEXT}   |  @{FG FILL}SHRES@{FG TEXT}  | @{FG FILL}Super hires mode (35ns pixel width)@{FG TEXT}                     |
| @{FG HIGHLIGHT}05@{FG TEXT}   | @{FG HIGHLIGHT}BYPASS=0@{FG TEXT}| @{FG HIGHLIGHT}Bitplanes are scrolled and prioritized normally, but@{FG TEXT}    |
|      |         | @{FG HIGHLIGHT}bypass color table and 8 bit wide data appear on R(7:0).@{FG TEXT}|
| @{FG HIGHLIGHT}04@{FG TEXT}   |  @{FG HIGHLIGHT}BPU3=0@{FG TEXT} | @{FG HIGHLIGHT}See above (BPU0/1/2)@{FG TEXT}                                    |
| 03   |  LPEN   | Light pen enable (reset on power up)                    |
| 02   |  LACE   | Interlace enable (reset on power up)                    |
| 01   |  ERSY   | External resync (HSYNC, VSYNC pads become inputs)       |
|      |         | (reset on power up)                                     |
| @{FG FILL}00@{FG TEXT}   | @{FG FILL}ECSENA=0@{FG TEXT}| @{FG FILL}When low (default), the following bits in @{FG TEXT}@{"BPLCON3" LINK BPLCON3}@{FG FILL} are@{FG TEXT}  |
|      |         | @{FG FILL}disabled: BRDRBLNK,BRDNTRAN,ZDCLKEN,BRDSPRT, and@{FG TEXT}        |
|      |         | @{FG FILL}EXTBLKEN. These 5 bits can always be set by writing@{FG TEXT}     |
|      |         | @{FG FILL}to BPLCON3, however there effects are inhibited until@{FG TEXT}   |
|      |         | @{FG FILL}ECSENA goes high. This allows rapid context switching@{FG TEXT}   |
|      |         | @{FG FILL}between pre-ECS viewports and new ones.@{FG TEXT}                 |
+------+---------+---------------------------------------------------------+
@ENDNODE


@NODE BPLCON1 "A Excerpts custom chip registers / BPLCON1"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLCON1 p  102    W       D Bit plane control reg. (horiz, scroll counter)
+------+---------+---------------------------------------------------------+
| BIT# | BPLCON1 | DESCRIPTION                                             |
+------+---------+---------------------------------------------------------+
| @{FG HIGHLIGHT}15@{FG TEXT}   | @{FG HIGHLIGHT}PF2H7=0@{FG TEXT} | @{FG HIGHLIGHT}(PF2Hx =) Playfield 2 horizontal scroll code, x=0-7@{FG TEXT}     |
| @{FG HIGHLIGHT}14@{FG TEXT}   | @{FG HIGHLIGHT}PF2H6=0@{FG TEXT} |                                                         |
| @{FG HIGHLIGHT}13@{FG TEXT}   | @{FG HIGHLIGHT}PF2H1=0@{FG TEXT} |                                                         |
| @{FG HIGHLIGHT}12@{FG TEXT}   | @{FG HIGHLIGHT}PF2H0=0@{FG TEXT} |                                                         |
| @{FG HIGHLIGHT}11@{FG TEXT}   | @{FG HIGHLIGHT}PF1H7=0@{FG TEXT} | @{FG HIGHLIGHT}(PF1Hx =) Playfield 1 horizontal scroll code, x=0-7@{FG TEXT}     |
| @{FG HIGHLIGHT}10@{FG TEXT}   | @{FG HIGHLIGHT}PF1H6=0@{FG TEXT} | @{FG HIGHLIGHT}where PFyH0=LSB=35ns SHRES pixel (bits have been@{FG TEXT}        |
| @{FG HIGHLIGHT}09@{FG TEXT}   | @{FG HIGHLIGHT}PF1H1=0@{FG TEXT} | @{FG HIGHLIGHT}renamed, old PFyH0 now PFyH2, ect). Now that the scroll@{FG TEXT} |
| @{FG HIGHLIGHT}08@{FG TEXT}   | @{FG HIGHLIGHT}PF1H0=0@{FG TEXT} | @{FG HIGHLIGHT}range has been quadrupled to allow for wider (32 or@{FG TEXT}     |
|      |         | @{FG HIGHLIGHT}64 bits) bitplanes.@{FG TEXT}                                     |
| 07   | PF2H5   |                                                         |
| 06   | PF2H4   |                                                         |
| 05   | PF2H3   |                                                         |
| 04   | PF2H2   |                                                         |
| 03   | PF1H5   |                                                         |
| 02   | PF1H4   |                                                         |
| 01   | PF1H3   |                                                         |
| 00   | PF1H2   |                                                         |
+------+---------+---------------------------------------------------------+
@ENDNODE


@NODE BPLCON2 "A Excerpts custom chip registers / BPLCON2"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLCON2 p  104   W    D   Bit plane control reg. (new control bits)

+------+----------+--------------------------------------------------------+
| BIT# | BPLCON2  | DESCRIPTION                                            |
+------+----------+--------------------------------------------------------+
| 15   | X        | don`t care- but drive to 0 for upward compatibility!   |
| @{FG FILL}14@{FG TEXT}   | @{FG FILL}ZDBPSEL2@{FG TEXT} | @{FG FILL}3 bit field which selects which bitplane is to be used@{FG TEXT} |
|      |          | @{FG FILL}for ZD when ZDBBPEN is set- 000 selects BB1 and 111@{FG TEXT}    |
|      |          | @{FG FILL}selects BP8.@{FG TEXT}                                           |
| @{FG FILL}13@{FG TEXT}   | @{FG FILL}ZDBPSEL1@{FG TEXT} |                                                        |
| @{FG FILL}12@{FG TEXT}   | @{FG FILL}ZDBPSEL0@{FG TEXT} |                                                        |
| @{FG FILL}11@{FG TEXT}   | @{FG FILL}ZDBPEN@{FG TEXT}   | @{FG FILL}Causes ZD pin to mirror bitplane selected by ZDBPSELx@{FG TEXT}  |
|      |          | @{FG FILL}bits. This does not disable the ZD mode defined by@{FG TEXT}     |
|      |          | @{FG FILL}ZDCTEN, but rather is "ored" with it.@{FG TEXT}                  |
| @{FG FILL}10@{FG TEXT}   | @{FG FILL}ZDCTEN@{FG TEXT}   | @{FG FILL}Causes ZD pin to mirror bit #15 of the active entry in@{FG TEXT} |
|      |          | @{FG FILL}high color table. When ZDCTEN is reset ZD reverts to@{FG TEXT}   |
|      |          | @{FG FILL}mirroring color (0).@{FG TEXT}                                   |
| @{FG FILL}09@{FG TEXT}   | @{FG FILL}KILLEHB@{FG TEXT}  | @{FG FILL}Disables extra half brite mode.@{FG TEXT}                        |
| @{FG HIGHLIGHT}08@{FG TEXT}   | @{FG HIGHLIGHT}RDRAM=0@{FG TEXT}  | @{FG HIGHLIGHT}Causes color table address to read the color table@{FG TEXT}     |
|      |          | @{FG HIGHLIGHT}instead of writing to it.@{FG TEXT}                              |
| @{FG HIGHLIGHT}07@{FG TEXT}   | @{FG HIGHLIGHT}SOGEN=0@{FG TEXT}  | @{FG HIGHLIGHT}When set causes SOG output pin to go high@{FG TEXT}              |
| 06   | PF2PRI   | Gives playfield 2 priority over playfield 1.           |
| 05   | PF2P2    | Playfield 2 priority code (with resp. to sprites).     |
| 04   | PF2P1    |                                                        |
| 03   | PF2P0    |                                                        |
| 02   | PF1P2    | Playfield 1 priority code (with resp. to sprites).     |
| 01   | PF1P1    |                                                        |
| 00   | PF1P0    |                                                        |
+------+----------+--------------------------------------------------------+
@ENDNODE


@NODE BPLCON3 "A Excerpts custom chip registers / BPLCON3"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLCON3 p  106   W    D   Bit plane control reg. (enhanced features)

+----+------------+--------------------------------------------------------+
|BIT#| BPLCON3    | DESCRIPTION                                            |
+----+------------+--------------------------------------------------------+
|    |            |                                                        |
| @{FG HIGHLIGHT}15@{FG TEXT} | @{FG HIGHLIGHT}BANK2=0@{FG TEXT}    | @{FG HIGHLIGHT}BANKx = Selects one of eight color banks, x=0-2.@{FG TEXT}       |
| @{FG HIGHLIGHT}14@{FG TEXT} | @{FG HIGHLIGHT}BANK1=0@{FG TEXT}    |                                                        |
| @{FG HIGHLIGHT}13@{FG TEXT} | @{FG HIGHLIGHT}BANK0=0@{FG TEXT}    |                                                        |
| @{FG HIGHLIGHT}12@{FG TEXT} | @{FG HIGHLIGHT}PF2OF2=0@{FG TEXT}   | @{FG HIGHLIGHT}Determine bit plane color table offset when playfield 2@{FG TEXT}|
|    |            | @{FG HIGHLIGHT}has priority in dual playfield mode:@{FG TEXT}                   |
|    |            +@{FG HIGHLIGHT}-----------+-------------------------------+------------@{FG TEXT}+
|    |            | @{FG HIGHLIGHT}PF20F     | AFFECTED BITPLANE             | OFFSET     @{FG TEXT}|
|    |            +@{FG HIGHLIGHT}---+---+---+-------------------------------+------------@{FG TEXT}+
|    |            | @{FG HIGHLIGHT}2 | 1 | 0 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | (decimal)  @{FG TEXT}|
|    |            +@{FG HIGHLIGHT}---+---+---+-------------------------------+------------@{FG TEXT}+
|    |            | @{FG HIGHLIGHT}0 | 0 | 0 | - | - | - | - | - | - | - | - | none       @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}0 | 0 | 1 | - | - | - | - | - | - | 1 | - | 2          @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}0 | 1 | 0 | - | - | - | - | - | 1 | - | - | 4          @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}0 | 1 | 1 | - | - | - | - | - | 1 | - | - | 8 (default)@{FG TEXT}|
|    |            | @{FG HIGHLIGHT}1 | 0 | 0 | - | - | - | 1 | - | - | - | - | 16         @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}1 | 0 | 1 | - | - | 1 | - | - | - | - | - | 32         @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}1 | 1 | 0 | - | 1 | - | - | - | - | - | - | 64         @{FG TEXT}|
|    |            | @{FG HIGHLIGHT}1 | 1 | 1 | 1 | - | - | - | - | - | - | - | 128        @{FG TEXT}|
|    |            +@{FG HIGHLIGHT}---+---+---+---+---+---+---+---+---+---+---+------------@{FG TEXT}+
|    |            |                                                        |
| @{FG HIGHLIGHT}11@{FG TEXT} | @{FG HIGHLIGHT}PF2OF1=1@{FG TEXT}   |                                                        |
| @{FG HIGHLIGHT}10@{FG TEXT} | @{FG HIGHLIGHT}PF2OF0=1@{FG TEXT}   |                                                        |
| @{FG HIGHLIGHT}09@{FG TEXT} | @{FG HIGHLIGHT}LOCT=0@{FG TEXT}     | @{FG HIGHLIGHT}Dictates that subsequent color palette values will be@{FG TEXT}  |
|    |            | @{FG HIGHLIGHT}written to a second 12- bit color palette, constituting@{FG TEXT}|
|    |            | @{FG HIGHLIGHT}the RGB low minus order bits. Writes to the normal hi@{FG TEXT}  |
|    |            | @{FG HIGHLIGHT}monus order color palette automatically copied to the@{FG TEXT}  |
|    |            | @{FG HIGHLIGHT}low order for backwards compatibility.@{FG TEXT}                 |
| 08 | X          | don`t care- but drive to 0 for upward compatibility!@{FG TEXT}   |
| @{FG HIGHLIGHT}07@{FG TEXT} | @{FG HIGHLIGHT}SPRES1=0@{FG TEXT}   | @{FG HIGHLIGHT}Determine resolution of all 8 sprites (x=0,1):@{FG TEXT}         |
|    |                                                                     |
|    |      @{FG HIGHLIGHT}+-------+--------+---------------------------------------------@{FG TEXT}+
|    |      @{FG HIGHLIGHT}|SPRES1 | SPRES0 | SPRITE RESOLUTION                           @{FG TEXT}|
|    |      @{FG HIGHLIGHT}+-------+--------+---------------------------------------------@{FG TEXT}+
|    |      @{FG HIGHLIGHT}|0      | 0      | ECS defaults (LORES,HIRES=140ns,SHRES=70ns) @{FG TEXT}|
|    |      @{FG HIGHLIGHT}|0      | 1      | LORES (140ns)                               @{FG TEXT}|
|    |      @{FG HIGHLIGHT}|1      | 0      | HIRES (70ns)                                @{FG TEXT}|
|    |      @{FG HIGHLIGHT}|1      | 1      | SHRES (35ns)                                @{FG TEXT}|
|    |      @{FG HIGHLIGHT}+-------+--------+---------------------------------------------@{FG TEXT}+
|    |                                                                     |
| @{FG HIGHLIGHT}06@{FG TEXT} | @{FG HIGHLIGHT}SPRES0=0@{FG TEXT}   |                                                        |
| @{FG FILL}05@{FG TEXT} | @{FG FILL}BRDRBLNK=0@{FG TEXT} | @{FG FILL}"Border area" is blanked instead of color (0).@{FG TEXT}         |
|    |            | @{FG FILL}Disabled when ECSENA low.@{FG TEXT}                              |
| @{FG FILL}04@{FG TEXT} | @{FG FILL}BRDNTRAN=0@{FG TEXT} | @{FG FILL}"Border area" is non minus transparent (ZD pin is low@{FG TEXT}  |
|    |            | @{FG FILL}when border is displayed). Disabled when ECSENA low.@{FG TEXT}   |
| 03 | X          | don`t care- but drive to 0 for upward compatibility!   |
| @{FG HIGHLIGHT}02@{FG TEXT} | @{FG HIGHLIGHT}ZDCLKEN=0@{FG TEXT}  | @{FG HIGHLIGHT}ZD pin outputs a 14MHz clock whose falling edge@{FG TEXT}        |
|    |            | @{FG HIGHLIGHT}coincides with hires (7MHz) video data. this bit when@{FG TEXT}  |
|    |            | @{FG HIGHLIGHT}set disables all other ZD functions.@{FG TEXT}                   |
|    |            | @{FG HIGHLIGHT}Disabled when ESCENA low.@{FG TEXT}                              |
| @{FG HIGHLIGHT}01@{FG TEXT} | @{FG HIGHLIGHT}BRDSPRT=0@{FG TEXT}  | @{FG HIGHLIGHT}Enables sprites outside the display window.@{FG TEXT}            |
|    |            | @{FG HIGHLIGHT}disabled when ESCENA low.@{FG TEXT}                              |
| @{FG HIGHLIGHT}00@{FG TEXT} | @{FG HIGHLIGHT}EXTBLKEN=0@{FG TEXT} | @{FG HIGHLIGHT}Causes BLANK output to be programmable instead of@{FG TEXT}      |
|    |            | @{FG HIGHLIGHT}reflecting internal fixed decodes.@{FG TEXT}                     |
|    |            | @{FG HIGHLIGHT}Disabled when ESCENA low.@{FG TEXT}                              |
+----+------------+--------------------------------------------------------+
@ENDNODE


@NODE BPLCON4 "A Excerpts custom chip registers / BPLCON4"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLCON4 p  10C   W    D   Bit plane control reg. (display masks)

+------+----------+--------------------------------------------------------+
| BIT# | BPLCON4  | DESCRIPTION                                            |
+------+----------+--------------------------------------------------------+
| @{FG HIGHLIGHT}15@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM7=0@{FG TEXT} | @{FG HIGHLIGHT}This 8 bit field is XOR`ed with the 8 bit plane color@{FG TEXT}  |
|      |          | @{FG HIGHLIGHT}address, thereby altering the color address sent to the@{FG TEXT}|
|      |          | @{FG HIGHLIGHT}color table (x=1-8)@{FG TEXT}                                    |
| @{FG HIGHLIGHT}14@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM6=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}13@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM5=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}12@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM4=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}11@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM3=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}10@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM2=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}09@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM1=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}08@{FG TEXT}   | @{FG HIGHLIGHT}BPLAM0=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}07@{FG TEXT}   | @{FG HIGHLIGHT}ESPRM7=0@{FG TEXT} | @{FG HIGHLIGHT}4 Bit field provides the 4 high order color table@{FG TEXT}      |
|      |          | @{FG HIGHLIGHT}address bits for even sprites: SPR0,SPR2,SPR4,SPR6.@{FG TEXT}    |
|      |          | @{FG HIGHLIGHT}Default value is 0001 binary. (x=7-4)@{FG TEXT}                  |
| @{FG HIGHLIGHT}06@{FG TEXT}   | @{FG HIGHLIGHT}ESPRM6=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}05@{FG TEXT}   | @{FG HIGHLIGHT}ESPRM5=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}04@{FG TEXT}   | @{FG HIGHLIGHT}ESPRM4=1@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}03@{FG TEXT}   | @{FG HIGHLIGHT}OSPRM7=0@{FG TEXT} | @{FG HIGHLIGHT}4 Bit field provides the 4 high order color table@{FG TEXT}      |
|      |          | @{FG HIGHLIGHT}address bits for odd sprites: SPR1,SPR3,SPR5,SPR7.@{FG TEXT}     |
|      |          | @{FG HIGHLIGHT}Default value is 0001 binary. (x=7-4)@{FG TEXT}                  |
| @{FG HIGHLIGHT}02@{FG TEXT}   | @{FG HIGHLIGHT}OSPRM6=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}01@{FG TEXT}   | @{FG HIGHLIGHT}OSPRM5=0@{FG TEXT} |                                                        |
| @{FG HIGHLIGHT}00@{FG TEXT}   | @{FG HIGHLIGHT}OSPRM4=1@{FG TEXT} |                                                        |
+------+----------+--------------------------------------------------------+
@ENDNODE


@NODE BPLxDAT "A Excerpts custom chip registers / BPLxDAT"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
BPLxDAT    110   W    A   Bit plane x data (parallel to serial convert)

           112            These regs receive the DMA data fetched from RAM
           114            by the bit plane address pointers described above.
           116            They may also be rewritten by either micro.
           118            they act as a 8 word parallel to serial buffer for
           11A            up to 8 memory 'bit planes'. x=1-8 the parallel to
        p  11C            serial conversion id triggered whenever bit plane
        p  11E            #1 is written, indicing the completion of all bit
                          planes for that word (16/32/64 pixels). The MSB is
                          output first, and is therefore always on the left.
@ENDNODE


@NODE COLORxx "A Excerpts custom chip registers / COLORxx"
NAME   rev ADDR     type chip Description
---------------------------------------------------------------------------
COLORxx    180-1BE   W        COLOR table xx

        There 32 of these registers (xx=00-31) and together with the banking
        bits they address the 256 locations in the color palette. There are
        actually two sets of color regs, selection of which is controlled by
        the LOCT reg bit. When LOCT = 0 the 4 MSB of red, green and blue
        video data are selected along with the T bit for genlocks the low
        order set of registers is also selected as well, so that the 4 bits-
        values are automatically extended to 8 bits.This provides
        compatibility with old software. If the full range of palette values
        are desired, then LOCT can be set high and independant values for
        the 4 LSB of red, green  and blue can be written. The low order
        color registers do not contain a transparency (T) bit.

        The table below shows the color register bit usage.

        +--------+-------------+-------------+-------------+-------------+
        | BIT#   | 15,14,13,12 | 11,10,09,08 | 07,06,05,04 | 03,02,01,00 |
        +--------+-------------+-------------+-------------+-------------+
        | @{FG HIGHLIGHT}LOCT=0@{FG TEXT} | T  X  X  X  | R7 R6 R5 R4 | G7 G6 G5 G4 | B7 B6 B5 B4 |
        | @{FG HIGHLIGHT}LOCT=1@{FG TEXT} | @{FG HIGHLIGHT}X  X  X  X@{FG TEXT}  | @{FG HIGHLIGHT}R3 R2 R1 R0@{FG TEXT} | @{FG HIGHLIGHT}G3 G2 G1 G0@{FG TEXT} | @{FG HIGHLIGHT}B3 B2 B1 B0@{FG TEXT} |
        +--------+-------------+-------------+-------------+-------------+

        T = TRANSPARENCY, R = RED, G = GREEN, B = BLUE, X = UNUSED

        T bit of COLOR00 thru COLOR31 sets ZD_pin HI, When that color is
        selected in all video modes.
@ENDNODE


@NODE COPJMP1 "A Excerpts custom chip registers / COPJMP1"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
COPJMP1   088  S    A     Coprocessor restart at first location

See: @{"COPJMP2" LINK COPJMP2}
@ENDNODE

@NODE COPJMP2 "A Excerpts custom chip registers / COPJMP2"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
COPJMP2   08A  S    A     Coprocessor restart at second location

         These address are strobe address, that when written to cause the
         coprocessor to jump indirect useing the address contained in the
         first or second location regs described below. The coprocessor
         itself can write to these address, causeing it`s own jump indirect.
@ENDNODE


@NODE COP1LCH "A Excerpts custom chip registers / COP1LCH"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
COP1LCH h 080  W    A         A Coprocessor first location reg
                                (high 5 bits) (old-3 bits)
COP1LCL   082  W    A         A Coprocessor first location reg
                                (low 15 bits)
COP2LCH h 084  W    A         A Coprocessor second location reg
                                (high 5 bits) (old-3 bits)
COP2LCL   086  W    A         A Coprocessor second location reg
                                (low 15 bits)

         These regs contain the jump addresses described in @{"COPINS" LINK COPINS}
@ENDNODE


@NODE COPINS "A Excerpts custom chip registers / COPINS"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
COPINS    08C  W   A      Coprocessor inst. fetch identify

         This is a dummy address that is generated by the coprocessor
         whenever it is loading instructions into its own instruction
         register.
         This actually occurs every coprocessor cycle except for the second
         (IR2) cycle of the MOVE instruction. The three types of instructions
         are shown below.

         MOVE: Move immediate to dest

         WAIT: Wait until beam counter is equal to, or greater than.
               (Keeps coprocessor off of bus until beam position has
               been reached)

         SKIP: Skip if beam counter is equal to, or greater than.
               (Skips following MOVE inst. unless beam position has been
               reached)

                +------------+-----------+-----------+
                |    MOVE    | WAIT UNTIL|  SKIP IF  |
         +------+-----+------+-----+-----+-----+-----+
         | BIT# | IR1 | IR2  | IR1 | IR2 | IR1 | IR2 |
         +------+-----+------+-----+-----+-----+-----+
         | 15   | x   | RD15 | VP7 | BFD | VP7 | BFD |
         | 14   | x   | RD14 | VP6 | VE6 | VP6 | VE6 |
         | 13   | x   | RD13 | VP5 | VE5 | VP5 | VE5 |
         | 12   | x   | RD12 | VP4 | VE4 | VP4 | VE4 |
         | 11   | x   | RD11 | VP3 | VE3 | VP3 | VE3 |
         | 10   | x   | RD10 | VP2 | VE2 | VP2 | VE2 |
         | 09   | x   | RD09 | VP1 | VE1 | VP1 | VE1 |
         | 08   | DA8 | RD08 | VP0 | VE0 | VP0 | VE0 |
         | 07   | DA7 | RD07 | HP8 | HE8 | HP8 | HE8 |
         | 06   | DA6 | RD06 | HP7 | HE7 | HP7 | HE7 |
         | 05   | DA5 | RD05 | HP6 | HE6 | HP6 | HE6 |
         | 04   | DA4 | RD04 | HP5 | HE5 | HP5 | HE5 |
         | 03   | DA3 | RD03 | HP4 | HE4 | HP4 | HE4 |
         | 02   | DA2 | RD02 | HP3 | HE3 | HP3 | HE3 |
         | 01   | DA1 | RD01 | HP2 | HE2 | HP2 | HE2 |
         | 00   | 0   | RD00 | 1   | 0   | 1   | 1   |
         +------+-----+------+-----+-----+-----+-----+

         IR1=First instruction register
         IR2=Second insturction register
         DA =Destination address for MOVE instruction.Fetched during
             IR1 time,used during IR2 time on RGA bus.
         RD =RAM Data moved by MOVE instruction at IR2 time
             directly from RAM to the address given by the DA field.
         VP =Vertical beam position comparison bit.
         HP =Horizontal beam position comparison bit.
         VE =Enable comparison (mask bit)
         HE =Enable comparison (mask bit)

 * Note: BFD = Blitter finished disable. When this bit is true, the blitter
               finished flag will have no effect on the coprocessor. When
               this bit is zero the blitter finished flag must be true (in
               addition to the rest of the bit comparisons) before the
               coprocessor can exit from it`s wait state, or skip over an
               instruction. Notethat the V7 comparison cannot be masked.

         The coprocessor is basically a 2 cycle machine that requests
         the bus only during odd memory cycles. (4 memory cycles per in)

         It has priority over the blitter and micro.

         There are only three types of instructions, MOVE immediate,
         WAIT until ,and SKIP if. All instructions require 2 bus cycles
         (and two instruction words).Since only the odd bus cycles are
         requested, 4 memory cycle times are required per instruction.
         (memory cycles are 280 ns)

         There are two indirect jump registers @{"COP1LC" LINK COP1LCH} and @{"COP2LC" LINK COP1LCH}.
         These are 20 bit pointer registers whose contents are used to modify
         program counter for initalization or jumps.

         They are transfered to the program counter whenever strobe address
         @{"COPJMP1" LINK COPJMP1} or @{"COPJMP2" LINK COPJMP2} are written. In addition COP1LC is automatically
         used at the beginning of each vertical blank time.

         It is important that one of the jump registers be initalized and
         it`s jump strobe address hit, after power up but before coprocessor
         DMA is initalized.T his insures a determined startup address, and
         state.
@ENDNODE


@NODE DDFSTRT "A Excerpts custom chip registers / DDFSTRT"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
DDFSTRT    092   W    A   Display data fetch start(horiz. position)
DDFSTOP    094   W    A   Display data fetch stop (horiz. position)
	These registers control the horizontal timing of the beginning
	and end of the bit plane DMA timing display data fetch.
	The vertical bit plane DMA timing is identical to the display
	windows described above.
	The bit plane Modulos are dependent on the bit plane
	horizontal size, and on this data fetch window size.

	Register bit assignment
	-----------------------

	BIT# 15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
	USE  XX   X   X   X   X   X   X  H8  H7  H6  H5  H4  H3  H2   X
	  (X bits should always be driven with 0 to maintain upward
	   compatability)

	The tables below show the start and stop timing for
	different register contents

         DDFSTRT (Left edge of display data fetch)
         +------------------+----+----+----+----+----+
         | PURPOSE          | H8 | H7 | H6 | H5 | H4 |
         +------------------+----+----+----+----+----+
         | Extra wide (max) | 0  | 0  | 1  | 0  | 1  |
         |                  |    |    |    |    |    |
         | wide             | 0  | 0  | 1  | 1  | 0  |
         |                  |    |    |    |    |    |
         | normal           | 0  | 0  | 1  | 1  | 1  |
         |                  |    |    |    |    |    |
         | narrow           | 0  | 1  | 0  | 0  | 0  |
         +------------------+----+----+----+----+----+

         DDFSTOP (Right edge of display data fetch)
         +------------------+----+----+----+----+----+
         | PURPOSE          | H8 | H7 | H6 | H5 | H4 |
         +------------------+----+----+----+----+----+
         | narrow           | 1  | 1  | 0  | 0  | 1  |
         |                  |    |    |    |    |    |
         | normal           | 1  | 1  | 0  | 1  | 0  |
         |                  |    |    |    |    |    |
         | wide (max)       | 1  | 1  | 0  | 1  | 1  |
         +------------------+----+----+----+----+----+

         Note that these numbers will vary with variable beam counter
         mode set: (The maxes and mins, that is)
@ENDNODE


@NODE DIWSTRT "A Excerpts custom chip registers / DIWSTRT"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
DIWSTRT    08E   W   A D  Display window start (upper left vert-hor pos)
DIWSTOP    090   W   A D  Display window stop (lower right vert-hor pos)
	These registers control the display window size and position,
	by locating the upper left and lower right corners.

	BIT# 15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
	USE  V7  V6  V5  V4  V3  V2  V1  V0  H9  H8  H7  H6  H5  H4  H3  H2

	DIWSTRT is vertically restricted to the upper 2/3
	of the display (v8=0),and horizontally restricted to the
	left 3/4 of the display (H8=0).*
	* Poof.. (see @{"DIWHIGH" link DIWHIGH} for exceptions)
@ENDNODE


@NODE DIWHIGH "A Excerpts custom chip registers / DIWHIGH"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
DIWHIGH p  1E4   W   A D  Display window upper bits for start, stop
	This is an added register for Hires chips, and allows
	larger start & stop ranges. If it is not written, the above
	(@{"DIWSTRT" link DIWSTRT},STOP) description holds. If this register is written,
	direct start & stop positions anywhere on the screen.
	It doesn`t affect the UHRES pointers.

	BIT# 15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
	      @{FG FILL}X   X  H10 @{FG HIGHLIGHT}H1  H0  @{FG FILL}V10 V9  V8   X   X  H10 @{FG HIGHLIGHT}H1  H0  @{FG FILL}V10 V9  V8
                      (stop)                 |         (start)@{FG TEXT}

	Take care (X) bits should always be written to 0 to
	maintain upwards compatibility. H1 and H0 values define
	70ns and 35ns increments respectively, and new LISA bits.

  Note: In all 3 display window registers, horizontal bit
	positions have been renamed to reflect HIRES pixel
	increments, e.g. what used to be called H0 is now referred to as H2.
@ENDNODE


@NODE DMACON "A Excerpts custom chip registers / DMACON"
NAME   rev ADDR type chip  Description
---------------------------------------------------------------------------
DMACON     096  W    A D P DMA control write (clear or set)
DMACONR    002  R    A   P DMA control (and blitter status) read

	This register controls all of the DMA channels, and contains
	blitter DMA status bits.

         +------+----------+--------------------------------------------+
         | BIT# | FUNCTION | DESCRIPTION                                |
         +------+----------+--------------------------------------------+
         | 15   | SET/CLR  | Set/Clear control bit. Determines if bits  |
         |      |          | written wit a 1 get set or cleared.        |
         |      |          | Bits written with a zero are unchanged.    |
         | 14   | BBUSY    | Blitter busy status bit (read only)        |
         | 13   | BZERO    | Blitter logic zero status bit. (read only) |
         | 12   | X        |                                            |
         | 11   | X        |                                            |
         | 10   | BLTPRI   | Blitter DMA priority (over CPU micro)      |
         |      |          | (also called "blitter nasty")              |
         |      |          | (disables /BLS pin, preventing micro       |
         |      |          | from stealing any bus cycles while         |
         |      |          | blitter DMA is running)                    |
         | 09   | DMAEN    | Enable all DMA below @{FG FILL}(also UHRES DMA)@{FG TEXT}      |
         | 08   | BPLEN    | Bit plane DMA enable                       |
         | 07   | COPEN    | Coprocessor DMA enable                     |
         | 06   | BLTEN    | Blitter DMA enable                         |
         | 05   | SPREN    | Sprite DMA enable                          |
         | 04   | DSKEN    | Disk DMA enable                            |
         | 03   | AUD3EN   | Audio chanel 3 DMA enable                  |
         | 02   | AUD2EN   | Audio chanel 2 DMA enable                  |
         | 01   | AUD1EN   | Audio chanel 1 DMA enable                  |
         | 00   | AUD0EN   | Audio chanel 0 DMA enable                  |
         +------+----------+--------------------------------------------+
@ENDNODE


@NODE DSKSYNC "A Excerpts custom chip registers / DSKSYNC"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
DSKSYNC  07E W  	P Disk sync register,the match code for disk
		          read synchronization. See @{"ADKCON" link ADKCON} bit 10
@ENDNODE


@NODE FMODE "A Excerpts custom chip registers / FMODE"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
FMODE   P  1FC   W        Memory Fetch Mode
	This register controls the fetch mechanism for different
	types of Chip RAM accesses:

         +-------+----------+-------------------------------------------+
         | BIT#  | FUNCTION | DESCRIPTION                               |
         +-------+----------+-------------------------------------------+
         | @{FG HIGHLIGHT}15@{FG TEXT}    | @{FG HIGHLIGHT}SSCAN2@{FG TEXT}   | @{FG HIGHLIGHT}Global enable for sprite scan-doubling.@{FG TEXT}   |
         | @{FG HIGHLIGHT}14@{FG TEXT}    | @{FG HIGHLIGHT}BSCAN2@{FG TEXT}   | @{FG HIGHLIGHT}Enables the use of 2nd P/F modulus on an@{FG TEXT}  |
         |       |          | @{FG HIGHLIGHT}alternate line basis to support bitplane@{FG TEXT}  |
         |       |          | @{FG HIGHLIGHT}scan-doubling.@{FG TEXT}                            |
         | @{FG HIGHLIGHT}13-04@{FG TEXT} | @{FG HIGHLIGHT}Unused@{FG TEXT}   |                                           |
         | @{FG HIGHLIGHT}03@{FG TEXT}    | @{FG HIGHLIGHT}SPAGEM@{FG TEXT}   | @{FG HIGHLIGHT}Sprite page mode (double CAS)@{FG TEXT}             |
         | @{FG HIGHLIGHT}02@{FG TEXT}    | @{FG HIGHLIGHT}SPR32@{FG TEXT}    | @{FG HIGHLIGHT}Sprite 32 bit wide mode@{FG TEXT}                   |
         | @{FG HIGHLIGHT}01@{FG TEXT}    | @{FG HIGHLIGHT}BPAGEM@{FG TEXT}   | @{FG HIGHLIGHT}Bitplane Page Mode (double CAS)@{FG TEXT}           |
         | @{FG HIGHLIGHT}00@{FG TEXT}    | @{FG HIGHLIGHT}BLP32@{FG TEXT}    | @{FG HIGHLIGHT}Bitplane 32 bit wide mode@{FG TEXT}                 |
         +-------+----------+-------------------------------------------+

         +------+-----+---------------+-----------+--------------+---------+
         |BPAGEM|BPL32| Bitplane Fetch|Increment  | Memory Cycle |Bus Width|
         +------+-----+---------------+-----------+--------------+---------+
         | @{FG HIGHLIGHT}0@{FG TEXT}    |  @{FG HIGHLIGHT}0@{FG TEXT}  | @{FG HIGHLIGHT}By 2 bytes@{FG TEXT}    |@{FG HIGHLIGHT}(as before)@{FG TEXT}|@{FG HIGHLIGHT}normal CAS@{FG TEXT}    |@{FG HIGHLIGHT}16@{FG TEXT}       |
         | @{FG HIGHLIGHT}0@{FG TEXT}    |  @{FG HIGHLIGHT}1@{FG TEXT}  | @{FG HIGHLIGHT}By 4 bytes@{FG TEXT}    |           |@{FG HIGHLIGHT}normal CAS@{FG TEXT}    |@{FG HIGHLIGHT}32@{FG TEXT}       |
         | @{FG HIGHLIGHT}1@{FG TEXT}    |  @{FG HIGHLIGHT}0@{FG TEXT}  | @{FG HIGHLIGHT}By 4 bytes@{FG TEXT}    |           |@{FG HIGHLIGHT}double CAS@{FG TEXT}    |@{FG HIGHLIGHT}16@{FG TEXT}       |
         | @{FG HIGHLIGHT}1@{FG TEXT}    |  @{FG HIGHLIGHT}1@{FG TEXT}  | @{FG HIGHLIGHT}By 8 bytes@{FG TEXT}    |           |@{FG HIGHLIGHT}double CAS@{FG TEXT}    |@{FG HIGHLIGHT}32@{FG TEXT}       |
         +------+-----+---------------+-----------+--------------+---------+

         +------+-----+------------+-----------+-------------+---------+
         |SPAGEM|SPR32|Sprite Fetch|Increment  |Memory Cycle |Bus Width|
         +------+-----+------------+-----------+-------------+---------+
         |  @{FG HIGHLIGHT}0@{FG TEXT}   |  @{FG HIGHLIGHT}0@{FG TEXT}  | @{FG HIGHLIGHT}By 2 bytes@{FG TEXT} |@{FG HIGHLIGHT}(as before)@{FG TEXT}| @{FG HIGHLIGHT}normal CAS@{FG TEXT}  |   @{FG HIGHLIGHT}16@{FG TEXT}    |
         |  @{FG HIGHLIGHT}0@{FG TEXT}   |  @{FG HIGHLIGHT}1@{FG TEXT}  | @{FG HIGHLIGHT}By 4 bytes@{FG TEXT} |           | @{FG HIGHLIGHT}normal CAS@{FG TEXT}  |   @{FG HIGHLIGHT}32@{FG TEXT}    |
         |  @{FG HIGHLIGHT}1@{FG TEXT}   |  @{FG HIGHLIGHT}0@{FG TEXT}  | @{FG HIGHLIGHT}By 4 bytes@{FG TEXT} |           | @{FG HIGHLIGHT}double CAS@{FG TEXT}  |   @{FG HIGHLIGHT}16@{FG TEXT}    |
         |  @{FG HIGHLIGHT}1@{FG TEXT}   |  @{FG HIGHLIGHT}1@{FG TEXT}  | @{FG HIGHLIGHT}By 8 bytes@{FG TEXT} |           | @{FG HIGHLIGHT}double CAS@{FG TEXT}  |   @{FG HIGHLIGHT}32@{FG TEXT}    |
         +------+-----+------------+-----------+-------------+---------+
@ENDNODE


@NODE HBSTOP "A Excerpts custom chip registers / HBSTOP"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
HBSTOP 1C6 W  D    Horizontal STOP position
HBSTRT 1C4 W  D    Horizontal START position

	 Bits 7-0 contain the stop and start positions,
	 respectively, for programed horizontal blanking in
	 280nS increments.Bits 10-8 provide a fine position
	 control in 35nS increments.


         +-------+----------+--------------+
         | BIT#  | FUNCTION | DESCRIPTION  |
         +-------+----------+--------------+
         | 15-11 |  x       | (unused)     |
         | 10    |  H1      | 140nS        |
         | 09    |  H1      | 70nS         |
         | 08    |  H0      | 35nS         |
         | 07    |  H10     | 35840nS      |
         | 06    |  H9      | 17920nS      |
         | 05    |  H8      | 8960nS       |
         | 04    |  H7      | 4480nS       |
         | 03    |  H6      | 2240nS       |
         | 02    |  H5      | 1120nS       |
         | 01    |  H4      | 560nS        |
         | 00    |  H3      | 280nS        |
         +-------+----------+--------------+
@ENDNODE


@NODE HCENTER "A Excerpts custom chip registers / HCENTER"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
HCENTER H 1E2  W  A  Horizontal position (CCKs) of VSYNC on long field

	 this is necessary for interlace mode with variable beam
	 counters. See @{"BEAMCON0" LINK BEAMCON0} for when it affects chip outputs.
	 See @{"HTOTAL" LINK HTOTAL} for bits.
@ENDNODE


@NODE HHPOSR "A Excerpts custom chip registers / HHPOSR"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
HHPOSR  H 1DA  R  A  DUAL mode hires Hbeam counter read
HHPOSW  H 1D8  W  A  DUAL mode hires Hbeam counter write

	This the secondary beam counter for
	the faster mode, triggering the UHRES pointers & doing the
	comparisons for @{"HBSTRT" LINK HBSTOP}, STOP, HTOTAL, HSSRT, @{"HSSTOP" LINK HSSTOP}
	(See @{"HTOTAL" LINK HTOTAL} for bits)
@ENDNODE


@NODE HSSTOP "A Excerpts custom chip registers / HSSTOP"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
HSSTOP H  1C2  W  A   Horiz line position for SYNC stop
		Sets # of colour clocks for sync stop (@{"HTOTAL" LINK HTOTAL} for bits)
HSSTRT H  1DE  W  A  Horiz line position for HSYNC stop
		Sets # of colour clocks for sync start (@{"HTOTAL" LINK HTOTAL} for bits)
		See @{"BEAMCON0" LINK BEAMCON0} for details of when these 2 are active.
@ENDNODE


@NODE HTOTAL "A Excerpts custom chip registers / HTOTAL"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
HTOTAL H  1C0  W  A    Highest colour clock count in horiz line


	BIT#  15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
	       x   x   x   x   x   x   x   x  h8  h7  h6  h5  h4  h3  h2  h1

	(x`s should be driven to 0 for upward compatibility)
	Horiz line has theis many + 1 280nS increments. If the
	pal bit & LOLDIS are not high, long line/skort line toggle
	will occur, and there will be this many +2 every other line.
	Active if VARBEAMEN=1 or DUAL+1.
@ENDNODE


@NODE INTENA "A Excerpts custom chip registers / INTENA"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
INTENA   09A  W 	P Interrupt enable bits (clear or set bits)
INTENAR  01C  R		P Interrupt enable bits (read)

	This register contains interrupt enable bits. The bit
	assignment for both the request, and enable registers
	is given below.

 +------+----------+-------+--------------------------------------------+
 | BIT# | FUNCTION | LEVEL | DESCRIPTION                                |
 +------+----------+-------+--------------------------------------------+
 | 15   |  SET/CLR |       | Set/clear control bit. Determines if bits  |
 |      |          |       | written with a 1 get set or cleared. Bits  |
 |      |          |       | written with a zero are always unchanged.  |
 | 14   |  INTEN   |       | Master interrupt (enable only, no request) |
 | 13   |  EXTER   |   6   | External interrupt                         |
 | 12   |  DSKSYN  |   5   | Disk sync register (@{"DSKSYNC" LINK DSKSYNC}) matches disk  |
 | 11   |  RBF     |   5   | Serial port receive buffer full            |
 | 10   |  AUD3    |   4   | Audio channel 3 block finished             |
 | 09   |  AUD2    |   4   | Audio channel 2 block finished             |
 | 08   |  AUD1    |   4   | Audio channel 1 block finished             |
 | 07   |  AUD0    |   4   | Audio channel 0 block finished             |
 | 06   |  BLIT    |   3   | Blitter has finished                       |
 | 05   |  VERTB   |   3   | Start of vertical blank                    |
 | 04   |  COPER   |   3   | Coprocessor                                |
 | 03   |  PORTS   |   2   | I/O Ports and timers                       |
 | 02   |  SOFT    |   1   | Reserved for software initated interrupt.  |
 | 01   |  DSKBLK  |   1   | Disk block finished                        |
 | 00   |  TBE     |   1   | Serial port transmit buffer empty          |
 +------+----------+-------+--------------------------------------------+
@ENDNODE


@NODE INTREQ "A Excerpts custom chip registers / INTREQ"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
INTREQ     09C   W    P   Interrupt request bits (clear or set)
INTREQR    01E   R    P   Interrupt request bits (read)

	This register contains interrupt request bits (or flags).
	These bits may be polled by the processor, and if enabled
	by the bits listed in the next register, they may cause
	processor @{"interrupts" LINK Chapter-4-4-13-1}. Both a set and clear operation
	are required to load arbitrary data into this register.
	The bit assignments are identical to the enable register @{"below." LINK INTENA}
@ENDNODE


@NODE SPRxCTL "A Excerpts custom chip registers / SPRxCTL"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
SPRxCTL p  142   W    A D Sprite position and control data

       +-------+----------+------------------------------------------------+
       | BIT#  | SYM      | FUNCTION                                       |
       +-------+----------+------------------------------------------------+
       | 15-08 | EV7-EV0  | End (stop) vert. value. Low 8 bits             |
       | 07    | ATT	  | Sprite attach control bit (odd sprites only)   |
       | @{FG FILL}06@{FG TEXT}    | @{FG FILL}SV9@{FG TEXT}	  | @{FG FILL}Start vert value 10th bit.@{FG TEXT}                     |
       | @{FG FILL}05@{FG TEXT}    | @{FG FILL}EV9@{FG TEXT}      | @{FG FILL}End (stop) vert. value 10th bit@{FG TEXT}                |
       | @{FG FILL}04@{FG TEXT}    | @{FG FILL}SH1=0@{FG TEXT}    | @{FG FILL}Start horiz. value, 70nS increment@{FG TEXT}             |
       | @{FG FILL}03@{FG TEXT}    | @{FG FILL}SH0=0@{FG TEXT}    | @{FG FILL}Start horiz. value 35nS increment@{FG TEXT}              |
       | 02    | SV8      | Start vert. value 9th bit                      |
       | 01    | EV8      | End (stop) vert. value 9th bit                 |
       | 00    | SH2      | Start horiz.value,140nS increment              |
       +-------+----------+------------------------------------------------+

         These 2 registers work together as position, size and
         feature sprite control registers.They are usually loaded
         by the sprite DMA channel, during horizontal blank,
         however they may be loaded by either processor any time.
         Writing to SPRxCTL disables the corresponding sprite.
@ENDNODE


@NODE SPRxDAT "A Excerpts custom chip registers / SPRxDAT"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
SPRxDATA   144  W      D  Sprite x image data register A
SPRxDATB   146  W      D  Sprite x image data register B

	These registers buffer the sprite image data. They are
	usually loaded by the sprite DMA channel but may be
	loaded by either processor at any time. When a horizontal
	coincidence occurs the buffers are dumped into shift
	registers and serially outputted to the display, MSB first
	on the left.
	NOTE: Writing to the A buffer enables (arms) the sprite.
	Writing to the @{"SPRxCTL" LINK SPRxCTL} registers disables the sprite.
	If enabled, data in the A and B buffers will be output
	whenever the beam counter equals the sprite horizontal
	position value in the @{"SPRxPOS" LINK SPRxPOS} register. In lowres mode,
	1 sprite pixel is 1 bitplane pixel wide. In HRES and
	SHRES mode, 1 sprite pixel is 2 bitplane pixels.
	The DATB bits are the 2SBs (worth 2) for the color registers,
	and MSB for SHRES. DATA bits are LSBs of the pixels.
@ENDNODE


@NODE SPRxPOS "A Excerpts custom chip registers / SPRxPOS"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
SPRxPOS    140   W    A D Sprite x vert-horiz start position data.

       +-------+----------+------------------------------------------------+
       | BIT#  | SYM      | FUNCTION                                       |
       +-------+----------+------------------------------------------------+
       | 15-08 | SV7-SV0  | Start vertical value. High bit (SV8) is        |
       |       |          | in SPRxCTL register below.                     |
       | 07-00 | SH10-SH3 | Sprite horizontal start value. Low order       |
       |       |          | 3 bits are in @{"SPRxCTL" link SPRxCTL} register below. @{FG HIGHLIGHT}If@{FG TEXT}      |
       |       |          | @{FG HIGHLIGHT}SSCAN2 bit in@{FG TEXT} @{"FMODE" link FMODE} @{FG HIGHLIGHT}is set, then disable@{FG TEXT}      |
       |       |          | @{FG HIGHLIGHT}SH10 horizontal coincidence detect.This bit@{FG TEXT}    |
       |       |          | @{FG HIGHLIGHT}is then free to be used by ALICE as an@{FG TEXT}         |
       |       |          | @{FG HIGHLIGHT}individual scan double enable.@{FG TEXT}                 |
       +-------+----------+------------------------------------------------+
@ENDNODE


@NODE VBSTOP "A Excerpts custom chip registers / VBSTOP"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
VBSTOP H 1CE   W    A    Vertical line for VBLANK stop
VBSTRT H 1CC   W    A    Vertical line for VBLANK start
		(V10-0 <- D10-0) Affects CSY pin if BLAKEN=1 and VSY pin
		if CSCBEN=1 (see @{"BEAMCON0" LINK BEAMCON0})
@ENDNODE


@NODE VHPOSR "A Excerpts custom chip registers / VHPOSR"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
VHPOSR     006  R   A    Read vert and horiz position of beam, or lightpen
VHPOSW     02C  W   A    Write vert horiz position of beam, or lightpen
 BIT#  15  14  13  12  11  10  09  08     07  06  05  04  03  02  01  00
 USE   V7  V6  V5  V4  V3  V2  V1  V0     H8  H7  H6  H5  H4  H3  H2  H1

		RESOLUTION = 1/160 of SCREEN WITH ( 280 nS)
@ENDNODE


@NODE VPOSR "A Excerpts custom chip registers / VPOSR"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
VPOSR  p 004   R    A   Read vert most sig. bits (and frame flop)
VPOSW    02A   W    A   Write most sig. bits (and frame flop)


 BIT#  15  14  13  12  11  10  09  08     07  06  05  04  03  02  01  00
 USE LOF   I6  I5  I4  I3  I2  I1  I0 LOL --  --  --  --  --  V10 V9  V8

         LOF = Long frame(auto toggle control bit in @{"BPLCON0" LINK BPLCON0})

         I0-I6 Chip identitication:

         8361 (Regular) or 8370 (Fat) (Agnus-ntsc) = 10
         8367 (Pal) or 8371 (Fat-Pal) (Agnus-pal)  = 00
         8372 (Fat-hr) (agnushr),thru rev4         = 20 Pal, 30 NTSC
         8372 (Fat-hr) (agnushr),rev 5             = 22 Pal, 31 NTSC
         8374 (Alice) thru rev 2                   = 22 Pal, 32 NTSC
         8374 (Alice) rev 3 thru rev 4             = 23 Pal, 33 NTSC

         LOL = Long line bit. When low, it indicates short raster line.
         v9,10 -- hires chips only (20,30 identifiers)
@ENDNODE


@NODE VSSTOP "A Excerpts custom chip registers / VSSTOP"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
VSSTOP H   1CA W   A   Vert position for VSYNC stop
                 See @{"BEAMCON0" LINK BEAMCON0} for more details. (V10-0 <- D10-0)
VSSTRT H   1E0 W   A   Vert position for VSYNC start
@ENDNODE


@NODE VTOTAL "A Excerpts custom chip registers / VTOTAL"
NAME   rev ADDR type chip Description
---------------------------------------------------------------------------
VTOTAL H   1C8 W   A   Highest numbered vertival line (VARBEAMEN = 1)

	It`s the line number to reset the counter,
	so there`s this many + 1 in a field. The exception is
	if the LACE bit is set (@{"BPLCON0" LINK BPLCON0}), in which case every
	other field is this many + 2 and the short field is this
	many + 1.
@ENDNODE


@NODE Appendix-B "Coder Aid / B CIA registers"
@{B}B CIA registers@{UB}

This appendix contains information about the 8520 Complex Interface
Adapter (CIA) chips which handle the serial, parallel, keyboard and
other Amiga I/O activities.

Each Amiga system contains two 8520 Complex Interface Adapter (CIA)
chips. Each chip has 16 general purpose input/output pins, plus a
serial shift register, three timers, an output pulse pin and an edge
detection input. In the Amiga system various tasks are assigned to
the chip's capabilities as follows:

CIAA Address Map
---------------------------------------------------------------------------
 Byte    Register                  Data bits
Address    Name     7     6     5     4     3     2     1    0
---------------------------------------------------------------------------
BFE001    pra     /FIR1 /FIR0  @{"/RDY" LINK Appendix-B-1} @{"/TK0" LINK Appendix-B-1}  @{"/WPRO" LINK Appendix-B-1} @{"/CHNG" LINK Appendix-B-1} /LED  OVL
BFE101    prb     Parallel port
BFE201    ddra    Direction for port A (BFE001);1=output (set to 0x03)
BFE301    ddrb    Direction for port B (BFE101);1=output (can be in or out)
BFE401    talo    CIAA timer A low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
BFE501    tahi    CIAA timer A high byte
BFE601    tblo    CIAA timer B low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
BFE701    tbhi    CIAA timer B high byte
BFE801    todlo   50/60 Hz event counter bits 7-0 (VSync or line tick)
BFE901    todmid  50/60 Hz event counter bits 15-8
BFEA01    todhi   50/60 Hz event counter bits 23-16
BFEB01            not used
BFEC01    sdr     CIAA serial data register (connected to keyboard)
BFED01    icr     CIAA interrupt control register
BFEE01    cra     CIAA control register A
BFEF01    crb     CIAA control register B

Note:  CIAA can generate interrupt @{"INT2" LINK Chapter-4-4-13-1}.


CIAB Address Map
---------------------------------------------------------------------------
 Byte     Register                   Data bits
Address     Name     7     6     5     4     3     2     1     0
---------------------------------------------------------------------------
BFD000    pra     /DTR  /RTS  /CD   /CTS  /DSR   SEL   POUT  BUSY
BFD100    prb     @{"/MTR" LINK Appendix-B-1}  @{"/SEL3" LINK Appendix-B-1} @{"/SEL2" LINK Appendix-B-1} @{"/SEL1" LINK Appendix-B-1} @{"/SEL0" LINK Appendix-B-1} @{"/SIDE" LINK Appendix-B-1}  @{"DIR" LINK Appendix-B-1}  @{"/STEP" LINK Appendix-B-1}
BFD200    ddra    Direction for Port A (BFD000);1 = output (set to 0xFF)
BFD300    ddrb    Direction for Port B (BFD100);1 = output (set to 0xFF)
BFD400    talo    CIAB timer A low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
BFD500    tahi    CIAB timer A high byte
BFD600    tblo    CIAB timer B low byte (.715909 Mhz NTSC; .709379 Mhz PAL)
BFD700    tbhi    CIAB timer B high byte
BFD800    todlo   Horizontal sync event counter bits 7-0
BFD900    todmid  Horizontal sync event counter bits 15-8
BFDA00    todhi   Horizontal sync event counter bits 23-16
BFDB00            not used
BFDC00    sdr     CIAB serial data register (unused)
BFDD00    icr     CIAB interrupt control register
BFDE00    cra     CIAB Control register A
BFDF00    crb     CIAB Control register B

Note:  CIAB can generate @{"INT6" LINK Chapter-4-4-13-1}.
@ENDNODE


@NODE Appendix-B-1 "B CIA registers / Signals when driving a disk"
@{B}B-1 Signals when driving a disk@{UB}

SEL1B-, SEL2B-, SEL3B-
   Select lines for the three external disk drives active low.

TK0-
   A selected drive pulls this signal low whenever its read-write head
   is on track 00.

RDY-
   When a disk drive's motor is on, this line indicates the selected
   disk is installed and rotating at speed. The driver ignores this
   signal. When the motor is off this is used as a data line for floppy
   detection.

WPRO-
   A selected drive pulls this signal low whenever it has a
   write-protected diskette installed.

INDEX-
   A selected drive pulses this signal low once for each revolution of
   its motor.

SIDEB-
   The system drives this signal to all disk drives -- low for side 1,
   high for side 0.

STEPB-
   Pulsed to step the selected drive's head.

DIRB
   The system drives this signal high or low to tell the selected drive
   which way to step when the STEPB- pulse arrives. Low means step in
   (to higher-numbered track); high means step out.

DKRD-
   A selected drive will put out read data on this line.

CHNG-
   A selected drive will drive this signal low whenever its internal
   "disk change" latch is set. This latch is set when the drive is first
   powered on, or whenever there is no diskette in the drive. To reset
   the latch, the system must select the drive, and step the head. Of
   course, the latch will not reset if there is no diskette installed.

MTRXD-
   This is the motor control line for all four disk drives. When the
   system wants to turn on a disk drive motor, it first deselects the
   drive (if selected), pulls MTRXD- low, and selects the drive. To turn
   the motor off, the system deselects the drive, pulls MTRXD- high, and
   selects the drive. The system will always set MTRXD- at least 1.4
   microseconds before it selects the drive, and will not change MTRXD-
   for at least 1.4 microseconds after selecting the drive. All external
   drives must have logic equivalent to a D flip-flop, whose D input is
   the MTRXD- signal, and whose clock input is activated by the
   off-to-on (high-to-low) transition of its SELxB- signal. As noted
   above, both the setup and hold times of MTRXD- with respect to SELxB-
   will always be at least 1.4 microseconds. The output of this
   flip-flop controls the disk drive motor. Thus, the system can control
   all four motors using only one signal on the cable (MTRXD-).
@ENDNODE


@NODE Appendix-C "Coder Aid / C Excerpts Autodocs"
@{B}C Excerpts Autodocs@{UB}

  C-1 @{" exec.library " LINK Appendix-C-1}
  C-2 @{" battclock.resource " LINK Appendix-C-2}
@ENDNODE


@NODE Appendix-C-1 "C Excerpts Autodocs / exec.library"
@{B}C-1 exec.library@{UB}

    C-1-1  @{" AllocAbs() " LINK AllocAbs()}
    C-1-2  @{" AllocMem() " LINK AllocMem()}
    C-1-3  @{" CacheClearU() " LINK CacheClearU()}
    C-1-4  @{" CacheControl() " LINK CacheControl()}
    C-1-5  @{" CloseDevice() " LINK CloseDevice()}
    C-1-6  @{" DoIO() " LINK DoIO()}
    C-1-7  @{" Disable() " LINK Disable()}
    C-1-8  @{" Enable() " LINK Enable()}
    C-1-9  @{" FindName() " LINK FindName()}
    C-1-10 @{" Forbid() " LINK Forbid()}
    C-1-11 @{" FreeMem() " LINK FreeMem()}
    C-1-12 @{" OpenDevice() " LINK OpenDevice()}
    C-1-13 @{" OpenResource() " LINK OpenResource()}
    C-1-14 @{" Permit() " LINK Permit()}
    C-1-15 @{" Supervisor() " LINK Supervisor()}
@ENDNODE


@NODE AllocAbs() "C Excerpts Autodocs / exec.library / AllocAbs"
NAME
    AllocAbs -- allocate at a given location

SYNOPSIS
    memoryBlock = AllocAbs(byteSize, location)
    D0            D0                 A1

    void *AllocAbs(ULONG, APTR);

FUNCTION
    This function attempts to allocate memory at a given absolute
    memory location.  Often this is used by boot-surviving entities
    such as recoverable ram-disks. If the memory is already being
    used, or if there is not enough memory to satisfy the request,
    AllocAbs will return NULL.

    This block may not be exactly the same as the requested block
    because of rounding, but if the return value is non-zero, the block
    is guaranteed to contain the requested range.

INPUTS
    byteSize - the size of the desired block in bytes
    This number is rounded up to the next larger
    block size for the actual allocation.
    location - the address where the memory MUST be.

RESULT
    memoryBlock - a pointer to the newly allocated memory block, or
    NULL if failed.

NOTE
    If the free list is corrupt, the system will panic with alert
    AN_MemCorrupt, $01000005.

    The 8 bytes past the end of an AllocAbs will be changed by Exec
    relinking the next block of memory.  Generally you can't trust
    the first 8 bytes of anything you AllocAbs.

SEE ALSO
    @{"AllocMem" LINK AllocMem()}, @{"FreeMem" LINK FreeMem()}
@ENDNODE


@NODE AllocMem() "C Excerpts Autodocs / exec.library / AllocMem"
NAME
    AllocMem -- allocate memory given certain requirements

SYNOPSIS
    memoryBlock = AllocMem(byteSize, attributes)
    D0                     D0        D1

    void *AllocMem(ULONG, ULONG);

FUNCTION
    This is the memory allocator to be used by system code and
    applications.  It provides a means of specifying that the allocation
    should be made in a memory area accessible to the chips, or
    accessible to shared system code.

    Memory is allocated based on requirements and options.  Any
    "requirement" must be met by a memory allocation, any "option" will
    be applied to the block regardless.  AllocMem will try all memory
    spaces until one is found with the proper requirements and room for
    the memory request.

INPUTS
    byteSize - the size of the desired block in bytes.  (The operating
            system will automatically round this number to a multiple of
            the system memory chunk size)

    attributes -
        requirements

            If no flags are set, the system will return the best
            available memory block.  For expanded systems, the fast
            memory pool is searched first.

            MEMF_CHIP:      If the requested memory will be used by
                            the Amiga custom chips, this flag *must*
                            be set.

                            Only certain parts of memory are reachable
                            by the special chip sets' DMA circuitry.
                            Chip DMA includes screen memory, images that
                            are blitted, audio data, copper lists, sprites
                            and Pre-V36 trackdisk.device buffers.


            MEMF_FAST:      This is non-chip memory.  If no flag is set
                            MEMF_FAST is taken as the default.

                            DO NOT SPECIFY MEMF_FAST unless you know
                            exactly what you are doing!  If MEMF_FAST is
                            set, AllocMem() will fail on machines that
                            only have chip memory!  This flag may not
                            be set when MEMF_CHIP is set.


            MEMF_PUBLIC:    Memory that must not be mapped, swapped,
                            or otherwise made non-addressable. ALL
                            MEMORY THAT IS REFERENCED VIA @{"INTERRUPTS" LINK Chapter-4-4-13-1}
                            AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC
                            OR LOCKED INTO MEMORY! This includes both
                            code and data.


            MEMF_LOCAL:     This is memory that will not go away
                            after the CPU RESET instruction.  Normally,
                            autoconfig memory boards become unavailable
                            after RESET while motherboard memory
                            may still be available.  This memory type
                            is now automatically set in V36.  Pre-V36
                            systems may not have this memory type
                            and AllocMem() will then fail.


            MEMF_24BITDMA:  This is memory that is within the address
                            range of 24-bit DMA devices.  (Zorro-II)
                            This is required if you run a Zorro-II
                            DMA device on a machine that has memory
                            beyond the 24-bit addressing limit of
                            Zorro-II.  This memory type
                            is now automatically set in V36.  Pre-V36
                            systems may not have this memory type
                            and AllocMem() will then fail.


        options

            MEMF_CLEAR:     The memory will be initialized to all
                            zeros.


            MEMF_REVERSE:   This allocates memory from the top of
                            the memory pool.  It searches the pools
                            in the same order, such that FAST memory
                            will be found first.  However, the
                            memory will be allocated from the highest
                            address available in the pool.  This
                            option is new as of V36.


RESULT
    memoryBlock - a pointer to the newly allocated memory block.
            If there are no free memory regions large enough to satisfy
            the request, zero will be returned.  The pointer must be
            checked for zero before the memory block may be used!

WARNING
    The result of any memory allocation MUST be checked, and a viable
    error handling path taken.  ANY allocation may fail if memory has
    been filled.

EXAMPLES
    AllocMem(64,0L)         - Allocate the best available memory
    AllocMem(25,MEMF_CLEAR) - Allocate the best available memory, and
                              clear it before returning.
    AllocMem(128,MEMF_CHIP) - Allocate chip memory
    AllocMem(128,MEMF_CHIP|MEMF_CLEAR) - Allocate cleared chip memory
    AllocMem(821,MEMF_CHIP|MEMF_PUBLIC|MEMF_CLEAR) - Allocate cleared,
            public, chip memory.

NOTE
    If the free list is corrupt, the system will panic with alert
    AN_MemCorrupt, $01000005.

    This function may not be called from @{"interrupts" LINK Chapter-4-4-13-1}.

    A DOS process will have its pr_Result2 field set to
    ERROR_NO_FREE_STORE if the memory allocation fails.

SEE ALSO
    @{"FreeMem" LINK FreeMem()}
@ENDNODE


@NODE CacheClearU() "C Excerpts Autodocs / exec.library / CacheClearU"
NAME
    CacheClearU - User callable simple cache clearing (V37)

SYNOPSIS
    CacheClearU()

    void CacheClearU(void);

FUNCTION
    Flush out the contents of any CPU instruction and data caches.
    If dirty data cache lines are present, push them to memory first.

    Caches must be cleared after *any* operation that could cause
    invalid or stale data.  The most common cases are DMA and modifying
    instructions using the processor.  See the CacheClearE() autodoc
    for a more complete description.

    Some examples of when the cache needs clearing:
                    Self modifying code
                    Building Jump tables
                    Run-time code patches
                    Relocating code for use at different addresses.
                    Loading code from disk

SEE ALSO
    exec/execbase.i, @{"CacheControl" LINK CacheControl()}, CacheClearE
@ENDNODE


@NODE CacheControl() "C Excerpts Autodocs / exec.library / Cache Control"
NAME
    Cache Control - Instruction & data cache control

SYNOPSIS
    oldBits = CacheControl(@{"cacheBits" LINK Chapter-4-4-9-6},cacheMask)
    D0                     D0        D1

    ULONG CacheControl(ULONG,ULONG);

FUNCTION
    This function provides global control of any instruction or data
    caches that may be connected to the system.  All settings are
    global -- per task control is not provided.

    The action taken by this function will depend on the type of
    CPU installed.  This function may be patched to support external
    caches, or different cache architectures.  In all cases the function
    will attempt to best emulate the provided settings.  Use of this
    function may save state specific to the caches involved.

    The list of supported settings is provided in the exec/execbase.i
    include file.  The bits currently defined map directly to the Motorola
    68030 CPU CACR register.  Alternate cache solutions may patch into
    the Exec cache functions.  Where possible, bits will be interpreted to
    have the same meaning on the installed cache.

INPUTS
    @{"cacheBits" LINK Chapter-4-4-9-6} - new values for the bits specified in cacheMask.

    cacheMask - a mask with ones for all bits to be changed.

RESULT
    oldBits   - the complete prior values for all settings.

NOTE
    As a side effect, this function clears all caches.

SEE ALSO
    exec/execbase.i, @{"CacheClearU" LINK CacheClearU()}, CacheClearE
@ENDNODE


@NODE CloseDevice() "C Excerpts Autodocs / exec.library / CloseDevice"
NAME
    CloseDevice -- conclude access to a device

SYNOPSIS
    CloseDevice(iORequest)
                A1

    void CloseDevice(struct IORequest *);

FUNCTION
    This function informs the device that access to a device/unit
    previously opened has been concluded.  The device may perform
    certain house-cleaning operations.

    The user must ensure that all outstanding IORequests have been
    returned before closing the device.  AbortIO function can kill
    any stragglers.

    After a close, the I/O request structure is free to be reused.
    Starting with V36 exec it is safe to CloseDevice() with an
    IORequest that is either cleared to zeros, or failed to
    open.

INPUTS
    iORequest - pointer to an I/O request structure

SEE ALSO
    @{"OpenDevice" LINK OpenDevice()}
@ENDNODE


@NODE Disable() "C Excerpts Autodocs / exec.library / Disable"
NAME
    Disable -- disable interrupt processing.

SYNOPSIS
    Disable();

    void Disable(void);

FUNCTION
    Prevents @{"interrupts" LINK Chapter-4-4-13-1} from being handled by the system, until a
    matching @{"Enable()" LINK Enable()} is executed.  Disable() implies Forbid().

    DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION.  THIS CALL IS
    VERY DANGEROUS!

RESULTS
    All interrupt processing is deferred until the task executing makes
    a call to @{"Enable()" LINK Enable()} or is placed in a wait state. Normal task
    rescheduling does not occur while interrupts are disabled.  In order
    to restore normal interrupt processing, the programmer must execute
    exactly one call to @{"Enable()" LINK Enable()} for every call to Disable().

    IMPORTANT REMINDER:

    It is important to remember that there is a danger in using
    disabled sections.  Disabling interrupts for more than ~250
    microseconds will prevent vital system functions (especially serial
    I/0) from operating in a normal fashion.

    Think twice before using Disable(), then think once more.
    After all that, think again.  With enough thought, the need
    for a Disable() can often be eliminated.  For the user of many
    device drivers, a write to disable *only* the particular interrupt
    of interest can replace a Disable().  For example:
                    MOVE.W  #INTF_PORTS,_intena
    Do not use a macro for Disable(), insist on the real thing.

    This call may be made from @{"interrupts" LINK Chapter-4-4-13-1}, it will have the effect
    of locking out all higher-level interrupts (lower-level interrupts
    are automatically disabled by the CPU).

    Note: In the event of a task entering a Wait() after disabling
          interrupts, the system "breaks" the disabled state and runs
          normally until the task which called Disable() is rescheduled.

NOTE
    This call is guaranteed to preserve all registers.

SEE ALSO
    @{"Forbid" LINK Forbid()}, @{"Permit" LINK Permit()}, @{"Enable" LINK Enable()}
@ENDNODE


@NODE DoIO() "C Excerpts Autodocs / exec.library / DoIO"
NAME
    DoIO -- perform an I/O command and wait for completion

SYNOPSIS
    error = DoIO(iORequest)
    D0           A1

    BYTE DoIO(struct IORequest *);

FUNCTION
    This function requests a device driver to perform the I/O command
    specified in the I/O request.  This function will always wait until
    the I/O request is fully complete.

    DoIO() handles all the details, including Quick I/O, waiting for
    the request, and removing the reply message, etc..

IMPLEMENTATION
    This function first tries to complete the IO via the "Quick I/O"
    mechanism.  The io_Flags field is always set to IOF_QUICK (0x01)
    before the internal device call.

    The LN_TYPE field is used internally to flag completion.  Active
    requests have type NT_MESSAGE.  Requests that have been replied
    have type NT_REPLYMSG.  It is illegal to start IO using a
    still active IORequest, or a request with type NT_REPLYMSG.

INPUTS
    iORequest - pointer to an IORequest initialized by @{"OpenDevice()" LINK OpenDevice()}

RESULTS
    error - a sign-extended copy of the io_Error field of the
            IORequest.  Most device commands require that the error
            return be checked.

SEE ALSO
    SendIO, CheckIO, WaitIO, AbortIO, amiga.lib/BeginIO
@ENDNODE


@NODE Enable() "C Excerpts Autodocs / exec.library / Enable"
NAME
    Enable -- permit system @{"interrupts" LINK Chapter-4-4-13-1} to resume.

SYNOPSIS
    Enable();

    void Enable(void);

FUNCTION
    Allow system interrupts to again occur normally, after a matching
    @{"Disable()" LINK Disable()} has been executed.

RESULTS
    Interrupt processing is restored to normal operation. The
    programmer must execute exactly one call to Enable() for every call
    to @{"Disable()" LINK Disable()}.

NOTE
    This call is guaranteed to preserve all registers.

SEE ALSO
    @{"Forbid" LINK Forbid()}, @{"Permit" LINK Permit()}, @{"Enable" LINK Enable()}
@ENDNODE


@NODE FindName() "C Excerpts Autodocs / exec.library / FindName"
NAME
    FindName -- find a system list node with a given name

SYNOPSIS
    node = FindName(start, name)
    D0,Z	    A0     A1

    struct Node *FindName(struct List *, STRPTR);

FUNCTION
    Traverse a system list until a node with the given name is found.
    To find multiple occurrences of a string, this function may be
    called with a node starting point.

    No arbitration is done for access to the list! If multiple tasks
    access the same list, an arbitration mechanism such as
    SignalSemaphores must be used.

INPUTS
    start - a list header or a list node to start the search
    (if node, this one is skipped)
    name - a pointer to a name string terminated with NULL

RESULTS
    node - a pointer to the node with the same name else
    zero to indicate that the string was not found.
@ENDNODE


@NODE Forbid() "C Excerpts Autodocs / exec.library / Forbid"
NAME
    Forbid -- forbid task rescheduling.

SYNOPSIS
    Forbid()

    void Forbid(void);

FUNCTION
    Prevents other tasks from being scheduled to run by the dispatcher,
    until a matching @{"Permit()" LINK Permit()} is executed, or this task is scheduled to
    Wait(). @{"Interrupts" LINK Chapter-4-4-13-1} are NOT disabled.

    DO NOT USE THIS CALL WITHOUT GOOD JUSTIFICATION.  THIS CALL IS
    DANGEROUS!

RESULTS
    The current task will not be rescheduled as long as it is ready to
    run.  In the event that the current task enters a wait state, other
    tasks may be scheduled.  Upon return from the wait state, the original
    task will continue to run without disturbing the Forbid().

    Calls to Forbid() nest. In order to restore normal task rescheduling,
    the programmer must execute exactly one call to @{"Permit()" LINK Permit()} for every
    call to Forbid().

WARNING
    In the event of a task entering a Wait() after a Forbid(), the system
    "breaks" the forbidden state and runs normally until the task which
    called Forbid() is rescheduled.  If caution is not taken, this can
    cause subtle bugs, since any device or DOS call will (in effect)
    cause your task to wait.

    Forbid() is not useful or safe from within interrupt code
    (All @{"interrupts" LINK Chapter-4-4-13-1} are always higher priority than tasks, and
    interrupts are allowed to break a Forbid()).

NOTE
    This call is guaranteed to preserve all registers.

SEE ALSO
    @{"Permit" LINK Permit()}, @{"Disable" LINK Disable()}, ObtainSemaphore, ObtainSemaphoreShared
@ENDNODE


@NODE "FreeMem()" "C Excerpts Autodocs / exec.library / FreeMem"
NAME
    FreeMem -- deallocate with knowledge

SYNOPSIS
    FreeMem(memoryBlock, byteSize)
            A1           D0

    void FreeMem(void *,ULONG);

FUNCTION
    Free a region of memory, returning it to the system pool from which
    it came.  Freeing partial blocks back into the system pool is
    unwise.

NOTE
    If a block of memory is freed twice, the system will Guru. The
    Alert is AN_FreeTwice ($01000009).   If you pass the wrong pointer,
    you will probably see AN_MemCorrupt $01000005.  Future versions may
    add more sanity checks to the memory lists.

INPUTS
    memoryBlock - pointer to the memory block to free
    byteSize - the size of the desired block in bytes. (The operating
    system will automatically round this number to a multiple of
    the system memory chunk size)

SEE ALSO
    @{"AllocMem" LINK AllocMem()}
@ENDNODE


@NODE OpenDevice() "C Excerpts Autodocs / exec.library / OpenDevice"
NAME
    OpenDevice -- gain access to a device

SYNOPSIS
    error = OpenDevice(devName, unitNumber, iORequest, flags)
    D0                 A0       D0          A1         D1

    BYTE OpenDevice(STRPTR,ULONG,struct IORequest *,ULONG);

FUNCTION
    This function opens the named device/unit and initializes the given
    I/O request block.  Specific documentation on opening procedures
    may come with certain devices.

    The device may exist in memory, or on disk; this is transparent to
    the OpenDevice caller.

    A full path name for the device name is legitimate.  For example
    "test:devs/fred.device".  This allows the use of custom devices
    without requiring the user to copy the device into the system's
    DEVS: directory.

NOTES
    All calls to OpenDevice should have matching calls to CloseDevice!

    Devices on disk cannot be opened until after DOS has been
    started.

    As of V36 tasks can safely call OpenDevice, though DOS may open
    system requesters (e.g., asking the user to insert the Workbench
    disk if DEVS: is not online).  You must call this function from a
    DOS Process if you want to turn off DOS requesters.

INPUTS
    devName - requested device name

    unitNumber - the unit number to open on that device.  The format of
            the unit number is device specific.  If the device does
            not have separate units, send a zero.

    iORequest - the I/O request block to be returned with
            appropriate fields initialized.

    flags - additional driver specific information.  This is sometimes
            used to request opening a device with exclusive access.

RESULTS
    error - Returns a sign-extended copy of the io_Error field
            of the IORequest.  Zero if successful, else an error code
            is returned.

BUGS
    AmigaDOS file names are not case sensitive, but Exec lists are.  If
    the library name is specified in a different case than it exists on
    disk, unexpected results may occur.

    Prior to V36, tasks could not make OpenDevice calls requiring disk
    access (since tasks are not allowed to make dos.library calls).
    Now OpenDevice is protected from tasks.

SEE ALSO
    @{"CloseDevice" LINK CloseDevice()}, @{"DoIO" LINK DoIO()}, SendIO, CheckIO, AbortIO, WaitIO
@ENDNODE


@NODE OpenResource() "C Excerpts Autodocs / exec.library / OpenResource"
NAME
    OpenResource -- gain access to a resource

SYNOPSIS
    resource = OpenResource(resName)
    D0                      A1

    APTR OpenResource(STRPTR);

FUNCTION
    This function returns a pointer to a resource that was previously
    installed into the system.

    There is no CloseResource() function.

INPUTS
   resName - the name of the resource requested.

RESULTS
    resource - if successful, a resource pointer, else NULL
@ENDNODE


@NODE Permit() "C Excerpts Autodocs / exec.library / Permit"
NAME
    Permit -- permit task rescheduling.

SYNOPSIS
    Permit()

    void Permit(void);

FUNCTION
    Allow other tasks to be scheduled to run by the dispatcher, after a
    matching @{"Forbid()" LINK Forbid()} has been executed.

RESULTS
    Other tasks will be rescheduled as they are ready to run. In order
    to restore normal task rescheduling, the programmer must execute
    exactly one call to Permit() for every call to @{"Forbid()" LINK Forbid()}.

NOTE
    This call is guaranteed to preserve all registers.

SEE ALSO
    @{"Forbid" LINK Forbid()}, @{"Disable" LINK Disable()}, @{"Enable" LINK Enable()}
@ENDNODE


@NODE Supervisor() "C Excerpts Autodocs / exec.library / Supervisor"
NAME
    Supervisor -- trap to a short supervisor mode function

SYNOPSIS
    result = Supervisor(userFunc)
    Rx                   A5

    ULONG Supervisor(void *);

FUNCTION
    Allow a normal user-mode program to execute a short assembly language
    function in the supervisor mode of the processor.  Supervisor() does
    not modify or save registers; the user function has full access to the
    register set.   All rules that apply to interrupt code must be
    followed.  In addition, no system calls are permitted.  The function
    must end with an RTE instruction.

EXAMPLE
            ;Obtain the Exception Vector base.  MC68010 or greater only!
            MOVECtrap:      MOVEC.L VBR,D0  ;$4e7a,$0801
                            RTE

INPUTS
    userFunc - A pointer to a short assembly language function ending
               in RTE.  The function has full access to the register set.

RESULTS
    result   - Whatever values the userFunc left in the registers.

SEE ALSO
    SuperState, UserState
@ENDNODE


@NODE Appendix-C-2 "C Excerpts Autodocs / battclok.resource"
@{B}C-2 battclock.resource@{UB}

    C-2-1 @{" ReadBattClock() " LINK ReadBattClock()}
@ENDNODE


@NODE ReadBattClock() "C Excerpts Autodocs / battclock.resource / ReadBattClock"
NAME
    ReadBattClock -- Read time from clock chip.  (V36)

SYNOPSIS
    AmigaTime = ReadBattClock( )

    ULONG ReadBattClock( void );
    D0

FUNCTION
    This routine reads the time from the clock chip and returns it
    as the number of seconds from 01-jan-1978.

INPUTS

RESULTS
    AmigaTime       The number of seconds from 01-Jan-1978 that
                        the clock chip thinks it is.

NOTES
    If the clock chip returns an invalid date, the clock chip is
    reset and 0 is returned.

SEE ALSO

BUGS
@ENDNODE


@NODE Appendix-D "Coder Aid / D Excerpts Amiga forums"
@{B}D Excerpts Amiga forums@{UB}

  D-1 @{" English Amiga Board " LINK Appendix-D-1}
  D-2 @{" Amiga Demoscene Archive " LINK Appendix-D-2}
@ENDNODE


@NODE Appendix-D-1 "D Excerpts Amiga forums / English Amiga Board"
@{B}D-1 English Amiga Board@{UB}

    D-1-1 @{" Undocumented Amiga hardware stuff " LINK Appendix-D-1-1}
    D-1-2 @{" Interesting AGA bitplane overrun special case " LINK Appendix-D-1-2}
@ENDNODE


@NODE Appendix-D-1-1 "D Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff"
@{B}D-1-1 Undocumented Amiga hardware stuff@{UB}

Here are some exerpts of Toni Wilen's contribution on the English Amiga
Board called @{I}Undocumented Amiga hardware stuff@{UI}.

      D-1-1-1 @{" Weird bitplane effect " LINK Appendix-D-1-1-1}
      D-1-1-2 @{" Sprite-related undocumented feature " LINK Appendix-D-1-1-2}
      D-1-1-3 @{" Horizontal sprite reuse " LINK Appendix-D-1-1-3}
      D-1-1-4 @{" Border sprites hardware bug " LINK Appendix-D-1-1-4}
@ENDNODE


@NODE Appendix-D-1-1-1 "D Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff / Weird bitplane effect"
@{B}D-1-1-1 Weird bitplane effect@{UB}

English Amiga Board > Coders > Coders. Asm / Hardware / Undocumented Amiga
hardware stuff
----------------------------------------------------------------------------
@{I}17 August 2005, 19:39

Toni Wilen
WinUAE developer
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 40
Posts: 16,569@{UI}

Weird bitplane effect used in SWIV's scoreboard.

PF2P > 5 (BPLCON2) and BITPLANES == 5 and NOT AGA

- pixel in bitplane 5 = zero: planes 1-4 work normally (any color from 0-15
  is possible)

- pixel in bitplane 5 = one: planes 1-4 are disabled, only pixel from plane
  5 is shown (color 16 is visible)
@ENDNODE


@NODE Appendix-D-1-1-2 "C Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff / Sprite-related undocumented feature"
@{B}D-1-1-2 Sprite-related undocumented feature@{UB}

English Amiga Board > Coders > Coders. Asm / Hardware / Undocumented Amiga
hardware stuff
----------------------------------------------------------------------------
@{I}11 May 2008, 10:14

Toni Wilen
WinUAE developer
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 40
Posts: 16,569@{UI}

Another interesting sprite-related undocumented feature:

Sprites are visible between DDFSTRT - End of scanline. Not DDFSTRT - DDFSTOP
as documented.

Tested with OCS and ECS Denise and A1200 (I am quite sure this is Denise's
feature)

(found while debugging Blittersweet-demo)

---------------------------------------------------------------------------
@{I}16 May 2008, 16:59

Toni Wilen is online now
Old 16 May 2008, 16:59 	  #18
Toni Wilen
WinUAE developer
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 40
Posts: 16,569@{UI}

@{I}Quote:
Originally Posted by Toni Wilen View Post@{UI}
"Sprites are visible between DDFSTRT - End of scanline. Not DDFSTRT -
DDFSTOP as documented."

This wasn't exactly right.

It is first write to BPL0DAT that also enables sprites.

Write to BPL0DAT enables bitplane shift registers inside Denise (this is
nothing new, Agnus DMA does this automatically internally). My guess is that
there is logic that outputs background color as long as BPL0DAT has not been
written to.

Test used: DDFSTRT set to 0x80, put sprite on left side of screen. It is not
visible. Use copper to write to BPL0DAT on left side of screen. Single
raster line of sprite is now visible + 16 pixels of bitplane data that was
written to BPL0DAT.

Perhaps useful for some weird tricks, not sure 
@ENDNODE


@NODE Appendix-D-1-1-3 "C Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff / Horizontal sprite reuse"
@{B}D-1-1-3 Horizontal sprite reuse@{UB}

English Amiga Board > Coders > Coders. Asm / Hardware / Undocumented Amiga
hardware stuff
----------------------------------------------------------------------------
@{I}15 March 2008, 17:50 	  #15
Toni Wilen
WinUAE developer
 
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 42
Posts: 18,909@{UI}
	
FMODE SSCAN2 bit. (This is documented but it can be easily missed and/or
misunderstood..)

HRM says "If SSCAN2 bit in FMODE is set, then disable SH10 horizontal
coincidence detect."

'Disable' means BOTH zero and one SH10 bit matches horizontal sprite
comparator = same sprite can appear TWICE (horizontally) on screen. Without
any copper tricks.

Fantastic Dizzy CD32 in Big6 compilation uses this feature to create
background tree graphics, background is created using 4 x 64 pixel attached
sprites.
@ENDNODE


@NODE Appendix-D-1-1-4 "C Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff / Border sprites hardware bug"
@{B}D-1-1-4 Border sprites hardware bug@{UB}

English Amiga Board > Coders > Coders. Asm / Hardware / Undocumented Amiga
hardware stuff
----------------------------------------------------------------------------
@{I}14 January 2017, 15:35 	  #224
Toni Wilen
WinUAE developer
 
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 42
Posts: 18,909@{UI}
	
DMA mode sprite interesting side-effect if sprite's x-starting position is
earlier than sprite's last or both DMA slots.

Sprite shift register is loaded immediately when x-coordinate matches and
sprite is armed, DATA or DATB accesses or contents won't make any difference.

This means previous line's data is shown if new DATA or DATB has not been
written. "Worst" case is when x matches between sprite's DMA slots, first
sprite plane is correct, second plane has previous data. Final side-effect
is last line appearing twice, first normally, then second time in next line.

Original report: http://eab.abime.net/showthread.php?t=85482 
@ENDNODE


@NODE Appendix-D-1-2 "C Excerpts Amiga forums / English Amiga Board / Undocumented Amiga hardware stuff / Interesting AGA bitplane overrun special case"
@{B}D-1-2 Interesting AGA bitplane overrun special case@{UB}

English Amiga Board > Coders > Coders. Asm / Hardware / Interesting AGA
bitplane overrun special case
----------------------------------------------------------------------------
@{I}24 August 2016, 21:04 	  #2
Toni Wilen
WinUAE developer
 
Join Date: Aug 2001
Location: Hmeenlinna/Finland
Age: 42
Posts: 19,057@{UI}
	
I finally connected logic analyzer to my A1200's RGA bus (maybe more signals
later if needed). It is confirmed, bitplane DMA slots really do appear at
the beginning of scanline, just after last refresh slot. It is perfect fit

R-X-R-X-R-X-R-@{FG HIGHLIGHT}BPL8-BPL4-BPL6-BPL2-BPL7-BPL3-BPL5-BPL1@{FG TEXT}

R = refresh
X = idle

Next test is to see what happens when conflicting DMA channel is also active
(for example BPL1 should conflict with first audio channel, easier to test
than disk DMA).

EDIT: Audio tested. If audio channel 0 is active, it will conflict with
BPLDAT1 and cause graphics corruption. So if this trick can even be used
for anything useful, first audio channel can't be be in DMA mode at the
same time.
@ENDNODE


@NODE Appendix-D-2 "D Excerpts Amiga forums / Amiga Demoscene Archive"
@{B}D-2 Amiga Demoscene Archive@{UB}

    D-2-1 @{" Colorswitching via BPLCON4 in HAM8-Mode " LINK Appendix-D-2-1}
@ENDNODE


@NODE Appendix-D-2-1 "D Excerpts Amiga forums / Amiga Demoscene Archive / Colorswitching via BPLCON4 in HAM8-Mode"
@{B}D-2-1 Colorswitching via BPLCON4 in HAM8-Mode@{UB}

Amiga Demoscene Archive Forum / Coding / Colorswitching via BPLCON4 in HAM8-
Mode
----------------------------------------------------------------------------
@{I}dissident
Member		
#1 - Posted: 4 Jun 2009 19:26
Reply Quote@{UI}

I tried to code a vertical screensplit with two HAM8 160x256 pixel pictures.
The first (left) one should colour 0-64 the second one colour 64-127. But
the colorswitching doesn't work. The colours 64-127 are not used. After the
switch with the value 64 the second (right) HAM8 picture uses the colours
0-63 but not in the right order.

Funnily enough the same routine works fine on a Screen with 128 colors and 7
bitplanes. The first picture uses colours 0-127 the second one colours 128-
255. So what can I do ? Or in other words is the use of colorswitching via
the bplcon4 register really possible on HAM8 screens?

----------------------------------------------------------------------------
@{I}dissident
Member
#2 - Posted: 7 Jun 2009 10:15
Reply Quote@{UI}

Completion to Colorswitching via BPLCON4 in HAM8-Mode

Meanwhile I tested the colourswitch on a HAM6 screen. It is apparent that
the content of the BPLCON4 register is totally ignored when you change it
every scanline with the copper. The second (right) picture uses exactly the
same palette (colours 0-15) as the first (left) one.

I know that HAM pixels behave different than normal pixels but strange that
it doesn't work. I thought selecting a colour value from a colour registers
by the value 00 in the modify planes works the same way as on standard
screens. Messing up the palette of the second picture on a HAM8 screen seems
to be a side effect using plane 0-1 for modify and not plane 6-7.

----------------------------------------------------------------------------
@{I}rload
Member		
#3 - Posted: 7 Jun 2009 10:33
Reply Quote@{UI}

Pity it doesn't work. Is it on a real Amiga or on WinUAE?

----------------------------------------------------------------------------
@{I}dissident
Member		
#4 - Posted: 14 Jun 2009 10:42
Reply Quote@{UI}

Hi rload,

it's on a real Amiga 1200. I haven't tested my routine on WinUAE yet.

----------------------------------------------------------------------------
@{I}winden
Member		
#5 - Posted: 22 Sep 2009 21:01 - Edited
Reply Quote@{UI}

A few quick checks:

- e-uae sourcecode confirms that both ham8 and ham6 modes ignore the xor
  value stored in bplcon4.

- minimig doesn't support aga, so there is no trace of bplcon4 
@ENDNODE


@NODE Appendix-E "Coder Aid / E Reference"
@{B}E Reference@{UB}

If you want technical information straight from the horse's mouth check
out these publications and contributions:

1989-a number composed by Rome Knight in 1989
ftp://modland.ziphoid.com/pub/modules/Protracker/Romeo%20Knight/1989-a%20number.mod

AGA doc v2.5 for AGA coders published on aminet by Randy of Comax in 2000
http://aminet.net/docs/misc/RandyAGA.lha

Amiga Hardware Reference Manual THIRD EDITION by COMMODORE-AMIGA, INC.
published by Addison-Wesley Publishing Company, Inc. in 1991
http://www.bombjack.org/amiga/amiga-books.htm

Amiga ROM Kernel Reference Manual LIBRARIES THIRD EDITION by COMMODORE-
AMIGA, INC. published by Addison-Wesley Publishing Company, Inc. in 1992
http://www.bombjack.org/amiga/amiga-books.htm

Colorswitching via BPLCON4 in HAM8-Mode is Dissident's contribution on
Amiga Demoscene Archive in 2009
http://ada.untergrund.net/?p=boardthread&id=470

Copper Orgasm by Cerberos released in 1990
http://ftp.amigascne.org/pub/amiga/Groups/C/Cerberos/CERBEROS-CopperOrgasm

COPPERrulez.AGAin by Dissident released on aminet.net in 2015
http://aminet.net/demo/aga/Copper-rulez-AGAin.lha

Desert Dream by Kefrens released on The Gathering in 1993
http://ftp.amigascne.org/pub/amiga/Groups/K/Kefrens/Kefrens-DesertDreamA.adf
http://ftp.amigascne.org/pub/amiga/Groups/K/Kefrens/KEFRENS-DesertDream-B.dms

Future Balls by Resistance released on RetroKomp LOAD ERROR 2017
http://resistance.no/releases/amiga/RSE-FutureBalls.zip

Hardware external interrupts generated by TCP/IP is dissident's contribution
on English Amiga Board in 2017
http://eab.abime.net/showthread.php?t=88694

Interesting AGA bitplane overrun special case is Toni Wilen's contribution
on English Amiga Board in 2016/2017
http://eab.abime.net/showthread.php?t=83771

Jesterday by Sanity released in 1992
http://ftp.amigascne.org/pub/amiga/Groups/S/Sanity/SANITY-Jesterday.DMS

Jim Power in Mutant Planet published by Loriciel in 1992

MC68000 8-/16-/32-Bit Microprocessors User's Manual Ninth Edition by
MOTOROLA INC. published by Freescale Semiconductor, Inc.
(www.freescale.com) in 1993
https://cache.nxp.com/docs/en/reference-manual/MC68000UM.pdf?fsrch=1&sr=2&pageNum=1

MC68020 MC68EC020 MICROPROCESSORS USER'S MANUAL First Edition by MOTOROLA
INC. published by Freescale Semiconductor, Inc. (www.freescale.com) in 1992
https://www.nxp.com/docs/en/data-sheet/MC68020UM.pdf

MOTOROLA MC68030 ENHANCED 32-BIT MICROPROCESSOR USER'S MANUAL Third
Edition by MOTOROLA INC. published by Freescale Semiconductor, Inc.
(www.freescale.com) in 1992
https://cache.nxp.com/docs/en/refere...sr=4&pageNum=1

MC68040 User's Manual Including the MC68040, MC68040V, MC68LC040,
MC68EC040 and MC68EC040V revised by MOTOROLA INC. published by
Freescale Semiconductor, Inc. (www.freescale.com) in 1992/93
https://cache.nxp.com/docs/en/reference-manual/MC68040UM.pdf?fsrch=1&sr=10&pageNum=1

MC68060 User's Manual Including the MC68060, MC68LC060, and MC68EC060
published by MOTOROLA INC. in 1994
https://cache.nxp.com/docs/en/data-s...sr=5&pageNum=1

Megademo 2 by Rebels released on the Kefrens and Dexion Party in 1990
http://ftp.amigascne.org/pub/amiga/Groups/R/Rebels/Rebels-Megademo2.dms

Megademo 7 by Kefrens relased in 1989
ftp://ftp.amigascne.org/pub/amiga/Groups/K/Kefrens/KEFRENS-MegademoVII.DMS

MSM6242B DIRECT BUS CONNECTED CMOD REAL TIME CLOCK/CALLENDAR published
by OKI Semiconductor
http://www.es.co.th/Schemetic/PDF/MSM6242B.PDF

Music Invasion by Dissident released on aminet.net in 2007
http://aminet.net/package/demo/disk/Music-Invasion_Disk1
http://aminet.net/package/demo/disk/Music-Invasion_Disk2

Sequential by Andromeda released on The Gathering in 1994
ftp://ftp.amigascne.org/pub/amiga/Groups/A/Andromeda/ANDROMEDA-Sequential.dms

SplitMOD by Dissident released on aminet.net in 2017
http://aminet.net/util/cli/SplitMOD.lha

StoneCracker V.4.10.3 by Jouni 'Mr. Spiv' Kurhonen released on aminet.net
in 1991-94
http://aminet.net/util/pack/Stc4103.lha

Undocumented Amiga hardware stuff is Toni Wilen's contribution on English
Amiga Board in 2005/2008
http://eab.abime.net/showthread.php?t=19676
@ENDNODE


@NODE Appendix-F "Coder Aid / F List of tables"
@{B}F List of tables@{UB}

  @{" RTC registers " LINK Chapter-4-4-8-1}
  @{" AllocMem() Memory options " LINK Chapter-4-4-8-2}
  @{" CACR of the MC68020 " LINK Chapter-4-4-9-4-1}
  @{" CACR of the MC68030 " LINK Chapter-4-4-9-4-2}
  @{" CACR of the MC68040 " LINK Chapter-4-4-9-4-3}
  @{" CACR of the MC68060 " LINK Chapter-4-4-9-4-4}
  @{" Attn Flags " LINK Chapter-4-4-9-5}
  @{" CacheControl() cacheBits " LINK Chapter-4-4-9-6}
  @{" Exception Vectors table " LINK Chapter-4-4-9-7}
  @{" Interrupt Priorities " LINK Chapter-4-4-13-1}
  @{" Three ocataves periods table tuning 0, normal " LINK Chapter-4-9-2-1-1}
@ENDNODE
