<html>
<head>
<title>Amiga C Kurs f&uuml;r Einsteiger</title>
<META NAME="description" CONTENT="Amiga C Kurs f&uuml;r Einsteiger">
<META NAME="keywords"    CONTENT="C, Amiga, Programmierung, Kurs, Einsteiger, StormC">
<META NAME="author"      CONTENT="Norman Walter">

<script language="JavaScript" src="JavaScript/C-Kurs_Kapitel.js" type="text/javascript">
</script>

</head>
<body bgcolor="black" link="#DDDDDD" vlink="#BBBBBB">
<center>
<TABLE>
<TD VALIGN="TOP" ALIGN="TOP" WIDTH="140">
<CENTER>
<A HREF="index.html" NAME="Home"><IMG SRC="Home.png" ALT="Home" BORDER="0"></A><BR>
<A HREF="download.html" NAME="Downloads"><IMG SRC="Download.png" ALT="Downloads" BORDER="0"></A><BR>
<A HREF="Links.html" NAME="Links"><IMG SRC="Links.png" ALT="Links" BORDER="0"></A><BR>
<a href="cgi-bin/GB_SHOW.cgi" method="POST"><img SRC="guestbook.png" BORDER=0 alt="Guestbook"></a>
<p>
<A HREF="Mailto:walternn@rupert.informatik.uni-stuttgart.de">
<IMG SRC="@.png" Border="0" Alt="e-mail"><BR><small>e-mail</small></A><BR>
<p>

<img src="C-Kurs/C-Kurs_sm.png" alt="Amiga C Kurs f&uuml;r Einsteiger" vspace="20"><BR>

<NOSCRIPT>
<font color="red">
Diese Seite ben&ouml;tigt JavaScript.
Entweder Ihr Browser unterst&uuml;tzt kein JavaScript, oder Sie haben es deaktiviert.
</font>
</NOSCRIPT>

<SCRIPT LANGUAGE="JavaScript">
<!--

  erzeuge_Kapitel();

//-->
</SCRIPT>

<p>
</CENTER>
</TD>
<TD VALIGN="TOP" ALIGN="TOP" WIDTH="400" HEIGHT="600">
<center>
<p>
<BR>
<font color="white">

<img src="C-Kurs/C-Kurs.png" alt="Amiga C Kurs f&uuml;r Einsteiger"><BR>
</center>
<p>
<font color="gray"><H2>Colortables</H2></font><BR>
<p>
Wenn wir die Farbwerte der Pens einses Screens einstellen m&ouml;chten, gibt es verschiedene
M&ouml;glichkeiten. Eine davon ist, die <a href="C-Kurs_8_5.html">RGB Werte</a> der einzelnen Pens in ein bestimmtes
Array - eine sogenannte Colortable - zu schreiben. Dieses wird dann beim Öffnen des
Screens in einem speziellen TagItem an die Funktion <TT>OpenScreenTags</TT> &uuml;bergeben.
Die Pens des neuen Screens sind dann automatisch auf die im Colortable angegebenen
Farbwerte eingestellt.
<p>
Man kann die <a href="C-Kurs_8_5.html">RGB Komponenten</a> der Farben entweder als 4 Bit oder 32 Bit Werte angeben.
In dieser Lektion sollen 32 Bit Werte verwendet werden.
<p>
Hier ein Beispiel f&uuml;r eine typische Colormap:
<p>
<center>
<TABLE border="0" cellpadding="5" cellspacing="0" bgcolor="lightgrey">
<TR>
<TD>
<pre>
   /* Die Farbtabelle ist ein Array */
   ULONG colortable[] =
   {
      16L&lt;&lt;16+0,    // 16 Farben

      0x00000000, 0x00000000, 0x00000000,   // Schwarz
      0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,   // Grau
      0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,   // Wei&szlig;
      0x66666666, 0x88888888, 0xBBBBBBBB,   // Blau-Grau
      0x00000000, 0xFFFFFFFF, 0xFFFFFFFF,   // T&uuml;rkis
      0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
      0xFFFFFFFF, 0x00000000, 0x00000000,
      0x00000000, 0xFFFFFFFF, 0x00000000,
      0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,
      0xAAAAAAAA, 0x55555555, 0x00000000,
      0xEEEEEEEE, 0x77777777, 0x44444444,
      0x44444444, 0x55555555, 0xAAAAAAAA,
      0x77777777, 0x44444444, 0xFFFFFFFF,
      0xEEEEEEEE, 0x11111111, 0x66666666,
      0x11111111, 0x99999999, 0x33333333,
      0x33333333, 0xAAAAAAAA, 0x66666666,

      0x00000000,   /* Terminator */
   };

</pre>
</TD>
</TR>
</TABLE>

</center>

<BR>
<p>
Eine Colortable ist ein Array vom Typ <TT>ULONG</TT> (ein <a href="C-Kurs_3_2.html">Synonym</a> f&uuml;r <a href="C-Kurs_Datentypen.html">unsigned long</a>).
Der erste Eintrag enth&auml;lt die Anzahl der angegebenen Farbwerte.
Dann folgen die Eintr&auml;ge f&uuml;r die Farbwerte der einzelnen Pens, beginnend mit Pen 0.
F&uuml;r jeden Pen werden drei 32 Bit Werte angegeben: <a href="C-Kurs_8_5.html">Die Rot- Gr&uuml;n- und Blaukomponente</a>
der gew&uuml;nschten Farbe. Der letzte Eintrag in einer Colortable ist der sogenannte Terminator
- ein Eintrag mit dem Wert 0, der das Ende der Tabelle markiert.
<p>
Um dem neuen Screen beim &Ouml;ffnen unsere Colortable mitzugeben, benutzen wir das TagItem
<TT>SA_Colors32, colortable</TT>. <TT>colortable</TT> ist dabei der Name
der zuvor festgelegten Colortable.
<p>
<center>
<TABLE border="0" cellpadding="5" cellspacing="0" bgcolor="lightgrey">
<TR>
<TD>
<pre>
     /* &Ouml;ffne neuen Screen */
     Bildschirm = OpenScreenTags(NULL,
                                 SA_LikeWorkbench, TRUE,   // Soll wie WB Screen sein
                                 SA_Colors32, colortable,  // Farben aus colortable &uuml;bernehmen
                                 TAG_DONE);

</pre>
</TD>
</TR>
</TABLE>

</center>

<BR>
<p>

Das folgende Beispielprogramm &ouml;ffnet einen Screen mit einem rahmenlosen, bildschirmf&uuml;llenden
Fenster. Das TagItem <TT>WA_RMBTrap, TRUE</TT> verhindert, da&szlig; die Men&uuml;leiste des Screens
erscheint, wenn der Benutzer den rechten Mausknopf dr&uuml;ckt. Der Screen ist dabei ein Klon des Workbench Screens.
Die Farben f&uuml;r die Pens werden aus der Colortable &uuml;bernommen.
Es wird eine farbenfrohe Spirale gezeichnet. Damit wir dabei zusehen k&ouml;nnen,
ist in der Funktion <TT>ZeichneSpirale</TT> eine kleine Zeitverz&ouml;gerung eingebaut.
<p>
<center>
<img src="C-Kurs/Spirale.png" alt="Spirale"><BR>
</center>
<p>
<center>
<TABLE border="0" cellpadding="5" cellspacing="0" bgcolor="lightgrey">
<TR>
<TD>
<pre>
/*
 *  Beispielprogramm f&uuml;r Colortables:
 *  Eine farbenfrohe Spirale.
 *
 */

#include &lt;exec/types.h&gt;
#include &lt;intuition/intuition.h&gt;
#include &lt;graphics/gfx.h&gt;

#include &lt;proto/intuition.h&gt;
#include &lt;proto/graphics.h&gt;
#include &lt;proto/dos.h&gt;
#include &lt;proto/exec.h&gt;

/* Includes aus der Lektion "Polarkoordinaten" */
#include "Polar.h"
#include "Polar.c"

struct IntuitionBase  *IntuitionBase = NULL;
struct GfxBase        *GfxBase = NULL;
struct Screen         *Bildschirm = NULL;           // Zeiger auf Screen Struktur
struct Window         *Fenster = NULL;
struct RastPort       *rp;

/* Makros */
#define Box(rp,x,y,r) RectFill(rp,x-r,y-r,x+r,y+r)  // Zeichnet ein Quadrat
#define MIN(a,b) ((a &lt; b) ? a : b)               // Minimum von a,b

void ZeichneSpirale(struct RastPort *rp, double r, int xc, int yc);

int main(void)
{
   int width,height;
   double max_r;

   /* Die Farbtabelle ist ein Array */
   ULONG colortable[] =
   {
      16L&lt;&lt;16+0,    // 16 Farben

      0x00000000, 0x00000000, 0x00000000,   // Schwarz
      0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,   // Grau
      0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,   // Wei&szlig;
      0x66666666, 0x88888888, 0xBBBBBBBB,   // Blau-Grau
      0x00000000, 0xFFFFFFFF, 0xFFFFFFFF,   // T&uuml;rkis
      0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
      0xFFFFFFFF, 0x00000000, 0x00000000,
      0x00000000, 0xFFFFFFFF, 0x00000000,
      0xFFFFFFFF, 0x00000000, 0xFFFFFFFF,
      0xAAAAAAAA, 0x55555555, 0x00000000,
      0xEEEEEEEE, 0x77777777, 0x44444444,
      0x44444444, 0x55555555, 0xAAAAAAAA,
      0x77777777, 0x44444444, 0xFFFFFFFF,
      0xEEEEEEEE, 0x11111111, 0x66666666,
      0x11111111, 0x99999999, 0x33333333,
      0x33333333, 0xAAAAAAAA, 0x66666666,

      0x00000000,   /* Terminator */
   };

   // &Ouml;ffne Intuition Library
    IntuitionBase = (struct IntuitionBase *) OpenLibrary("intuition.library", 37L);
   GfxBase = (struct GfxBase *) OpenLibrary("graphics.library", 37L);

   if (IntuitionBase != NULL)
   {
     /* &Ouml;ffne neuen Screen */
     Bildschirm = OpenScreenTags(NULL,
                                 SA_LikeWorkbench, TRUE,   // Soll wie WB Screen sein
                                 SA_Colors32, colortable,  // Farben aus colortable &uuml;bernehmen
                                 TAG_DONE);

     if (Bildschirm != NULL)
     {
       /*  Wir &ouml;ffnen ein rahmenloses Fenster, welches den gesammten
        *  Screen ausf&uuml;llt
        */

       /* H&ouml;he und Breite vom Screen */
       width = Bildschirm-&gt;Width;
       height = Bildschirm-&gt;Height;

       Fenster = OpenWindowTags(NULL,
                                WA_Width, width,
                                WA_Height, height,
                                WA_Borderless, TRUE,          // Rahmenlos
                                WA_CustomScreen, Bildschirm,  // Auf welchen Screen?
                                WA_RMBTrap, TRUE,             // Rechten Maus Knopf abfangen
                                WA_Activate, TRUE,
                                TAG_DONE);

       rp = Fenster-&gt;RPort;

       /* Maximalen Radius f&uuml;r Spirale ermitteln */
       max_r = (double)MIN(width/2,height/2);

       SetRast(rp,0L);
       /* Mauszeiger auf busy setzen */
       SetWindowPointer(Fenster,WA_BusyPointer,TRUE,TAG_DONE);
       /* Grafik zeichnen */
       ZeichneSpirale(rp,max_r, width/2, height/2);
       /* Normaler Mauszeiger */
       SetWindowPointer(Fenster,TAG_DONE);

     } // end if

     Delay(250);               // Warte 5 Sekunden

     if (Fenster != NULL) CloseWindow(Fenster);

     if (Bildschirm != NULL)   // Falls der Screen ge&ouml;ffnet werden konnte...
     CloseScreen(Bildschirm);  // Schlie&szlig;e Screen

   } // end if

   if (GfxBase != NULL) CloseLibrary((struct Library *) GfxBase);
   if (IntuitionBase != NULL) CloseLibrary((struct Library *) IntuitionBase);

   return 0;
}

/*  Die Funktion ZeichneSpirale zeichnet eine Spirale um den Punkt
 *  mit den Koordinaten xc/yc und dem maximalen Radius rmax in
 *  den RastPort rp.
 */
void ZeichneSpirale(struct RastPort *rp, double rmax, int xc, int yc)
{
   double r,phi,xd,yd,alpha;
   int x,y;
   LONG p,z;  // Variablen f&uuml;r den Pen
   p=0;
   z=0;
   r=1.0;     // Startwert f&uuml;r den Radius
   phi=0.0;   // Winkel
   alpha=2.0; // Schrittweite f&uuml;r den Winkel

   /* Schleife zum Zeichnen der Spirale */
   for (phi=0.0;r&lt;=rmax;phi+=alpha)
   {
      /* Polarkoordinaten in kartesische Koordinaten umrechnen */
      PolarKart(r,DEG2RAD(phi),xd,yd);
      x=(int)xd+xc;
      y=(int)yd+yc;
      r+=0.25;       // Radius vergr&ouml;&szlig;ern
      z++;           // Z&auml;hler f&uuml;r den Pen erh&ouml;hen
      p=z%15;        // Pen zwischen 0 und 15 ausw&auml;hlen
      SetAPen(rp,p); // Pen ausw&auml;hlen
      Box(rp,x,y,5); // Quadrat zeichnen
      Delay(1);      // kurze Verz&ouml;gerung
   }

}

</pre>
</TD>
</TR>
</TABLE>

</center>

<BR>
<p>
Beim Zeichnen der Spirale wird zur Umrechnung von <a href="C-Kurs_8_4.html">Polarkoordinaten</a>
in kartesische Koordinaten die Funktion <TT>PolarKart</TT> aus <TT>Polar.c</TT> verwendet.
Deshalb m&uuml;ssen die beiden Includes <TT>Polar.h</TT> und <TT>Polar.c</TT>
aus der Lektion <a href="C-Kurs_8_4.html">Polarkoordinaten</a> mit eingebunden werden.
Beide Dateien m&uuml;ssen im selben Verzeichnis wie der Quellcode des Programms sein.
<p>
In der Funktion <TT>ZeichneSpirale</TT> wird in jedem Schleifendurchlauf der
<a href="C-Kurs_1_7.html"><TT>for</TT> Schleife</a> ein neuer Pen ausgew&auml;hlt.
Dazu bedienen wir uns folgendem Trick: Die Variable <TT>z</TT> wird in jedem Schleifendurchlauf
um 1 hochgez&auml;hlt. Durch die <a href="C-Kurs_1_4.html">Modulo</a> Rechnung <TT>p=z%15</TT> wird sichergestellt, da&szlig;
die Zahl im Bereich unserer Colormap bleibt, d.h. die <a href="C-Kurs_1_2.html">Variable</a> <TT>p</TT> Werte
im Bereich von 0 bis 15 annimmt. Das funktioniert, weil eine beliebige nat&uuml;rliche
Zahl <a href="C-Kurs_1_4.html">Modulo</a> 15 immer in sogenannten Restklassen landet. Das bedeutet, da&szlig; wenn wir
eine nat&uuml;rliche Zahl durch 15 teilen, immer ein ganzzahliger Rest von mindestens 0 bis maximal 15
&uuml;brigbleibt.
<p>
Wer genau hinschaut, wird sehen, da&szlig; in diesem Beispiel auch die L&ouml;sung zu
<a href="C-Kurs_8_3.html">&Uuml;bung 8.2</a> versteckt ist.
<p>
</font>
</center>
</TD>

</TABLE>

</body>
</html>
