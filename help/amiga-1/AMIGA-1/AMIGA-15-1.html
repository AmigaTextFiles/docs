        <html>
        <head><base target="_self">
<title>русский транзит - amiga#1: arexx, функции сравнения</title>
</head>
<body link="#009999" vlink="#006666" alink="#000088" bgcolor="#ffffff" text="#000000">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="keywords" content="amiga,develope,ARexx,сравнение,abbrev,compare,find,index,lastpos,pos,verify">

<font face="Verdana, Arial size=2">
<p align="left"><a name=A15>Глава 15</a></p></font>
<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><b>Функции</b></p></font>

<blockquote><p align="justify">
В этой главе рассказывается о встроенных функциях ARexx-a, а также о функциях библиотеки rexxsupport.library. Следует отметить, что уже написана и продолжает создаваться масса системных библиотек ARexx-a. Как правило, эти библиотеки являются связующим звеном между ARexx-программами и библиотеками Амиги, поскольку в амиговских библиотеках есть абсолютно все, что может потребоваться в работе, надо только достучаться до их функций из ARexx-a. Например, библиотека rexxarplib.library позволяет легко создавать мощнейшие графические интерфейсы для прикладных программ, rexxreqtools.library позволяет пользоваться знаменитой риквестерной библиотекой reqtools.library ((c) Нико Фрэнсис); apig.library ((c) Ронни Келли) позволяет без ограничений пользоваться функциями бездонных амиговских библиотек intuition.library и graphics.library. На настоящий момент существует более дюжины внешних библиотек ARexx-a, каждая из которых является просто кладезью ценных функций для ARexx-a, и список этот непрерывно пополняется.
</p></blockquote>

<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><a name=A151>Функции сравнения</a></p></font>

<blockquote><p align="justify">
Помимо приведенных ниже, к функциям сравнения можно отнести функции побитовых манипуляций <a href="AMIGA-15-12.html#A15124">ВIТСОМР()</a> и <a href="AMIGA-15-12.html#A15127">BITTST()</a>, а также общеязыковую функцию <a href="AMIGA-15-9.html#A1594">DATATYPE()</a>. Все строковые функции сравнения/поиска учитывают регистр букв.
</p></blockquote>


<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1511>
<b>ABBREV</b>()
<blockquote>bool = <b>ABBRЕV</b>(&#60;длинная_строка&#62;,&#60;короткая_строка&#62;[,&#60;длина&#62;])
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Возвращает значение &quot;ИСТИНА&quot; (1), если &quot;короткая_строка&quot; совпадает с начальной частью &quot;длинной_строки&quot;. Если присутствует параметр &quot;длина&quot;, то &quot;короткая_строка&quot; должна иметь длину не меньшую, чем указано. Если длина не указана, а &quot;короткая_строка&quot; является пустой строкой, то функция даст совпадение строк. Примеры:
</p></blockquote>

<blockquote><blockquote><pre>
say ABBREV('пароход', 'пар')      ==> 1
say ABBREV('пароход', 'Пар')      ==> 0
say ABBREV('пароход', 'пар', 3)   ==> 1
say ABBREV('пароход', 'пар', 4)   ==> 0
say ABBREV('пароход', '')         ==> 1
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1512>
<b>COMPARE</b>()
<blockquote>pos = <b>COMPARE</b>(&#60;строка_1&#62;,&#60;строка_2&#62;[,&#60;наполнитель&#62;])
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Возвращает 0, если &quot;строка_1&quot; идентична &quot;строке_2&quot;. В противном случае возвращается номер позиции 1-го несовпавшего символа (нумерация идет с единицы). Если одна из строк короче другой, то короткая дополняется с конца символом-наполнителем (по умолчанию наполнитель - пробел). Примеры:
</p></blockquote>

<blockquote><blockquote><pre>
say COMPARE('123', '123')           ==> 0
say COMPARE('132', '123')           ==> 0
say COMPARE('123', '123 ')          ==> 2
say COMPARE{'123', '123...', '.')   ==> 0
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1513>
<b>FIND</b>()
<blockquote>pos = <b>FIND</b>(&#60;строка&#62;,&#60;слово&#62;)
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Ищет зажатое между пробелами &quot;слово&quot; в исходной &quot;строке&quot;. Возвращается номер первого совпавшего слова в строке, или 0, если совпадений нет. Пример:
</p></blockquote>

<blockquote><blockquote><pre>
say  FIND('Что может быть лучше Амиги?', 'лучше')  ==> 4
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1514>
<b>INDEX</b>()
<blockquote>pos = <b>INDEX</b>(&#60;строка&#62;,&#60;подстрока&#62;[,&#60;старт&#62;])
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Ищет заданную подстроку в строке. Если поиск успешный, возвращается позиция первого символа подстроки в строке, иначе возвращается ноль. Поиск может начинаться не с первого символа строки, а с указанного параметром &quot;старт&quot;. Пример:
</p></blockquote>

<blockquote><blockquote><pre>
pos = INDEX('Лень учить Си?
             Работайте на ARexx-e!', 'Раб')  ==> 16
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1515>
<b>LASTPOS</b>()
<blockquote>pos = <b>LASTPOS</b>(&#60;подстрока&#62;,&#60;строка&#62;[,&#60;старт&#62;])
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Ищет заданную подстроку в строке. Поиск происходит от конца строки к ее началу. Если поиск успешный, возвращается позиция первого символа подстроки в строке, иначе возвращается ноль. Поиск может начинаться не с последнего символа строки, а с указанного параметром &quot;старт&quot; (отсчет для параметра &quot;старт&quot; происходит с конца строки). Пример:
</p></blockquote>

<blockquote><blockquote><pre>
pos  = LASTPOS('колпак', 'Сшит колпак,
                         да не по-колпаковски')  ==> 23
</pre></blockquote></blockquote>
 
<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1516>
<b>POS</b>()
</a></pre></font></blockquote>

<blockquote><p align="justify">
То же, что и <a href="AMIGA-15-1.html#A1514">INDEX()</a>. Использование POS() предпочтительнее, поскольку функция INDEX() изъята из формального стандарта языка Rexx (TRL2), хотя ARexx поддерживает обе функции.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1517>
<b>VERIFY</b>()
<blockquote>pos = <b>VERIFY</b>(&#60;строка&#62;,&#60;список&#62;[,'Match'][,&#60;старт&#62;])
</blockquote></a></pre></font></blockquote>

<blockquote><p align="justify">
Поиск в указанной строке любой из литер, присутствующих в &quot;списке&quot;. Если в параметрах для VERIFY() отсутствует ключевое слово &quot;Match&quot;, то функция вернет ноль в том случае, если все имеющиеся в строке литеры также имеются и в &quot;списке&quot; - строке, содержащей искомые литеры в произвольном порядке. Если же какая-либо из литер строки в &quot;списке&quot; отсутствует, то будет возвращен номер ее позиции в строке (сканирование строки происходит от начала к концу).
</p></blockquote>

<blockquote><p align="justify">
Наличие параметра &quot;М&quot; (или Match) изменит логику работы функции VERIFY(). Теперь в случае совпадения одной из литер строки с любой литерой &quot;списка&quot;, будет возвращена позиция этой литеры в строке. Ноль будет возвращен, если ни одной литеры из &quot;списка&quot; в строке нет.
</p></blockquote>

<blockquote><p align="justify">
Поиск может начинаться не с первого символа строки, а с указанного параметром &quot;старт&quot;. Примеры:
</p></blockquote>

<blockquote><blockquote><pre>
pos = VERIFY('123456789', '736')       ==> 1
pos = VERIFY('123456789', '736', 'М')  ==> 3
</pre></blockquote></blockquote>

<hr>

</body></html>