        <html>
        <head><base target="_self">
<title>русский транзит - amiga#1: cli (shell) интерфейс</title>
</head>
<body link="#009999" vlink="#006666" alink="#000088" bgcolor="#ffffff" text="#000000">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="keywords" content="amiga, амига, pc, commodore, amiga#1, unix, linux, shell, cli, 
интерфейс, voice, голос, проговорить, говорилка, speak, workbench, shell-startup, kickstrart, 
шаблон, маска, образец, образцы, перенаправление, ввод, вывод, ввод/вывод, история, команда,
командная, строка, подсказка, помощь, клавиатура, directory, opus, directoryopus, терминал,
терминальный, консоль, консольный, console, terminal, файл, директория, каталог, аргумент,
argument, параметр, parameter, проговаривание, произнесение, речь, поиск, переключатель,
ключевое, слово, ключ, всегда, обязательный, синоним, число, последний, регулярное, выражение,
regular, expression, amigaos, amigados, msdos, ms-dos, pcdos, pc-dos, microsoft">

<table width="95%"><tr>
<td valign="top"><font face="Verdana, Arial size=2">
<p align="left">Глава 9</p></font>
<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><b>CLI (Shell) интерфейс</b></p></font></td>
<td align="right"><img src="Gfx/AMIGA-9.gif" width="150" height="170"></td>
</tr></table>

<blockquote><p align="justify">
Shell, появившийся в версии ОС 1.3, есть не что иное, как улучшенный вариант CLI. Начиная со второй версии ОС, между CLI и Shell нет никакой разницы, т.к. 
CLI приобрел все Shell-возможности.
</p></blockquote><blockquote><p align="justify">
Для того, чтобы перейти в CLI из Workbench, необходимо дважды щёлкнуть по иконке &quot;Shell&quot; каталога System (либо по иконке &quot;CLI&quot; того же каталога 
при версии Kickstart < 2.0). В открывшемся окне вы увидите Shell-подсказку, которая, как правило состоит из номера Shell-процесса и текущего маршрута. Теперь вы можете 
вводить команды ОС с клавиатуры.
</p></blockquote><blockquote><p align="justify">
Shell-окна запоминают все введенные в них строки в т.н. &quot;буфере истории&quot;. Нет необходимости вводить какие-либо строки повторно, достаточно воспользоваться курсорными 
клавишами &quot;курсор вверх/вниз&quot; для перелистывания содержимого этого буфера. Комбинации клавиш &quot;Shift&nbsp;+&nbsp;курсор влево/вправо&quot; переместят курсор в 
начало/конец вводимой строки.
</p></blockquote><blockquote><p align="justify">
Перед каждым запуском Shell автоматически исполняется файл &quot;S:Shell-Startup&quot;, который настраивает различные параметры Shell.
</p></blockquote>

<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><a name=A91>Перенаправление ввода/вывода</a></p></font>
<blockquote><p align="justify">
При нахождении в Shell, ОС по умолчанию производит ввод символов с клавиатуры, а вывод &mdash; в текущее Shell-окно. 
Иногда возникает необходимость изменить обычное направление ввода/вывода; направить, например, поток вывода на принтер, чтобы напечатать содержимое каталога, либо попросить 
Амигу прочитать голосом какой-нибудь файл. Здесь на помощь приходят символы &quot;&lt;&quot; и &quot;&gt;&quot;, которые могут быть использованы для того, чтобы перенаправить 
ввод и вывод соответственно. Эти символы имеют локальное действие т.е., работают в пределах только одной команды. Например, введя:
</p></blockquote><blockquote><blockquote><pre>
type S:User-Startup >SPEAK:
</pre></blockquote></blockquote><blockquote><p align="justify">
мы заставим Амигу прочитать голосом весь файл &quot;S:User-Startup&quot;. Здесь мы использовали &quot;говорилку&quot; Амиги в качестве устройства вывода, где &quot;распечатали&quot; 
нужный нам файл.
</p></blockquote><blockquote><p align="justify">
Shell, начиная с версии ОС 1.3 имеет ещё одну возможность по переназначению потока вывода. С помощью комбинации символов &quot;&gt;&gt;&quot; 
можно добавить то, что будет выведено, к уже имеющемуся файлу. Например, если у нас есть файл названием &quot;Каталоги&quot;, то после выполнения команды:
</p></blockquote><blockquote><blockquote><pre>
dir >>Каталоги RAM:
</pre></blockquote></blockquote><blockquote><p align="justify">
к содержимому файла "Каталоги" будет добавлен каталог RAM-диска.
</p></blockquote><blockquote><p align="justify">
Следует учесть, что если файл, к которому планируется &quot;присоединить&quot; некоторую информацию ещё не создан, то ОС 1.3 выдаст сообщение об ошибке, а более поздние версии ОС вначале 
создадут &quot;пустой&quot; файл, а затем добавят к нему то, что &quot;выдал&quot; Shell, что гораздо более логично.
</p></blockquote><blockquote><p align="justify">
Символ &quot;*&quot;. указанный в качестве имени устройства ввода/вывода означает не что иное, как текущее консольное (т.е. CLI- или Shell-окно). Подобное применение символа 
&quot;*&quot; чрезвычайно удобно, поскольку позволяет трактовать консольные окна, как файлы, из которых можно читать и в которые можно производить запись.
</p></blockquote><blockquote><p align="justify">
Пример использования: рассортировать файл &quot;RAМ:Имена&quot; и вывести результат в текущее Shell-окно:
</p></blockquote><blockquote><blockquote><pre>
sort RAM:Имена ТО *
</pre></blockquote></blockquote><blockquote><p align="justify">
или ещё пример:
</p></blockquote><blockquote><blockquote><pre>
copy * TO PRT:
</pre></blockquote></blockquote><blockquote><p align="justify">
теперь всё, что мы набираем на клавиатуре будет немедленно распечатываться на принтере до тех пор, пока мы не нажмем комбинацию клавиш &quot;CTRL&nbsp;+&nbsp;\&quot;, что 
означает EOF (End Of File &mdash; конец файла).
</p></blockquote><blockquote><p align="justify">
Символ &quot;+&quot; позволяет вводить команду, занимающую несколько строк: достаточно поставить &quot;+&quot; в конце строки и можно продолжить ввод команды с новой строки 
(нажав, разумеется, &quot;Enter&quot; после &quot;+&quot;).
</p></blockquote>

<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><a name=A92>Образцы (подсказка)</a></p></font>
</p></blockquote><blockquote><p align="justify">
Вряд ли кто-нибудь даже из самых опытных пользователей Амиг будет в состоянии запомнить все возможные комбинации аргументов Shell-команд. 
Здесь приходит на помощь встроенная во все стандартные команды ОС палочка-выручалочка: наберите имя команды, а после него &mdash; отделённый пробелом вопросительный знак. 
ОС немедленно покажет вам то, что называется образцом аргументов команды. Образец является по сути некоей аббревиатурой того, какие аргументы допустимы либо обязательно требуются 
для исследуемой команды. После вывода образца ОС терпеливо ждет, пока вы творчески осмыслите увиденное и введёте именно те аргументы, которые ею могут быть поняты (само имя команды 
повторно вводить не требуется). Если вы решите не вводить никаких параметров, то просто нажмите клавишу &quot;Ввод&quot; и команда будет исполнена безо всяких аргументов. 
Проверим, что получится если набрать:
</p></blockquote><blockquote><blockquote><pre>
dir ?
</pre></blockquote></blockquote><blockquote><p align="justify">
ОС тут же выведет подсказку:
</p></blockquote><blockquote><blockquote><pre>
DIR,ОРТ/К,ALL/S,DIRS/S,FILES/S,INTER/S:
</pre></blockquote></blockquote><blockquote><p align="justify">
Мы сразу видим, что в командных образцах аргументы разделяются запятыми. Каждый из аргументов может состоять из одной или двух частей, разделенных символом &quot;/&quot;. 
Первой частью аргумента может являться либо имя аргумента, либо некоторое ключевое слово, ассоциированное с аргументом. Если первая часть аргумента &mdash; ключевое слово, 
то за ней может следовать идентификатор аргумента (/А, /К, /S, /N, /M, /F), который уточняет, что именно представляет собой сам аргумент. Когда вы хотите ввести команду ОС, 
ключевые слова должны быть набраны в точности так, как показано в образце (разумеется, только в том случае, если в них есть необходимость, что зависит как от конкретной команды, 
так и от того, какой результат вы желаете получить). А теперь расшифруем значения различных идентификаторов аргументов:
</pre></blockquote></blockquote><blockquote><p align="justify">
/А &mdash; (от слова <em>always</em> &mdash; всегда); этот аргумент должен всегда присутствовать для данной команды ОС, иначе выдается сообщение об ошибке. <br>
Например:
</p></blockquote><blockquote><blockquote><pre>
diskchange ?
DEVICE/A: DF0: &mdash; имя диска должно быть указано.
</pre></blockquote></blockquote><blockquote><p align="justify">
/К &mdash; (от слова <em>keyword</em> &mdash; ключевое слово); необязательное ключевое слово. После ключевого слова должна следовать дополнительная информация, которая будет 
использована при исполнении команды. Ключевое слово может иметь не один, а несколько идентификаторов &mdash; например, FROM/К/А.
</p></blockquote><blockquote><p align="justify">
/S &mdash; (от слова <em>switch</em> &mdash; переключатель); если аргумент присутствует, то некоторая функция соответствующей команды ОС считается включённой, иначе &mdash; выключенной.
</p></blockquote><blockquote><p align="justify">
= &mdash; сообщает о том, что для ключевого слова, находящегося слева от &quot;=&quot; есть синоним, который находится справа от &quot;=&quot;. Какой из синонимов выбрать, абсолютно 
безразлично. Один из синонимов обычно короче, а другой &mdash; понятнее.
</p></blockquote><blockquote><blockquote><p align="justify">
Приведенные ниже идентификаторы &quot;работают&quot;, начиная со второй версии ОС.
</p></blockquote></blockquote><blockquote><p align="justify">
/М &mdash; (от слова <em>multiply</em> &mdash; несколько); аргументов может быть несколько. В ранних версиях на множественные аргументы указывала серия запятых. Если аргументу 
соответствуют несколько идентификаторов (например, /М/А), то идентификатор /М должен быть первым по счёту.
</p></blockquote><blockquote><p align="justify">
/N &mdash; (от слова <em>number</em> &mdash; число); аргумент должен быть числом.
</p></blockquote><blockquote><p align="justify">
/F &mdash; (от слова <em>final</em> &mdash; последний); введённый аргумент-строка должен быть самым последним среди всех имеющихся. 
Строка может содержать произвольное число пробелов.
</p></blockquote><blockquote><blockquote><p align="justify">
Если аргументы для заданной команды введены неправильно, то ОС выдаст сообщение об ошибке &quot;Отсутствует обязательный параметр&quot;, 
либо &quot;Неверное число параметров&quot;.
</p></blockquote></blockquote>

<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><a name=A93>Шаблоны (маски)</a></p></font>
</p></blockquote><blockquote><p align="justify">
Некоторые команды ОС позволяют ссылаться на несколько файлов сразу; для этого используются т.н. шаблоны имён. Используя шаблоны, вы, например, 
можете разом скопировать все файлы с расширением &quot;.txt&quot; или удалить их. Те, кто работал в MS-DOS, наверное, сразу вспомнили про символы 
&quot;*&quot; и &quot;?&quot;, но в Амиге дела обстоят несколько по-другому. Если в MS-DOS звездочка используется для замены произвольной строки, 
то в Амиге &mdash; это идентификатор начала командной последовательности, который позволяет вставлять другие идентифицирующие символы (в т.ч. 
такие же звездочки) после него. Кроме того, звездочка может являться идентификатором текущего консольного (т.е. CLI или Shell) окна. 
В версии Kickstart 2.0 или выше, можно заставить звездочку работать точно так же, как в MS-DOS, однако, сделать это можно только из некоторой 
прикладной программы (например, StartClick). Если уж дальше продолжать сравнение ОС Амиги (AmigaOS) и MS-DOS, то следует упомянуть, что число 
команд MS-DOS, позволяющих использовать шаблоны, превышает число аналогичных команд ОС Амиги. Зато шаблоны Амиги куда более мощные, нежели 
применяемые в MS-DOS. К примеру, можно &mdash;поймать&mdash; строки по таким признакам, как группа определённых символов где-нибудь в середине 
строки (неважно, сколько символов предшествуют искомой подстроке и сколько следуют за ней), искать символы по произвольным группам в начале и 
конце и т.д. По сути, шаблоны (маски) в AmigaOS представляют собой мощный и развитый механизм описания регулярных выражений.
</p></blockquote><blockquote><p align="justify">
Рассмотрим подробнее все эти возможности (напомним, что имена файлов в ОС Амиги могут содержать до 31-го символа (ограничение &quot;штатной&quot; 
файловой системы FFS в AmigaOS 1.3&hellip;3.1), иметь любое число расширений любой длины и содержать какие угодно знаки, например, быть полностью русскими).
</p></blockquote><blockquote><p align="justify">
Важнейшими символами шаблонов являются &quot;#&quot; (решётка) и &quot;?&quot;. 
Комбинация решётки с каким-либо символом означает, что этот символ может повторяться любое число раз, либо отсутствовать вовсе. 
Пример: шаблон <b>#Отчёт</b> даст совпадения для: <b>Отчёт</b>, <b>ОООООтчёт</b> и <b>тчёт</b>.
</p></blockquote><blockquote><p align="justify">
Вопросительный знак может заменить любой символ (но не отсутствие символа). Пример: шаблон <b>Мас?а</b> даст совпадения для: <b>Масса</b> и <b>Маска</b>.
</p></blockquote><blockquote><p align="justify">
Комбинация #? по сути то же, что звездочка в MS-DOS &mdash; ей может соответствовать произвольная строка символов. 
Например, <b>#?</b> выберет все файлы текущего каталога, а <b>Доклад#?</b> &mdash; все файлы, начинающиеся со слова 
&quot;Доклад&quot; т.е. &quot;<b>Доклад 1</b>&quot;, &quot;<b>Докладная.текст</b>&quot; и т.д.
</p></blockquote><blockquote><p align="justify">
Кроме символов решётки и вопросительного знака, в ОС Амиги имеются ещё несколько менее употребительных символов.
</p></blockquote><blockquote><p align="justify">
С помощью пары круглых скобок () вы может сгруппировать любое число символов в группу, которая будет считаться элементом поиска. 
Если теперь после решётки будет следовать группа символов, заключённая в круглые скобки, то ей может соответствовать любое число повторений 
этой группы в искомой строке (включая ни одного повторения). Например, шаблон <b>#(по)лзти</b> даст совпадения для: <b>поползти</b>, <b>ползти</b> и <b>лзти</b>.
</p></blockquote><blockquote><p align="justify">
Вертикальная черта &quot;|&quot; может трактоваться как слово &quot;или&quot;, т.е. совпадение возможно либо с символом (группой символов) слева от черты, либо с символом (группой символов) 
справа от черты. Например, шаблон <b>п(а|о)года</b> даст совпадения для: <b>погода</b> и <b>пагода</b>.
</p></blockquote><blockquote><p align="justify">
Шаблон же <b>(ДА|НЕТ)</b> даст совпадения для: <b>ДА</b> и <b>НЕТ</b>.
</p></blockquote><blockquote><p align="justify">
Знак % обозначает пустую строку (отсутствие символов). 
Его удобно применять в тех случаях, когда # не обеспечивает должной гибкости поиска, поскольку иногда может потребоваться найти либо единственное вхождение требуемого символа 
в строке, либо его отсутствие. Пример: шаблон <b>в(о|%) поле</b> даст совпадения со строками: <b>в поле</b> и <b>во поле</b>. 
Совпадения же со строкой &quot;воо поле&quot;, которое произошло бы в случае использования шаблона <b>в#о поле</b>, уже не произойдет.
</p></blockquote><blockquote><p align="justify">
Комбинация (?|%) сработает как на любой символ, так и на его отсутствие. Пример: <b>(?|%)е?а</b> даст совпадение на: <b>беда</b> и <b>еда</b>, 
но не даст на: &quot;победа&quot;.
</p></blockquote><blockquote><p align="justify">
Вы можете спросить, а что делать, если искомая строка сама по себе включает какие-либо из символов описания шаблонов? 
Для этого используется знак апострофа &quot;&nbsp;'&nbsp;&quot; &mdash; если после него поставить такой символ, то он будет трактоваться 
как обычный. Например, шаблон <b>ч?о'?</b> даст совпадение со словом <b>что?</b>.
</p></blockquote><blockquote><p align="justify">
Если же необходимо, чтобы поиск сработал на строке, содержащей символ апострофа, то в шаблоне необходимо поставить два апострофа подряд. Например, чтобы найти слово <b>don't</b>, 
шаблон должен быть: <b>don"t</b>.
</p></blockquote><blockquote><p align="justify">
Начиная с версии 2 в ОС Амиги введены еще два символа, управляющих поиском по шаблону. 
Первый из них - тильда &quot;~&quot;, обозначающий отрицание. Если мы, например, хотим работать со всеми файлами, за исключением иконок 
(файлов с расширением &quot;.info&quot;), то выбрать их можно с помощью шаблона <b>~(#?.info)</b>.
</p></blockquote><blockquote><p align="justify">
И, наконец, последний символ &quot;-&quot; (тире), употребляемый вместе с парой квадратных скобок для определения диапазона подходящих 
символов. Например, шаблон <b>[Б-Г]#?</b> выберет все файлы, начинающиеся с букв Б, В, Г. Учтите только, что русская и английская буквы 
&quot;А&quot; в русифицированой AmigaOS совпадают, а твердый знак вынесен в самый конец русского алфавита (см. рис. &quot;<a href="AMIGA-ADD-1.html">ASCII-таблица</a>&quot;), 
поэтому будьте осторожны при подобном выборе для русских строк!
</p></blockquote><blockquote><p align="justify">
Ещё одно замечание: если в шаблоне присутствуют пробелы, то он обязательно должен быть заключен в кавычки. А теперь подведем итог нашего повествования о шаблонах в кратком резюме:
</p></blockquote>

<table width="95%">
<tr><td align="right" valign="top"><b>#a</b> &mdash;</td>
<td align="justify" width="80%">найдёт любое число повторений символа, &quot;а&quot;, а также его отсутствие.<br>
<b>X#Y</b> совпадёт с <b>X</b>, <b>XY</b>, <b>XYY</b> и <b>XYYY</b>;</td></tr>
<tr><td align="right" valign="top"><b>?</b> &mdash;</td>
<td align="justify" width="80%">найдёт любой символ, лишь бы он вообще был.<br>
<b>X?Y</b> совпадёт с <b>XAY</b>, <b>XBY</b> и <b>XCY</b>;</td></tr>
<tr><td align="right" valign="top"><b>#?</b> &mdash;</td>
<td align="justify" width="80%">совпадёт с любой строкой, либо ее отсутствием;</td></tr>
<tr><td align="right" valign="top"><b>#(ab)</b> &mdash;</td>
<td align="justify" width="80%">найдёт любое число повторений группы &quot;ab&quot;, а также её отсутствие.<br>
<b>#(XY)Z</b> совпадёт с <b>XYZ</b>, <b>XYXYZ</b>, или просто с <b>Z</b>;</td></tr>
<tr><td align="right" valign="top"><b>X|Y</b> &mdash;</td>
<td align="justify" width="80%">совпадёт или с X, или с Y.<br>
<b>Р(Ы|О)БА</b> совпадёт с <b>РЫБА</b> или <b>РОБА</b>;</td></tr>
<tr><td align="right" valign="top"><b>%</b> &mdash;</td>
<td align="justify" width="80%">совпадёт с отсутствующим символом.<br>
<b>К(Л|%)ОК</b> совпадёт с <b>КЛОК</b> или <b>КОК</b>;</td></tr>
<tr><td align="right" valign="top"><b>(&nbsp;)</b> &mdash;</td>
<td align="justify" width="80%">выделение группы символов.<br>
<b>(X|Y)Z</b> совпадёт с <b>XZ</b> или <b>YZ</b>.<br>
<b>X|YZ</b> совпадёт с <b>X</b> или <b>YZ</b>;</td></tr>
<tr><td align="right" valign="top"><b>(?|%)</b> &mdash;</td>
<td align="justify" width="80%">совпадёт с любым или отсутствующим символом.<br>
<b>К(?|%)ОК</b> совпадёт с <b>КЛОК</b> или <b>КОК</b>;</td></tr>
<tr><td align="right" valign="top"><b>'</b> &mdash;</td>
<td align="justify" width="80%">используется перед специальными символами (вроде %), чтобы отменить их &quot;специальный&quot; смысл.<br>
<b>DON''T</b> совпадёт с <b>DON'T</b>;</td></tr>
<tr><td align="right" valign="top"><b>~</b> &mdash;</td>
<td align="justify" width="80%">логическое отрицание.<br>
<b>~А#?</b> совпадёт со всеми строками, не начинающимися с буквы &quot;А&quot;;</td></tr>
<tr><td align="right" valign="top"><b>[a-c]</b> &mdash;</td>
<td align="justify" width="80%">совпадёт со всеми символами из диапазона от &quot;а&quot; до &quot;с&quot; включительно.</td></tr>
</table>
<br>
<hr>
</body></html>

