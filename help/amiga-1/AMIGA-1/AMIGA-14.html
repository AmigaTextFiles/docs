        <html>
        <head><base target="_self">
<title>русский транзит - amiga#1: arexx, инструкции</title>
</head>
<body link="#009999" vlink="#006666" alink="#000088" bgcolor="#ffffff" text="#000000">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="keywords" content="amiga,develope,ARexx,Инструкции">

<font face="Verdana, Arial size=2">
<p align="left"><a name=A14>Глава 14</a></p></font>
<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><b>Инструкции</b></p></font>

<blockquote><p align="justify">
Инструкции ARexx'a состоят из ключевого слова, за которым могут следовать один или несколько параметров. Вертикальная черта | означает выбор одной из нескольких альтернатив, квадратные скобки - необязательный параметр. Угловые скобки означают обязательный параметр.</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A141>
<b>ADDRESS</b> | &#60;имя&#62; [командное выражение]
        | [VALUE &#60;выражение, вычисляющее имя хозяина&#62;]
        |;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Инструкция ADDRESS позволяет выбрать нового текущего хозяина или послать указанному параметром &#60;имя&#62; хозяину результат вычисления некоторого выражения.
</p></blockquote>

<blockquote><p align="justify">
Имя хозяина является именем его ARexx-порта. В этом имени регистр букв менять нельзя, например для русификатора имя должно быть 'Rusifier.porf, но никак не 'RUSIFIER.PORT. Имя должно быть литеральной строкой, заключенной в апострофы или кавычки - при использовании значения переменной в качестве имени хозяина необходим параметр VALUE. Специальным именем хозяина является COMMAND - при этом результат будет аналогичен запуску последующих ОС-команд из cli (shell). При использовании VALUE командное выражение не может присутствовать в качестве параметра - в этом случае вычисляется имя нового текущего хозяина.
</p></blockquote>

<blockquote><p align="justify">
Если кроме имени хозяина присутствует также командное выражение, то замены текущего хозяина не произойдет, а просто указанному хозяину будет послан результат вычисления выражения.</p></blockquote>

<blockquote><p align="justify">
ARexx всегда помнит двух хозяев - предыдущего и текущего. Если исполнить ADDRESS без параметров, то предыдущий хозяин станет текущим (а текущий, разумеется, предыдущим).</p></blockquote>

<blockquote><p align="justify">
Пример использования - выводим текущий каталог из ARexx-a:</p></blockquote>

<blockquote><blockquote><pre>
ADDRESS 'COMMAND'
DIR
</pre></blockquote></blockquote>

<blockquote><p align="justify">
При первоначальном запуске ARexx-программы с помощью команды RX текущим хозяином становится порт интерпретатора по имени REXX. Этот хозяин умеет делать единственное дело: синхронно запускать на исполнение другие ARexx-программы. Когда ему посылается команда, он ищет файл с именем, соответствующим имени команды, вначале в текущем каталоге, затем в каталоге REXX:. В обоих случаях сначала ищется файл, точно соответствующий указанному имени, а в случае неудачи - файл с тем же именем, но расширением ".гехх". ARexx-файл, запустивший на исполнение другой ARexx-файл. послав команду REXX-хозяину, всегда ждет, пока "сыновний" файл закончит работу (это и есть синхронный запуск). Остаток строки после имени запускаемого файла может содержать аргументы для него.</p></blockquote>

<blockquote><p align="justify">
Еще один всегда готовый к работе хозяин по имени "AREXX" во всем подобен "REXX"-y, однако запускает ARexx-программы асинхронно (т.е. основная ARexx-программа, обратившаяся с просьбой о запуске другой ARexx-программы к хозяину "AREXX", не ждет, пока новая программа закончит работу). Если надо, новая программа может использовать функцию OPENPORT() и начать обмениваться различными сообщениями с кем угодно, в том числе и с "программой-родителем",</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A142>
<b>ARG</b> &#60;образец&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Сокращение от PARSE UPPER ARGS &lt;образец&gt;. Инструкция позволяет использовать аргументы при запуске программы или вызове функции. Подробности см. в описании PARSE.</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A143>
<b>BREAK</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
Выход из DO...END блока или из интерпретируемой (см. инструкцию INTERPRET) строки.</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A144>
<b>CALL</b> &#60;имя&#62; [выражение] [[,] выражение] ...
</a></pre></font></blockquote>

<blockquote><p align="justify">
Вызов функции, подпрограммы или запуск другой ARexx-программы. Имя должно быть литеральной строкой - имена переменных здесь не допускаются. Имя соответствует имени функции, ARexx-программы или метке подпрограммы.</p></blockquote>

<blockquote><p align="justify">
При вызове функции возможные аргументы могут быть заключены в необязательные круглые скобки. После возврата из вызванной подпрограммы (функции), значение, возможно возвращенное вызванной подпрограммой (функцией), присваивается переменной RESULT. Кроме того, при вызове внутренней подпрограммы (функции), переменной SIGL присваивается значение, равное номеру строки программы, в которой находится инструкция CALL.</p></blockquote>
 
<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A145>
<b>DO</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
Определяет группу инструкций в качестве единого блока инструкций. DO может быть идентификатором начала целой серии программных структур. Каждой открывающей блок инструкции DO должна соответствовать закрывающая блок инструкция END. Допускается неограниченное вложение DO...END конструкций. Ниже демонстрируются возможные варианты использования DO...END:</p></blockquote>

<blockquote><blockquote><pre>
DO                      /* Простейший тип блока, обычно        */
   инструкции...        /* употребляемый в конструкциях        */
END                     /* типа  IF...THEN...ELSE              */
<br>
DO 5                    /* Выполнить инструкции блока 5 раз    */
   инструкции...        /* Разумеется, вместо цифры 5 может    */
END                     /* стоять имя переменной               */
<br>
DO i = 1 TO 5 BY 2      /* Переменная i последовательно при-   */
   инструкции...        /* нимает значения от 1 до 5 с шагом 2 */
   ...                  /* При отсутствии BY шаг изменения     */
END                     /* i будет равен единице.              */
<br>
DO i = 1 TO x FOR 5     /* Выход из цикла произойдёт либо      */
   инструкции...        /* после достижения переменной i       */
   ...                  /* значения x, либо после того, как    */
END                     /* цикл будет исполнен 5 раз           */
<br>
DO WHILE x < limit      /* Исполнять, пока значение перемен-   */
   инструкции...        /* ной x меньше значения переменной    */
   ...                  /* limit. Цикл может вообще не ис-     */
END                     /* полняться, если сразу x~< limit.    */
<br>
DO UNTIL x < limit      /* Аналогично WHILE, однако проверка   */
   инструкции...        /* выполняется не перед исполнением    */
   ...                  /* тела цикла, а после него, поэтому   */
   ...                  /* цикл всегда будет исполнен хотя бы  */
END                     /* 1 раз                               */
<br>
DO FOREVER                      /* Бесконечный цикл. Выйти из  */
  инструкции...                 /* цикла можно с помощью ин-   */
  ...                           /* струкций LEAVE или BREAK.   */
  IF  e = f  THEN ITERATE       /* Исполнение EXIT приведет к  */
  IF  x = у  THEN BREAK         /* прекращению работы програм- */
  IF  a = b  THEN LEAVE         /* мы. ITERATE вызывает игно-  */
  IF  с = d  THEN EXIT          /* рирование оставшейся части  */
END               /* цикла и переход на его начало (только     */
                  /* в том случае, если конструкция DO...END   */
                  /* является циклической, а не просто блоком; */
                  /* это касается и LEAVE)                     */
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A146>
<b>DROP</b> &#60;имя&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Присваивает переменной с заданным именем ее изначальное значение - 
например, переменная Var1 после исполнения DROP Var1 будет иметь 
значение VAR1.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A147>
<b>ECHO</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
То же, что SAY (см. описание ARexx-инструкции SAY).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A148>
<b>EXIT</b> [значение]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Эта инструкция прекращает исполнение ARexx-программы. Параметром для EXIT может быть код возврата, соответствующий ОС-овскому уровню ошибки (см. описание ОС-команды FAILAT).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A149>
<b>IF</b> &#60;expr&#62; <b>THEN</b> ... [<b>ELSE</b>]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Инструкция осуществляет управление ветвлениями в программе в зависимости от результата выражения ехрr. Если результат получится ненулевой, будет исполняться инструкция (блок инструкций) после THEN. Если результат нулевой и присутствует ключевое слово ELSE, то будет выполняться инструкция (блок инструкций) после ELSE. Примеры:
</p></blockquote>

<blockquote><blockquote><pre>
IF x > 1 THEN SAY x
IF x ~= 0 THEN
   SAY 'x не равно нулю'
ELSE
   SAY 'x равно нулю'
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Поскольку ELSE всегда соответствует ближайшему IF, но использование ELSE не является необходимостью, иногда приходится вводить фиктивные ELSE для правильной логики работы всей конструкции:
</p></blockquote>

<blockquote><blockquote><pre>
IF x > 5 THEN
   IF x = 7 THEN
       say 'x равно семи'
       ELSE
           NOP
   ELSE
       say 'x меньше или равно пяти'
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Если бы мы в этом примере не использовали дополнительного ключевого слова ELSE, то последнее ELSE относилось бы не к первому IF, как требуется по логике примера, а ко второму. Поскольку после ELSE в любом случае должна следовать некоторая инструкция (блок инструкций), мы были вынуждены использовать "пустую" инструкцию NOP. которая ничего не делает.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14A>
<b>INTERPRET</b> &#60;выражение&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Обрабатывает выражение, затем исполняет его в качестве инструк­ции ARexx-a. Результатом выражения должна явиться строка, содержащая одно или несколько утверждений ARexx-a (если утверждений несколько, то они должны быть отделены друг от друга символом ";". Пример:
</p></blockquote>

<blockquote><blockquote><pre>
Part1 = 'SAY'
part2 = 'Привет!'
part3 = 'Bye!'
INTERPRET part1 part2 ';' part1 part3      ==> Привет! Bye!
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Мы сознательно приводим наипростейший пример - на самом деле возможности INTERPRET 
очень велики.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14B>
<b>NOP</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
Пустая операция, пример использования которой см. в описании IF.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14C>
<b>NUMERIC</b> | <b>DIGITS</b> &#60;выражение&#62;
        | <b>FUZZ</b> &#60;выражение&#62;
        | <b>FORM</b> | [<b>SCIENTIFIC</b>]
               | [<b>ENGINEERING</b>]
               | [[<b>VALUE</b>] &60;выражение&#62;]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Определяет точность чисел используемых при вычислении выражений, а также точность возвращаемых результатов. Если количество цифр какого-либо числа превышает величину, заданную инструкцией NUMERIC, то производится округление этого числа до значения, содержащего заданное по NUMERIC число значащих цифр.
</p></blockquote>

<blockquote><p align="justify">
NUMERIC DIGITS определяет точность расчета арифметических выражений (по умолчанию она равна 9 значащим цифрам). Выражение, оп­ределяющее требуемую точность, должно возвращать значение от 1 до 14. Чтобы узнать текущую точность вычислений, достаточно исполнить встро­енную функцию DIGITS().
</p></blockquote>

<blockquote><p align="justify">
NUMERIC FUZZ задает точность сравнения чисел. Выражение, определяющее требуемую точность, должно  возвращать значение меньшее,
нежели текущая точность расчета. Чтобы узнать текущую точность сравнения чисел, достаточно исполнить встроенную функцию FUZZ(). Нулевое значение параметра означает, что точность сравнения соответствует значению NUMERIC DIGITS.
</p></blockquote>

<blockquote><p align="justify">
NUMERIC FORM определяет формат вывода, когда число представлено в экспоненциальной форме - научный (SCIENTIFIC) или инженерный (ENGINEERING). По умолчанию принят научный формат - мантисса числа больше 0 и меньше 1. При инженерной нотации порядок (степень десяти) представлен максимальным числом, нацело делящимся на 3. Выражение (если оно есть) должно возвращать соответствующую требуемой нотации строку - т.е. SCIENTIFIC или ENGINEERING. Ключевое слово VALUE можно не употреблять в том случае, если выражение начинается не с символа и не с литеральной строки. Использование NUMERIC FORM без дополнительного выражения, восстанавливает нотацию, принятую по умолчанию (т.е. научную). Чтобы узнать, какой является текущая нотация, достаточно исполнить функцию FORM().
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14D>
<b>OPTIONS</b> | <b>RESULTS</b> [<b>ON</b> | <b>OFF</b>]
        | <b>PROMPT</b> &#60;выражение&#62; [<b>ON</b> | <b>OFF</b>]
        | <b>FAILAT</b> &#60;выражение&#62; [<b>ON</b> | <b>OFF</b>]
        | <b>CACHE</b>   [<b>ON</b> | <b>OFF</b>]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Эта инструкция меняет некоторые установки, касающиеся текущей  исполняемой ARexx-программы. Дополнительные переключатели ON и OFF могут использоваться для включения/выключения заданной опции (по умолчанию при исполнении OPTIONS заданная опция всегда включается, так что использовать ON нет абсолютно никакой необходимости).
</p></blockquote>

<blockquote><p align="justify">
OPTIONS RESULTS заставляет ARexx присваивать переменной RESULT значение строки, зачастую возвращаемое многими внешними программами (командами ОС).
</p></blockquote>

<blockquote><p align="justify">
OPTIONS PROMPT определяет строку подсказки, используемую в таких инструкциях, как PULL, PARSE PULL и PARSE EXTERNAL. Подсказка является строкой, полученной в результате вычисления выражения параметра OPTIONS PROMPT. Эта строка должна иметь вид, позволяющий вывести ее в консольное (т.е. shell-) окно и может содержать управляющие коды, меняющие, например, ее цвет или форму символов.
</p></blockquote>

<blockquote><p align="justify">
OPTIONS FAILAT определяет уровень ошибки, возвращенный внешней программой, который будет рассматриваться ARexx-интерпретатором в качестве фатального, т.е. вызовет прерывание исполнения текущей ARехх-программы. По умолчанию этот уровень наследуется из ОС (используется уровень, существовавший на момент запуска ARexx-программы); в ОС для изменения уровня фатальной ошибки служит команда FAILAT (см. описание FAILAT). OPTIONS FAILAT определяет уровень срабатывания ловушки, возможно установленной с помощью инструкции SIGNAL ON FAILURE.
</p></blockquote>

<blockquote><p align="justify">
Опция OPTIONS CACHE no умолчанию является включенной; ее действие заключается в буферизации повторяющихся ARexx-инструкций, что ускоряет интерпретацию программы. Отключать OPTIONS CACHE нет никакого смысла - много памяти вы на этом не выиграете, а исполнение ARexx-программы может существенно замедлиться.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14E>
<b>PARSE</b> [<b>UPPER</b>] | <b>ARG</b>  &#60;список переменных&62;
              | <b>EXTERNAL</b> &#60;список переменных&#62;
              | <b>NUMERIC</b>  &#60;список переменных&#62;
              | <b>PULL</b>    &#60;список переменных&#62;
              | <b>SOURCE</b>  &#60;список переменных&#62;
              | <b>VALUE</b>  &#60;выражение&#62;  <b>WITH</b>  &#60;список переменных&#62;
              | <b>VAR</b>  &#60;список переменных&#62;
              | <b>VERSION</b>  &#60;переменная&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Инструкция присваивает перечисленным в списке переменным значения аргументов, полученные из некоторого источника. Что это за источник, определяет одно из дополнительных ключевых слов. Необязательное ключевое слово UPPER может предварительно преобразовать все строчные буквы аргументов-строк в заглавные. Если необходимо "перепрыгнуть" через один или несколько аргументов, то вместо имен переменных, соответствующих этим аргументам, в списке используют точки (точки должны отделяться пробелами от любых других имен).
</p></blockquote>

<blockquote><p align="justify">
Ключевое слово ARG указывает на то, что аргументы определены при запуске текущей программы (или вызове функции). Синонимом инструкции PARSE UPPER ARG является просто ARG. Пример использования - наша ARexx-программа называется Sample.гехх и вызывается из shell строкой:
</p></blockquote>

<blockquote><blockquote><pre>
rx  Sample.гехх  Привет   1   2
</pre></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
А вот текст самой программы, а заодно и результаты ее работы:
</p></blockquote></blockquote>

<blockquote><blockquote><pre>
/*  Первая строчка любой ARexx-программы      */
/*  всегда содержит комментарий               */
PARSE ARG  first, second, third
say first                  ==> Привет
say second                 ==>   1
say third                  ==>  2
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Следует отметить, что библиотека RexxDosSupport.Iibrary (автор Хартмут Гебель) позволяет использовать в ARexx-программе мощнейшие механизмы ОС Амиги для манипуляции с аргументами, передаваемыми функции (программе), что резко упрощает задачу ARexx-программиста по написанию процедур обработки этих аргументов.
</p></blockquote>

<blockquote><p align="justify">
PARSE PULL выуживает аргументы из стандартного потока ввода (Stdln), который, как правило, "вливается" в ARexx-программу из материнского shell-окна. Если какие-либо данные были отправлены во входной поток инструкциями PUSH или QUEUE, то PARSE PULL достает их оттуда согласно порядку их расположения. Если входной поток пуст, то будет ожидаться ввод пользователем данных с клавиатуры, который должен завершиться нажатием клавиши Enter. PULL можно использовать в качестве самостоятельной инструкции, которая работает аналогично PARSE UPPER PULL. Для определения подсказки, появляющейся в shell-окне при ожидании ARexx-программой ввода пользователя, служит инструкция OPTIONS PROMPT.
</p></blockquote>

<blockquote><p align="justify">
PARSE EXTERNAL работает подобно инструкции PARSE PULL однако используется поток ввода StdErr (а не Stdln). Поток этот явно определен только в случае, если включена трассировка ARexx-программы и на экране присутствует трассировочное окно. Можно определить поток StdErr, как исходящий из текущего консольного окна, исполнив утверждение:
</p></blockquote>

<blockquote><blockquote><pre>
call  open(STDERR,"*",'R')
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Ключевые слова NUMERIC, SOURCE и VERSION позволяют получить доступ к информации о текущей ARexx-программе и системе, в которой она работает.
</p></blockquote>

<blockquote><p align="justify">
PARSE NUMERIC присвоит требуемой переменной строку, характеризующую текущий режим обработки чисел - точность операций, точность сравнения и выбранный формат вывода для чисел с плавающей точкой. Пример:
</p></blockquote>

<blockquote><blockquote><pre>
PARSE  NUMERIC  Nums
SAY  Nums   ==>   9  0  SCIENTIFIC
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Первым в строке находится параметр, соответствующий установке NUMERIC DIGITS, затем - NUMERIC FUZZ, затем - NUMERIC FORM (см. описание инструкции NUMERIC).
</p></blockquote>

<blockquote><p align="justify">
PARSE SOURCE присваивает требуемой переменной строку, характеризующую среду, из которой была вызвана текущая ARexx-программа. Формат полученной строки:
</p></blockquote>
<blockquote><blockquote><p align="justify">
<i> &#60;тип&#62; &#60;результаты&#62; &#60;вызвана&#62; &#60;маршрут&#62; &#60;расширение&#62; &#60;хозяин&#62;</i>
 </p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Тип&quot; соответствует тому, как была вызвана текущая программа - в качестве ARexx-программы или внешней функции. Соответственно токен типа может принимать значения COMMAND или FUNCTION.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>Токен &quot;результаты&quot; может принимать логические значения &quot;Истина&quot; (единица), либо &quot;Ложь&quot; (ноль), в зависимости от того, включен ли режим OPTIONS RESULTS.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Вызвана&quot; соответствует имени этой ARexx-программы или функции; &quot;маршрут&quot; соответствует ее полному маршруту; &quot;расширение&quot; - дополнительному расширению, с учетом которого производится поиск файлов в случае неудачного поиска заданного файла без расширения. По умолчанию это расширение &quot;REXX&quot; (точка, отделяющая имя от расширения, здесь не указывается).</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Хозяин&quot; - изначальный хозяин программы - то же, что результат исполнения функции ADDRESS() на момент старта программы. Следует учесть, что при запуске внешней функции или ARexx-программы из другой ARexx-программы хозяин &quot;наследуется&quot;; команда же RX устанавливает хозяина REXX.</i>
</p></blockquote></blockquote>

<blockquote><p align="justify">
PARSE VERSION предоставляет общую информацию о конфигурации системы, в которой ARexx-программа имеет честь работать. Формат полученной строки:
</p></blockquote>

<blockquote><blockquote><p align="justify">
<i>&#60;язык&#62; &#60;версия&#62; &#60;процессор&#62; &#60;сопроцессор&#62; &#60;видеорежим&#62; &#60;кадровая_частота&#62;</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Язык&quot; всегда будет &quot;AREXX&quot;, поскольку все происходит на Амиге. На других компьютерах вы могли бы получить что-нибудь типа &quot;REXX370&quot; или &quot;REXXSAA&quot;.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Версия&quot; соответствует текущей версии ARexx-интерпретатора вашей системы. На июнь 1995 года последней версией является 1.15.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Процессор&quot; соответствует типу центрального процессора вашей системы. Версия 1.15 ошибочно сообщает пользователям 68040, что в системе стоит процессор 68070, о котором даже сама фирма Motorola ничего не знает.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Сопроцессор&quot; соответствует типу математического сопроцессора вашей системы (разумеется, если он есть - иначе будет выведено &quot;NONE&quot;). В случае, если в вашей системе установлен центральный процессор 68040 со встроенным математическим сопроцессором, вам будет сообщено о наличии 68881-го сопроцессора, что не совсем соответствует действительности.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Видеорежим&quot; может принимать 2 значения - NTSC и PAL.</i>
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<i>&quot;Кадровая частота&quot; может быть &quot;50HZ&quot; или &quot;60HZ&quot;. Эти два сообщения могут иметь весьма сомнительное отношение к реальному экранному режиму AGA-компьютеров (А1200 и А4000).</i>
</p></blockquote></blockquote>

<blockquote><p align="justify">
PARSE VALUE и PARSE VAR позволяют использовать не внешние, а внутренние данные в качестве опрерандов для PARSE. PARSE VAR использует значение единственной переменной, a PARSE VALUE - значение некоторого выражения, после которого должно следовать обязательное ключевое слово WITH, а далее - список переменных. Разумеется, выражение может состоять из единственного имени переменной, однако в этом случае проще использовать PARSE VAR. Примеры использования: 
</p></blockquote>

<blockquote><blockquote><pre>
PARSE VALUE TIME() WITH Hours ':' Min ':' Sec
SAY Hours 'часов' Min 'минут' Sec 'секунд'
                      ==>  12 часов 11 минут 37 секунд
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Если выражение отсутствует, то всем переменным списка будут присвоены нулевые значения. Таким образом можно использовать PARSE VALUE для обнуления сразу нескольких переменных.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14F>
<b>PROCEDURE</b> [<b>EXPOSE</b> &#60;переменная&#62; [&#60;переменная&#62;] [<b>...</b>]]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Эта инструкция создает новую символьную таблицу для встроенной функции. В символьную таблицу входят имена переменных, доступных из этой функции. Без использования инструкции PROCEDURE все переменные вызывающей функцию программы доступны из нее без каких-либо ограничений, т.е. ничто не мешает менять их из тела функции. Пример:
</p></blockquote>

<blockquote><blockquote><pre>
х = 1
call func
say x  ==>  2
exit

func:
   x = 2
   return
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Ситуация меняется при использовании инструкции PROCEDURE, локализирующей переменные, действия с которыми происходят в теле функции:
</p></blockquote>

<blockquote><blockquote><pre>
х = 1
call func
say x  ==>  1
exit

func: PROCEDURE
   x = 2
   return
</pre></blockquote></blockquote>

<blockquote><p align="justify">
В этом случае переменная х создается функцией заново и не имеет никакого отношения к глобальной переменной х, созданной в основной программе. Если же какие-либо переменные основной программы и в этом случае должны быть доступны из тела функции, то их имена следует явно указать после ключевого слова EXPOSE:
</p></blockquote>

<blockquote><blockquote><pre>
X = 1
У = 3 
call func
say x ==> 2 
say у ==> 3
exit

func: PROCEDURE EXPOSE x 
   x = 2 
   у = 4 
   return
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14G>
<b>PULL</b> Сокращение от PARSE UPPER PULL (см. описание PARSE). 
</a></pre></font></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14H>
<b>PUSH</b> &#60;выражение&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Кладет результат вычисления выражения с добавленной литерой "перевод строки" (ASCII значение 10) во входной поток Stdln. Порядок помещения данных во входной поток при этом соответствует стековому принципу LIFO (Last In First Out) - "последний ушел - первый вышел". Позже все что было положено во входной поток, может быть оттуда вынуто инструкцией PARSE PULL. Если на момент окончания работы ARexx-программы входной поток не будет пустым, то ОС Амиги попытается исполнить все лежащие в нем строки одну за другой, как если бы их набирали в shell-окне с клавиатуры. Для выяснения количества имеющихся строк во входном потоке служит встроенная функция LINES().
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14I>
<b>QUEUE</b> &#60;выражение&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Инструкция работает аналогично PUSH, но укладка строк во входной поток происходит по принципу FIFO (First In First Out) - "первый ушел - первый вышел", т.е. первая положенная строка будет использована первой при последующем чтении входного потока.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14J>
<b>RETURN</b> [&#60;выражение&#62;]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Используется внутри функций для возврата управления в точку, следующую за точкой вызова функции. Значение выражения является величиной, возвращаемой функцией.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14K>
<b>SAY</b> [&#60;выражение&#62;]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Выводит результат вычисления выражения с добавленной литерой "перевод строки" (ASCII значение 10) в выходной поток StdOut (как правило, этот поток направлен в shell-окно, из которого ARexx-программа была запущена на исполнение). Синонимом SAY является ECHO.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14L>
<b>SELECT</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
Выбор одного из альтернативных ветвлений. Пример:
</p></blockquote>

<blockquote><blockquote><pre>
SELECT
   WHEN x = 1 THEN
       SAY 'x равно единице'
   WHEN x < 5 THEN
       DO
	      y = y + 1
		  SAY 'x меньше пяти'
	   END
   OTHERWISE
       SAY 'x не меньше пяти!'
END
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Если результат вычисления выражения, следующего после WHEN не равен нулю, то выполняется 
инструкция (блок инструкций) между соответствующим THEN и последующим WHEN (OTHERWISE, END). 
Необязательное ключевое слово OTHERWISE &quot;срабатывает&quot; только в том случае, если не &quot;сработало&quot; 
ни одно из WHEN.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14M>
<b>SIGNAL</b>
</a></pre></font></blockquote>

<blockquote><p align="justify">
Эта инструкция имеет двоякое значение. При использовании вместе с ключевыми словами ON или OFF, SIGNAL вызывает включение (ON) или выключение (OFF) явно определяемой реакции на возникновение какой-либо исключительной ситуации в системе. Если для заданной ситуации было исполнено SIGNAL ON, то в случае ее возникновения произойдет безусловный переход на некоторую подпрограмму. Ситуация, на которую предполагается отреагировать, ассоциируется с одним из нижеследующих резервированых слов (имя вызываемой подпрограммы должно совпадать с соответствующим резервированным словом):
</p></blockquote>

<blockquote><blockquote><pre>
BREAK_C    <i>получение сигнала останова от ОС (см. описание</i>
BREAK_D    <i>ОС-команды BREAK), также при нажатии соответствующей</i>
BREAK_E    <i>комбинации клавиш (например, CTRL-C или CTRL-D);</i>
BREAK_F
ERROR      <i>команда вернула ненулевой код ошибки;</i>
FAILURE    <i>команда вернула код ошибки более 19-ти;</i>
HALT       <i>получен общий сигнал останова (см. описание команды HI);</i>
IOERRR     <i>ОС сигнализирует об ошибке ввода-вывода:</i>
NOVALUE    <i>использование значения неинициализированной переменной;</i>
SYNTAX     <i>синтаксическая ошибка либо ошибка периода исполнения.</i>
</pre></blockquote></blockquote>

<blockquote><p align="justify">
ARexx по умолчанию (т.е. без исполнения SIGNAL ON) реагирует на некоторые из вышеперечисленных сигналов следующим образом:
</p></blockquote>

<blockquote><blockquote><pre>
BREAK_C, HALT, SYNTAX   - <i>исполнение программы прерывается.</i>
FAILURE                 - <i>выводится сообщение об ошибке; исполне-</i>
                          <i>ние программы прерывается.</i>
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Все остальные исключительные ситуации по умолчанию игнорируются. Если возникла одна из ситуаций, на которую ARexx должен отреагировать, то системная переменная ARexx-a SIGL будет содержать номер строки, во время исполнения которой эта ситуация произошла. Пример использования SIGNAL с ключевым словом ON:
</p></blockquote>

<blockquote><blockquote><pre>
SIGNAL ON ERROR    /* Реагировать на ненулевой уровень ошибки */
   ...          /* Здесь находится собственно ARexx-программа */
   exit
ERROR:                      /* Подпрограмма реакции на ошибку */
   SAY 'Произошла ошибка в строке'  SIGL 
   exit
</pre></blockquote></blockquote>

<blockquote><p align="justify">
Если SIGNAL используется без ключевых слов ON или OFF, то параметром должно быть или имя метки, на которую происходит передача управления, или должно следовать ключевое слово VALUE, затем выражение, вычисляющее имя той же метки. Подобная конструкция практически то же самое, что и оператор GOTO, который рекомендуется использовать только тогда, когда не использовать его нельзя, т.е. никогда.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14N>
<b>TRACE</b> | {<b>?</b>|<b>!</b>} [&#60;опция&#62;]
      | <b>VALUE</b> &#60;выражение&#62;
      | [<b>-</b>] &#60;число&#62;
</a></pre></font></blockquote>

<blockquote><p align="justify">
Включает мощные отладочные средства ARexx-a. Вывод отладочной информации производится в выходной поток StdErr, который может быть открыт внутри этой же ARexx-программы. Если поток StdErr не определен, но с помощью команды ТОО (Trace COnsole) было открыто консольное окно трассировки, то поток StdErr направляется именно туда. Если и такого окна нет, то ARexx направит StdErr туда же, куда и StdOut - как правило, в текущее shell-окно.
</p></blockquote>

<blockquote><p align="justify">
Параметр &quot;опция&quot; определяет формат выводимой информации; мы дадим полные английские идентификаторы трассировочных опций ARexx-a, хотя реальные опции состоят из однобуквенных идентификаторов, являющихся первыми буквами имен указанных опций:
</p></blockquote>

<blockquote><blockquote><p align="justify">
<b>А</b>ll - (все); все утверждения выводятся в консольное окно по мере их исполнения, но результаты не показываются.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>B</b>ackground - (фон); прекращает трассировку, причем даже внешний запрос на начало трассировки (команда TS) после Background не будет иметь эффекта.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>C</b>ommands - (команды); трассируются только командные утверждения.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>E</b>rrors - (ошибки); выводятся командные утверждения, чье исполнение вызвало ненулевой уровень ошибки; также выводится значение уровня ошибки. 
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>I</b>ntermediates - (промежуточные); трассируется все, что только можно. Выводятся промежуточные результаты, получаемые при вычислении каждого из выражений вместе со значениями переменных. Идентификаторами типов выводимых данных являются:
</p></blockquote></blockquote>

<blockquote><blockquote><blockquote><p align="justify">
&#62;.&#62; <i>- это значение не присваивается (см. описание инструкции PARSE, где сказано об использовании точек в образцах).</i><br>
&#62;&#62;&#62; <i>- результат исполнения всего утверждения в целом. Этот идентификатор используется и при других опциях трассировки.</i><br>
&#62;С&#62; <i>- имя комбинированной переменной;</i><br>
&#62;F&#62; <i>- значение, возвращенное функцией;</i><br>
&#62;L&#62; <i>- литеральное значение (константа);</i><br>
&#62;О&#62; <i>- результат бинарной операции;</i><br>
&#62;Р&#62; <i>- результат унарной (префиксной) операции;</i><br>
&#62;U&#62; <i>- имя переменной, значение которой не было присвоено;</i><br>
&#62;V&#62; <i>- значение переменной.</i>
</p></blockquote></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>L</b>abels - (метки); трассируются только переходы на строки, содержащие метки (например, при вызовах подпрограмм).
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>N</b>ormal - (обычный); этот режим трассировки устанавливается по умолчанию. При нем трассируются только утверждения, возвращающие код ошибки выше установленного текущего предела.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>O</b>ff - (выключить); прекращает трассировку, которая может быть снова возобновлена после исполнения команды TS.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
<b>R</b>esults - (результаты); трассируется все, но выводятся только результаты вычисления выражений.
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
Scan - (сканирование); в этом режиме трассируются все утверждения без их действительного исполнения; весьма удобно использовать для предварительной проверки синтаксиса.
</p></blockquote></blockquote>

<blockquote><p align="justify">
Если после инструкции TRACE присутствует ключевое слово VALUE, то за ним должно следовать выражение, результатом вычисления которого будет одна из вышеприведенных опций (т.е. первая буква этой опции).
</p></blockquote>

<blockquote><p align="justify">
Символы "<b>!</b>" и "<b>?</b>" могут быть использованы как отдельно (TRACE ?), так и в комбинации с необходимыми однобуквенными идентификаторами формата (TRACE ?). Эти символы действуют в качестве переключателей: первое их использование включает соответствующий им режим, повторное - выключает и т.д.
</p></blockquote>

<blockquote><blockquote><p align="justify">
Символ "<b>?</b>" - переключатель интерактивного режима (интерактивный режим трассировки, подробно описанный в соответствующей главе, также автоматически включается при исполнении команды TS (Trace Start).
</p></blockquote></blockquote>

<blockquote><blockquote><p align="justify">
Символ "<b>!</b>" - переключатель режима "отключения хозяина". Если хозяин отключен, то никакие сообщения ему не посылаются, хотя все остальные действия, связанные с обработкой утверждений, предназначенных для хозяина, выполняются как обычно. При этом считается, что проблем у хозяина не возникает и он всегда возвращает нулевой код ошибки. Этот режим весьма удобен при отладке ARexx-программы без запуска программы-хозяина (хозяев).
</p></blockquote></blockquote>

<blockquote><p align="justify">
Если параметром инструкции TRACE является отрицательное число, то трассировка не включается для числа программных строк, соответствующих абсолютному значению этого числа.
</p></blockquote>

<blockquote><p align="justify">
Если параметром инструкции TRACE является положительное число, то трассировка этого числа программных строк &quot;проскакивает подряд&quot;, т.е. интерактивный режим для них отменяется.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A14O>
<b>UPPER</b> &#60;переменная&#62; [&#60;переменная&#62;] [...]
</a></pre></font></blockquote>

<blockquote><p align="justify">
Переводит буквы в значениях строчных переменных в заглавный регистр.
</p></blockquote>

<hr>

</body></html>