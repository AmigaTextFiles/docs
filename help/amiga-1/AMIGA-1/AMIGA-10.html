        <html>
        <head><base target="_self">
<title>русский транзит - amiga#1: стандартные команды ос</title>
</head>
<body link="#009999" vlink="#006666" alink="#000088" bgcolor="#ffffff" text="#000000">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="keywords" content="amiga,амига,world,pc,commodore,amiga#1,мультимедиа,multimedia,ham,p&p,
autoconfig,plug,кикстарт,kickstart,addbuffers,adddatatypes,alias,ask,assign,avail,binddrivers,break,
cd,changetaskpri,conclip,copy,cpu,date,delete,dir,diskchange,diskcopy,diskdoctor,echo,ed,else,endcli,
endif,endshell,endskip,eval,execute,failat,fault,ff,filenote,format,get,getenv,if,info,install,iprefs,
join,lab,list,loadwb,lock,magtape,makedir,makelink,mount,newcli,newshell,path,prompt,protect,quit,
relabel,remrad,rename,requestchoice,requestfile,resident,run,search,set,setclock,setdate,setenv,setfont,
setkeyboard,setmap,setpath,skip,sort,stack,status,type,unalias,unset,unsetenv,version,wait,which,why,;,
стандартные,команды,ос,os,amigaos,amigados,aos,русский,транзит">

<table width="95%"><tr>
<td valign="top"><font face="Verdana, Arial size=2">
<p align="left">Глава 10</p></font>
<font face="Arial, Helvetica, sans-serif" size="4">
<p align="left"><b>Стандартные команды ОС</b></p></font></td>
<td align="right"><img src="Gfx/AMIGA-10.gif" width="150" height="174"></td>
</tr></table>

<blockquote><p align="justify">
Стандартные команды ОС могут быть как загружаемыми с диска (находятся в каталоге С:), так и встроенными в систему (находятся в постоянном запоминающем устройстве &mdash; ПЗУ). Ниже следует алфавитный список этих команд. Если команда встроенная, это указывается явно; по умолчанию команды находятся в каталоге С:. Некоторые команды находятся в других каталогах &mdash; об этом также явно сообщается. Список встроенных команд можно также получить, исполнив команду RESIDENT без параметров. 
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1001>
<b>ADDBUFFERS</b> DRIVE/A,BUFFERS/N
</a></pre></font></blockquote>
<blockquote><p align="justify">
Если считывание информации с жёсткого диска происходит в принципе не намного медленнее, нежели считывание из памяти, то с гибкими дисками все происходит неизмеримо хуже. ОС пытается хотя бы частично решить эту проблему, сохраняя наиболее часто используемую информацию в т.н. дисковых буферах, находящихся в памяти Амиги. Длина каждого буфера &mdash; 512 байт, т.е. совпадает с длиной дискового сектора. Команда ADDBUFFERS присваивает требуемое число буферов указанному устройству. Разумеется, память резервированная под буферы, потеряна для остальной системы, поэтому приходится искать некий компромисс между скоростью доступа к диску и расходуемой памятью. По умолчанию, дисководу DF0: присваивается (в файле&nbsp;S:Startup&ndash;Sequence) 15 буферов командой:
</p></blockquote>
<blockquote><blockquote><pre>
AddBuffers DF0: 15
</pre></blockquote></blockquote>
<blockquote><p align="justify">
Если в вашей Амиге достаточно памяти, но нет жёсткого диска, есть смысл увеличить число буферов хотя бы в 2 раза, дабы несколько уменьшить возню с гибким диском. Присвоение конкретному дисководу более 30&ndash;ти буферов особого смысла не имеет, т.к. увеличение быстродействия становится неадекватным объему расходуемой памяти.
</p></blockquote><blockquote><p align="justify">
Что касается использования ADDBUFFERS для жёстких дисков, то здесь, чем больше буферов, тем лучше (особенно если у вас &ndash; слишком быстрый жёсткий диск; скорость общения с диском можно выяснить, воспользовавшись, например, программой Syslnfo. Для IDE-винчестеров хорошим показателем можно считать что-нибудь около 1,8 Мб/сек). Однако, как правило, число резервируемых буферов для каждой партиции (логического диска, на которые разбивается реальный, т.е. физический диск) диска жёстко задается при его разбивке на партиции и хранится в т.н. Rigid-блоке описателя структуры диска. 
</p></blockquote><blockquote><p align="justify">
Необходимо отметить, что для ускорения работы жёстких дисков есть гораздо более радикальные и мощные средства, нежели использование ADDBUFFERS. Примером служит великолепная программа Dynamic-Cache, которая умудряется резервировать вообще всю свободную память системы под дисковые буферы, да ещё так, что любая программа, которая попросит для себя память, получит её так же легко и просто, как если бы DynamicCache вообще не был бы установлен и вся резервированная DynamicCache память на самом деле была бы свободна. Не правда ли, просто идеальное решение проблемы? Кроме ускорения работы с жёстким диском, мы ещё и бережем его, т.к. число обращений к нему резко сокращается за счет того, что все повторные считывания наиболее часто используемых файлов происходят не с диска, а из памяти. Использование DynamicCache просто незаменимо, если при вашей работе на машине приходится многократно считывать одни и те же файлы, например, при отладке/компиляции программ на языке С, когда число считываемых header-файлов для любого мало-мальски приличного проекта весьма и весьма велико. У автора этой книги, например, до 90% обращений к жёсткому диску при программировании заменяются на чрезвычайно быструю работу с DynamicCache-буферами. 
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1002>
<b>ADDDATATYPES</b> FILES/M,QUIET/S,REFRESH/S
</a></pre></font></blockquote>
<blockquote><p align="justify">
Эта команда появилась, начиная с версии ОС 3.0, как средство поддержки новой объектно-ориентированной системы работы с различными типами данных. Частью этой системы, например, является программа MultiView, находящаяся в каталоге Utilities, которая позволяет просмотреть текстовые и гипертекстовые файлы, а также картинки произвольного формата, либо прослушать звуки и музыку. Казалось бы, подобная программа должна быть достаточно большой по объёму, чтобы уметь &quot;разбираться&quot; с различными типами файлов, которые ей &quot;подсовываются&quot;. А как быть, если в системе со временем появляются файлы абсолютно новых типов, которые были неизвестны на момент написания MultiView? Переписывать всю программу заново, чтобы она стала понимать эти новые типы? Некрасиво получается&hellip; Разработчики ОС специально для MultiView и тому подобных программ создали универсальный механизм определения и манипуляции с различными типами данных, находящихся в файлах. 
</p></blockquote><blockquote><p align="justify">
Что значит фраза &quot;появляется новый тип данных&quot;? Это значит, что создан файл с необходимой для идентификации нового типа данных информацией, а также системная библиотека, которая содержит все необходимые процедуры, которые могут быть применены к этому типу данных. Файл идентификации помещается в каталог &quot;DEVS:Datatypes&quot;, а библиотека &mdash; в каталог &quot;SYS:Classes/Datatypes&quot;. Задача MultiView и других программ подобного рода &mdash; просто вызывать процедуры библиотеки datatypes.library для файла, указанного пользователем.
</p></blockquote><blockquote><p align="justify">
Все типы данных из каталога &quot;DEVS:Classes/DataTypes&quot; должны &quot;пройти регистрацию&quot; в библиотеке &quot;LIBS:datatypes.library&quot;, чтобы та знала об их существовании, а не искала их каждый раз по системе, тратя время попусту, когда возникнет необходимость работы с очередным типом данных. Такой регистрацией и занимается команда ADDDATATYPES, которая запускается из файла &quot;S:Startup-Sequence&quot;, т.е при каждом (ре-)старте Амиги. Вы можете сами запустить ADDDATATYPES с параметром REFRESH из Shell, если в систему были добавлены новые типы данных, а перезапускать Амигу вам не хочется (пожалуй, единственный случай, когда есть необходимость использовать эту команду &quot;вручную&quot;). 
</p></blockquote><blockquote><p align="justify">
Параметрами команды ADDDATATYPES могут быть имена файлов, описывающих типы данных, а также переключатели REFRESH и QUIET. Если имена файлов (с маршрутами, разумеется) не указаны, то ADDDATATYPES регистрирует файлы из каталога &quot;DEVS:DataTypes&quot;. Переключатель REFRESH инициирует поиск более новых версий типов данных, a QUIET &mdash; подавляет вывод каких-либо сообщений при работе команды.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1003>
<b>ALIAS</b> NAME,STRING/F (встроенная)
</a></pre></font></blockquote>
<blockquote><p align="justify">
ALIAS позволяет определить &quot;псевдоним&quot; для любой Shell-команды. Можно, например, превратить &quot;dir&quot; в &quot;d&quot; для краткости, либо вообще сделать все Shell-команды русскими; можно также определить псевдоним для Shell-команды с длинным списком параметров, чтобы не набирать его каждый раз заново. Alias без параметров выводит список всех имеющихся псевдонимов. ALIAS с единственным параметром-псевдонимом для версий ОС выше 1.3 выводит реальную команду ОС, соответствующую псевдониму, а в версии 1.3 уничтожает соответствующий псевдоним. Псевдонимы могут быть распознаны только в том окне Shell, где они были созданы, либо в Shell-окнах, порожденных из этого окна исполнением команды <a href="AMIGA-10.html#A101N">NEWCLI</a> (либо <a href="AMIGA-10.html#A101O">NEWSHELL</a>) т.е. они являются локальными определениями. 
Если необходимо, чтобы некоторые псевдонимы распознавались во всех Shell-окнах без исключения, то необходимо включить соответствующие команды ALIAS в файл &quot;S:Shell-Startup&quot;, который исполняется всякий раз при открытии очередного Shell-окна. Параметр NAME соответствует самому псевдониму, а параметр STRING &mdash; реально существующей командной строке, которая может включать в себя произвольные аргументы, допустимые для данной команды. 
</p></blockquote><blockquote><p align="justify">
При создании псевдонимов нельзя ссылаться на уже существующие псевдонимы &mdash; допустимы ссылки только на реальные команды DOS. 
</p></blockquote>
<blockquote><blockquote><pre>
   Примеры использования:

1. Сократим команду DIR до одной буквы:

   ALIAS d dir
   
2. Определим русскую команду удаления (возможно не пустого) каталога:

   ALIAS прибить DELETE [ ] ALL
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1004>
<b>ASK</b> PROMPT/A (встроенная для ОС 2 и 3)
</a></pre></font></blockquote>
<blockquote><p align="justify">
Эта команда используется исключительно в командных файлах для того, чтобы попросить пользователя ввести с клавиатуры ДА или НЕТ. Ответ пользователя обычно используется для организации ветвления в командном файле. Действие команды заключается в том, что она выводит в текущее Shell-окно некоторую подсказку, специфицированную в качестве параметра команды ASK, а затем ждёт, чтобы пользователь набрал на клавиатуре Y, YES, N или NO; можно также просто нажать клавишу &quot;Ввод&quot;, что равносильно NO.
</p></blockquote><blockquote><p align="justify">
Параметром команды, как уже упоминалось, должна быть строка подсказки. Если в ней есть пробелы, необходимо заключить всю строку в кавычки.
</p></blockquote><blockquote><p align="justify">
Пример &mdash; командный файл, который запрашивает да/нет и затем печатает ответ пользователя: 
</p></blockquote>
<blockquote><blockquote><pre>
ASK "Что вы выбираете - ДА или НЕТ? (Yes/No)" 
IF WARN 
   Echo "Вы сказали - ДА" 
ELSE 
   Echo "Вы сказали - НЕТ" 
ENDIF
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1005>
<b>ASSIGN</b> NAME,TARGET/M,LIST/S,EXISTS/S,DISMOUNT/S,DEFFER/S, 
       PATH/S,ADD/S,REMOVE/S,VOLS/S,DIRS/S,DEVICES/S
</a></pre></font></blockquote>
<blockquote><p align="justify">
Эта команда работает с логическими именами, в частности присваивает их каталогам, дискам и устройствам (или, как ещё говорят, производит связывание имён). Её использование позволяет чрезвычайно гибко &quot;конструировать&quot; свою систему. Работа с логическими устройствами резко облегчает жизнь пользователя &mdash; покажем на конкретном примере. Допустим, упрощенное дерево директорий нашего жёсткого диска соответствует схеме:
</p></blockquote>
<blockquote><p align="center">
<img src="Gfx/AMIGA-scheme1.gif" alt="дерево директорий партиции Work:" width=300 height=150>
</p></blockquote><blockquote><p align="justify">
Теперь, чтобы например, напечатать из Shell какой-либо файл каталога &quot;Work:Paбoтa/Тексты/Деловые&quot;, надо каждый раз набирать имя всего этого маршрута целиком, либо делать этот каталог текущим, используя команду <a href="AMIGA-10.html#A1009">CD</a>. Можно, конечно, воспользоваться командой <a href="AMIGA-10.html#A1003">ALIAS</a> и определить псевдоним. Однако псевдонимы работают только в Shell, да к тому же только в том Shell-процессе, где они были определены. А что делать, например, если вы хотите получать быстрый доступ к файлам каталога, используя риквестеры какого-либо текстового редактора, не &quot;продираясь&quot; к файлу по всему дереву?
</p></blockquote><blockquote><p align="justify">
Если вы обратили внимание, в риквестерах имеется управляющее поле &quot;Л.Имена&quot; (Л. означает &quot;логические&quot;). Что произойдет, если мы щёлкнем по нему? Появится список имен всех устройств, имеющихся в вашей системе. Заметьте, напротив одних устройств указана степень заполнения устройства (например, &quot;Занято 240 Мб&quot;), напротив других &mdash; &quot;Л.Имя&quot;. В чем тут разница? А разница в том, что если напротив имени устройства стоит идентификатор &quot;Л.Имя&quot;, то это устройство &mdash; логическое, т.е. КАК БЫ существующее. На самом деле, это добавочное имя некоторого МАРШРУТА, который &quot;обозвали&quot; соответствующим образом. Исполним, например:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN ПИСЬМА: Work:Работа/Тексты/Личные
</pre></blockquote></blockquote><blockquote><p align="justify">
и у нас появится логическое устройство ПИСЬМА: являющееся на самом деле каталогом &quot;Work:Pa6oтa/Тексты/Личные&quot;. С этого момента нам больше не надо помнить весь маршрут, чтобы добраться до писем. Набираем ПИСЬМА: и всё. 
</p></blockquote><blockquote><p align="justify">
При инициализации системы многие присвоения происходят автоматически. Так, у нас появляются логические устройства С: DEVS: FONTS: L: LIBS: S: SYS:. Все эти каталоги, кроме SYS:, под теми же именами (разумеется, без двоеточия, служащего идентификатором того, что данное имя принадлежит устройству) имеются на диске, с которого производится старт системы. Если же какие-либо из вышеупомянутых каталогов отсутствуют на стартовом диске, то соответствующие имена логических устройств &quot;перепрыгнут&quot; на корневой каталог этого диска, которому в любом случае присваивается логическое имя SYS:. 
</p></blockquote><blockquote><p align="justify">
Назначения логических имен части устройств, необходимых для нормальной работы ОС происходят в командном файле S:Startup-Sequence, автоматически исполняемом при каждом (ре-)старте системы. Устройства же, необходимые для нормальной работы прикладных программ, как правило, назначаются в файле S:User-Startup, который в свою очередь запускается на исполнение из файла S:Startup-Sequence.
</p></blockquote><blockquote><p align="justify"><em>
<img src="Gfx/AMIGA-NB.gif" alt="notabene!" width="40" height="20">
Постарайтесь без крайней нужды не экспериментировать с файлом S:Startup-Sequence, а все требуемые дополнения вносить в S:User-Startup. Если вдруг (чего ни бывает) вы всё же сделаете что-то не то и нормальный старт машины с винчестера станет невозможным, то стартуйте с Workbench-дискеты, войдите в Shell и исполните: 
</em></p></blockquote><blockquote><blockquote><pre>
Ed DH0:S/User-Startup
</pre></blockquote></blockquote>
</p></blockquote><blockquote><p align="justify"><em>
У вас появится возможность либо вернуть User-Startup к первозданному виду, либо исправить вашу ошибку. Кстати говоря, советую тем владельцам Амиг, чей монитор не поддерживает &quot;телевизионный&quot; режим работы с частотой строчной развертки 15 Кгц, а старт системы происходит с жёсткого диска, заблаговременно установить соответствующий режим для Workbench-дискеты с тем, чтобы при старте с неё не оказаться без изображения на мониторе. 
</em></p></blockquote><blockquote><p align="justify">
Каждое последующее присвоение логического имени может использовать результаты предыдущих присвоений. Например, абсолютно допустимы такие строки в вашем файле User-Startup:
</p></blockquote><blockquote><blockquote><pre>
assign ТЕКСТЫ: "WORK:Работа/Тексты"
assign ПИСЬМА: "ТЕКСТЫ:Личные"
</pre></blockquote></blockquote><blockquote><p align="justify">
Как мы видим, для присвоения некоторого логического имени после слова ASSIGN должно вначале следовать присваиваемое имя, а затем маршрут (имя), которому новое имя ставится в соответствие (желательно указывать полный маршрут, т.к. ASSIGN всегда начинает поиск для неполного маршрута, начиная с текущего каталога). 
</p></blockquote><blockquote><p align="justify">
Если ранее с помощью команды ASSIGN было определено другое логическое имя для каталога (устройства), то оно может быть изменено в соответствии с новым именем, указанным в команде ASSIGN. Старое имя при этом отменяется.
</p></blockquote><blockquote><p align="justify">
ASSIGN с единственным параметром &mdash; ранее определенным логическим именем, вызовет изъятие этого логического имени из списка имен существующих логических устройств. С этой же целью можно явно поставить в конец управляющей строки параметр-переключатель REMOVE. Действие этого параметра различно для ОС версии 1.3 и более поздних версий (2 и 3). 
</p></blockquote><blockquote><p align="justify">
В ОС 1.3 комбинация ASSIGN NAME: REMOVE вызовет удаление физического устройства с именем NAME: из системного списка устройств (хотя резервированная этим устройством память не будет возвращена системе).
</p></blockquote><blockquote><p align="justify">
В ОС 2 или 3 исполнение ASSIGN NAME: PATHNAME REMOVE имеет смысл только для изъятия одного из нескольких маршрутов (pathname), соответствующих заданному логическому устройству, имеющему несколько маршрутов. Для удаления (или, как еще говорят, демонтажа) некоторого физического устройства (аналогично REMOVE для DOS 1.3) служит параметр-переключатель DISMOUNT:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN NAME: DISMOUNT
</pre></blockquote></blockquote><blockquote><p align="justify">
Если исполнить ASSIGN без параметров, то мы получим список всех устройств, доступных в нашей системе.
</p></blockquote><blockquote><p align="justify">
Если мы добавим параметр-переключатель LIST в конце ASSIGN-строки, содержащей какие-либо имена и параметры, то после всех необходимых манипуляций с логическими устройствами, выполненными командой ASSIGN, будет выведен список этих устройств.
</p></blockquote><blockquote><p align="justify">
ОС версий от 2.0 и выше позволяет присвоить одно и то же логическое имя сразу нескольким каталогам. Например, представим себе ситуацию, когда на вашем жёстком диске имеется масса различных шрифтов, причем часть из них &mdash; цветные (ColorFonts), а часть &mdash; русифицированные. В этом случае было бы логично создать три каталога для шрифтов &mdash; FONTS, Color_Fonts и Rus_Fonts, чтобы не мешать всё в одну кучу в стандартном каталоге SYS:Fonts (ОС всегда ищет шрифты на устройстве FONTS: которое обычно соответствует каталогу SYS:Fonts). В нашем же случае устройством FONTS: станут три разных каталога сразу. Для этого можно исполнить:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN FONTS:  SYS:FONTS SYS:RUS_FONTS SYS:COLOR_FONTS
</pre></blockquote></blockquote><blockquote><p align="justify">
Правда, в вышеприведённом примере не учитывается тот факт, что логическое устройство FONTS:, соответствующее маршруту SYS:Fonts, создается системой автоматически ещё даже до исполнения файла S:Startup-Sequence. Было бы гораздо уместнее не переопределять все маршруты,а просто добавить для устройства FONTS: новые маршруты SYS:Rus_Fonts и SYS:Color_Fonts. Для этого существует параметр-переключатель ADD. Теперь наше присвоение (которое можно и даже нужно включить в файл S:Startup-Sequence, чтобы ОС имела возможность найти все потребующиеся ей шрифты) будет выглядеть следующим образом:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN FONTS:  SYS:RUS_FONTS SYS:COLOR_FONTS  ADD
</pre></blockquote></blockquote><blockquote><p align="justify">
В результате к уже имеющемуся маршруту, &quot;входящему&quot; в определение устройства FONTS:, добавились еще два.
</p></blockquote><blockquote><p align="justify">
Можно проверить, существует ли в нашей системе какое-либо из логических устройств, и не выводя их полный список. Для этого имеется параметр-переключатель EXISTS. Если исполнить:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN DF1: EXISTS
</pre></blockquote></blockquote><blockquote><p align="justify">
то при наличии в вашей системе дополнительного дисковода DF1: будет выведено его имя (без двоеточия), иначе будет выведено:
</p></blockquote><blockquote><blockquote><pre>
DF1: not assigned
</pre></blockquote></blockquote><blockquote><p align="justify">
и команда возвратит код ошибки 5, что может быть использовано в командных файлах:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN >NIL: DF1: EXISTS 
if WARN
   echo "Дисковод DF1: отсутствует!" 
else
   echo "Дисковод DF1: обнаружен." 
endif
</pre></blockquote></blockquote><blockquote><p align="justify">
Напомним, что &quot;>NIL:&quot; перенаправляет все сообщения в &quot;никуда&quot;, поэтому команда ASSIGN сама по себе ничего не напечатает; в данном случае нас интересует только код ошибки, который она возвращает.
</p></blockquote><blockquote><p align="justify">
Иногда бывает полезно произвести связывание логического имени с конкретным маршрутом не в момент исполнения команды ASSIGN, а в момент использования этого маршрута. Поясним на примере. Допустим, в момент старта машины была исполнена команда:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN FONTS: DF0:Fonts
</pre></blockquote></blockquote><blockquote><p align="justify">
Теперь устройство FONTS: будет соответствовать каталогу Fonts того диска, который находился в дисководе DF0: на момент исполнения команды ASSIGN, и всегда при обращении к FONTS: система будет требовать, чтобы вы вставили этот диск в DF0: (назовем его диск &quot;А&quot;). А что делать, если некоторая программа, находящаяся на другом диске (диск &quot;Б&quot;) нежели тот, с которого вы стартовали, считает что устройство FONTS: уже имеется и находится на диске &quot;Б&quot; в каталоге FONTS? Вот здесь-то и поможет &quot;отложенное&quot; связывание логического имени и конкретного маршрута, происходящее не в момент исполнения ASSIGN, а в момент первого использования этого логического имени. Отложенное связывание происходит при использовании параметра-переключателя DEFER. Если исполнить:
</p></blockquote><blockquote><blockquote><pre>
ASSIGN FONTS: DF0:Fonts DEFER
</pre></blockquote></blockquote><blockquote><p align="justify">
то устройство FONTS: будет соответствовать каталогу Fonts того диска в дисководе DF0:, который там находился при первом обращении к FONTS:.
</p></blockquote><blockquote><p align="justify">
Ещё один параметр-переключатель PATH позволяет сделать процедуру присвоения логического имени еще более гибкой. Присваивание здесь не просто задерживается, как в случае использования DEFER, но к тому же при каждом обращении к заданному логическому устройству происходит заново (без параметра PATH связывание логического имени происходит &quot;раз и навсегда&quot;). Так, в результате, после исполнения
</p></blockquote><blockquote><blockquote><pre>
FONTS: DF0:Fonts PATH
</pre></blockquote></blockquote><blockquote><p align="justify">
при каждом обращении к устройству FONTS: система будет искать каталог Fonts на любом диске, находящемся в дисководе DF0:.
</p></blockquote><blockquote><p align="justify">
Однако при использовании PATH нельзя произвести множественное присвоение нескольких маршрутов одному устройству при помощи, например, параметра-переключателя ADD. Вообще говоря, PATH &mdash; очень удобное средство для тех машин, у которых отсутствует жёсткий диск, т.к. при грамотном использовании может многократно уменьшить необходимость частой замены гибких дисков в дисководах.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1006>
<b>AVAIL</b> CHIP/S,FAST/S,TOTAL/S,FLUSH/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда сообщает об имеющихся ресурсах системной памяти. Будучи использованной без аргументов, она выводит полный список имеющейся в системе свободной и занятой памяти обоих глобальных типов (CHIP и FAST). Можно попросить её быть чуточку менее болтливой, указав с помощью соответствующего параметра-переключателя, что именно нас интересует: отдельно типы CHIP или FAST, либо общее количество свободной памяти в системе (TOTAL). Переключатель можно использовать только один, либо вообще никакого.
</p></blockquote><blockquote><p align="justify">
В полном списке ресурсов системной памяти, выводимом командой AVAIL без параметров, кроме полей Available (свободно), In-Use (занято), Maximum (всего имеется в системе), дополнительных разъяснений может потребовать содержимое поля Largest (наибольший). Здесь указываются длины наибольших непрерывных участков свободной памяти как для FAST, так и для CHIP-памяти. Некоторые программы требуют достаточно длинных непрерывных участков памяти для своей работы и поэтому могут выдать сообщение об ошибке, если система не сможет подобрать для них участок подходящей длины.
</p></blockquote><blockquote><p align="justify">
Параметр FLUSH (выброс) заслуживает отдельного рассмотрения. Компьютер, как вы понимаете, не кассетный магнитофон и никакого выброса микросхем памяти через открывшуюся верхнюю крышку в нем не произойдёт даже при исполнении AVAIL FLUSH. Здесь мы получаем доступ к механизму управления ресурсами. Звучит грозно, а на самом деле всё очень просто. Представим себе для примера ситуацию, когда некоторая программа-редактор текстов попросит операционную систему открыть какой-либо шрифт, который ранее никем другим открыт не был. Система загрузит шрифт целиком с диска в память 
(не грузить же каждый раз по одной букве, в конце концов!) и сообщит редактору, где его можно найти. При этом счетчик программ, пользующихся данным шрифтом, будет установлен равным единице. Поработав со шрифтом, редактор благополучно уходит в небытие, освободив занимаемое им самим (а не шрифтом, который любезно предоставила ему система) место в памяти. Правда, если редактор написан как положено (а другими мы, разумеется, не пользуемся), то перед прекращением своей работы он обязательно попросит систему закрыть открытый ранее шрифт, поскольку он (редактор) далее не намерен 
им пользоваться. Система ответит редактору, что его запрос принят к сведению и редактор может спокойно почить в бозе. Далее система вместо того, чтобы уничтожить шрифт, просто уменьшит на единицу число пользователей открытого шрифта. Шрифт же остается в памяти и система об этом знает. 
</p></blockquote><blockquote><p align="justify">
Теперь если кто-то захочет вновь открыть тот же самый шрифт, то никакой загрузки с диска уже происходить не будет &mdash; система, порывшись в списках загруженных шрифтов и обнаружив требуемый, проста сообщит страждущей программе, где он находится, не теряя времени на возню с диском. Счетчик числа пользователей шрифта будет при этом увеличен на единицу.
</p></blockquote><blockquote><p align="justify">
Ну-с, а если шрифт никому стал не нужен (счетчик пользователей обнулился), то почему он занимает драгоценную память, спросите вы. А занимает потому, что авось кому потребуется в будущем. Не все ли равно что находится в памяти, пока её (памяти) всем хватает. А вот если не хватает?..
</p></blockquote><blockquote><p align="justify">
Все без исключения программы, процессы, задачи и т.д., работающие в системе Амиги получают память в своё распоряжение только по запросу к системе. Это вам не ZX-Spectrum, никакого там LOAD "screen$" CODE 16384,6912 (помните?) здесь и в помине нет. Абсолютные адреса отсутствуют в системе как класс, за единственным исключением, коим является адрес указателя базы библиотеки &quot;exec.library&quot;. Так вот, если какой-либо запрос на резервирование свободной памяти система удовлетворить не может, то возникает ситуация, которая называется memory panic &mdash; что-то сродни бросанию мешков с песком с 
падающего воздушного шара. Система начинает лихорадочно уничтожать ресурсы с нулевыми счётчиками пользователей, пока не наберёт нужное количество свободной памяти. Красиво, не правда ли?
</p></blockquote><blockquote><p align="justify">
Имитирует эту ситуацию исполнение AVAIL FLUSH. Обычно этот параметр используется только для того, чтобы посмотреть какое реальное количество свободной памяти имеется на данный момент времени в вашей системе. Все те цифры, касающиеся свободной памяти, которые выводят как сама команда AVAIL (без FLUSH), так и любые другие (включая Workbench и Directory OPUS), не учитывают той памяти, которая МОГЛА БЫ быть освобождена в случае необходимости и в силу этого обстоятельства практически всегда являются заниженными. Поэтому пусть вас не пугает ситуация, когда вы, например, смотрите сколько у вас 
памяти в системе, затем загружаете какую-либо программу, а после выхода из неё вдруг окажется, что часть свободной памяти куда-то пропала. Бывают, конечно, программы которые после себя не все убирают&hellip; Если у вас есть сомнения на этот счет, то проверить их можно либо исполнив AVAIL FLUSH до и после запуска подозрительной программы, либо зафиксировав величину свободной памяти ПОСЛЕ первого запуска программы, а затем запустив и выйдя из нее ещё раз, сравнить величину свободной памяти с первоначальной. Первый способ, вообще говоря, более точен, поскольку при повторном запуске программа 
вполне могла открыть какой-либо ресурс, который не был открыт при первом запуске, и это спутает все карты. 
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1007>
<b>BINDDRIVERS</b>
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда пытается обнаружить в каталоге &quot;SYS:Expansion&quot; драйверы для каких-либо подключенных к Амиге дополнительных устройств и в случае успеха связывает их с ОС. Драйверы дополнительных устройств обычно поставляются вместе с самими устройствами и автоматически помещаются в директорий &quot;SYS:Expansion&quot; во время инсталяции устройства (между прочим, совершенно необязательно, чтобы дополнительное устройство имело свой собственный драйвер; в системе существует т.н. AutoConfig-протокол, с помощью которого Амига может обойтись и без отдельного драйвера, пообщавшись с устройством в момент старта). 
Примерами устройств, обычно имеющих собственные драйверы, могут служить т.н. мост-карты (bridgeboards), эмулирующие PC или Macintosh, а также неавтобутирующиеся винчестеры.
</p></blockquote><blockquote><p align="justify">
BINDDRIVERS является частью стандартного файла &quot;S:Startup-Sequence&quot;, поэтому распознавание подключённых устройств осуществляется на этапе старта системы. Однако, если каталог Expansion пуст, то BINDDRIVERS можно спокойно удалить (или закомментировать) из (в) &quot;S:Startup-Sequence&quot;.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1008>
<b>BREAK</b> PROCESS/A/N,ALL/S,C/S,D/S,E/S,F/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда устанавливает флажок останова для некоторого процесса &mdash; практически то же самое, что нажатие комбинации клавиш CTRL + С (+ D, + Е, + F). Реагировать на флажок или нет &mdash; это уж дело самого процесса. Большинство стандартных команд AmigaOS прекращают работу, получив сигнал останова. Параметрами для BREAK могут быть как номер останавливаемого процесса (подробнее см. описание команды <a href="AMIGA-10.html#A102B">STATUS</a>), так и аналоги нажимаемых вместе с CTRL клавиш при &quot;ручной&quot; остановке процесса. Исполнив BREAK с номером процесса в качестве параметра можно затормозить даже процесс заднего плана (запущенный с помощью команды <a href="AMIGA-10.html#A101Y">RUN</a>), до которого с клавиатуры не достучаться, поскольку у него вполне может не быть никакого окна. Параметр ALL выставляет все 4 флажка (С, D, Е и F) сразу, BREAK без параметров &mdash; только флажок C.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1009>
<b>CD</b> DIR/K (встроенная в ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Позволяет изменить текущий каталог (если задан параметр &mdash; имя этого каталога), либо показать имя текущего каталога, (если параметр отсутствует). Имя может быть как полным, так и неполным маршрутом. Неполный маршрут &quot;отсчитывается&quot; от текущего каталога. Если параметром является символ &quot;/&quot;, то происходит возврат на уровень выше по дереву каталогов относительно текущего каталога. Символов &quot;/&quot; может быть несколько, за ними может следовать маршрут. Покажем на примере:
</p></blockquote><blockquote><p align="center">
<img src="Gfx/AMIGA-scheme2.gif" alt="дерево директорий партиции Work:" width=427 height=149>
</p></blockquote><blockquote><p align="justify">
Предположим, что текущий каталог &mdash; &quot;Wогк:Работа/Тексты/Деловые&quot;. Мы же хотим перейти в каталог &quot;Work:Devs/Classes&quot; без использования полного маршрута (т.е. без упоминания в маршруте корневого каталога Work:). Для этого достаточно набрать:
</p></blockquote><blockquote><blockquote><pre>
cd ///Devs/Classes
</pre></blockquote></blockquote><blockquote><p align="justify">
А для того, чтобы перейти в каталог &quot;Тексты&quot;, можно просто набрать:
</p></blockquote><blockquote><blockquote><pre>
cd /
</pre></blockquote></blockquote><blockquote><p align="justify">
Для возврата в корневой директорий текущего устройства можно использовать единственный символ &mdash; двоеточие.
</p></blockquote><blockquote><p align="justify">
В версиях ОС 2 и 3 можно исполнить команду CD даже не упоминая её имени &mdash; достаточно набрать маршрут (исключением является ситуация, когда маршрут содержит пробелы &mdash; тогда использование CD обязательно и кроме того, маршрут должен быть заключен в кавычки).
</p></blockquote><blockquote><p align="justify">
Еще одной дополнительной возможностью, предоставляемой этими версиями ОС является то, что можно использовать шаблоны в качестве параметра (при условии, что под шаблон подпадает одно-единственное имя каталога).
</p></blockquote><blockquote><p align="justify">
Одно замечание для тех, кто привык работать в других операционных системах. ОС Амиги во главу угла ставит не физические, а логические имена устройств (напомним, что для дисководов логическим именем и, соответственно, именем корневого каталога является имя диска, находящегося в этом дисководе). Что из этого следует?
</p></blockquote><blockquote><p align="justify">
Представим себе ситуацию, что в дисководе DF0: находится диск с именем &quot;Work&quot;. Если исполнить:
</p></blockquote><blockquote><blockquote><pre>
cd DF0:
</pre></blockquote></blockquote><blockquote><p align="justify">
то текущим станет корневой каталог этого диска. Теперь заменим диск &quot;Work&quot; на какой-либо другой и исполним, например, команду DIR. Система немедленно попросит нас вставить диск &quot;Work&quot; в дисковод DF0, а уж затем исполнит DIR. Если мы хотим, чтобы текущим стал какой-либо каталог другого диска (например, в дисководе DF0:), то нам необходимо вставить нужный диск, а уж затем исполнить CD DF0:. Если у вас несколько дисководов, то можно вообще просто указать имя диска, совсем не упоминая конкретный дисковод. Если такого диска нет ни в одном из дисководов, то система попросит вас вставить его в любой из имеющихся.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100A>
<b>CHANGETASKPRI</b> PRI=PRIORITY/A/N,PROCESS/K/N
</a></pre></font></blockquote><blockquote><p align="justify">
Поскольку Амига &mdash; машина многозадачная, то вам придется привыкнуть к специфической организации ОС, которая позволяет бесконфликтно обслуживать множество одновременно работающих программ. Здесь надо объяснить два основополагающих понятия многозадачности &mdash; <em>процесс</em> (process) и <em>задача</em> (task). Но сначала небольшая иллюстрация, поясняющая логическую структуру многозадачной работы Амиги:
</p></blockquote><blockquote><p align="center">
<img src="Gfx/AMIGA-scheme3.gif" alt="дерево процессов и порождённых ими задач" width=488 height=150>
</p></blockquote><blockquote><p align="justify">
Пойдем снизу вверх &mdash; от того, что имеем, к тому, что желаем. На самом нижнем уровне Амига, по сути, является ни чем иным как набором некоторых системных ресурсов, таких как процессор, память, дисковод, экран дисплея и т.д. Если мы хотим, чтобы несколько программ одновременно пользовались одними и теми же ресурсами, то очевидно, что должен существовать некий системный арбитр, осуществляющий распределение ресурсов (в частности, процессорного времени) 
между заинтересованными в них программами более высокого уровня. В Амиге эти функции возложены на библиотеку &quot;exec.library&quot; (от английского слова execute &mdash; исполнять). Образно говоря, работу exec.library по переключению задач можно представить в виде рулетки игры &quot;Что? Где? Когда?&quot;, когда разложенным письмам на столе соответствуют исполняемые задачи, а стрелка указывает, какую задачу в данный момент исполняет процессор. Вот только задачи, в 
отличие от что-где-когда-шных писем, не являются равноценными, и у каждой задачи есть свой приоритет, который указывает относительную степень срочности исполнения этой задачи по отношению к другим. Стрелка проходит всегда от задач с наивысшим приоритетом (который, кстати, равен 127), к задачам с низшим (равным &ndash;128). Поэтому, если задачи с высоким приоритетом требуют массу процессорного времени, то дело может вообще не дойти до обслуживания каких-либо 
низкоприоритетных задач, если исчерпан лимит времени на исполнение всех имеющихся задач.
</p></blockquote><blockquote><p align="justify">
Поясним на примере. Допустим, в вашей системе установлен гаситель экрана (бланкер), который каждые пару минут начинает рисовать движущиеся кривые на экране, если клавиатура и мышка находятся в покое. В это время вы начинаете закачивать к себе файл по модему и любуетесь на этот процесс, не прикасаясь ни к мышке ни к клавиатуре. Срабатывает бланкер и начинает вырисовывать свои кривые. Если модем у вас &mdash; высокоскоростной, а Амига не слишком быстрая (скажем на 
процессоре 68000/7Мгц), то процессор может быть предельно загружен совместной работой с модемом, а тут на него еще сваливается &quot;проснувшаяся&quot; (что это значит, будет объяснено далее) задача по обслуживанию бланкера. Представим теперь, что будет, если приоритеты терминальной программы, обслуживающей модем, и программы-бланкера равны и процессорное время распределяется поровну между ними: часть данных с модема будет неминуемо потеряна, т.к. процессор будит 
возиться с бланкером, а не забирать данные с модема ровно половину своего времени! Вот тут-то нас и спасают приоритеты. Просто ставим приоритет терминальной программы выше, чем приоритет бланкера &mdash; и всё в порядке. Правда, теперь движение линии по экрану будет происходить только тогда, когда процессор заканчивает очередной цикл работы с модемом, но в данном случае это никак не фатально. Кстати, если уж речь зашла о модеме, то ставьте пятый приоритет своих 
терминальных программ, и во время перекачки файлов можете что угодно делать на своей машине &mdash; ошибок по части модема не будет!
</p></blockquote><blockquote><p align="justify">
Разница между понятиями процесса и задачи состоит в том, что процесс может пользоваться функциями DOS, а задача &mdash; нет, поскольку вызов многих ОС-функций по сути является созданием или активацией некоторой задачи; представим, что было бы, если бы активированная задача сама была бы в состоянии вызвать ОС-функцию, которая опять бы создала копию задачи, которая опять бы вызвала ОС... Замкнутый круг, в результате которого &mdash; &quot;зависание&quot; машины. 
Поэтому уровень ОС на приведенной иерархической схеме соответствует уровню процессов.
</p></blockquote><blockquote><p align="justify">
Иллюзия одновременного исполнения нескольких программ создается за счет быстрого переключения активных процессов (задач), что происходит 50 раз в секунду.
</p></blockquote><blockquote><p align="justify">
Задача (процесс) может находиться как в активном состоянии (или в очереди на получение процессорного времени), так и &quot;спать&quot;, т.е. ожидать некоторого события, чтобы перейти в активное состояние. Если задача не активна, то затраты процессорного времени на её обслуживание близки к нулю. В связи с этим большая просьба для господ программистов: никогда не пишите циклы, которые вертятся, ожидая какого-либо внешнего события! На Амиге это считается грубейшей 
ошибкой и признаком вашего полного программистского бессилия. Вам необходимо сообщить системе, какие именно события вас интересуют, после чего воспользоваться чем-нибудь вроде функции библиотеки &quot;exec.library&quot; Wait(). Как только произойдет одно из интересующих вас событий, вы выскочите из Wait() и можете спокойно анализировать что там случилось и что делать дальше.
</p></blockquote><blockquote><p align="justify">
Теперь, после затянувшегося вступления, можно и про CHANGETASKPRI рассказать. Эта команда позволяет изменить приоритет некоторого CLI-процесса (приоритет задач с помощью CHANGETASKPRI менять нельзя), выделив ему большую или меньшую долю процессорного времени. В AmigaOS практически всегда одновременно работают несколько процессов и/или задач (например, на компьютере автора только при старте системы запускаются сразу 42 процесса/задачи, которые далее работают постоянно). 
Вы можете посмотреть, что творится в вашей системе, исполнив команду TASKLIST с диска, прилагаемого к этой книге.
</p></blockquote><blockquote><p align="justify">
Обычный приоритет задач/процессов равен нулю. Старайтесь не поднимать его выше пяти, если вы не вполне отдаете себе отчет в последствиях своих действий. В системе всегда работает несколько задач, которые должны очень быстро реагировать на различные внутренние события и возможное замедление их реакции на эти события из-за неоправданно высокого приоритета вашей задачи ни к чему хорошему не приведет. По аналогии с человеческим организмом, сердце должно биться, даже если 
вы выступаете с трибуны с отчётным докладом, какие бы судьбоносные тезисы в этом докладе не излагались. Если же вы опустите приоритет ниже, чем &ndash;5, то ваш процесс/задача может почти не пробуждаться к активной жизни (в зависимости от степени загруженности процессора).
</p></blockquote><blockquote><p align="justify">
Обязательным параметром команды служит номер приоритета; дополнительным параметром может служит номер Shell-процесса, чей приоритет вы желаете изменить. Если второй параметр отсутствует, то изменение коснется текущего Shell-процесса. Номеру процесса (если он есть) обязательно должно предшествовать ключевое слово PROCESS.
</p></blockquote>
<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100B>
<b>CONCLIP</b> CLIPUNIT=UNIT/N,OFF/S
</a></pre></font></blockquote><blockquote><p align="justify">
Клип-устройство Амиги является чрезвычайно удобным средством обмена данными между программами. Команда CONCLIP позволяет использовать клип-устройство не только для обмена данными между прикладными программами, но также для копирования/вставки блоков текста в Shell-окнах. Если не исполнять CONCLIP, то устройство управления Shell-окнами &quot;console.device&quot; резервирует свой собственный буфер для операций копирования/вставки текста, и, вследствие этого, текст, находящийся в буфере, 
недоступен для программ, честно использующих клип-устройство.
</p></blockquote><blockquote><p align="justify">
CONCLIP исполняется в файле &quot;S:Startup-Sequence&quot;, разрешая клип-операции Shell-окон сразу же после старта машины. Параметром может служить номер модуля клип-устройства (в диапазоне от нуля до 255; по умолчанию выбирается нулевой модуль). Без особой необходимости нет смысла назначать ненулевой модуль, т.к. многие прикладные программы работают только с нулевым модулем. Для отключения клип-поддержки Shell-окон можно использовать параметр-переключатель OFF, 
хотя смысл подобной операции более чем сомнителен.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100C>
<b>COPY</b> FROM/M,TO/A,ALL/S,QUIET/S,BUF=BUFFER/K/N,CLONE/S,DATES/S,
     NOPRO/S,COM/S,NOREQ/S
</a></pre></font></blockquote><blockquote><p align="justify">
</p></blockquote><blockquote><p align="justify">
Ну какая же ОС обойдется без команды копирования? Видимо, никакая (вроде бы даже в MS-DOS есть что-то похожее&hellip;).
</p></blockquote><blockquote><p align="justify">
Команда COPY копирует один или несколько файлов и/или каталогов, специфицированных заданным маршрутом источника (маршрутами источников) в новое устройство, определяемое обязательно задаваемым маршрутомприемника (возможно, &quot;на лету&quot; меняя имя копируемого объекта или объектов). Если маршрутприемника отличается от маршрута источника и уже содержит файлы с теми же именами, что копируемые, то они будут вначале удалены, а затем уже произойдет собственно копирование. 
Если какие-либо из удаляемых при этом файлов защищены от удаления (сброшен признак &quot;Удаляемый&quot;), то будет выдано сообщение об ошибке. Ни при каких условиях команда COPY не может создать файл с тем же именем, что и копируемый, находящийся по тому же маршруту, что маршрут источника.
</p></blockquote><blockquote><p align="justify">
Необязательный параметр FROM сообщает системе, что непосредственно за ним следует спецификация маршрута/источника. Примеры:
</p></blockquote><blockquote><blockquote><pre>
COPY SYS:Работа  RAM:            &mdash; копировать файл
COPY FROM  SYS:Работа  ТО  RAM:    &quot;Работа&quot; с системного
COPY SYS:Работа ТО RAM:            диска в RAM-диск 
</pre></blockquote></blockquote><blockquote><p align="justify">
Если заданы параметры и ТО и FROM, то порядок спецификации маршрута-источника и маршрута-приёмника можно поменять на обратный:
</p></blockquote><blockquote><blockquote><pre>
COPY TO  RAM:  FROM  SYS:Работа
</pre></blockquote></blockquote><blockquote><p align="justify">
Если спецификация источника вообще отсутствует, что определяется по тому факту, что первым параметром является ТО, то источником считается весь текущий каталог. Все его файлы и, возможно, подкаталоги будут скопированы (в версии ОС 1.3 ссылкой на текущий каталог может быть также пара кавычек &quot;&quot;)- Это единственный случай, когда использование ТО обязательно. Примеры:
</p></blockquote><blockquote><blockquote><pre>
COPY TO RAM:      &mdash; скопировать весь текущий каталог в RAM-диск 
                          без подкаталогов. 
COPY TO RAM: ALL  &mdash; скопировать весь текущий каталог в RAM-диск вместе 
                          со всеми подкаталогами. 
COPY &quot;&quot; TO RAM:   &mdash; только для ОС версии 1.3 
</pre></blockquote></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL включает полное копирование всех подкаталогов маршрута-источника; при этом создаётся дубликат всего дерева каталогов (если считать маршрут-источник корнем этого дерева). При отсутствии ALL копируются только файлы каталога-источника; возможно имеющиеся в нем подкаталоги игнорируются.
</p></blockquote><blockquote><p align="justify">
Для выборочного копирования файлов (ОС 1.3) или файлов и каталогов (ОС 2 и 3) можно воспользоваться шаблонами (описаны в главе &quot;Шаблоны&quot;). ОС 2 и 3 также даёт возможность явно сообщить несколько имён файлов, которые вы намерены скопировать; имена должны быть разделены пробелами. Примеры:
</p></blockquote><blockquote><blockquote><pre>
COPY SYS:Работа SYS:Письмо RAM:  &mdash;  скопировать 2 файла в RAM-диск. 
COPY (а|б|в)#? Работа RAM:       &mdash;  скопировать все файлы текущего
                                    каталога, чьи имена начинаются
				    с букв &quot;а&quot;, &quot;б&quot; или &quot;в&quot;, а также
				    файл &quot;Работа&quot; в RAM-диск.
</pre></blockquote></blockquote><blockquote><p align="justify">
Копирование под другим именем требует явного указания нового имени в маршруте-приемнике. Пример:
</p></blockquote><blockquote><blockquote><pre>
COPY SYS:Работа SYS:Резерв/Наработки   &mdash; скопировать файл &quot;Работа&quot;
                                         в подкаталог &quot;SYS:Резерв&quot;
				         под новым именем &quot;Наработки&quot;.
</pre></blockquote></blockquote><blockquote><p align="justify">
Обратите внимание: если в каталоге &quot;SYS:Peзepв&quot; уже существует подкаталог &quot;Наработки&quot;,
то файл &quot;Работа&quot; будет скопирован именно туда под своим собственным именем! Ведь в маршруте приемника 
явно не указывается, что такое &quot;Наработки&quot; &mdash; новое имя файла или подкаталог каталога &quot;Работа&quot;. 
Система вполне резонно считает, что если в каталоге &quot;Резерв&quot; есть подкаталог &quot;Наработки&quot;, то вы желаете 
скопировать файл именно туда &mdash; в любом случае в каталоге &quot;Резерв&quot; не могут одновременно существовать и подкаталог 
и файл с одним и тем же названием.
</p></blockquote><blockquote><p align="justify">
Дублирование файла в некотором каталоге требует просто указания имени файла-дубликата, которое, само собой разумеется, должно отличаться от имени исходного файла. Пример:
</p></blockquote><blockquote><blockquote><pre>
COPY Работа Наработки  &mdash; создать в текущем каталоге копию
                         файла &quot;Работа&quot; под именем &quot;Наработки&quot;
</pre></blockquote></blockquote><blockquote><p align="justify">
Теперь &mdash; то, что касается копирования целых каталогов. Если каталоги, соответствующие маршрутуприемника, отсутствуют на диске, то ОС 1.2 выдаст сообщение об ошибке, а все версии ОС, начиная с 1.3, создадут требуемые каталоги и продолжат копирование.
</p></blockquote><blockquote><p align="justify">
Копирование файлов может происходить не только на диск, но вообще на любое устройство, имеющее понятие о том, что нужно делать с файлом, который &quot;сваливается ему на голову&quot;. Это может быть, например принтер (устройство PRT:), параллельный (PAR:) 
или последовательный (SER:) порты, а также устройство SPEAK:, которое просто прочитает то, что в него скопировали.
</p></blockquote><blockquote><p align="justify">
Обычно копирование сопровождается выводом информации о том какие файлы были скопированы. Если вы использовали шаблоны или параметр-переключатель ALL, то выдаваемый на-гора список может быть весьма внушительным. Здесь, возможно, пригодится использование 
параметра-переключателя QUIET, который заставит команду COPY работать без вывода всей этой информации. QUIET практически всегда используется с COPY в командных файлах, когда вывод информации о скопированных файлах может оказаться совсем уж нежелательным.
</p></blockquote><blockquote><p align="justify">
Команда COPY во время своей работы создает буферную область в памяти, которая используется как перевалочный пункт для содержимого копируемых файлов. Размер этой области по умолчанию составляет 200 буферов по 512 байт каждый (всего 100 Кб). При операциях 
копирования, где источником и/илиприемником служит какое-либо устройство, организованное в оперативной памяти компьютера, использование буферов достаточно бессмысленно, т.к. вместо ускорения процесса копирования, что всегда дает использование буферов при 
операциях типа диск-диск, мы получаем обратный результат. Использование параметра &mdash; ключевого слова BUF или BUFFERS, за которым следует некоторое число, позволяет специфицировать требуемое число буферов для конкретной операции копирования. Если у вас 
предостаточно памяти, но только один дисковод, есть смысл устанавливать максимально возможное число буферов, с тем чтобы свести к минимуму весьма раздражающую операцию по перестановке дисков в дисководе. ОС 2 и 3 позволяют задать значение параметра BUF=0 при 
этом резервируется область памяти размерами точно с копируемый файл (конечно, если хватает памяти).
</p></blockquote><blockquote><p align="justify">
При операции копирования дата и время скопированных объектов устанавливаются на текущее время (т.е. на тот момент, когда произошло копирование). Для того, чтобы ни дата ни время не изменились, необходимо использовать параметр-переключатель DATES.
</p></blockquote><blockquote><p align="justify">
Поле файлового комментария по умолчанию не копируется, т.е. скопированный объект всегда имеет пустой комментарий. Для копирования комментариев необходимо использовать параметр-переключатель СОМ. 
Вместо использования пары параметров-переключателей СОМ DATES можно использовать единственный параметр-перключатель CLONE.
</p></blockquote><blockquote><p align="justify">
Признаки защиты скопированного файла по умолчанию также копируются. Если желательно, чтобы признаки скопированного файла приняли стандартные значения, т.е. RWED &mdash; Readable, Writeable, Executable, Deleteable (читаемый, изменяемый, исполняемый, удаляемый), то 
необходимо использовать параметр-переключатель NOPRO.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель NOREQ подавляет возможный вывод риквестера запроса тома, который команда COPY не может найти. Например, если мы попытаемся исполнить:
</p></blockquote><blockquote><blockquote><pre>
COPY  Work:Таблица  RAM:
</pre></blockquote></blockquote><blockquote><p align="justify">
а диска (устройства, маршрута, логического имени) поименованного как Work: в системе на момент исполнения COPY нет, будет выведен риквестер с просьбой вставить диск &quot;Work&quot; в любой дисковод. При исполнении COPY в командном файле зачастую гораздо логичнее было бы 
вернуть код ошибки вместо активации риквестера &mdash; для чего и существует NOREQ.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100D>
<b>CPU</b>        [NO]Burst/S   [NO]CopyBack/S    [NO]InstBurst/S
           [NO]Cache/S   [NO]NOMMUTEST/S     [NO]FastROM/S
       [NO]InstCache/S   [NO]DataCache/S        [NO]TRAP/S
   [NO]ExternalCache/S   [NO]DataBurst/S           CHECK/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда версий ОС 2 и 3 позволяет управлять режимом работы центрального процессора с помощью приведенных параметров, абсолютное большинство из которых являются переключателями. Мы будем объяснять только включение различных функций, выключение осуществляется парным NО-параметром.
</p></blockquote><blockquote><p align="justify">
Будучи использованной без параметров, CPU сообщит нам о типе используемого в вашем компьютере центрального процессора и (если таковой имеется) сопроцессора для операций с плавающей точкой (FPU &mdash; Floating Point Unit), а также о режимах работы процессорной кэш-памяти (для процессоров, 
начиная с 68020).
</p></blockquote><blockquote><p align="justify">
Но сначала несколько слов по поводу различных типов процессоров, используемых в Амигах.
</p></blockquote><blockquote><p align="justify">
Процессор 68000 хоть и красивая штука, но в настоящее время уже безнадежно устаревшая. Применять какие-либо из CPU-переключений к нему бессмысленно, т.к. все они предназначены для более мощных процессоров (начиная с 68020). В моделях А500, А500+, А600 и А2000 процессор 68000 работает как правило 
на тактовой частоте 7 Мгц (крайне редко встречаются старые платы акселераторов с 68000 на 14 мгц). Процессоры 68010 никогда &quot;штатно&quot; на Амиги не устанавливались. 68020 (14 Мгц) является стандартным процессором для А1200, 68030 (25 Мгц) &mdash; для АЗ000 и части А4000 (модели 4000/030), 
и наконец, 68040 (25 Мгц) изначально устанавливается в 4000/040. Внутренняя тактовая частота для 68040 в 2 раза выше внешней, т.е. составляет 50 Мгц. Все процессоры, начиная с 68020 &mdash; 32-разрядные, как внутри, так и снаружи. В настоящее время уже появились акселераторы CyberStorm на процессорах 
68060, 64-разрядные по внутренней архитектуре, которые в минимальном варианте дают 4-кратное ускорение работы по сравнению с 68040/25 Мгц (скорость порядка 80 миллионов операций в секунду).
</p></blockquote><blockquote><p align="justify">
Процессоры, кроме того, бывают &quot;полные&quot; (например, имеющие маркировку RC) и &quot;урезанные&quot; (с маркировкой ЕС). ЕС-процессоры не содержат устройства управления памятью (MMU), которое, впрочем, в повседневной работе по-настоящему необходимо только в том случае, если вы &mdash; программист 
и желаете тестировать ваши программы на несанкционированный доступ к памяти с помощью специальных утилит типа Enforcer.
</p></blockquote><blockquote><p align="justify">
Все процессоры, начиная с 68020 используют т.н. встроенную кэш-память для ускорения своей работы. Поскольку память этого типа находится на том же кристалле, что и сам процессор, время доступа к ней существенно меньше, нежели к оперативной памяти системы, что дает значительный выигрыш в быстродействии. 
Кэш делится на 2 типа &mdash; кэш команд и кэш данных. В небольшой табличке мы показываем имеющиеся у различных процессоров объемы и типы кэш-памяти:
</p></blockquote>
<table align="center" border=0>
<caption align="center">
<th>&nbsp;&nbsp;CPU&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;Кэш команд&nbsp;&nbsp;</th>
<th>&nbsp;&nbsp;Кэш данных&nbsp;&nbsp;</th>
</caption>
<tr align="center">
<td>68020</td>
<td>256 байт</td>
<td>&mdash;</td>
</tr>
<tr align="center">
<td>68030</td>
<td>256 байт</td>
<td>256 байт</td>
</tr>
<tr align="center">
<td>68040</td>
<td>4 Кб</td>
<td>4 Кб</td>
</tr>
</table>
</p></blockquote><blockquote><p align="justify">
Кроме основного процессора в состав системы может также входить сопроцессор для выполнения операций с плавающей точкой (FPU), который либо выполнен в виде отдельной микросхемы (68881 или 68882), либо находится на том же кристалле, что и основной процессор (68040). FPU значительно ускоряет работу с числами в вещественном формате, что крайне существенно для всех серьезных программ обработки изображений (трассировки лучей). Некоторые из этих программ при отсутствии FPU отказываются выполнять часть своих функций (например, ADPro), другие (например, LightWave или Real 3D) вообще имеют по 2 различных версии &mdash; для систем с FPU и без него. В любом случае, сколько-нибудь серьёзная работа с изображениями без FPU невозможна.
</p></blockquote><blockquote><p align="justify">
Но вернемся к описанию различных параметров команды CPU.
</p></blockquote>
<blockquote><table border=0>
<tr>
<td width="10%" valign="top" align="right">Burst&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
режим &quot;вспышек&quot; процессора 68030, который позволяет резко ускорить обмен данными между основной и кэш-памятью в том случае, если основная память поддерживает этот режим. Для 68040 CPU режим автоматически считается включенным, если включена соответствующая кэш-память. Исполнение Burst равносильно исполнению InstBurst и DataBurst.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">InstBurst&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">включение режима &quot;вспышек&quot; для кэш-памяти команд.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">DataBurst&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">включение режима &quot;вспышек&quot; для кэш-памяти данных.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">Cache&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">включение все типы кэш-памяти.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">InstCache&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">включает только кэш-память команд.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">DataCache&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">включает только кэш-память данных.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">ExternalCache&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">включает внешнюю кэш-память, если таковая имеется в вашей системе.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">CopyBack&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">включается специальный режим работы кэш-памяти данных процессора 68040. В этом случае запись каких-либо данных в память означает только то, что они попадут в кэш-память данных. Перепись же данных из кэш-памяти в основную память системы происходит только тогда, когда это действительно необходимо. Включение CopyBack-режима резко ускоряет работу процессора 68040. Следует заметить, что существуют отдельные программы, несовместимые с этим режимом.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">TRAP&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">включение специальной ловушки, отслеживающей факты несанкционированного доступа к запрещенным областям памяти. Для процессора 68000 не работает. Используется исключительно программистами при отладке программ, хотя для этой цели гораздо лучше подходят специальные утилиты типа Enforcer, выполняющие аналогичные задачи. При использовании TRAP необходимо иметь канал вывода данных (скорость 9600 бод), подключенный через последовательный порт Амиги.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">FastROM&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">скопировать всю информацию из постоянного запоминающего устройства (ПЗУ) в оперативную память системы. Пользоваться далее информацией из оперативной памяти при обращениях к ПЗУ. Подобную конфигурацию системы можно использовать только при наличии в системе устройства управления виртуальной памятью (MMU). За счет потери части оперативной памяти (256 Кб для KickStart < 2 или 512 Кб для Kickstart 2 и 3) вы выигрываете в быстродействии, т.к. доступ к ПЗУ занимает больше времени, нежели доступ к 32-разрядной оперативной памяти. Чем выше быстродействие процессора, тем больше выигрыш по скорости. В модели А4000 этот режим включается автоматически при старте системы.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">NOMMUTEST&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">позволяет функции CPU FastROM произвести все необходимые манипуляции с устройством управления памятью (MMU) не проверяя, задействовано ли MMU на момент исполнения FastROM или нет.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">CHECK&nbsp;&mdash;&nbsp;</td>
<td width="100%" valign="top" align="justify">дополнительным параметром, который должен следовать после этого ключевого слова, является тип центрального процессора (68010, 68020, 68030 или 68040), либо тип математического сопроцессора (68881, 68882 или просто FPU, чтобы узнать, присутствует ли он вообще), либо MMU. В случае, если имеющийся в вашей системе центральный процессор или математический сопроцессор ниже рангом, нежели указанный, либо математический сопроцессор или устройство управления памятью отсутствуют, команда CPU CHECK возвратит код 5 (т.н. WARN, или код предупреждения). Пример использования в командном файле:
</td></tr>
</table></blockquote>
</p></blockquote><blockquote><blockquote><pre>
CPU >NIL: CHECK FPU
IF WARN
   Echo "Отсутствует сопроцессор!"
ELSE
   Echo "Сопроцессор имеется в вашей системе."
ENDIF
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100E>
<b>DATE</b> DAY,DATE,TIME,TO=VER/K
</a></pre></font></blockquote><blockquote><p align="justify">
Используется для того, чтобы показать или изменить системное время. Не следует путать возможно имеющиеся в вашей Амиге часы реального времени с системными часами &mdash; это разные вещи. Часы реального времени с автономным питанием от аккумулятора работают всегда, системные же часы &mdash; только тогда, когда включено питание компьютера. В момент старта системы значения даты и времени из часов реального времени (если они есть) автоматически переписываются в системные часы (только для ОС 2 и 3; более ранние версии ОС требуют для этой цели исполнения <a href="AMIGA-10.html#A1021">SETCLOCK LOAD</a>). В случае отсутствия часов реального времени, ОС обшаривает диск, с которого был произведён старт системы, в поисках файла с наибольшим значением времени создания/изменения и устанавливает системное время несколько вперёд (на 11 секунд) по отношению к нему.
</p></blockquote><blockquote><p align="justify">
Если вы изменили системное время с помощью команды DATE, то эти изменения никак не отражаются на показаниях часов реального времени до тех пор, пока вы не исполните команду <a href="AMIGA-10.html#A1021">SETCLOCK SAVE</a>.
</p></blockquote><blockquote><p align="justify">
Показания часов реального времени нигде и никогда в программах не используются &mdash; они всегда идут &quot;на заднем плане&quot;. Где бы ни требовались текущие значения времени, они всегда берутся исключительно из системных часов.
</p></blockquote><blockquote><p align="justify">
Команда DATE без параметров просто выводит текущие дату и время. Дата выводится в соответствии с шаблоном ДД-МММ-ТГ (например, 20-Jun-95). Если версия ОС больше или равна 2.1 и в вашей системе установлен русификатор версии 5, то дата будет выводиться по-русски (например, 20-Июн-95). Ввод даты также может осуществляться по-русски.
</p></blockquote><blockquote><p align="justify">
Если после команды ввести дату в соответствии с шаблоном, то она запишется в системные часы. Перед датой может стоять необязательное слово DAY. Вместо конкретной даты допускается использование слов &quot;вчера&quot;, &quot;завтра&quot; и &quot;будущее&quot;, причем &quot;будущее&quot; устанавливает дату на послезавтра. Английскими аналогами этих слов для тех, у кого не установлен русификатор 5-й версии, являются &quot;yesterday&quot; &quot;today&quot; и &quot;future&quot;.
</p></blockquote><blockquote><p align="justify">
Годы с 78 по 99 трактуются как с 1978 по 1999; с 0 по 45 &mdash; как 2000 по 2045. Значения от 46 до 77 воспринимаются, как ошибочные. Если вы случайно поставите будущее время в системе, то время созданных/модифицированных с этого момента файлов будет показано как &quot;будущее&quot; (разумеется, после того, как вы спохватитесь и правильно скорректирует системное время), а вы даже не сможете определить порядок создания/изменения файлов с такой маркировкой. Для коррекции времени создания изменения файла (файлов) служит команда <a href="AMIGA-10.html#A1022">SETDATE</a>.
</p></blockquote><blockquote><p align="justify">
Вместо даты можно ввести день недели, причём дата всегда при этом движется вперёд от текущей, даже если вы установите текущий день! День недели можно вводить в двух вариантах &mdash; полном (например, &quot;воскресение&quot;) и неполном (&quot;вс&quot;), хотя более старые версии ОС, нежели 3-я могут не поддерживать сокращенный вариант. Вот список принятых сокращений дней недели русификатора 5-й версии:
</p></blockquote><blockquote><blockquote>
Пн, Вт, Ср, Чт, Пт, Сб, Вс
</blockquote></blockquote><blockquote><p align="justify">
Перед днём недели может стоять необязательное слово DATE. При вводе дня недели и месяца регистр букв роли не играет.
</p></blockquote><blockquote><p align="justify">
Время вводится в соответствии с шаблоном ЧЧ:ММ:СС. Незначащие нули вводить необязательно, начиная с версии ОС 1.3. Если не вводить секунды, либо минуты и секунды, то их значения считаются нулевыми. Перед значением времени может стоять необязательное слово TIME. Время всегда вводится в 24-часовом формате. Установка даты никак не влияет на время и наоборот.
</p></blockquote><blockquote><p align="justify">
Параметры ТО или VER позволяют записать значение системной даты/времени в произвольный файл или, например, распечатать его на принтере. После ТО или VER должно следовать имя файла (устройства; для принтера, например &mdash; PRT:). Не следует применять ТО или VER одновременно с изменением даты и/или времени, т.к. ОС в этом случае создаст пустой файл, поскольку при изменении системного времени команда DATE не производит никакого вывода (если время введено правильно).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100F>
<b>DELETE</b> FILE/M/A,ALL/S,QUIET/S,FORCE/S
</a></pre></font></blockquote><blockquote><p align="justify">
Удалить один или несколько файлов и/или каталогов. Обязательным параметром является маршрут, по которому производится удаление. Если маршрут &mdash; неполный, т.е. не содержит имени устройства (через двоеточие), то отсчет происходит от текущего каталога. В именах/маршрутах объектов, подлежащих удалению, можно без каких-либо ограничений использовать шаблоны.
</p></blockquote><blockquote><p align="justify">
Более старые версии ОС, нежели версия 2, не позволяют указать более 10 имен файлов, подлежащих удалению одной командой DELETE.
</p></blockquote><blockquote><p align="justify">
В случае, если указано несколько имен и/или применены шаблоны и в силу каких-либо причин удаления некоторых объектов не произошло, DELETE продолжает невзирая на это двигаться по списку, пока список не кончится (только для версий ОС, начиная с 1.3).
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL вызывает удаление всех подкаталогов и файлов заданного каталога (и самого каталога также). Для удаления непустых каталогов (т.е. каталогов, содержащих файлы и/или другие каталоги) этот параметр обязателен.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель QUIET подавляет вывод сообщений о попытках удаления очередного файла/каталога при множественных операциях удаления.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель FORCE заставляет команду DELETE удалять даже те объекты, которые защищены от удаления (отсутствует признак &quot;Удаляемый&quot;). Примеры использования:
</p></blockquote><blockquote><blockquote><pre>
DELETE #? ALL            &mdash; удалить весь текущий каталог со всеми его 
                           подкаталогами.
DELETE win32.exe nc.exe  &mdash; удалить 2 файла из текущего каталога.
DELETE Work:(W N) #?     &mdash; удалить из устройства &quot;Work:&quot; все 
                           файлы, начинающиеся с букв W и N.
</pre></blockquote></blockquote><blockquote><p align="justify">
Если вы нечаянно удалили какой-либо из нужных файлов, а потом спохватились, то можно гарантированно восстановить его (в случае, если после удаления файла запись на диск не производилась) с помощью таких программ, как DiskSalvage, AmiBack Tools или UnDel.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100G>
<b>DIR</b> DIR,OPT/K,ALL/S,DIRS/S,FILES/S,INTER/S
</a></pre></font></blockquote><blockquote><p align="justify">
Показать список файлов и подкаталогов либо текущего, либо любого другого каталога. В списке, как правило, вначале идут имена подкаталогов, а затем &mdash; файлов. С помощью различных параметров этой команды можно просмотреть список в интерактивном режиме (останавливаясь после каждого выведенного имени), или просмотреть содержимое подкаталогов выбранного каталога. Прервать вывод списка можно в любой момент времени нажатием комбинации клавиш &quot;CTRL&nbsp;+&nbsp;C&quot;.
</p></blockquote><blockquote><p align="justify">
После команды DIR может следовать маршрут каталога, содержимое которого необходимо показать; если маршрут отсутствует, будет показано содержимое текущего каталога.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL (синоним ОРТ А) заставит команду DIR показать также содержимое всех подкаталогов выбранного каталога; DIRS (синоним ОРТ D) оставит в списке только имена подкаталогов, FILES &mdash; файлов.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель INTER (синоним ОРТ I) включит интерактивный режим вывода списка, когда после каждого имени вывод приостанавливается и ожидается нажатие одной из следующих клавиш (после нажатия любой, отличной от Enter, клавиши необходимо нажать Enter):
</p></blockquote>
<blockquote><table border=0>
<tr>
<td width="10%" valign="top" align="right">Enter&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
вывести следующее имя. 
</td></tr>
<tr>
<td width="10%" valign="top" align="right">T&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
распечатать содержимое файла, соответствующего последнему выведенному имени. Если последнее выведенное имя соответствовало не файлу, а каталогу, то система сообщит о том, что опция Т была ошибочной и попросит выбрать другую. Приостановить распечатку файла можно нажатием любой клавиши (обычно для этого используется клавиша &quot;Пробел&quot;) &mdash; для возобновления распечатки достаточно нажать клавишу Backspace или комбинацию клавиш &quot;CTRL&nbsp;+&nbsp;X&quot;. Если желательно вообще прекратить распечатку файла, нажмите &quot;CTRL&nbsp;+&nbsp;C&quot;.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">DEL&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
удалить файл или каталог (можно удалять только пустые (!) каталоги).
</td></tr>
<tr>
<td width="10%" valign="top" align="right">E&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
войти в подкаталог. Если последнее выведенное имя соответствовало не каталогу, а файлу, то система сообщит о том, что опция Е была ошибочной и попросит выбрать другую. Режим остаётся интерактивным. 
</td></tr>
<tr>
<td width="10%" valign="top" align="right">B&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
вернуться из подкаталога, в который вы вошли по опции Е.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">Q&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
прекратить работу команды DIR.
</td></tr>
<tr>
<td width="10%" valign="top" align="right">Q&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
эта опция введена в интерактивный режим, начиная с ОС 1.3. Синонимом её является СОМ. Вам будет выдан запрос на исполнение любой команды ОС, после исполнения которой произойдет возврат в интерактивный режим команды DIR.
</td></tr>
</table></blockquote>
</p></blockquote><blockquote><p align="justify">
Синонимом обоих параметров-переключателей INTER и ALL является OPT AI<br>
Примеры использования: 
</p></blockquote><blockquote><blockquote><pre>
dir Work: DIRS  &mdash; показать имена всех каталогов корневого 
                  директория устройства Work:
dir :~(Ы)#? ALL &mdash; показать имена всех файлов, каталогов 
                  (и содержащихся в них файлов/каталогов)
                  корневого директория текущего диска, 
                  имена которых не начинаются с буквы &quot;ы&quot;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100H>
<b>DISKCHANGE</b> DEVICE/A
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда сообщает ОС о том, что вы заменили диск в дополнительно подключённом к Амиге пятидюймовом (например) дисководе, либо винчестере со сменными дисками. Подобные устройства не всегда имеют встроенный механизм, который подобно механизму штатных амижных дисководов незамедлительно сообщает системе о том, что диск был вынут или вставлен. 
Ситуация, когда диск был сменён, а ОС об этом ничего не знает, является катастрофической, т.к. ОС сохраняет часть информации о диске во внутренних буферах, и несовпадение этой информации с реальной обессмыслит любые операции с диском.
</p></blockquote><blockquote><p align="justify">
DISKCHANGE также следует исполнять после Shell-команды <a href="AMIGA-10.html#A101T">RELABEL</a>, т.к. операционная среда Workbench в этом случае ничего не будет знать о переименовании диска, что также может привести к нежелательным (хотя и не к катастрофическим, 
как в предыдущем случае) последствиям.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром для DISKCHANGE является физическое имя устройства в котором был сменен диск. Пример использования: 
</p></blockquote><blockquote><blockquote><pre>
DISKCHANGE DF2:  &mdash; информировать ОС, что во внешнем 
                   дисководе DF2: был заменен диск.
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100I>
<b>DISKCOPY</b> FROM/A,TO/A,NAME/K,NOVERIFY/S,MULTI/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда находится в каталоге &quot;System&quot; и её назначение &mdash; копирование всей информации с одного диска на другой. Копирование происходит на физическом уровне &mdash; дорожка за дорожкой диска-источника переносятся на соответствующие дорожки диска-приёмника вне зависимости от того, записано ли что-нибудь на них или нет. Одновременно с записью на диск-приёмник происходит его форматирование, поэтому никакой предварительной подготовки этого диска не требуется. Время работы команды DISKCOPY практически то же самое, что время форматирования диска. Необходимым условием является эквивалентность основных характеристик устройства-источника и устройства-приемника: объёма, числа сторон, дорожек и секторов на каждой дорожке. Пока это условие соблюдено, можно использовать кроме гибких дисков различные псевдодисковые устройства типа &quot;RAD:&quot; или &quot;SD:&quot; безо всяких ограничений.
</p></blockquote><blockquote><p align="justify">
В силу того, что время копирования команды DISKCOPY совершенно не зависит от объема реально копируемой информации, зачастую выгоднее использовать Сору чтобы просто скопировать нужные файлы/каталоги.
</p></blockquote><blockquote><p align="justify">
Обязательными параметрамми команды DISKCOPY являются физические имена устройства-источника и устройства-приемника. Перед именем устройства-источника может стоять необязательное ключевое слово FROM, перед именем устройства-приемника &mdash; ТО (в версиях ОС ниже, чем 2, параметр ТО является обязательным). Если имя устройства-источника является не первым параметром команды DISKCOPY, то использование ключевого слова FROM обязательно.
</p></blockquote><blockquote><p align="justify">
Обычно при копировании дисков DISKCOPY проверяет правильность записи каждой дорожки. При использовании параметра-переключателя NOVERIFY такая проверка отключается, что двукратно ускоряет копирование.
</p></blockquote><blockquote><p align="justify">
Если желательно, чтобы имя диска приемника было другим, нежели имя диска-источника, то необходимо использовать в строке параметров ключевое слово NAME, после которого следует новое имя диска-приемника (если оно содержит пробелы, то должно быть заключено в кавычки). 
</p></blockquote><blockquote><p align="justify">
Во время работы DISKCOPY выдает соответствующие подсказки и сообщает о том, что и как происходит по мере копирования. Если в тот момент, когда DISKCOPY ожидает вашей реакции на какой-либо запрос, нажать &quot;CTRL&nbsp;+&nbsp;C&quot;, а затем Enter, то операция будет прервана. То же произойдёт при нажатии &quot;CTRL&nbsp;+&nbsp;C&quot; в процессе копирования.
</p></blockquote><blockquote><p align="justify">
Если в вашей системе достаточно памяти, чтобы &quot;образ&quot; диска поместился в ней целиком и необходимо сделать несколько копий одного того же диска, то для более удобной и быстрой работы команды DISKCOPY есть смысл использовать параметр-переключатель MULTI. При этом весь диск источник будет предварительно считан в память, а затем система будет просить вас только заменить очередной диск-приемник.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100J>
<b>DISKDOCTOR</b>
</a></pre></font></blockquote><blockquote><p align="justify">
Это устаревшая команда, которая начиная с версии ОС 2.1 &quot;снята с вооружения&quot;, а посему мы не будем тратить время на её описание. Перефразируя известное выражение товарища Сухова &quot;Восток &mdash; дело тонкое&quot;, можно сказать &mdash; &quot;Восстановление подпорченных дисков &mdash; дело тончайшее&quot;. Для этого явно мало одной ОС-овской команды, какой бы мощной она не была. Для Амиги существуют несколько хороших программ, выполняющих аналогичные задачи подобающим образом, в частности Disk Salvage, AmiBack Tools и QB Tools.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100K>
<b>ECHO</b> /M,NOLINE/S,FIRST/K/N,LEN/K/N,TO/K (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Используется в основном для вывода некоторой информации в Shell-окна во время исполнения командных файлов. С помощью ECHO пользователь может например узнать, какая конкретно команда исполняется и что при этом происходит.
</p></blockquote><blockquote><p align="justify">
После команды Echo всегда идет строка, которую надо вывести в текущий поток вывода. Как правило, этот поток направлен в активное Shell-окно, хотя ничто не мешает пустить его в некоторый файл или на принтер, используя ключевое слово ТО, после которого должен следовать маршрут открытия потока вывода.
</p></blockquote><blockquote><p align="justify">
Если строка содержит пробелы, то версии ОС до 2-й требуют, чтобы строка была заключена в кавычки. Для ОС 2 или 3 кавычки необязательны в тех случаях, когда пробелы в строке отсутствуют или после строки не следует никаких параметров для команды ECHO. Строка всегда заключается в кавычки, если в ней присутствует символ перевода строки (в командных файлах он обозначается *N).
</p></blockquote><blockquote><p align="justify">
Обычно ECHO вставляет символ &quot;перевод строки&quot; в конец печатаемой строки. Если это по каким-либо причинам нежелательно, то следует использовать параметр-переключатель NOLINE.
</p></blockquote><blockquote><p align="justify">
Строку можно выводить не с начала. Для указания того, с какого по счету символа строки начнётся вывод, используется ключевое слово FIRST с числовым параметром &mdash; порядковым номером первого выводимого символа.
</p></blockquote><blockquote><p align="justify">
Можно ограничить длину выводимой строки, использовав ключевое слово LEN, после которого должен следовать параметр &mdash; число выводимых символов. Если параметр FIRST отсутствует, то отсчет выводимых символов ведется с конца строки.<br><br>
Примеры использования: 
</p></blockquote><blockquote><blockquote><pre>
echo "Эта строка будет распечатана на принтере!" ТО PRT: 
echo "Вывод этой строки начнется со слова 'этой'" FIRST 7 
echo "Будет выведено слово 'слово'" FIRST 16 LEN 5 
echo "Будет выведено только последнее слово" LEN 5 
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100L>
<b>ED</b> FROM/A,SIZE/N,WITH/K,WINDOW/K,TABS/N,WIDTH=COL/N,
   HEIGHT=ROW/N
</a></pre></font></blockquote><blockquote><p align="justify">
ED представляет собой экранный текстовый редактор, который находится в каталоге С диска Workbench. При разработке ED во главу угла ставились не мощность и удобство пользования, а минимальный размер расходуемой памяти и места на системной дискете. 
Поэтому ED ни в коей мере нельзя рассматривать в качестве серьёзного редактора для повседневной работы &mdash; когда у вас появится &quot;настоящий&quot; редактор, можете со спокойной душой удалить ED из вашей системы.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром при запуске ED является имя редактируемого текстового файла. Если это имя не является первым по счету параметром, то ему обязательно должно предшествовать ключевое слово FROM. Если такой файл действительно существует на диске, то он будет загружен в редактор, в противном случае редактор просто начнёт новый файл, имя которого будет соответствовать заданному.
</p></blockquote><blockquote><p align="justify">
С помощью параметра SIZE можно задать размер буфера, используемого редактором для хранения текста редактируемого файла. Размер задаётся в байтах. Если это второй параметр управляющей строки, то слово SIZE можно не использовать. Если вы не намерены явно указывать размер буфера, то по умолчанию он задается равным 40000 байт. Если же редактируемый файл не помещается в буфере заданной длины, то редактор выдаст сообщение об ошибке и вам придется задать больший размер буфера.
</p></blockquote><blockquote><p align="justify">
Все следующие параметры работают только для версий ОС 2 и 3.
</p></blockquote><blockquote><p align="justify">
С помощью ключевого слова WITH, после которого следует маршрут, можно указать редактору на некоторый командный файл, который редактор должен исполнить после загрузки текстового файла, подлежащего редактированию. 
Командный файл редактора ED является текстовым файлом, содержащим расширенные команды редактирования, понятные для ED-a. Каждая команда должна располагаться на отдельной строке. Исполняться они будут, как если бы их вводили одна за другой с клавиатуры.
</p></blockquote><blockquote><p align="justify">
Числовой параметр TABS указывает редактору на ширину шага меток табуляции. По умолчанию эта величина равна трём.
</p></blockquote><blockquote><p align="justify">
Параметры WINDOW, WIDTH и HEIGHT, использование которых в реальной жизни весьма сомнительно, позволяют вам запускать редактор на удалённом терминале (другом компьютере).
</p></blockquote><blockquote><p align="justify">
WINDOW может быть именем устройства (например, &quot;AUX:&quot;) или спецификацией консольного окна (&quot;CON://640/256&quot;).
</p></blockquote><blockquote><p align="justify">
WIDTH указывает число символов в строке, HEIGHT &mdash; общее число строк, которые помещаются на экране удаленного терминала.
</p></blockquote><blockquote><p align="justify">
Полностью описывать возможности редактора ED, по-видимому, нет смысла в силу того, что существуют несравненно более мощные программы, решающие аналогичные задачи, которыми мы и рекомендуем пользоваться читателю. То же относится и к строчному редактору EDIT, практическая ценность которого приближается к нулю. Время подобных текстовых редакторов безвозвратно ушло.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100M>
<b>ELSE</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Использование ELSE ограничивается исключительно командными файлами, где она всегда работает в паре с командой IF для выбора альтернативного ветвления в том случае, если условие, проверяемое IF, оказалось ложным. Пример использования см. в описании команды <a href="AMIGA-10.html#A100D">CPU</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100N>
<b>ENDCLI</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Завершает текущий Shell-процесс с закрытием Shell-окна. Если у вас версия ОС 2 или 3, то прекратить текущий Shell-процесс можно, щёлкнув по закрывающему полю Shell-окна (если такое поле имеется), либо послав Shell-окну символ EOF (End Of File &mdash; конец файла; ему соответствует комбинация клавиш &quot;CTRL&nbsp;+&nbsp;\&quot;).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100O>
<b>ENDIF</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Использование ENDIF ограничивается исключительно командными файлами, где эта команда, всегда замыкает конструкцию <a href="AMIGA-10.html#A101A">IF&hellip;ENDIF</a> или <a href="AMIGA-10.html#A101A">IF&hellip;ELSE&hellip;ENDIF</a>. По поводу работы этих конструкций см. описание команды <a href="AMIGA-10.html#A101A">IF</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100P>
<b>ENDSHELL</b>
</a></pre></font></blockquote><blockquote><p align="justify">
То же, что ENDCLI (см. описание <a href="AMIGA-10.html#A100N">ENDCLI</a>). В версии ОС 1.3 это псевдоним ENDCLI, определенный в файле &quot;S:Shell-Startup&quot;. В более поздних версиях ОС &mdash; внутренняя команда.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100R>
<b>ENDSKIP</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Команда используется только в командных файлах, где она замыкает блок <a href="AMIGA-10.html#A1028">SKIP-команд</a>, После исполнения ENDSKIP устанавливается флажок предупреждения (WARN) со значением 5.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100S>
<b>EVAL</b> VALUE1/A,OP,VALUE2/M,TO/K,LFORMAT/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда позволяет вычислить результат целочисленных выражений, содержащих один или два аргумента, и вывести его в формате, определяемом пользователем. EVAL часто используется в командных файлах, например, для вычисления значений переменных цикла.
</p></blockquote><blockquote><p align="justify">
Первым параметром всегда является числовой аргумент вычисляемого выражения, которому может предшествовать ключевое слово VALUE1. В случае, когда первый аргумент выражения не является первым по счету параметром команды EVAL, использование ключевого слова VALUE1 обязательно.
</p></blockquote><blockquote><p align="justify">
По умолчанию числа вводятся в десятичном формате. Если числу предшествует комбинация символов &quot;0x&quot; или &quot;#X&quot;, то оно считается шестнадцатиричным, а если число начинается с нуля или символа &quot;#&quot;, то &mdash; восьмиричным.
</p></blockquote><blockquote><p align="justify">
Используя символ апострофа &quot;'&quot; можно также вводить ASCII-значения символов, например, 'А будет трактоваться, как 65. Старший бит ASCII-значения трактуется как знаковый разряд, т.е. все символы с кодами от 128 до 255 включительно (в этот диапазон, в частности, попадают и русские буквы) будут трактоваться как отрицательные числа в диапазоне от -128 до -1.
</p></blockquote><blockquote><p align="justify">
ОР является тем оператором, который возможно применить к аргументу (аргументам). Вот список допустимых для EVAL операторов:
</p><blockquote><pre>
  +  сложение 
  -  вычитание, либо унарный минус 
  *  умножение 
  /  деление 
mod  модуль 
  &amp;  побитовая операция И 
  |  побитовая операция ИЛИ 
хоr  побитовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ 
  ~  побитовая операция отрицания (инверсия) 
 &gt;&gt;  сдвиг числа влево 
 &lt;&lt;  сдвиг числа вправо 
eqv  побитовая эквивалентность 
</pre></blockquote><p align="justify">
Если операнды и оператор идут в стандартном порядке, т.е.
</p><blockquote><p align="justify">
Операнд_1 Оператор Операнд_2, 
</p></blockquote><p align="justify">
то ключевое слово ОР, равно как и VALUE2 употреблять необязательно. Есть нюанс, связанный с нахождением знака + в конце строки: после него обязательно должен стоять пробел, иначе он будет считаться не знаком сложения, а связывающим символом для двух соседних строк в командном файле.
</p></blockquote><blockquote><p align="justify">
Второй необязательный аргумент VALUE2 может даваться в том же формате, что и VALUE1. ОС версий 2 и 3 позволяет использовать несколько аргументов, каждый из которых должен отделяться от предыдущего соответствующим оператором. Для изменения последовательности выполнения различных операторов могут использоваться круглые скобки. Если вы пользуетесь ОС 1.3, то пробелы между операторами и аргументами недопустимы.
</p></blockquote><blockquote><p align="justify">
Ключевое слово ТО с последующим маршрутом вызовет переключение вывода (иначе называемого выходным потоком) команды EVAL в файл или, например, на принтер.
</p></blockquote><blockquote><p align="justify">
Ключевое слово LFORMAT с последующей управляющей строкой определяет желательный формат вывода команды EVAL. По умолчанию результат вычислений выводится в десятичном виде, однако, используя LFORMAT, вы можете определить выводимые числа с помощью различных спецификаций формата вывода; числа можно выводить как шестнадцатеричные (%Х), восьмеричные (%O), либо десятичные (%N). Можно также вывести символ, соответствующий ASCII-значению результата, воспользовавшись спецификацией %С.
</p></blockquote><blockquote><p align="justify">
При выводе шестнадцатеричных и восьмеричных чисел в спецификации формата вывода можно также указывать требуемое число цифр в выводимом числе, например %4Х выведет ровно 4 шестнадцатеричные цифры. Если реальное число цифр окажется меньше, нежели указано в спецификации формата вывода, то выведенное число будет дополнено слева нулями. Если задано меньше цифр, нежели получилось в результате вычисления, то будут выведены младшие цифры числа в соответствии с их установленным количеством.
</p></blockquote><blockquote><p align="justify">
Кроме собственно результата вычислений, параметр LFORMAT позволяет вывести также произвольный текст. Следует учесть, что EVAL не делает автоматического переноса строки после вывода результата. Когда требуется перенос строки, необходимо вставить в спецификацию формата вывода символы &quot;*N&quot;, а всю форматную строку заключить в кавычки. Кавычки также обязательны, если где-либо в форматной строке присутствуют пробелы.
</p></blockquote><blockquote><p align="justify">
Пример использования:
</blockquote><blockquote><blockquote><pre>
EVAL  2 * (2 + 5) LFORMAT  "Два на семь = %N*N"  TO  PRT:
</pre></blockquote><p align="justify">
На принтере будет распечатано:
</p><blockquote><pre>
Два на семь = 14
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100Q>
<b>EXECUTE</b> FILE/A [аргументы]
</a></pre></font></blockquote><blockquote><p align="justify">
Запускает на исполнение командный файл, представляющий собой последовательность команд ОС. Командному файлу могут быть переданы дополнительные аргументы. Сам исполняемый командный файл может содержать любое число директив EXECUTE, т.е. может запускать на исполнение любые другие командные файлы. Начиная с версии ОС 1.3 командные файлы можно исполнять и без директивы EXECUTE в том случае, если у этих файлов установлен признак &quot;Командный&quot; (script) &mdash; достаточно просто набрать имя файла и нажать Enter.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром для EXECUTE является маршрут исполняемого файла, после которого может следовать строка аргументов, используемых во время исполнения этого файла.
</p></blockquote><blockquote><p align="justify">
Если EXECUTE предполагает передать какие-либо аргументы командному файлу, то перед запуском файл сканируется в поисках тех мест, где эти аргументы могут быть использованы. Строки командного файла, содержащие директивы для команды EXECUTE, начинаются с точки. Рассмотрим эти директивы.
</p></blockquote><blockquote><p align="justify">
<em>.К</em> или <em>.KEY</em>, после которых следует имя переменной (список имён переменных), каждой из которых последовательно присваивается значение очередного аргумента, передаваемого командой EXECUTE. Каждое из имён переменных может завершаться идентификатором типа аргумента. Команда EXECUTE, считав все имена переменных, следующих после <em>.К</em> или <em>.KEY</em>, сканирует весь командный файл в поисках тех же имён, но заключенных в угловые скобки &quot;&lt;&gt;&quot; (скобки указывают на то, что символы между ними являются именами переменных). Найденным переменным присваиваются их конкретные значения.
</p></blockquote><blockquote><p align="justify">
Допустим, что командный файл &quot;RAM:Пpoбa&quot; содержит следующие строки: 
</p></blockquote><blockquote><blockquote><pre>
.К PARAM_1,PARAM_2,PARAM_3 
echo &lt;PARAM_1&gt;
echo &lt;PARAM_2&gt;
echo &lt;PARAM_3&gt;
</pre></blockquote></blockquote><blockquote><p align="justify">
Если запустить этот файл на исполнение командой:
</p></blockquote><blockquote><blockquote><pre>
execute RAM:Проба 123
</pre></blockquote></blockquote><blockquote><p align="justify">
то будут распечатаны цифры 1, 2 и 3. Если же мы попробуем запустить файл с числом параметров, не равным трём, то получим сообщение об ошибке, поскольку EXECUTE не сможет сбалансировать требуемые параметры с используемыми.
</p></blockquote><blockquote><p align="justify">
В случае, если какая-либо из переменных должна принимать некоторое значение по умолчанию (т.е. соответствующий ей аргумент может отсутствовать), это значение ставится после символа &quot;$&quot;:
</p></blockquote><blockquote><blockquote><pre>
.К PARAM_1,PARAM_2,PARAM_3
echo &lt;PARAM_1$Heт параметра 1&gt;
echo &lt;PARAM_2$Heт параметра 2&gt;
echo &lt;PARAM_3$Heт параметра 3&gt;
</pre></blockquote></blockquote><blockquote><p align="justify">
Теперь можно исполнить этот файл вообще без параметров, поскольку для недостающих аргументов будут подставлены значения, находящиеся справа от знака доллара. Однако подобные подмены происходят "локально" для каждого использования какой-либо из переменных, что не всегда удобно. EXECUTE предоставляет возможность изменить значение любой из переменных раз и навсегда, если аргумент, соответствующий ей не определен. Для этого существует директива .DEF: 
</p></blockquote><blockquote><blockquote><pre>
.DEF  PARAM_1  &quot;Новое значение параметра 1&quot;
</pre></blockquote></blockquote><blockquote><p align="justify">
Возможна и замена любого из управляющих символов:
</p></blockquote>
<blockquote><table border=0>
<tr>
<td width="10%" valign="top" align="right" nowrap><b>.BRA</b> x&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
символ х будет рассматриваться командой Execute, как &lt;
</td></tr>
<tr>
<td width="10%" valign="top" align="right" nowrap><b>.KET</b> x&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
символ х будет рассматриваться командой Execute, как &gt;
</td></tr>
<tr>
<td width="10%" valign="top" align="right" nowrap><b>.DOT</b> x&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
символ х будет рассматриваться командой Execute, как <b>.</b>
</td></tr>
<tr>
<td width="10%" valign="top" align="right" nowrap><b>.DOL</b> x&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
символ х будет рассматриваться командой Execute, как $
</td></tr>
<tr>
<td width="10%" valign="top" align="right" nowrap><b>.DOLLAR</b> x&nbsp;&mdash;&nbsp;</td>
<td width="100%" align="justify">
символ х будет рассматриваться командой Execute, как $
</td></tr>
</table></blockquote><blockquote><p align="justify">
Странные на первый взгляд мнемоники BRA и КЕТ окажутся вовсе не такими странными, если прочитать их подряд, прозвучит &mdash; BRAcKET. по-английски &mdash; скобка. Сразу становится ясно, что соответствует открывающей скобке, а что &mdash; закрывающей.
</p></blockquote><blockquote><p align="justify">
Если применить переопределения управляющих символов, то командный файл из предыдущего примера сможет выглядеть хотя бы так:
</p></blockquote><blockquote><blockquote><pre>
.DOT * 
*BRA [ 
*КЕТ ]
*DOL |
*К PARAM_1,PARAM_2,PARAM_3
echo [PARAM_1|Heт параметра 1]
echo [PARAM_2|Heт параметра 2]
echo [PARAM_3|Heт параметра 3] 
</pre></blockquote></blockquote><blockquote><p align="justify">
Точка с последующим пробелом рассматривается как строка, содержащая комментарий. Комментарием также считается правая часть любой строки после символа &quot;;&quot;.
</p></blockquote><blockquote><p align="justify">
Двойной знак доллара в угловых скобках представляет собой имя переменной, значением которой всегда является номер shell-процесса, исполняющего данный командный файл.
</p></blockquote><blockquote><p align="justify">
Попробуйте теперь исполнить вот такой файл с аргументами и без них:
</p></blockquote><blockquote><blockquote><pre>
.К PARAM_1,PARAM_2,PARAM_3 
. Эта строка содержит комментарий 
echo &quot;Работает shell-процесс &lt;$$&gt;&quot;
echo &lt;PARAM_1$Heт параметра 1&gt;
echo &lt;PARAM_2$Heт параметра 2&gt;
echo &lt;PARAM_3$Heт параметра 3&gt;
.DEF PARAM_1 &quot;Новое значение&quot;;Глобальная подстановка 
echo &lt;PARAM_1&gt;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101Q>
<b>FAILAT</b> /N (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Используется исключительно в командных файлах для установки уровня ошибки, при которой выполнение командного файла прерывается.
</p></blockquote><blockquote><p align="justify">
Большинство исполняемых команд возвращают код ошибки, который характеризует результаты их работы. ОС 2 или 3 помещает значение этого кода в глобальную переменную окружения RC, на которую всегда можно сослаться при помощи идентификатора $RC. Более ранние версии ОС прячут это значение, хотя до него можно достучаться несколькими способами, в том числе и при помощи FAILAT.
</p></blockquote><blockquote><p align="justify">
Отсутствию ошибки соответствует значение ноль. Существует ещё три &quot;официальных&quot; уровня ошибки:
</p></blockquote><blockquote><blockquote>
5 &mdash; предупреждение. Можно продолжать работу.<br>
10 &mdash; некоторая ошибка. Реакция по обстоятельствам.<br>
20 &mdash; серьезный сбой. Полная неудача работы команды.
</blockquote></blockquote><blockquote><p align="justify">
Если при исполнении командного файла возникнет ошибочная ситуация, то по умолчанию исполнение прерывается, начиная с уровня 10. Команда FAILAT с числовым параметром &mdash; пределом уровня ошибки &mdash; позволяет выставить тот уровень, который вызовет прерывание исполнения командного файла. 
Например, исполнив FAILAT 21 мы сможем продолжать исполнение командного файла даже в случае серьёзных неудач и, анализируя код ошибки, принимать с помощью <a href="AMIGA-10.html#A101A">IF</a> соответствующие решения по ходу дела.
</p></blockquote><blockquote><p align="justify">
Действие FAILAT является локальным, т.е. распространяется только на тот командный файл, где была исполнена команда FAILAT. После исполнения файла предельный уровень ошибки возвращается на стандартное значение 10.
</p></blockquote><blockquote><p align="justify">
Если исполнить FAILAT без параметра, то будет показан текущий предел уровня ошибки.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100T>
<b>FAULT</b> /N/M (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Если ОС возвращает некоторый вторичный код ошибки (например, 205) то исполнив FAULT 205, мы получим развернутое объяснение ситуации, вызывающей эту ошибку. Объяснение будет дано по-русски, если у вас версия ОС 2.1 или выше и установлены русские каталоги.
</p></blockquote><blockquote><p align="justify">
Мы можем исполнить FAULT с несколькими числовыми аргументами, соответствующими различным вторичным кодам ошибок, &mdash; каждому из них будет дано индивидуальное объяснение. Если FAULT ничего не сможет сообщить по поводу некоторого кода, то код ошибки будет просто сдублирован в выходном сообщении.
</p></blockquote><blockquote><p align="justify">
ОС 2 или 3 всегда кладёт вторичный код ошибки в глобальную переменную окружения result2.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100U>
<b>FF</b> [-O][-N][шрифт]
</a></pre></font></blockquote><blockquote><p align="justify">
Это устаревшая команда, применявшаяся в ОС 1.2 и 1.3 для ускорения вывода текста и для замены шрифта topaz.8 и topaz.9 на какой-либо другой, но &mdash; аналогичного формата. Эта же команда использовалась в качестве вспомогательной для русификаторов устаревших версий (менее 5.0). Поскольку ОС 2 и 3 сами по себе выводят текст с максимальной скоростью, а русификаторы, начиная с 5-й версии, берут всю работу по подмене шрифтов на себя, то нет никакой необходимости использовать FF, если у вас &mdash; ОС 2 или 3, а русификатор &mdash; V5.0 или выше.
</p></blockquote><blockquote><p align="justify">
Необязательный параметр -O включает режим ускоренного вывода текста (впрочем, этот режим и так включается по умолчанию). -N отключает режим ускоренного вывода. Этот параметр имеет смысл использовать только в том случае, если у вас ОС 2 или 3, но русификатор старый.
</p></blockquote><blockquote><p align="justify">
Если в качестве параметра определено имя некоторого шрифта, то попытки любых программ открыть шрифт &quot;topaz.8&quot; или &quot;topaz.9&quot; приведут к открытию шрифта, указанного в качестве параметра команды FF. Имя шрифта должно иметь обязательное расширение &quot;.font&quot;. Шрифт должен иметь формат 8x8 или 10x9 и должен быть фиксированной ширины (не пропорциональный!), в противном случае FF откроет обычный topaz. FF создает &quot;перекрёстную&quot; подмену шрифтов &mdash; если какая-либо из программ попытается открыть тот же шрифт, что был специфицирован для FF, на самом деле откроется topaz.
</p></blockquote><blockquote><p align="justify">
Старые русификаторы использовали FF для подсовывания системе англо-русского шрифта topar при открытии шрифта topaz. Новые версии, начиная с 5.0, со всем справляются сами.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100V>
<b>FILENOTE</b> FILE/A,COMMENT,ALL/S,QUIET/S
</a></pre></font></blockquote><blockquote><p align="justify">
ОС позволяет для каждого файла иметь комментарий. Комментарий не зависит от содержимого файла и не влияет на аспекты его функционирования. При создании файла комментарий отсутствует.
</p></blockquote><blockquote><p align="justify">
При копировании файлов с помощью команды <a href="AMIGA-10.html#A100C">COPY</a>, копия файла по умолчанию создается без комментария, даже если у исходного файла он был. Чтобы комментарий перешёл и на копию, команда <a href="AMIGA-10.html#A100C">COPY</a> должна иметь параметры СОМ или CLONE. Переименование файла с помощью команды <a href="AMIGA-10.html#A101V">RENAME</a> не приводит к потере комментария.
</p></blockquote><blockquote><p align="justify">
Команда FILENOTE позволяет создать комментарий для одного (ОС 1.3) или нескольких (ОС 2 или 3) файлов. В случае, если комментарий у файла уже был, он замещается на новый. Обязательным параметром является маршрут файла, комментарий которого планируется изменить. ОС 2 или 3 позволяет использовать шаблоны для того, чтобы изменить комментарий целой группы файлов. Если маршрут не является первым параметром команды FILENOTE, то использование ключевого слова FILE обязательно.
</p></blockquote><blockquote><p align="justify">
Параметр COMMENT соответствует собственно строке комментария, которая может иметь в длину до 79 символов. В случае, когда строка комментария не является вторым параметром команды FILENOTE, использование ключевого слова COMMENT обязательно. Если строка комментария содержит пробелы, она должна быть заключена в кавычки.
</p></blockquote><blockquote><p align="justify">
<em>Следующие два параметра-переключателя работают только для ОС 2 и 3.</em>
</p></blockquote><blockquote><p align="justify">
Параметр ALL позволяет создать один и тот же комментарий для всех файлов заданного каталога и всех его подкаталогов. Параметр QUIET подавляет сообщения команды FILENOTE, которые выводятся при множественном присвоении комментариев, что происходит при использовании шаблонов или параметра-переключателя ALL.
</p></blockquote><blockquote><p align="justify">
Пример использования: 
</p></blockquote><blockquote><blockquote><pre>
filenote  WORК:Зарплата  &quot;Хорошая&hellip; но маленькая&quot;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100X>
<b>FORMAT</b> DEVICE=DRIVE/K/A,NAME/K/A,OFS/S,FFS/S,
       INTL=INTERNATIONAL/S,NOINTL=NOINTERNATIONAL/S,
       DIRCACHE/S,NODIRCACHE/S,NOICONS/S,QUICK/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда находится в каталоге &quot;System&quot;. Её задача &mdash; отформатировать диск, подготавливая его к работе в ОС. После форматирования диска на нём не будет никакой информации. Форматировать можно как гибкие, так и жёсткие диски, а также различные псевдодисковые устройства типа &quot;RAD:&quot; или &quot;SD:&quot;.
</p></blockquote><blockquote><p align="justify">
FORMAT в начале своей работы всегда выводит запрос на подтверждение того, что вы действительно хотите отформатировать диск. Подтверждая свое желание произвести форматирование, всю ответственность за возможные последствия этой операции вы берёте на себя.
</p></blockquote><blockquote><p align="justify">
Когда начнётся процесс форматирования, вы уже не сможете никоим образом восстановить то, что было на диске, несмотря на то, что ОС 2 и 3 позволяют прервать форматирование, не дождавшись его окончания.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром команды FORMAT является физическое имя устройства, чей диск вы намерены отформатировать. Этому имени должно предшествовать ключевое слово DRIVE (или DEVICE).
</p></blockquote><blockquote><p align="justify">
Процесс форматирования отображается на экране. Каждый цилиндр диска сначала форматируется, затем проверяется на правильность записи. После окончания форматирования диску присваивается имя, указанное вами после обязательного ключевого слова NAME. Имя диска не может содержать более 31-го символа. Если имя содержит пробелы, его необходимо заключить в кавычки. Ограничений на сами символы, входящие в имя диска, не существует &mdash; можете именовать его по-русски безо всяких проблем.
</p></blockquote><em><blockquote><p align="justify">
<img src="Gfx/AMIGA-NB.gif" alt="notabene!" width="40" height="20">
Зачастую нет необходимости форматировать даже заведомо не AmigaOS-диск перед его использованием &mdash; например, <a href="AMIGA-10.html#A100I">DISKCOPY</a> подготавливает его &quot;на лету&quot;. Масса имеющихся дисковых копировщиков &mdash; например, DeluxeCopy или TurboСору и ещё тысяча и одна программа такого рода также форматируют диск во время записи на него информации. Диск надо форматировать только для честного использования под систему, перед тем как скопировать на него файлы командой <a href="AMIGA-10.html#A100C">COPY</a>, либо перед созданием каталогов командой <a href="AMIGA-10.html#A101K">MAKEDIR</a> и т.д. Популярный архиватор физического содержимого дисков DiskMasher (DMS), раскрывая на диск свой архив, также на лету производит форматирование. Если вам необходимо скопировать нечто &quot;диск-в-диск&quot;, никогда не теряйте времени даром, исполняя сначала FORMAT, затем <a href="AMIGA-10.html#A101C">INSTALL</a>, затем <a href="AMIGA-10.html#A100C">COPY ALL</a> &mdash; что-нибудь типа <a href="AMIGA-10.html#A100I">DISKCOPY</a> сделает то же самое в десять раз быстрее. 
</p></blockquote><blockquote><p align="justify">
Если же в качестве форматируемого диска вы уверены, используйте <a href="AMIGA-10.html#A100I">DISKCOPY NOVERIFY</a> и чистый AmigaOS-диск как источник &mdash; вы сэкономите половину времени, затрачиваемого на форматирование &quot;в лоб&quot;. Если нужно сразу несколько чистых дисков, то добавьте для <a href="AMIGA-10.html#A100I">DISKCOPY</a> параметр MULTI &mdash; процесс пойдёт ещё быстрее.
</p></blockquote><blockquote><p align="justify">
Однако, копирование &quot;диск-в-диск&quot; не всегда является подходящим. Если вы многократно удаляли/создавали файлы на некотором диске, то его содержимое неизбежно становится сильно фрагментированным &mdash; физически это проявляется в замедленном доступе к информации на диске и сильному &quot;пилежу&quot; головок вперёд-назад даже при выполнении достаточно элементарных действий. Представьте себе, например, ситуацию когда вы удалили с почти заполненного диска несколько коротких файлов с тем, чтобы записать один длинный. Поскольку очень мало шансов, что удаленные короткие файлы лежали на диске впритык &quot;один за другим&quot;, то длинный файл с точки зрения размещения на диске распадется на несколько фрагментов, которые будут вставлены на место удалённых коротких файлов. Теперь для считывания длинного файла головке придется хорошо побегать по диску, прежде чем она соберет весь 
файл из разбросанных там и сям кусочков. В случае работы с гибким диском наилучшим решением будет скопировать фрагментированный диск с помощью <a href="AMIGA-10.html#A100C">COPY ALL</a> на предварительно сформатированный диск. Содержимое полученного при этом диска не будет фрагментированным. Жёсткий же диск, скорее всего, придётся дефрагментировать одной из специально предназначенных для этого программ, наилучшей из которых на данный момент времени является ReOrg V2.31 (это shareware-программа немецкого программиста Хольгера Крузе; как очень часто бывает на Амиге, shareware-программы по качеству значительно лучше коммерческих). Опции дефрагментирования есть также в коммерческих программах AmiBack Tools и QuarterBack Tools.
</p></blockquote><blockquote><p align="justify">
<img src="Gfx/AMIGA-NB.gif" alt="notabene!" width="40" height="20">
Кстати говоря, вряд ли есть более опасная операция, нежели дефрагментирование жёсткого диска. Никогда не принимайтесь за неё, если у вас нет резервной копии содержимого дефрагментируемой партиции. Любой сбой в питании или в работе компьютера &mdash; и вы безвозвратно теряете всё, что было на партиции.
</p></blockquote></em><blockquote><p align="justify">
ОС 2 и 3 поддерживает два типа файловых систем &mdash; OFS (Old File System &mdash; старая файловая система) и FFS (Fast File System &mdash; быстрая файловая система). Если у вас есть возможность выбирать между возрастом и скоростью, то скорее всего вы в советах не нуждаетесь. Кроме ускорения работы с диском, FFS к тому же высвобождает 42 Кб на стандартной дискете двойной плотности (максимальный объем FFS-дискеты &mdash; 878 Кб) по сравнению с OFS-дискетой, чей максимальный объем &mdash; 836 Кб. ОС 1.3 в принципе может работать с FFS-дисками, но старт машины с них невозможен, т.к. сама система FFS является там загружаемой с диска. Более старые, нежели 1.3 версии ОС работают исключительно с OFS. Для форматирования диска под FFS необходимо вставить в строку параметров команды FORMAT параметр-переключатель FFS.
</p></blockquote><blockquote><p align="justify">
Начиная с версии ОС 2.1 введена еще одна опция форматирования &mdash; международный режим, который включается параметром-переключателем INTL (либо INTERNATIONAL). Этот режим позволяет игнорировать регистр символов с ASCII-кодами более 191 (в этот диапазон входят все русские буквы, за исключением букв &quot;а(А)&quot; и &quot;ё(Ё)&quot;). Практически это проявляется в том, что ОС найдет требуемый файл (каталог), чьё имя содержит русские буквы даже в том случае, если регистры букв в реальном имени файла (каталога) и строке поиска не совпадают. Исключением на данный момент времени является твёрдый знак, чей регистр при поиске должен совпадать с регистром твёрдого знака в имени файла (каталога).
</p></blockquote><blockquote><p align="justify">
Третья версия ОС позволяет использовать еще одну опцию &mdash; кэш каталогов, включаемый параметром-переключателем DIRCACHE, что позволяет резко увеличить скорость поиска нужных файлов на гибких дисках за счёт компактного размещения информации о дисковой структуре в кэш-таблице каталогов. Использование DIRCACHE для жёстких дисков не даёт никакого ощутимого выигрыша в скорости, да и в случае (не дай Бог, конечно) каких-либо неполадок с содержимым винчестера восстановить на нём порядок будет куда труднее. Вообще говоря, испорченные FFS-диски восстановить гораздо труднее, нежели диски с OFS, поскольку на последних содержится избыточная информация, облегчающая процесс восстановления. Полезный объем дисков, отформатированных с использованием DIRCACHE несколько меньше, чем без DIRCACHE, поскольку для хранения кэшированной информации о каталогах используются отдельные дисковые блоки.
</p></blockquote><blockquote><p align="justify">
Включение DIRCACHE автоматически включает режим INTERNATIONAL.
</p></blockquote><blockquote><p align="justify">
Устройство, носитель информации которого подлежит форматированию, в общем случае может быть какого угодно типа. По умолчанию некоторому устройству может быть приписан, например, тип файловой системы FFS INTERNATIONAL DIRCACHE. В этом случае можно не использовать параметры-переключатели FFS, 1NTL и DIRCACHE при операции форматирования &mdash; диск и без них отформатируется в таком режиме. А как быть, если мы по какой-либо причине пожелаем сформатировать диск в этом устройстве в старом формате OFS? Для этого существуют параметры-переключатели OFS, NOINTL (NOINTERNATIONAL) и NODIRCACHE.
</p></blockquote><blockquote><p align="justify">
По умолчанию, гибкие диски форматируются в старом формате, а формат жёстких дисков описывается либо в соответсвующем mountlist-файле (устаревший вариант), либо в специальном блоке-описателе жёсткого диска (т.н. Rigid Disk Block, или RDB диска).
</p></blockquote><blockquote><p align="justify">
Иногда некоторые диагностические программы сообщают, что на вашем диске стоит, например, &quot;DOS 3&quot;. Подобное наименование типа файловой системы является отражением того, как хранится на диске дескриптор (т.е. определитель) типа файловой системы, под которую этот диск отформатирован. Первыми тремя буквами дескриптора всегда являются &quot;DOS&quot;, затем следует однобайтовый идентификатор типа:
</p></blockquote><blockquote><blockquote><pre>
                       OFS &mdash; 0  (488 байт на блок данных)  
                       FFS &mdash; 1  (512 байт на блок данных)  
         OFS INTERNATIONAL &mdash; 2 
         FFS INTERNATIONAL &mdash; 3 
OFS DIRCACHE INTERNATIONAL &mdash; 4 
FFS DIRCACHE INTERNATIONAL &mdash; 5 
</pre></blockquote></blockquote><blockquote><p align="justify">
Если мы хотим, чтобы отформатированный диск не содержал &quot;мусорной корзины&quot; &mdash; каталога Trashcan с соответствующей ему иконкой, необходимо использовать параметр-переключатель NOICONS.
</p></blockquote><blockquote><p align="justify">
ОС предоставляет также возможность быстрого форматирования диска с использованием параметра-переключателя QUICK. Если диск был однажды отформатирован безо всяких проблем и вы уверены в том, что его качество как носителя информации с той поры не ухудшилось, то всегда имеет смысл применять именно быстрое форматирование. При этом заново переписываются системные области диска и создаётся пустой корневой каталог, что происходит практически мгновенно.
</p></blockquote><blockquote><p align="justify">
Форматированные диски содержат карту свободных блоков, которыми ОС пользуется при записи информации на диск (нечто напоминающее MS-DOS-овскую FAT). Процесс записи происходит следующим образом: прежде всего проверяется признак того, что карта правильно отображает расклад занятых блоков на диске &mdash; для этого есть специальный признак. Когда признак установлен, происходит его сброс, запись новых блоков на диск, обновление карты свободных блоков и установка признака &quot;Карта верна&quot;. Любой сбой (например, отключение питания) после начала записи приведёт к тому, что при последующем запуске компьютера признак &quot;Карта диска верна&quot; не будет установлен для этого диска (партиции винчестера), поскольку запись не была закончена.
</p></blockquote><blockquote><p align="justify">
Если при любом обращении к диску (неважно &mdash; для чтения или записи) обнаружится, что признак &quot;Карта верна&quot; сброшен, то на диск немедленно вешается &quot;замок&quot; по записи (см. описание команды <a href="AMIGA-10.html#A101I">LOCK</a>) и начинается просмотр всего содержимого диска с целью восстановления карты занятых блоков (в таких случаях говорится, что диск &quot;развалидирован&quot;). Физически это проявляется в замедленном старте машины и чрезвычайно интенсивной работе с жёстким диском без видимых причин. Процесс этот может занимать достаточно продолжительное время &mdash; вплоть до нескольких минут (в зависимости от числа файлов и каталогов на диске). Пока сканирование не закончено, запись на диск невозможна из-за &quot;замка&quot; на нём. Практика показывает, 
что во время коррекции карты свободных блоков лучше всего воздержаться от работы на компьютере (сборка карты &mdash; просто один из текущих процессов, которые могут происходить), пока содержимое карты не будет восстановлено.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100Y>
<b>GET</b> NAME/A (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда выводит значение локальной переменной окружения, чьё имя используется в качестве обязательного параметра команды. Локальные переменные размещаются в специально резервированных областях оперативной памяти и доступны только из того процесса, который их создал (а также из процессов, порождённых этим процессом). Обычно для ссылок на переменные окружения в командных файлах перед именами этих переменных необходимо ставить знак доллара ($), но поскольку команда GET имеет дело только с переменными, знак доллара в данном случае не ставится.
</p></blockquote><blockquote><p align="justify">
Несколько важных локальных переменных автоматически инициализируются системой для каждого стартовавшего Shell-процесса. Вот что они собой представляют:
</p></blockquote><blockquote><blockquote><p align="justify">
Process &mdash; номер текущего Shell-процесса.
</p></blockquote><blockquote><p align="justify">
RC &mdash; код возврата последней исполненной команды (уровень ошибки, см. описание команды FAILAT).
</p></blockquote><blockquote><p align="justify">
Result2 &mdash; вторичный код ошибки последней исполненной команды (см. описание команды FAULT).
</p></blockquote><blockquote><p align="justify">
Echo &mdash; значение этой переменной управляет режимом работы текущего Shell-процесса; если оно равно &quot;ON&quot;, то Shell-процесс выводит каждую строку командного файла по мере его исполнения. Любое другое значение отключает этот режим, использование которого чрезвычайно удобно при отладке командных файлов.
</p></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A100Z>
<b>GETENV</b> NAME/A (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Команда выводит значение глобальной переменной окружения, чьё имя использовано в качестве обязательного параметра команды. Глобальные переменные являются по сути обычными текстовыми файлами устройства &quot;ENV:&quot; (один из каталогов RAM-диска) и доступны для всех программ/процессов без исключения. Тем не менее, обращаться к глобальным переменным окружения, как к файлам не следует, поскольку в будущих версиях ОС организация размещения глобальных переменных может измениться, в результате чего ваши процедуры обращения станут несовместимы с требованиями системы.
</p></blockquote><blockquote><p align="justify">
Знак доллара ($), обычно необходимый перед переменными окружения, в данном случае не ставится, поскольку команда GETENV имеет дело только с такими переменными.
</p></blockquote><blockquote><p align="justify">
Некоторые важные глобальные переменные автоматически инициализируются при старте системы (только для ОС 2 и 3). Такими переменными являются:
</p></blockquote><blockquote><blockquote><p align="justify">
Kickstart &mdash; текущая версия системного ПЗУ.<br>
Workbench &mdash; текущая версия Workbench.
</p></blockquote></blockquote><blockquote><p align="justify">
Версии ОС начиная с 2.1 инициализируют ещё одну глобальную переменную: 
</p></blockquote><blockquote><blockquote><p align="justify">
Language &mdash; предпочитаемый системный язык (например english или russian).
</p></blockquote></blockquote><blockquote><p align="justify">
Эти переменные инициализируются при исполнении файла &quot;S:Startup-Sequence&quot;. Ещё одну переменную вы можете проинициализировать сами:
</p></blockquote><blockquote><blockquote><p align="justify">
Editor &mdash; маршрут (путь) к вашему любимому редактору текстов.
</p></blockquote></blockquote><blockquote><p align="justify">
Для этого включите в файл &quot;S:User-Startup&quot; следующую строку:
</p></blockquote><blockquote><blockquote><pre>
setenv Editor C:Ed
</pre></blockquote></blockquote><blockquote><p align="justify">
Вместо &quot;<a href="AMIGA-10.html#A100L">C:Ed</a>&quot; вы, разумеется, можете указать любой другой маршрут. Некоторые программы (например, More) используют значение переменной Editor для вызова текстового редактора.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101A>
<b>IF</b> NOT/S,WARN/S,ERROR/S,FAIL/S,   (встроенная для ОС 2 и 3)
   EQ/K,GT/K,GE/K,VAL/S,EXISTS/K
</a></pre></font></blockquote><blockquote><p align="justify">
Команда используется исключительно в командных файлах для организации ветвлений в конструкциях IF&hellip;ENDIF или IF&hellip;ELSE&hellip;ENDIF. IF проверяет значение некоторого выражения, следующего непосредственно за ним в строке. Если это значение &mdash; ненулевое, то выполняются все команды между IF и ELSE, либо между IF и ENDIF (при отсутствии ELSE). Если значение выражения &mdash; нулевое (т.е. ложное), то управление передается на строку, непосредственно следующую за командой ELSE, либо ENDIF (при отсутствии ELSE).
</p></blockquote><blockquote><p align="justify">
Использование IF без соответствующего ему ENDIF не допускается. ELSE может находиться между IF и ENDIF. Конструкции IF&hellip;ENDIF могут иметь любую степень вложенности:
</p></blockquote><blockquote><blockquote><pre>
IF ERROR
   IF $result2 EQ 205
       echo "Ошибка 205!"
   ENDIF
ELSE
   echo "Порядок!"
ENDIF
</pre></blockquote></blockquote><blockquote><p align="justify">
Параметр-переключатель NOT заставляет IF работать &quot;наоборот&quot; &mdash; команды после IF NOT будут выполняться тогда и только тогда, если значение условного выражения ложно (равно нулю).
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель WARN вызывает срабатывание IF, если код возврата предыдущей исполненной команды больше или равен 5. ERROR и FAIL работают аналогично WARN, но для значения кода возврата 10 и 20 соответственно.
</p></blockquote><blockquote><p align="justify">
Ключевое слово EQ (от слова EQual &mdash; равно) может использоваться для проверки на равенство двух строк, содержащих произвольные символы, регистр букв при этом игнорируется. Для того, чтобы проверка давала правильный результат для строк, содержащих русские буквы различных регистров, у вас должна быть как минимум ОС 2.1, а также русификатор начиная с пятой версии. Строки, содержащие пробелы, должны быть обязательно заключены в кавычки. Вместо строк можно без ограничений использовать имена переменных окружения (перед этими именами должен стоять знак доллара). 
Если одна строка длиннее другой, то в любом случае они считаются не равными.
</p></blockquote><blockquote><p align="justify">
Пример использования EQ:
</p></blockquote><blockquote><blockquote><pre>
IF &quot;РОТА, ПОДЪЕМ!&quot; EQ &quot;рота, подъем!&quot;
   echo &quot;Проверка работает правильно&quot;
ELSE
   echo &quot;У вас старый русификатор или старая Амига&quot;
ENDIF
</pre></blockquote></blockquote><em><blockquote><p align="justify">
Весьма специфический текст этого примера связан с необходимостью проверить правильность сравнения строчного твердого знака с заглавным &mdash; только языковой драйвер &quot;LOCALE:Languages/russian.language&quot;, поставляемый с русификатором 5-й версии, позволяет правильно сравнивать твердые знаки в разных регистрах. Столь запоздалое появление языкового драйвера связано с полнейшим отсутствием документации по имеющимся функциям, включаемым в драйверы, а также по способам вызова этих функций, только недавно удалось выкроить время и со всем этим разобраться.
</p></blockquote></em><blockquote><p align="justify">
Комбинация NOT EQ будет означать &quot;не равно&quot;.
</p></blockquote><blockquote><p align="justify">
Параметры-переключали GT и GE также, как и EQ сравнивают содержимое двух строк. GT означает &quot;больше чем&quot; (от слова GreaTer), a GE &mdash; больше или равно (от Greater or Equal). Комбинации NOT GT и NOT GE будут соответственно означать &quot;меньше или равно&quot; и &quot;меньше&quot;. При сравнении символов на &quot;больше-меньше&quot; учитываются значения их беззнаковых ASCII-кодов (в отличие, например, от трактовки ASCII-символов командой EVAL), например &quot;ъ&quot; имеет код 255 (а не -1). Регистры букв не учитываются, как и в случае параметра EQ. 
Если одна из строк длиннее другой, то при прочих равных условиях считается, что она &quot;больше&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель VAL, будучи использованным перед EQ, GT или GE, вызовет сравнение строк в два этапа: вначале строки будут преобразованы в числа, а затем будет произведено сравнение чисел между собой. Без использования VAL, например, оказалось бы, что 10 больше, чем 012, поскольку сравнение строк всегда происходит слева направо до первого несовпадающего символа, a ASCII-значение символа &quot;1&quot; больше, чем &quot;0&quot;. VAL успешно корректирует эту ситуацию для чисел.
</p></blockquote><blockquote><p align="justify">
Ключевое слово EXISTS с последующим маршрутом позволяет предпринять нужные действия в зависимости от того, в состоянии ли система обнаружить этот маршрут. Пример:
</p></blockquote><blockquote><blockquote><pre>
IF EXISTS С:
   echo &quot;В системе есть логическое устройство С:&quot;
ELSE
   echo &quot;Логическое устройство С: не обнаружено!&quot;
ENDIF
</pre></blockquote></blockquote><blockquote><p align="justify">
Если после EXISTS вы специфицируете имя диска (тома) или физическое имя устройства (например, DF1:), как по отдельности, так и в составе некоторого полного маршрута, а такое устройство (том) на момент исполнения IF EXISTS отсутствует в вашей системе, то выскочит риквестер типа &quot;Вставьте диск в устройство&hellip;&quot;, что, вообще говоря, обычно нежелательно при исполнении командных файлов. Поэтому для варианта поиска тома или физического устройства лучше подойдет следующий пример:
</p></blockquote><blockquote><blockquote><pre>
   assign >NIL: EXISTS DF1:
IF WARN
   echo "Дисковод DF1: отсутствует в вашей системе"
ELSE
   echo "Дисковод DF1: обнаружен"
ENDIF
</pre></blockquote></blockquote><blockquote><p align="justify">
В этом примере используется тот факт, что в случае неудачного поиска требуемого тома (устройства) команда <a href="AMIGA-10.html#A1005">ASSIGN EXISTS</a> не выводит никаких риквестеров. Правда, придётся умерить излишнюю разговорчивость самой команды <a href="AMIGA-10.html#A1005">ASSIGN</a>, направив выдаваемые ей сообщения вместо текущего Shell-окна в устройство &quot;NIL:&quot; (т.е. в никуда). 
Мы используем только результат работы команды <a href="AMIGA-10.html#A1005">ASSIGN</a> &mdash; тот уровень ошибки, который она после себя оставила.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101B>
<b>INFO</b> DEVICE
</a></pre></font></blockquote><blockquote><p align="justify">
Команда показывает общую информацию о различных устройствах, имеющихся в нашей системе. Будучи использованной без параметров, INFO становится наиболее многословной и сообщает все возможные сведения обо всех дисковых и псевдодисковых устройствах. В результате выводится что-то вроде следующей таблицы:
</p></blockquote><blockquote><blockquote><pre>
Mounted disks:

Unit   Size    Used    Free  Full  Errs  Status   Name
  
CD0:   No disk present  
SD0:   879K      11    1747    1%  0  Read/Write  SD0  
RAM:   483K     483       0  100%  0  Read/Write  Ram Disk  
DH0:   344M  561362  144236   80%  0  Read/Write  Work  
DF0:  1759K     185    3333    5%  0  Read Only   Пустой  
DF2:   879K     835     923   47%  0  Read/Write  Преферанс  
DH1:   342M  691804    9769   99%  0  Read/Write  General  
DH2:   345M  335040  372574   47%  0  Read/Write  Volatile  

Volumes available:

Пустой [Mounted]
Преферанс [Mounted]
SD0 [Mounted]
Ram Disk [Mounted]
Volatile [Mounted]
General [Mounted]
Work [Mounted] 
</pre></blockquote></blockquote><blockquote><p align="justify">
Сначала пройдёмся по столбцам, т.е. слева направо. Столбцы содержат информацию только в случае, когда в устройстве есть диск, иначе выводится сообщение &quot;No disk present&quot; (диск отсутствует).
</p></blockquote><blockquote><blockquote><p align="justify">
<em>Unit</em>&nbsp;&nbsp;содержит физические имена смонтированных устройств;
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Size</em>&nbsp;&nbsp;показывает максимальный объем информации, который данное устройство способно вместить (буква &quot;К&quot; соответствует килобайтам, &quot;М&quot; &mdash; мегабайтам);
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Used</em>&nbsp;&nbsp;показывает число заполненных блоков (размер одного блока составляет, как правило, 512 байт); 
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Free</em>&nbsp;&nbsp;показывает, сколько блоков свободны;
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Full</em>&nbsp;&nbsp;показывает процент заполненности, т.е. отношение числа используемых блоков к общему числу блоков для данного устройства;
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Errs</em>&nbsp;&nbsp;показывает число динамических ошибок, которое зафиксировано системой при работе с данным устройством. Динамические ошибки по сути являются временными ошибками чтения с диска, которые удалось устранить после повторной попытки (попыток). Если после нескольких повторных попыток ошибку так и не удалось устранить, ошибка считается статической, т.е. постоянной;
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Status</em>&nbsp;&nbsp;показывает, защищён ли диск от записи. Любые попытки произвести запись на диск находящийся в состоянии &quot;Read Only&quot; приведут к выводу сообщения об ошибке. Чтобы разрешить запись на дискету, необходимо передвинуть позунок защиты к центру дискеты.
</p></blockquote></blockquote><blockquote><blockquote><p align="justify">
<em>Name</em>&nbsp;&nbsp;показывает имя диска (тома), находящегося в устройстве.
</p></blockquote></blockquote><blockquote><p align="justify">
В дополнительной табличке, озаглавленной &quot;Volumes available&quot; выводится список всех дисков (томов), о существовании которых ОС так или иначе знает на данный момент времени. Кроме имён, выводится также статус дисков &mdash; смонтированы они или нет. Например, если некоторый маршрут, которым пользуется ОС, указывает на диск, которого нет ни в одном из дисководов, то имя этого диска 
будет выведено в этой табличке, хотя и будет указано, что он не смонтирован (Not mounted). 
</p></blockquote><blockquote><p align="justify">
Команде INFO можно также указать физическое имя или имя тома, информацию о котором желательно получить. В этом случае будет выведена информация, касающаяся только указанного устройства (тома).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101C>
<b>INSTALL</b> DRIVE/A,NOBOOT/S,CHECK/S,FFS/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда устанавливает минимальные средства ОС на форматированный гибкий диск. В дальнейшем с этого диска становится возможным старт системы в наиболее урезанном варианте &mdash; будет запущен первый Shell-процесс и, соответственно, выведено Shell-окно. Однако из всего того, что есть в ОС, будут работать только встроенные команды. Для более-менее полноценной работы ОС необходимо еще скопировать массу каталогов и файлов на новый диск.
</p></blockquote><blockquote><p align="justify">
Если вы хотите создать стартовый диск путем копирования требуемых каталогов и файлов с системной дискеты на свежеотформатированный диск, то без команды INSTALL, примененной к новому диску, старт системы с него будет невозможным.
</p></blockquote><blockquote><p align="justify">
<img src="Gfx/AMIGA-NB.gif" alt="notabene!" width="40" height="20">
<em>Не следует применять INSTALL к не ОС-овским дискам, содержащим игрушки &mdash; в 99% случаев вы не сможете больше в эти игрушки играть, а ясности в том, что на этих дисках находится, вы таким путем все равно не достигнете. Хакеры (это слово во всем цивилизованном мире является, мягко говоря, нелестным, только в России почему-то произносится с уважением) взламывают защищенные от копирования диски отнюдь не с помощью INSTALL.</em>
</p></blockquote><blockquote><p align="justify">
Обязательным параметром для INSTALL является физическое имя устройства, на диск которого вы желаете проинсталировать ОС. Перед именем может стоять необязательное ключевое слово DRIVE. INSTALL работает только с дисководами (DF0:, DF1:, DF2: и DF3:). Для инсталяции ОС на жёсткие диски применяются иные средства (обычно используется описанная в четвертой части этой книги программа HDToolBox).
</p></blockquote><blockquote><p align="justify">
INSTALL можно также рассматривать в качестве простейшего средства борьбы с вирусами, поскольку параметр-переключатель NOBOOT позволяет удалить с диска бут-блок, который зачастую является носителем вирусов. INSTALL NOBOOT не разбирается, является ли бут-блок диска стандартным или нет, а просто стирает его.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель CHECK позволяет проверить, имеет ли некоторый диск бут-блок и если да, то стандартный ли это бут-блок или нет. В случае нестандартного бут-блока (вдруг там вирус?), кроме соответствующего сообщения, команда возвратит также код ошибки 5.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель FFS насильно устанавливает FFS бут-блок на диск, сформатированный под OFS. По умолчанию INSTALL устанавливает бут-блок той файловой системы, под которую диск был отформатирован.
</p></blockquote><blockquote><p align="justify">
При использовании команды INSTALL в системах, где есть только один дисковод (DF0:, разумеется), возникает забавный эффект, связанный с тем что INSTALL (в отличие, например, от <a href="AMIGA-10.html#A100X">FORMAT</a>) не просит вставить диск, на который будет инсталироваться ОС, а сразу берётся за дело. Поскольку INSTALL не является встроенной командой, то ОС попросит вас вставить в DF0: системный диск, с которого загрузит и запустит INSTALL, которая, ничтоже сумняшесь, проинсталирует ОС на этот же системный диск, оставив вас в состоянии некоторой растерянности. Можно, конечно, сделать INSTALL резидентной командой и держать её в памяти, пока в том есть необходимость; а есть ещё небольшой системный трюк, после которого вы сможете почувствовать себя кем-то вроде хакера (в хорошем смысле этого слова) &mdash; исполните:
</p></blockquote><blockquote><blockquote><pre>
INSTALL ?
</pre></blockquote></blockquote><blockquote><p align="justify">
Честная ОС загрузит INSTALL с системного диска и выведет в качестве подсказки возможные образцы параметров, ожидая, что вы выберете. Вот тут-то и замените диск в DF0: на тот, что вам нужен, а затем наберите DF0: и нажмите Enter. Видите, как просто&hellip;
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101D>
<b>IPREFS</b>
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда ОС 2 и 3 автоматически запускается из файла &quot;S:Startup-Sequence&quot; и обеспечивает работу обновленного для этих версий ОС механизма пользовательских установок (preferences). Команда IPREFS при первоначальном запуске считывает все файлы установок, находящиеся в каталоге &quot;ENV:Sys&quot;, и подгоняет всю систему под их требования. Затем IPREFS остается работать в качестве резидентного процесса системы, зорко следя за тем, не захотели ли вы изменить какие-либо из установок. Если да, то IPREFS берет на себя всю работу по оповещению всей системы о произошедших изменениях.
</p></blockquote><blockquote><p align="justify">
Одной из наиболее сложных с точки зрения системы ситуаций является какое-либо изменение характеристик Workbench-экрана, на котором самыми разными процессами может быть открыта масса окон. В этом случае система попросит вас закрыть окна вручную (за исключением окон, представляющих содержимое каталогов, &mdash; система может их закрыть сама, не опасаясь каких-либо побочных эффектов), т.к. необходимо закрыть и заново открыть в ином режиме экран Workbench, породивший все эти окна. То же самое происходит при запуске IPREFS &mdash; поэтому, если в силу каких-то причин экран Workbench с окном (окнами) на нём 
оказался открытым на момент исполнения IPREFS, вы получите тот же запрос на ручное закрытие окон. По этой причине никакой вывод на экран в файле &quot;S:Startup-Sequence&quot; не допускается (по крайней мере, до исполнения IPREFS). Вообще говоря, если у вас ОС 2 или 3, то &quot;S:Startup-Sequence&quot; трогать не надо, за исключением каких-либо форс-мажорных ситуаций &mdash; экспериментируйте себе на здоровье с файлом &quot;S:User-Startup&quot;.
</p></blockquote><blockquote><p align="justify">
IPrefs автоматически запускается без параметров и повторный ручной запуск ни при каких обстоятельствах не потребуется.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101E>
<b>JOIN</b> FILE/M/A,AS=TO/K/A
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда позволяет объединить несколько файлов в один. Файлы &quot;подцепляются&quot; друг к другу в порядке их перечисления в команде JOIN. После указания объединяемых файлов должно следовать обязательное ключевое слово AS (или ТО), а затем маршрут создаваемого файла, являющегося объединением всех перечисленных. Создаваемый файл не может переписывать заново ни один из исходных файлов. ОС 2 и 3 допускает применение шаблонов в именах (имени) исходных файлов. Например, при исполнении:
</p></blockquote><blockquote><blockquote><pre>
join  #? AS RAM:Все
</pre></blockquote></blockquote><blockquote><p align="justify">
все файлы текущего каталога сольются в единственный файл RAM-диска под названием &quot;Все&quot;. Заметьте, что если RAM-диск был текущим каталогом на момент исполнения JOIN и на нём уже присутствовал файл &quot;Все&quot;, то вы получите сообщение об ошибке. Применяя шаблоны следует быть осторожным, т.к. практически всегда важна очередность сцепки файлов друг с другом, а в случае применения шаблонов очередность сцепки файлов, подпадающих под один и тот же шаблон, может быть какой угодно 
(на самом деле она зависит от того, какой из файлов был записан на диск раньше другого &mdash; время создания файла здесь запросто может не быть ориентиром).
</p></blockquote><blockquote><p align="justify">
Версии ОС до 2-й не допускали объединения сразу более 15-ти файлов, а также применения шаблонов. Ключевое слово ТО было введено, начиная с ОС 1.3.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101F>
<b>LAB</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Применяется в командных файлах для указания строки, куда будет осуществлен переход по команде <a href="AMIGA-10.html#A1028">SKIP</a>. После LAB дожно следовать имя метки. 
Это же имя должно находиться после соответствующей команды <a href="AMIGA-10.html#A1028">SKIP</a>, которая осуществит переход на строку, где находится LAB. Пример использования:
</p></blockquote><blockquote><blockquote><pre>
IF EXISTS WORK:Работа
   SKIP DoIt 
ENDIF
   echo &quot;Нечего делать!&quot;
QUIT 

LAB DoIt
    Ed Work:Работа
    echo &quot;Готово!&quot;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101G>
<b>LIST</b> DIR/M,P=PAT/K,KEYS/S,DATES/SINODATES/S,TO/KISUB/K,SINCE/K,
     UPTO/K,QUICK/S,BLOCK/S,NOHEAD/S,FILES/S,DIRS/S,LFORMAT/K,
     ALL/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда выводит массу информации либо обо всём выбранном каталоге, либо о части каталога, либо о единственном файле. Показываются также комментарии, возможно созданные командой <a href="AMIGA-10.html#A100V">FILENOTE</a>. Имена каталогов и файлов выводятся в крайней левой колонке, затем следует различная дополнительная информация, касающаяся объекта с этим именем. Для файлов указывается длина в байтах, а для каталогов &mdash; идентификатор Dir. Далее могут следовать признаки защиты, а затем дата создания/изменения. Если имеется комментарий, то он показывается под текущей строкой и перед ним ставится двоеточие.
</p></blockquote><blockquote><p align="justify">
Команда LIST, будучи использованной без параметров, выведет листинг текущего каталога.
</p></blockquote><blockquote><p align="justify">
Первым параметром по умолчанию считается маршрут каталога (каталогов), содержимое которого (которых) необходимо показать (этих маршрутов может быть несколько). Если маршрут является не первым параметром, ему обязательно должно предшествовать ключевое слово DIR. В маршруте (маршрутах) можно использовать шаблоны &mdash; при этом отпадает необходимость использовать ключевое слово PAT (или Р) при показе группы объектов. Например, чтобы показать текущий каталог без файлов, соответствующих иконкам, достаточно исполнить:
</p></blockquote><blockquote><blockquote><pre>
LIST ~ (#?.info)
</pre></blockquote></blockquote><blockquote><p align="justify">
Ключевое слово PAT (или просто Р) использовалось в версиях ОС до 1.3, т.к. там нельзя было использовать шаблоны в именах объектов. В более новых версиях нет никакой необходимости пользоваться PAT &mdash; достаточно просто задать шаблон и всё.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель KEYS заставляет LIST выводить номера блоков, соответствующих каждому из показываемых объектов. Каждый объект должен иметь уникальный номер описывающего его блока &mdash; иначе последствия могут быть, мягко говоря, не очень приятными (так называемый &quot;кросс-линк&quot;, безболезненно избавиться от которого &mdash; всё равно что попытаться выдернуть из карточного домика нижнюю карту, не обрушив всю конструкцию; здесь следует воспользоваться наиболее умными из имеющихся на данный момент диск-корректоров, например AmiBack Tools). Монотонность возрастания номеров блоков в списке свидетельствует о малой степени фрагментации диска.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель DATES вызывает вывод информации о дате и времени создания или последнего изменения объектов. Явное использование DATES представляется достаточно бессмысленным, поскольку по умолчанию дата и время и так выводятся (чтобы отключить вывод дат/времени необходимо использовать параметр QUICK или NODATES).
</p></blockquote><blockquote><p align="justify">
Ключевое слово ТО с последующим маршрутом определяет, куда направить поток вывода команды LIST. По умолчанию вывод происходит в текущее Shell-окно, однако ничто не мешает, используя ТО, создать файл, содержащий то, что вывела команда LIST или распечатать листинг каталога на принтере. Если вывод направлен в уже существующий файл, то этот файл будет вначале удален, а затем создан заново &mdash; по этой причине отсутствие признака &quot;Удаляемый&quot; у такого файла вызовет генерацию командой LIST сообщения об ошибке. Альтернативой ТО является более общий оператор перенаправления потока вывода &quot;&gt;&quot; (например, LIST&nbsp;&gt;&nbsp;PRT: вызовет распечатку листинга на принтере).
</p></blockquote><blockquote><p align="justify">
Ключевое слово SUB с последующим параметром &mdash; некоторой строкой (если эта строка содержит пробелы, то она обязательно должна быть заключена в кавычки) заставляет LIST выводить информацию только о тех объектах, чьи имена включают в себя эту строку. Как и параметр PAT, SUB является атавизмом тех времен, когда LIST не позволял использовать шаблоны (иначе говоря, &mdash; маски, только на Амиге они сравнимы по мощности с регулярными выражениями), поэтому, начиная с ОС 1.3, использовать SUB нет ни малейшего смысла &mdash; шаблоны куда мощнее.
</p></blockquote><blockquote><p align="justify">
Использование ключевого слова SINCE с последующей спецификацией некоторой даты, приводит к тому, что будет выведена информация только о тех объектах, чьё время создания/последнего изменения приходится либо на указанную дату, либо после неё. Формат вводимой даты полностью совпадает с тем, что требуется для команды DATE (см. описание DATE). Единственная разница, что дни недели берутся из прошлого, а не из будущего (&quot;LIST SINCE Понедельник&quot; покажет все файлы/каталоги созданные/изменённые, начиная с прошлого понедельника).
</p></blockquote><blockquote><p align="justify">
Ключевое слово UPTO с последующей спецификацией некоторой даты приводит к тому, что будет выведена информация только о тех объектах, чьё время создания/последнего изменения приходится либо на указанную дату, либо до неё. Формат строки, представляющей дату тот же, что и при использовании ключевого слова SINCE.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели DIRS или FILES заставляют LIST выводить информацию только о каталогах, либо только о файлах.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель QUICK заставляет LIST выдавать минимум информации &mdash; будут выводиться только имена файлов и каталогов. Впрочем, можно заставить QUICK выводить время создания/модификации объектов, использовав параметр-переключатель DATES. Опцию QUICK можно принудить к еще большей лаконичности, использовав параметры-переключатели DIRS или FILES.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель BLOCK заставляет LIST показывать длину файлов не в байтах, а в блоках (как правило, длина блока &mdash; 512 байт).
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель NOHEAD подавляет вывод заголовка списка и его заключительной строки, где подытоживаются данные по всему списку.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL вызывает генерацию листинга не только указанного каталога, но также и всех возможно имеющихся в нем подкаталогов.
</p></blockquote><blockquote><p align="justify">
Ключевое слово LFORMAT с последующей форматной строкой позволяет вам полностью управлять форматом вывода команды LIST. Комбинируя LFORMAT с ключевым словом ТО или используя перенаправление потока вывода с помощью &quot;&gt;&quot;, что, в принципе то же самое, можно, например, автоматически генерировать командные файлы, выполняющие заданные вами действия над теми объектами, имена которых выведет команда LIST. Ваша форматная строка может содержать абсолютно произвольный текст. В тех местах, где команда LIST должна вставлять имена объектов, необходимо использовать идентификатор подстановки %S. Допускается многократное использование %S в одной и той же форматной строке. При многократном использовании %S, на его место будет подставляться или относительный маршрут или имя объекта в соответствии со следующей таблицей, где N? &mdash; число вхождений %S в форматной строке, М &mdash; относительный маршрут, О &mdash; имя объекта:
<center><img src="Gfx/AMIGA-scheme4.gif" width=139 height=76 alt="таблица вхождений форматной строки"></center>
</p></blockquote><blockquote><p align="justify">
Например, при четырех вхождениях %S в форматную строку 3-е вхождение будет заменено на относительный маршрут. Относительным маршрутом является список каталогов, который вы должны пройти, чтобы добраться до нужного каталога из текущего.
</p></blockquote><blockquote><p align="justify">
Версии ОС 2 и 3 позволяют использовать в форматной строке, кроме %S, следующие дополнительные идентификаторы подстановок:
</p></blockquote><blockquote><blockquote><pre>
%А &mdash; признаки защиты объекта;
%В &mdash; размер файла в блоках;
%С &mdash; комментарий файла;
%D &mdash; дата создания или последнего изменения;
%F &mdash; полный маршрут объекта (начинающийся с корневого каталога);
%К &mdash; номер ключевого блока;
%L &mdash; длина файла в байтах;
%N &mdash; имя объекта;
%Р &mdash; относительный маршрут объекта;
%Т &mdash; время создания или последнего изменения объекта.
</pre></blockquote></blockquote><blockquote><p align="justify">
Ещё два идентификатора подстановок имеются в вашем распоряжении, начиная с ОС 2.1:
</p></blockquote><blockquote><blockquote><pre>
%Е &mdash; расширение имени файла (часть имени после последней точки);
%М &mdash; имя без расширения (часть имени до последней точки).
</pre></blockquote></blockquote><blockquote><p align="justify">
Так, расширением имени файла &quot;Амига.ОС.описание&quot; будет слово &quot;описание&quot;.
</p></blockquote><blockquote><p align="justify">
Пример использования: создадим с помощью LIST командный файл, запустив который мы сделаем неудаляемыми все файлы и каталоги, имеющиеся на диске в дисководе &quot;DFO:&quot;. Командный файл по имени &quot;Проба&quot; будет создан в каталоге &quot;RAM:&quot;.
</p></blockquote><blockquote><blockquote><pre>
LIST DF0: ALL LFORMAT &quot;protect %S -d&quot; TO RAM: Проба
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101H>
<b>LOADWB</b> DEBUG/S,DELAY/S,CLEANUP/S,NEWPATH/S
</a></pre></font></blockquote><blockquote><p align="justify">
Запускает операционную среду Workbench. Обычно она исполняется автоматически (LOADWB &mdash; предпоследняя команда файла &quot;S:Startup-Sequence&quot;) и никакой нужды в её ручной активации не возникает. Разумеется, если вы настраиваете свою систему и были вынуждены в силу каких-либо причин остановить исполнение файла &quot;S:Startup-Sequence&quot;,нажав CTRL&nbsp;+&nbsp;С, то потом вы сможете запустить LOADWB вручную.
</p></blockquote><blockquote><p align="justify">
Когда запускается Workbench, LOADWB фиксирует все маршруты поиска, существующие на этот момент времени, и позже может передавать их любому Shell-процессу, который стартовал уже из Workbench.
</p></blockquote><blockquote><p align="justify">
Попытка повторного запуска Workbench в версиях ОС до 2-й приводит к инициализации ещё одного Workbench-процесса. Более новые версии ОС проигнорируют подобное действие.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель DEBUG активирует обычно отсутствующее меню, предназначенное исключительно для программистов. Меню состоит из двух заголовков &mdash; Debug (отладчик для ОС 2 и 3 называется ROMWACK) и Flushlibs. Действие Flushlibs полностью аналогично исполнению команды AVAIL с параметром FLUSH (см. описание <a href="AMIGA-10.html#A1006">AVAIL</a>). Что касается отладчика, то для его использования вам необходим, как минимум, удаленный терминал, связанный с Амигой через последовательный порт (скорость 9600 бод). Без такого терминала машина просто зависнет, поскольку весь ввод будет осуществляться только с него и ни мышь, ни клавиатура работать не будут.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель DELAY создает трехсекундную паузу перед возвратом из LOADWB. Дело в том, что в случае, если старт системы произошел с дискеты, то LOADWB устраивает интенсивную возню с диском, которую желательно закончить до того, как следующая за LOADWB команда тоже полезет (возможно) на этот же диск &mdash; иначе обе команды попытаются одновременно работать с диском, таская головку туда-сюда, что весьма неэстетично с системной точки зрения.
</p></blockquote><blockquote><p align="justify">
Версия ОС 1.3 не позволяет использовать параметры DELAY и DEBUG одновременно.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель CLEANUP (аналогичный опции меню Workbench &quot;Расставить&quot; вызывает авторасстановку дисковых иконок Workbench &quot;по линеечке&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель NEWPATH, работающий только в ОС 2 и 3, позволяет изменить маршрут, ассоциированный с Workbench. По умолчанию LOADWB запоминает маршрут того shell-процесса, из которого произошел запуск LOADWB и присваивает этот маршрут любому shell-процессу, который стартовал после щелканья по соответствующей Workbench-иконке. Используя параметр NEWPATH можно позднее изменить этот маршрут, исполнив LOADWB NEWPATH из другого Shell-окна.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101I>
<b>LOCK</b> ON/S,OFF/S,PASSKEY/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда является &quot;надводной частью айсберга&quot; системы динамического распределения доступа к различным ресурсам Амиги. Очень трудно удержаться от сооблазна и не рассказать о системе замков (lock переводится на русский именно так) чуть-чуть поподробнее &mdash; примерно 1% от того, что вообще можно на эту тему сказать.
</p></blockquote><blockquote><p align="justify">
Поскольку Амига &mdash; по-настоящему многозадачный компьютер (в отличие от многих других, пытающихся изо всех сил казаться &quot;тоже многозадачными&quot;, но устойчиво работающих в многозадачном режиме, только если работает одна-единственная задача), то в системе обязательно должен присутствовать &quot;высший судия&quot;, разбирающий бесконечные иски законопослушных процессов о единоличносм праве на владение ресурсами. Мы не случайно употребили слово &quot;законопослушных&quot; в тайной надежде, что эту книгу читает программист, который больше не будет писать программ, самоуверенно полагающих что они и только они в любой момент времени могут делать с системой всё, что заблагорассудится. Всё, что может сделать НОРМАЛЬНАЯ амиговская программа: попросить на некоторое время у системы некоторый ресурс, попользоваться им, если система таковой ресурс предоставила, а затем сообщить системе, что данный ресурс ей более не нужен. Под ресурсом можете подразумевать, что угодно: диски, файлы, каталоги, память, экраны, окна, звуковые каналы, джойстик &mdash; все, кроме блока питания.
</p></blockquote><blockquote><p align="justify">
Высшим судьей, или, более прозаично выражаясь, системным арбитром является набор функций различных системных библиотек (в основном &mdash; &quot;exec.library&quot;), который отвечает за устойчивую работу Амиги в многозадачном режиме. Поскольку НОРМАЛЬНЫХ программ в системе может одновременно работать сколько угодно, никто не запрещает им например, попросить у системы открыть один и тот же файл (сознательно приводим пример попроще). Ну хорошо, открыли, вроде ничего страшного, а если все вдруг начнут в него записывать каждый своё? 
Что в конце концов запишется на диск? Вот здесь-то и надо вспомнить о руководящей и направляющей силе системных библиотек. Любое открытие файла сопровождается навешиванием на него замка тем процессом, который получил разрешение на открытие файла. Замки бывают двух типов &mdash; разрешающий доступ по чтению, иначе называемый разделяемым (shared), поскольку имеется в виду множественный доступ по чтению (правильнее было бы назвать его &quot;прозрачным&quot; &mdash; хоть видит око, да зуб неймёт, не знаю, есть ли в Штатах, где все это выдумали, аналогичная поговорка). 
В этом случае другие программы смогут только читать файл. Есть еще совсем суровый &quot;исключительный&quot; замок (exclusive lock), когда даже читать нельзя, пока замок не снимет тот, кто его повесил. Правда, никакими доступными для пользователя (не для программиста, разумеется) командами повесить его нельзя.
</p></blockquote><blockquote><p align="justify">
Команда LOCK является единственным средством, позволяющим пользователю повесить прозрачный замок на любое (псевдо-)дисковое устройство Амиги. Вы можете, например, запретить запись на целую партицию жесткого диска, воспользовавшись этой командой.
</p></blockquote><blockquote><p align="justify">
Команда LOCK впервые появилась в ОС 1.3 для разрешения/запрета записи на FFS-партиции жестких дисков. В ОС 2 и 3 диапазон её применения расширился &mdash; теперь с помощью LOCK можно блокировать по записи любые (псевдо-)дисковые устройства Амиги.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром для LOCK является имя устройства, которое вы хотите заблокировать. Эта команда является своего рода исключением в том, как она работает с дисководами. Обычно команды всегда имеют дело с конкретным диском, находящимся в дисководе. Однако LOCK блокирует по записи именно сам дисковод.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели ON и OFF указывают, должна ли команда LOCK навесить или снять замок. Впрочем, OFF можно вообще никогда не употреблять &mdash; по умолчанию замок снимается.
</p></blockquote><blockquote><p align="justify">
Необязательный параметр PASSKEY является строкой, представляющей из себя пароль. Если применить пароль при установке замка, то тот же пароль должен быть введен и при его снятии, иначе убрать замок не удастся. Строка-пароль, содержащая пробелы, должна быть заключена в кавычки.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101J>
<b>MAGTAPE</b> DEVICE/K,UNIT/N/K,RET=RETENSION/S,REW=REWIND/S,SKIP/N/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда ОС 2 и 3 позволяет управлять стримером Commodore А3070, который используется как устройство для архивирования данных. Поскольку стример является устройством последовательного доступа, манипуляции с ним напоминают работу с магнитофоном, так как для поиска требуемого файла надо вручную управлять стримером, перематывая плёнку. Команда MAGTAPE позволяет перематывать плёнку, пропуская заданное число файлов. Периодическая перемотка пленки требуется и для снятия внутренних напряжений в рулоне.
</p></blockquote><blockquote><p align="justify">
Обычно стример работает через драйвер &quot;scsi.device&quot; с номером модуля 4. Если конфигурация вашей системы отлична от стандартной, то необходимо явно указать имя устройства и модуля, задав параметры DEVICE и UNIT.
</p></blockquote><blockquote><p align="justify">
Использование параметра-переключателя RET (или RETENSION) вызовет полную перемотку кассеты в обоих направлениях, что снимет возможные механические напряжения в рулоне.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель REW (или REWIND) вызовет перемотку плёнки на начало. Ключевое слово SKIP с числовым параметром &mdash; количеством файлов, которые надо пропустить, вызовет перемотку плёнки вперёд с пропуском заданного числа файлов.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101K>
<b>MAKEDIR</b> NAME/M/A
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда создает новый каталог (или сразу несколько каталогов). Параметром служит один или несколько маршрутов, завершающихся именами создаваемых каталогов. Если каталоги с указанными именами уже существуют по указанным маршрутам, то будет выдано сообщение об ошибке. Ошибка также произойдет, если указанные маршруты не будут обнаружены. В случае указания неполных маршрутов, точкой отсчета будет являться текущий каталог.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101L>
<b>MAKELINK</b> FROM/A,TO/A,HARD/S,FORCE/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда версий ОС 2 и 3 создаёт связные файлы, являющиеся по сути указателями на некоторые другие файлы. Теперь если какая-либо из программ обратится к связному файлу, то на самом деле она получит доступ к тому файлу, на который указывает связной файл. Столь экзотическая на первый взгляд возможность становится весьма удобной, если учесть тот факт, что многие программы сами пытаются обращаться к различным файлам, которые, как этим 
программам кажется, должны лежать по раз и навсегда отведенным маршрутам. Например, в Амиге существует масса различных программ для просмотра текстовых файлов &mdash; называются они More, MuchMore, Moor или даже Less. Находиться эти файлы могут и в каталоге &quot;С:&quot;, и &quot;SYS:System&quot;, и &quot;SYS:Utilities&quot; и т.д. В иконках же текстовых файлов, в полях стандартного инструмента, зачастую стоят совершенно определенные 
ссылки на конкретный маршрут и файл. Поэтому представляется весьма удобным свести всю эту разноголосицу к общему знаменателю, использовав файлы связей и не возиться каждый раз с иконками очередных текстовых файлов.
</p></blockquote><blockquote><p align="justify">
Параметр FROM соответствует обязательно задаваемому имени создаваемого связного файла. Само ключевое слово FROM необходимо употреблять только тогда, когда этот параметр не является первым по счёту. 
Обязательный параметр ТО соответствует тому файлу, на который будет указывать создаваемый связной файл. Ключевое слово ТО необходимо использовать только в том случае, если это не второй параметр команды MAKELINK.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель HARD устанавливает т.н. сильную (hard) связь, когда связной файл и тот, на который связной файл указывает, находятся на одном и том же диске. В случае же слабой (soft) связи эти файлы могут находиться на разных дисках.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель FORCE позволяет создавать связные файлы, указывающие не на файлы, а на каталоги. Вообще говоря, подобные связи являются достаточно опасными с точки зрения нормального функционирования файловой системы (в особенности, если указанные каталоги сами содержат связные файлы или связь устанавливается с родительским каталогом по отношению к маршруту связного файла). MAKELINK, разумеется, по мере сил и возможностей пытается предотвратить различные побочные эффекты подобных связей и может запретить вам создавать некоторые из них, но стопроцентной гарантии безопасности здесь нет.
</p></blockquote><blockquote><p align="justify">
Периодически сообщается о не слишком высокой надежности работы связной системы, в особенности для 2-й версии ОС. Поэтому рекомендуем пользоваться командой MAKELINK начиная с ОС 3 (лучше всего 3.1), не создавать слабые связи и не использовать FORCE. При соблюдении этих правил никаких проблем возникать не должно.
</p></blockquote><blockquote><p align="justify">
Пример использования &mdash; заставим все программы, которые ожидают, что на устройстве &quot;С:&quot; есть файл MuchMore, на самом деле использовать Мооr (очень хорошую программу для просмотра текстов), находящуюся в каталоге &quot;SYS:Utilities&quot;:
</p></blockquote><blockquote><blockquote><pre>
makelink C:MuchMore SYS:Utilities/Moor
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101M>
<b>MOUNT</b> DEVICE/M,FROM/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда монтирует различные устройства, т.е. сообщает ОС об их наличии и параметрах. Как правило, MOUNT используется только при старте системы, исполняясь из файла&nbsp;&quot;S:Startup-Sequence&quot;.&nbsp;Источником данных, описывающих заданное устройство в версиях ОС, до 2-й служил файл &quot;DEVS:Mountlist&quot;, который в более поздних версиях ОС частично потерял свое значение в качестве единственного источника информации, требуемой для MOUNT. Кроме этого файла, можно явно указать на дополнительные описания устройств, находящиеся в файле, чей маршрут специфицирован после ключевого слова FROM.
</p></blockquote><blockquote><p align="justify">
Первым параметром для MOUNT является физическое имя монтируемого устройства, например, &quot;SPEAK:&quot;. Имён может быть несколько, в случае, если у вас версия ОС 2.1 или выше. Для этих же версий ОС играет роль наличие или отсутствие двоеточия, замыкающего имя устройства. Если двоеточие имеется, то используется или файл описания &quot;DEVS:Mountlist&quot;, или тот файл, который соответствует параметру FROM. В противном случае поиск будет производиться вначале в каталоге &quot;DEVS:DOSDrivers&quot;, затем в &quot;SYS:Storage/DOSDrivers&quot; и только в случае неудачного поиска &mdash; в обоих этих каталогах; MOUNT полезет в файл &quot;DEVS:Mountlist&quot; или указанный вами FROM-файл. В имени файла-описателя можно использовать шаблоны для одновременного монтирования нескольких устройств.
</p></blockquote><blockquote><p align="justify">
Файл описания устройств(-а) является обычным текстовым файлом, содержащим различные параметры устройств(-а). Для тех, кто знаком с языком программирования Си, некоторые особенности его синтаксиса покажутся знакомыми, в частности задание комментариев с помощью символов /* &hellip; */. формат шестнадцатеричных символов 0х&hellip; и разделение отдельных утверждений с помощью символа &quot;;&quot; (правда, точка с запятой здесь требуется только в том случае, если на одной строке находится более одного утверждения). Статья описания каждого отдельного устройства всегда заканчивается символом &quot;#&quot;.
</p></blockquote><blockquote><p align="justify">
Вот пример стандартного описания устройства псевдодискового устройства RAD:
</p></blockquote><blockquote><pre>
 Device          = ramdrive.device  /* Имя драйвера устройства */
 Unit            = 0                /* Номер модуля */
 Flags           = 0                /* Дополнительные признаки */
 Surfaces        = 2                /* Число сторон носителя */
 SectorsPerTrack = 11               /* Число секторов на дорожке */
 SectorSize      = 512              /* Длина сектора в байтах */
 Reserved        = 2                /* Число резервированных секторов */
 Interleave      = 0                /* Интерлив - как правило, нулевой */
 LowCyl          = 0                /* Номер первого цилиндра */
 HighCyl         = 79               /* Номер первого цилиндра */
 Buffers         = 5                /* Число резервированных буферов */
 BufMemType      = 1                /* Тип буферной памяти */
#
</pre></blockquote><blockquote><p align="justify">
Наиболее важным параметром является имя драйвера устройства, в данном случае, &quot;ramdrive.device&quot;. Драйвер может быть встроенным, т.е. находиться в постоянном запоминающем устройстве (ПЗУ), либо загружаемым с диска. В последнем случае, если маршрут драйвера не указан явно, считается, что он находится в каталоге &quot;DEVS:&quot;. Драйвер является программой-мостиком нижнего уровня между системой и конкретным устройством. 
Система воспринимает устройство на уровне &quot;чёрного ящика&quot;, посылая драйверу команды достаточно общего характера и только драйвер знает, что и как надо делать с устройством, чтобы добиться желаемых результатов. Это сравнимо с тем, что вы просите водителя такси подвезти вас до аэропорта, а дело водителя уметь рычаги дергать и педали нажимать &mdash; на то он и знаток конкретного устройства, которым управляет. Может там вообще 
не машина, а, скажем, самокат &mdash; неважно, лишь бы довёз куда надо. Поэтому пусть вас не удивляет, что в псевдодисковых устройствах типа &quot;RAD:&quot; или &quot;SD:&quot; присутствуют такие чисто дисковые параметры, как, например, число поверхностей или размер сектора, хотя никаких таких дисков в памяти компьютера, разумеется, нет &mdash; можете вскрыть по очереди все микросхемы памяти и убедиться сами. Подобные параметры введены 
исключительно ради того, чтобы достигнуть максимального единообразия команд, которые система посылает драйверу, что в конечном счёте сильно экономит системные ресурсы. Это его, драйверовы проблемы, что конкретно надо сделать, чтобы прочесть 3-й сектор 5-й дорожки по просьбе системы.
</p></blockquote><blockquote><p align="justify">
Команда MOUNT совершенно необязательно должна иметь дело с устройствами, хранящими данные в виде файлов. В AmigaOS есть, например, монтируемое устройство &quot;AUX:&quot;, которое позволяет использовать компьютер в многопользовательском режиме, подключив к нему один или несколько удаленных терминалов. Описание &quot;AUX:&quot; имеет следующий вид:
</p></blockquote><blockquote><pre>
 Handler   = L:aux-handler 
 Stacksize = 1000 
 Priority  = 5 
# 
</pre></blockquote><blockquote><p align="justify">
Здесь в первой строке вместо имени драйвера устройства стоит имя хэндлера устройства. Хэндлер, который, в принципе, делает то же самое, что и драйвер, на самом деле является программой более высокого уровня, нежели драйвер, и зачастую сам общается с устройствами, используя драйверы &mdash; ну всё равно, что мы бы разговаривали с уже упомянутым водителем такси через переводчика. В AmigaOS принято, что все хэндлеры должны находиться в каталоге &quot;L:&quot;. 
В случае с устройством &quot;AUX:&quot;, которое не имеет ни малейшего отношения к способу хранения информации в виде файлов, нет смысла применять понятия, характерные для файловых систем. Мы указываем имя хэндлера, размер стека, достаточного для его нормальной работы и приоритет нового процесса, обслуживающего устройство &quot;AUX:&quot;.
</p></blockquote><blockquote><p align="justify">
Начиная с версии ОС 2.1 введён более удобный механизм монтирования различных устройств, нежели смешивание их параметров в одну большую кучу &mdash; файл &quot;DEVS:Mountlist&quot;. В каталоге &quot;DEVS:&quot; появился подкаталог &quot;DOSDrivers&quot;, где каждому монтируемому устройству соответствует &quot;личный&quot; файл параметров, являющийся по сути вырезкой из старого файла &quot;DEVS:Mountlist&quot;. Правда здесь есть и нюансы. Во-первых, каждый файл каталога 
&quot;DEVS:DOSDrivers&quot; может описывать одно и только одно устройство. Во-вторых, имя устройства указывать в самом файле не нужно, т.к. это имя всегда совпадает с именем самого файла. В-третьих, символ &quot;#&quot; в тексте более не требуется, поскольку разделять описания различных устойств здесь не нужно.
</p></blockquote><blockquote><p align="justify">
Каждый файл снабжен собственной иконкой, которую в случае необходимости можно убрать, не вылезая из Workbench, в &quot;хранилище невостребованных устройств&quot; &mdash; каталог &quot;SYS:Storage/DOSDrivers&quot;. Начиная со следующего старта машины это устройство уже не будет монтироваться. Разумеется, ничто не мешает проделать обратную операцию и перенести иконку из &quot;SYS:Storage/DOSDrivers&quot; в &quot;DEVS:DOSDrivers&quot;. Если некоторое устройство требуется вам 
временно и нет необходимости монтировать его каждый раз при запуске машины, то и перетаскивать иконку не надо &mdash; достаточно открыть &quot;SYS:Storage/DOSDrivers&quot; и дважды щелкнуть по соответствующей иконке &mdash; требуемое устройство тут же будет смонтировано.
</p></blockquote><blockquote><p align="justify">
В последнее время стало модным вообще не создавать текстовые файлы описания устройств, а просто класть соответствующие строки в инструментарий иконки, что в данном случае аналогично использованию файла-описателя. Иногда этот способ задания параметров комбинируется со старым, когда строки, наиболее &quot;подверженные&quot; изменениям (обычно это строка номера модуля устройства &quot;unit &mdash; х&quot;) кладутся в иконку, а все прочие строки остаются в текстовом файле. 
Такой подход позволяет излишне не замусоривать инструментарий иконки практически никогда не меняющимися параметрами (инвариантами).
</p></blockquote><blockquote><p align="justify">
Некоторые параметры могут устанавливаться по умолчанию (в случае отсутствия в описателе соответствующей строки). Не все параметры имеют смысл для всего разнообразия монтируемых устройств. Ниже в алфавитном порядке дан полный список параметров, значения которых могут устанавливаться для различных устройств.
</p></blockquote><table width="95%">
<tr><td align="right" valign="top">Baud =</td>
<td width="80%">скорость последовательного порта в бодах.</td></tr>
<tr><td align="right" valign="top">BlocksPerTrack =</td>
<td width="80%">число блоков (дисковых секторов) на одну дорожку (цилиндр).</td></tr>
<tr><td align="right" valign="top">BootPri =</td>
<td width="80%">приоритет бутирования с данного устройства.<br> Может находиться в диапазоне от -129 до 127. В случае -129, устройство не является бутовым (т.е. старт системы с него невозможен или нежелателен).</td></tr>
<tr><td align="right" valign="top">Buffers =</td>
<td width="80%">число кэш-буферов, приписанных устройству. Имеет смысл только для действительно дисковых устройств.</td></tr>
<tr><td align="right" valign="top">BufMemType =</td>
<td width="80%">тип памяти, отводимой под кэш-буферы:<br>
0 или 1 &mdash; любая (если в системе есть fast-память, будет fast);<br>
2 или 3 &mdash; chip;<br>
4 или 5 &mdash; fast. 
</td></tr>
<tr><td align="right" valign="top">Control =</td>
<td width="80%">управляющие параметры последовательного порта: длина слова, чётность и число стоповых бит (например, 8N1 &mdash; расшифровывается как длина слова 8 бит, чётность не проверяется (None), 1 стоповый бит). Проверка на чётность обозначается &quot;Е&quot;, на нечётность &mdash; &quot;О&quot; (от слов Even и Odd).</td></tr>
<tr><td align="right" valign="top">Device =</td>
<td width="80%">имя драйвера устройства.</td></tr>
<tr><td align="right" valign="top">DosType =</td>
<td width="80%">идентификатор типа файловой системы, используемой данным устройством. Соответствует краткой форме описания типа ОС (см. команду FORMAT), правда, вводится довольно необычно: необходимо преобразовать строку, соответствующую типу требуемой файловой системы, в шестнадцатеричное число по правилам, принятым в языке Си. Пример: 
мы используем DOS3 (файловая система &quot;FFS-международная&quot;). Теперь заменяем все символы на их шестнадцатеричные ASCII-значения, причем от ASCII-значения цифры &quot;3&quot; оставляем только 4 младших бита &mdash; получилось 444F5303. Добавляем принятый в языке Си префикс шестнадцатиричного числа &quot;0х&quot; и получаем то, что требовалось: DosType = 0x444F5303.</td></tr>
<tr><td align="right" valign="top">EHandler =</td>
<td width="80%">только для ОС 2 и 3: имя хэндлера окружения.</td></tr>
<tr><td align="right" valign="top">FileSystem =</td>
<td width="80%">имя хэндлера файловой системы заданного устройства.</td></tr>
<tr><td align="right" valign="top">Flags =</td>
<td width="80%">различные битовые флажки, используемые функцией OpenDevice().</td></tr>
<tr><td align="right" valign="top">ForceLoad =</td>
<td width="80%">только для ОС 2.1 и выше. При нулевом значении параметра (а также по умолчанию), прежде, чем монтировать устройство, система просмотрит список открытых ресурсов на предмет обнаружения уже работающей файловой системы, чьё имя совпадает с затребованной. Если такая система будет обнаружена, то загрузка новой не произойдет &mdash; будет использоваться уже работающая. Ненулевое же значение параметра вызовет загрузку файловой системы вне зависимости от того, загружена она уже или нет.</td></tr>
<tr><td align="right" valign="top">GlobVec =</td>
<td width="80%">глобальный BCPL-вектор хэндлера. Исторически сложилось так, что первоначальная версия ОС была большей частью написана на языке BCPL. Хотя к настоящему времени масса функций была заново переписана на Си и ассемблере, тем не менее кое-что осталось из тех времен. В частности, если хэндлер написан на BCPL, то ему требуется глобальный вектор. Нулевое значение устанавливает собственный (private) глобальный вектор; любое другое &mdash; означает, что хэндлер написан на языке Си или ассемблере и 
никакого глобального вектора ему вообще не требуется. При отсутствии ключевого слова GlobVec в описании устройства используется общий (shared) глобальный вектор ОС.</td></tr>
<tr><td align="right" valign="top">Handler =</td>
<td width="80%">имя хэндлера устройства.</td></tr>
<tr><td align="right" valign="top">HighCyl =</td>
<td width="80%">номер наибольшего цилиндра.</td></tr>
<tr><td align="right" valign="top">Interleave =</td>
<td width="80%">значение ОС-интерлива. К физическому интерливу диска не имеет отношения.</td></tr>
<tr><td align="right" valign="top">LowCyl =</td>
<td width="80%">номер наименьшего цилиндра. Нумерация начинается с нуля.</td></tr>
<tr><td align="right" valign="top">Mask =</td>
<td width="80%">файловая система FFS использует это значение в качестве маски адресов, определяя диапазон памяти, пригодной для обмена данными в режиме прямого доступа.</td></tr>
<tr><td align="right" valign="top">MaxTransfer =</td>
<td width="80%">файловая система FFS использует это значение как максимальное число блоков, записанных или считанных за одну операцию.</td></tr>
<tr><td align="right" valign="top">Mount =</td>
<td width="80%">если это значение больше нуля, то команда MOUNT загружает хэндлер или драйвер устройства немедленно, а не при первой активации устройства, как обычно. Синонимом этого ключевого слова для версии ОС, начиная с 2.1 является ACTIVATE.</td></tr>
<tr><td align="right" valign="top">PreAlloc =</td>
<td width="80%">число резервированных блоков в конце партиции. Для амижных партиций всегда равно нулю. Ненулевое значение обычно используется для IBM-совместимых устройствах.</td></tr>
<tr><td align="right" valign="top">Priority =</td>
<td width="80%">приоритет созданного процесса (задачи). Стандартное значение для хэндлеров &mdash; 5, для файловых систем &mdash; 10.</td></tr>
<tr><td align="right" valign="top">Reserved =</td>
<td width="80%">Число блоков, резервированных под бут-блок. Как правило, 2.</td></tr>
<tr><td align="right" valign="top">Stacksize =</td>
<td width="80%">размер стека запускаемого процесса.</td></tr>
<tr><td align="right" valign="top">Startup =</td>
<td width="80%">строка, передаваемая хэндлеру, драйверу или файловой системе при старте. Передается BPTR (BCPL-указатель) на BSTR (BCPL-строку, содержащую счетчик собственных символов в первом байте).</td></tr>
<tr><td align="right" valign="top">Surfaces =</td>
<td width="80%">число поверхностей носителя.</td></tr>
<tr><td align="right" valign="top">Unit =</td>
<td width="80%">номер модуля.</td></tr>
</table>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101N>
<b>NEWCLI</b> WINDOW [AUX:|CON:x-позиция/y-позиция            (встроенная 
       /ширина/высота/заголовок/параметры], FROM       для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
NEWCLI открывает и активирует новое CLI-окно на экране. Открываемое окно имеет те же управляющие поля (gadgets), что и CLI-процесс, который был запущен либо путём двойного щелчка по CLI-иконке, либо при старте с какого-либо CLI-диска. Маршрут текущего каталога также берётся из родительского СLI-процесса.
</p></blockquote><blockquote><p align="justify">
Все CLI-окна абсолютно независимы друг от друга и являются отображением параллельно идущих в системе CLI-процессов. Каждый из этих процессов характеризуется уникальным порядковым номером. Этот номер выводится в CLI-окне в качестве подсказки (либо части подсказки). В любой момент времени активным может быть только одно из CLI-окон. 
Весь ввод с клавиатуры и &quot;мышиные&quot; операции попадают в активное окно (не могут же они случайным образом распределяться между всеми окнами в системе). Однако вывод может направляться в любое окно, и даже самые неактивные из них могут быть очень активны. Активное окно всегда помечается измененным цветом окаймляющей его рамки. 
Для активации любого из CLI-окон достаточно установить где-либо внутри него указатель мышки и щелкнуть левой кнопкой.
</p></blockquote><blockquote><p align="justify">
При старте системы всегда порождается CLI-процесс под номером 1, из которого запускается на исполнение командный файл &quot;S:Startup-Sequence&quot;. Если этот файл по каким-то причинам не будет обнаружен (или его исполнение будет прервано &mdash; возможно, из-за произошедшей ошибки), то система просто откроет CLI-окно, выведет подсказку 
(номер процесса, в данном случае 1) и будет ожидать ввода команд с клавиатуры.
</p></blockquote><blockquote><p align="justify">
Родительским каталогом для первого CLI-процесса всегда является &quot;SYS:&quot;, т.е. корневой каталог того диска, с которого был произведен старт системы.
</p></blockquote><blockquote><p align="justify">
ОС версий ниже 2-й не позволяли запускать более 20 CLI-процессов. Начиная с ОС 2, это ограничение было снято.
</p></blockquote><blockquote><p align="justify">
Параметр WINDOW позволяет указать имя хэндлера CLI-процесса. Весьма экзотическим хэндлером может быть &quot;AUX:&quot; &mdash; при этом Амига превращается в многопользовательский компьютер, к которому один или несколько удаленных терминалов подключаются через последовательный порт (на момент исполнения NEWCLI устройство &quot;AUX:&quot; должно быть уже смонтировано). 
Поскольку подобное использование CLI-окон находит крайне редкое применение, мы лишь ограничимся упоминанием о такой возможности.
</p></blockquote><blockquote><p align="justify">
Если у вас версия ОС 1.3, то желательно в качестве хэндлера использовать &quot;NEWCON:&quot; (хотя можно и &quot;CON:&quot;), во всех остальных случаях &mdash; только &quot;CON:&quot;. Имя хэндлера обязательно должно присутствовать в строке параметров, если хотя бы один из нижеследующих аргументов вы намерены определить явно (в круглых скобках даются значения параметров, 
присваемые по умолчанию в случае отсутствия конкретных значений в управляющей строке):
</p></blockquote><blockquote><blockquote><p align="justify">
Х-позиция &mdash; отступ левой границы окна от левой границы экрана. Здесь и далее все экранные координаты задаются в пикселях (0).
</p></blockquote><blockquote><p align="justify">
Y-позиция &mdash; отступ верхней границы окна от верхней границы экрана (0).
</p></blockquote><blockquote><p align="justify">
Ширина &mdash; ширина окна (640).
</p></blockquote><blockquote><p align="justify">
Высота &mdash; высота окна (100).
</p></blockquote><blockquote><p align="justify">
Заголовок &mdash; имя окна (AmigaShell &mdash; для ОС 2 или 3. либо NEWCON:-хэндлера, иначе NEWCLI).
</p></blockquote></blockquote><blockquote><p align="justify">
Если где-либо в строке параметров (например, в имени окна) имеются пробелы, то вся строка аргументов должна быть заключена в кавычки. 
Вот примеры NEWCLI с параметрами:
</p></blockquote><blockquote><blockquote><pre>
NEWCLI &quot;CON:////Мое окно&quot;   - в случае, если какие-либо
                   параметры пропущены, соответствующие
                   им символы  &quot;/&quot;  остаются  на  своих
	           местах.
			  
NEWCLI CON://///     - окно будет стандартных размеров,
                     но без заголовка, поскольку место,
                     соответствующее строке  заголовка 
                     также пустое.
				  
NEWCLI CON:200/100/50/50   - небольшое окно, смещённое
                         вниз и вправо от стандартного
                  положения со стандартным заголовком.
</pre></blockquote></blockquote><blockquote><p align="justify">
В версиях ОС 2 и 3 к вышеуказанным параметрам для СОМ:-хэндлера добавилось еще множество. Все они могут вводиться в любом порядке через тот же символ &quot;/&quot; после &quot;основных&quot; параметров:
</p></blockquote><blockquote><p align="justify">
AUTO &mdash; окно открывается не тогда, когда мы исполнили NEWCLI, а тогда, когда CLI-процесс либо начнёт ждать ввода с клавиатуры, либо захочет что-нибудь вам сообщить.
</p></blockquote><blockquote><p align="justify">
CLOSE &mdash; окно будет иметь поле закрытия. Если NEWCLI исполняется вообще без параметров, то это поле также будет присутствовать.
</p></blockquote><blockquote><p align="justify">
BACKDROP &mdash; появившееся окно будет &quot;заднеплановым&quot;, т.е. находиться позади всех других окон экрана. Возможности воздействия на подобное окно мышкой весьма ограничены &mdash; вы не можете передвигать его, менять 
план показа и размеры, за исключением схлопывания/раскрытия с помощью поля схлопывания.
</p></blockquote><blockquote><p align="justify">
NOBORDER &mdash; рамки вокруг окна не будет. Поля схлопывания и закрытия будут видны только в том случае, если высота окна меньше высоты экрана.
</p></blockquote><blockquote><p align="justify">
NODRAG &mdash; окно нельзя перемещать по экрану. Поля закрытия у него также не будет.
</p></blockquote><blockquote><p align="justify">
NOSIZE &mdash; окно не будет иметь полей схлопывания, размера и закрытия &mdash; только одно поле глубины.
</p></blockquote><blockquote><p align="justify">
SCREENимя &mdash; окно будет открыто на общем экране под именем &quot;имя&quot; (имя должно писаться слитно со словом SCREEN). Экран с этим именем уже должен быть открыт на момент исполнения NEWCLI.
</p></blockquote><blockquote><p align="justify">
SIMPLE &mdash; выбирается такой способ обновления формата содержимого окна после изменения пользователем размеров окна, когда текст, возможно находящийся в окне, автоматически переформатируется. 
ОС 2 и 3 использует этот режим по умолчанию, т.е. если параметры для NEWCLI отсутствуют вообще.
</p></blockquote><blockquote><p align="justify">
SMART &mdash; формат содержимого окна после возможного изменения пользователем размеров окна остается неизменным. Этот режим по умолчанию устанавливается для CLI-окон версий ОС 1.3 или более ранних. Параметры SMART и SIMPLE являются взаимно исключающими.
</p></blockquote><blockquote><p align="justify">
WAIT &mdash; когда CLI-процесс, породивший окно заканчивает свою работу, то обычно окно закрывается автоматически. Иногда это неудобно &mdash; не успеваешь прочитать то, что было выведено в окно. Параметр WAIT запрещает автоматическое закрытие окна &mdash; вам необходимо 
или щелкнуть по полю закрытия (если оно есть), или послать символ EOF (End Of File &mdash; конец файла), нажав комбинацию клавиш &quot;CTRL&nbsp;+&nbsp;\&quot;.
</p></blockquote><blockquote><p align="justify">
Необязательный параметр FROM позволяет указать стартующему CLI-процессу на командный файл, который должен автоматически исполняться при старте этого процесса. Начиная с версии ОС 1.3 при отсутствии спецификации такого файла команда NEWCLI пытается исполнить файл &quot;S:CLI-Startup&quot;, 
если этот файл будет обнаружен; Shell-окна соответственно пытаются исполнить &quot;S:Shell-Startup&quot;. Обычно в файлах типа CLI- или &quot;S:Shell-Startup&quot; определяется вид подсказки и псевдонимы &mdash; те параметры, которые не передаются CLI- и Shell-процессами &quot;по наследству&quot;. 
Если у вас &mdash; ОС 2 или 3 и русификатор 4-й версии или новее, то будет удобно включить в ваш файл &quot;S:Shell-Startup&quot; следующие строки:
</p></blockquote><blockquote><blockquote><pre>
SYS:Rexxc/WaitForPort Rusifier.port 
IF NOT WARN 
   SYS:Rexxc/rx &quot;ADDRESS 'Rusifier.port'; 'ENGLISH'&quot;
ENDIF
</pre></blockquote></blockquote><blockquote><p align="justify">
Теперь при каждом открытии Shell-окна (а CLI-окна &mdash; практически то же самое, только возможностей у них поменьше в ОС 1.3) у вас будет автоматически включаться латинский режим клавиатуры &mdash; надо только, чтобы сервер языка ARexx был инициализирован как положено (язык ARexx описан в соответствующей главе этой книги).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101O>
<b>NEWSHELL</b> WINDOW,FROM
</a></pre></font></blockquote><blockquote><p align="justify">
Для ОС 1.3 NEWSHELL &mdash; это псевдоним вызова <a href="AMIGA-10.html#A101N">NEWCLI</a> с усовершенствованным хэндлером &quot;NEWCON:&quot;. В более поздних версиях ОС NEWSHELL &mdash; встроенная команда; никакого &quot;NEWCON:&quot; в версиях ОС, начиная со 2-й уже нет, поскольку стандартный хэндлер &quot;CON:&quot; вобрал в себя всё, что было в &quot;NEWCON:&quot; и даже более того. 
И хэндлер &quot;CON:&quot; и сама команда NEWSHELL стали встроенными в систему. По сути в этих версиях ОС нет никакой разницы между командами <a href="AMIGA-10.html#A101N">NEWCLI</a> и NEWSHELL &mdash; обе они открывают Shell-процесс.
</p></blockquote><blockquote><p align="justify">
Shell-интерфейс представляет собой усовершенствованный вариант CLI-интерфейса. Он поддерживает массу полезных вещей: псевдонимы, &quot;исторический&quot; буфер, редактирование командной строки и еще много всего. Параметры запуска и прочая информация те же, что и у <a href="AMIGA-10.html#A101N">NEWCLI</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101P>
<b>PATH</b> PATH/M,ADD/S,RESET/S,
     REMOVE/S,QUIET/S
</a></pre></font></blockquote><blockquote><p align="justify">
PATH показывает или изменяет маршруты, по которым ОС производит поиск командных файлов. Когда находясь в Shell- (CLI-) окне вы набираете имя командного файла и нажимаете затем Enter, ОС первым делом пытается найти этот файл в текущем каталоге. 
Если нужный файл не обнаружен, то дальнейший поиск будет производиться по маршрутам, определенным с помощью команды PATH (обычно PATH определяет дополнительные маршруты, будучи запущенной из файла &quot;S:Startup-Sequence&quot; и &quot;S:User-Startup&quot;, 
т.е. на этапе старта системы). В случае неудачи, ОС продолжает поиск в &quot;С:&quot;. На самом деле, логическое устройство &quot;С:&quot; совершенно не обязательно должно соответствовать каталогу &quot;SYS:C&quot;, хотя на практике это всегда одно и то же.
</p></blockquote><blockquote><p align="justify">
Будучи использованной без параметров либо с единственным параметром-переключателем SHOW (что одно и то же), PATH покажет все маршруты, по которым ОС ищет свои команды.
</p></blockquote><blockquote><p align="justify">
Если после PATH ввести один или несколько маршрутов (можно с необязательным параметром-переключателем ADD), то поиск команд ОС с этого момента будет производиться и по этим маршрутам. Эти маршруты могут быть как относительными (т.е. их точкой отсчёта будет текущий 
каталог на момент исполнения команды PATH), так и абсолютными &mdash; начинающимися с имени корневого каталога, устройства, тома &mdash; короче, сразу видно по двоеточию в строке маршрута, полный он или нет. Маршруты (если их несколько) отделяются друг от друга пробелами.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель RESET вызовет уничтожение всех имеющихся маршрутов поиска (за исключением текущего каталога и &quot;С:&quot; &mdash; эти маршруты команде PATH не подвластны). Ничто не мешает, уничтожив старые маршруты, тут же определить новые, &quot;не выходя&quot; из команды 
PATH. Например исполнив:
</p></blockquote><blockquote><blockquote><pre>
PATH  WORK:Utilities  RESET,
</pre></blockquote></blockquote><blockquote><p align="justify">
мы сначала уничтожим старые маршруты поиска, а затем добавим новый маршрут &mdash; &quot;WORK:Utilities&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель REMOVE (только для ОС 2 и 3) меняет действие PATH на обратное: теперь указанные маршруты будут не добавляться, а изыматься из цепочки поиска.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель QUIET, появившийся, начиная с ОС 1.3. в комбинации с SHOW подавляет вывод риквестеров типа &quot;Вставьте диск X&quot; в том случае, если устройства, специфицированные в маршруте (маршрутах), еще не смонтированы. Для не смонтированных устройств PATH просто покажет их имена без цепочки 
каталогов, которая возможно должна была бы следовать после имени конкоетного устройства.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101Q>
<b>PROMPT</b> (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
PROMPT меняет текущую подсказку для Shell-окна. По умолчанию подсказкой является номер текущего Shell-процесса с последующим символом &quot;&gt;&quot;. Эта команда обычно используется в файле &quot;S:Shell-startup&quot;, где она устанавливает подсказку в виде номера Shell-процесса вместе с маршрутом текущего каталога.
</p></blockquote><blockquote><p align="justify">
Будучи использованной без параметров, PROMPT (пере-)установит ту же подсказку, которая была установлена ПОСЛЕ исполнения файла &quot;S:Shell-Startup&quot;. Любой параметр для PROMPT будет восприниматься в качестве новой строки для подсказки. Внутри этой строки можно использовать Escape-последовательности ANSI-стандарта, что 
позволит, например, разукрасить подсказку и/или сделать ее шрифт жирным, наклонным или подчеркнутым.
</p></blockquote><blockquote><p align="justify">
В строке подсказки можно применять специальные переменные &mdash; %S, %N и %R (последняя &mdash; только для ОС 2 и 3), которые означают соответственно маршрут текущего каталога, номер Shell-процесса и уровень ошибки, который оставила последняя исполненная команда.
</p></blockquote><blockquote><p align="justify">
Пример использования (только для ДОС 2 и 3):
</p></blockquote><blockquote><blockquote><pre>
PROMPT  &quot;%N-й процесс; (*'DATE*') %S>&quot;
</pre></blockquote></blockquote><blockquote><p align="justify">
И вот что за подсказка получилась в результате:
</p></blockquote><blockquote><blockquote><pre>
5-й процесс; (Суббота 24-Июн-95 00:00:06) Work:>
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101R>
<b>PROTECT</b> FILE/A,FLAGS, ADD=+/S,SUB=-/S, ALL/S, QUIET/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда позволяет изменить признаки файла. Признаков всего 8, хотя &quot;официально&quot; определены только 7:
</p></blockquote><table width="95%">
<tr><td align="right" valign="top">Читаемый (Readable) &mdash;</td>
<td width="60%">допустима операция считывания содержимого файла;</td></tr>
<tr><td align="right" valign="top">Изменяемый (Writeable) &mdash;</td>
<td width="60%">файл можно изменять произвольным образом;</td></tr>
<tr><td align="right" valign="top">Исполняемый (Executable) &mdash;</td>
<td width="60%">файл является исполняемой программой. Впрочем, если этот признак установлен у не исполняемого файла, ОС все равно не станет пытаться его исполнить;</td></tr>
<tr><td align="right" valign="top">Удаляемый (Deleatable) &mdash;</td>
<td width="60%">файл можно удалить;</td></tr>
<tr><td align="right" valign="top">Командный (Script) &mdash;</td>
<td width="60%">файл, содержащий команды ОС. Наличие этого признака позволяет запускать файлы на исполнение, просто набрав их имя (без предшествующей команды <a href="AMIGA-10.html#A100Q">EXECUTE</a>). Такой запуск допустим только из Shell- (не CLI!) окон.</td></tr>
<tr><td align="right" valign="top">Реентрантный (Pure) &mdash;</td>
<td width="60%">файл можно сделать резидентным и одновременно исполнять из нескольких одновременно работающих программ. О резидентных программах подробнее см. описание команды <a href="AMIGA-10.html#A1010">RESIDENT</a>.</td></tr>
<tr><td align="right" valign="top">Архивирован (Archived) &mdash;</td>
<td width="60%">копия файла была сохранена в некотором архиве. С этим признаком имеют дело только программы, осуществляющие (де-)архивирование. ОС никогда его не читает, однако любое изменение содержимого файла ведет к сбросу этого признака.</td></tr>
<tr><td align="right" valign="top">Скрытый (Hidden) &mdash;</td>
<td width="60%">свободно трактуемый и не задокументированный &quot;официально&quot; признак, часто означающий, что файл может быть не показан некоторой прикладной программой при распечатке списка файлов данного каталога. Используется, например, в чрезвычайно популярной программе Directory OPUS.</td></tr>
</table>
</p></blockquote><blockquote><p align="justify">
Если вы хотите просмотреть значения признаков какого-либо файла или каталога, используйте команду <a href="AMIGA-10.html#A101G">LIST</a>. Идентификаторами конкретных признаков являются первые буквы их английских наименований, например, &quot;d&quot; означает &quot;удаляемый&quot;. При создании нового файла ОС всегда устанавливает признаки RWED, остальные будут сброшены. 
Установленный признак можно читать как &quot;да&quot;, сброшенный &mdash; как &quot;нет&quot; и текущее состояние файла (каталога) сразу станет ясным. Для сброшенных флагов команда <a href="AMIGA-10.html#A101G">LIST</a> вместо соответствующей латинской буквы показывает прочерк &quot;-&quot;.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром команды PROTECT является маршрут объекта (т.е. файла или каталога), чьи признаки вы намерены изменить. ОС " и 3 позволяет использовать шаблоны, чтобы разом изменить признаки лой группы объектов. Ключевое слово FILE должно присутствовать толькс в том случае, если маршрут объекта &mdash; не первый параметр команды.
</p></blockquote><blockquote><p align="justify">
После необязательного ключевого слова FLAGS могут следовать однобуквенные идентификаторы тех признаков, которые должны быть установлены командой PROTECT. He указанные признаки будут сброшены. Отсутствие упоминания каких-либо конкретных признаков после FLAGS приведет к сбросу всех признаков без исключения. При сбросе признака &quot;Удаляемый&quot; 
следует учесть, что некоторые команды ОС (в частности, <a href="AMIGA-10.html#A100C">COPY</a>) при переписи файлов заново, вначале удаляют старый файл, а затем создают новый с тем же именем. Поскольку операция удаления не сработает при отсутствии у файла признака &quot;Удаляемый&quot;, такая команда может вернуть неожиданное сообщение об ошибке.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели ADD (его синонимом является знак &quot;+&quot;) или SUB (синоним &quot;-&quot;) позволяют работать по отдельности с каждым признаком, а не определять их все разом. Чтобы установить какой-либо признак, необходимо или поставить ADD после однобуквенного идентификатора признака, или поставить 
&quot;+&quot; перед идентификатором. Сброс признака выполняется при аналогичном использовании SUB или знака &quot;-&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL (только для ОС 2 и 3) позволяет изменить признаки во всех файлах, каталогах и подкаталогах выбранного каталога.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель QUIET подавляет вывод команды PROTECT при операциях на нескольких объектах (т.е. при использовании ALL или шаблонов).
</p></blockquote><blockquote><p align="justify">
<blockquote>Примеры использования:</blockquote>
Сделать все объекты каталога FONTS неудаляемыми:
</p></blockquote><blockquote><blockquote><pre>
PROTECT FONTS:#? -d
</pre></blockquote></blockquote><blockquote><p align="justify">
Сделать все объекты каталога &quot;FONTS:&quot; и всех его подкаталогов только читаемыми, изменяемыми и исполняемыми:
</p></blockquote><blockquote><blockquote><pre>
PROTECT FONTS: RWE ALL
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101S>
<b>QUIT</b> RC/N  (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда является встроенной для ОС 2 и 3; в более ранних версиях ОС она находится в каталоге С. Используется исключительно в командных файлах для прекращения их работы (возможно, с установкой требуемого уровня ошибки). Значение уровня ошибки, который вернет командный файл из-за исполнения QUIT, может быть числовым параметром для QUIT. Пример использования:
</p></blockquote><blockquote><blockquote><pre>
echo &quot;Привет!&quot;
QUIT 50 
echo &quot;А эта строка никогда не будет исполняться!&quot;
</pre></blockquote></blockquote><blockquote><p align="justify">
Исполнение подобного командного файла вернет уровень ошибки 50.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101T>
<b>RELABEL</b> DRIVE/A,NAME/A
</a></pre></font></blockquote><blockquote><p align="justify">
Команда позволяет изменить имя тома (т.е. или диска, или псевдодиска, или партиции жёсткого диска). Имя изначально присваивается конкретному тому после форматирования, либо после т.н. &quot;физического копирования&quot;, которое, например делает команда <a href="AMIGA-10.html#A100I">DISKCOPY</a>. Не следует путать имя тома с именем устройства (например, &quot;DF0:&quot;) &mdash; это абсолютно разные понятия.
</p></blockquote><blockquote><p align="justify">
Кроме имени, ОС отличает один том от другого по так называемым серийным номерам, которые присваиваются томам при их форматировании. Поэтому, в случае необходимости ОС отличит друг от друга даже два диска с одинаковыми именами (труднее может быть вам &mdash; может получиться ситуация, когда ОС попросит вас вставить диск &quot;Графика&quot; в любой дисковод, а у вас несколько таких дисков и ОС отвергнет все, за исключением того, у которого окажется нужный серийный номер. Поэтому старайтесь, чтобы диски назывались по-разному).
</p></blockquote><blockquote><p align="justify">
Владельцы Амиги с единственным дисководом могут испытывать некоторое неудобство при использовании RELABEL из-за возникновения эффекта, который сродни тому, что возникает при использовании команды <a href="AMIGA-10.html#A101C">INSTALL</a>. Избавиться от него можно тем же путем, что и при использовании <a href="AMIGA-10.html#A101C">INSTALL</a> (см. описание <a href="AMIGA-10.html#A101C">INSTALL</a>).
</p></blockquote><blockquote><p align="justify">
Обязательными параметрами команды должны быть физическое имя устройства, том которого вы намерены переименовать, а также новое имя для тома (не более 30-ти символов). Если имя тома содержит пробелы, его обязательно надо заключить в кавычки. Если порядок следования параметров обратный (т.е. вначале идет имя тома, затем &mdash; устройства), то необходимо использовать оба ключевых слова &mdash; NAME и DRIVE.
</p></blockquote><blockquote><p align="justify">
Пример использования:
</p></blockquote><blockquote><blockquote><pre>
RELABEL RAD: &quot;Всякая всячина&quot;
RELABEL NAME &quot;Трехмерная графика&quot; DRIVE DH1:
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101U>
<b>REMRAD</b> DEVICE,FORCE/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда позволяет удалить из системы псевдодисковое устройство &quot;RAD:&quot;, не прибегая к отключению питания. После исполнения REMRAD освобождается почти вся память, которую это устройство зарезервировало. Следующий перезапуск системы освободит и ту часть памяти, что осталась резервированной под устройство &quot;RAD:&quot;, невзирая на исполнение команды REMRAD.
</p></blockquote><blockquote><p align="justify">
ОС 2 и 3 допускает использование двух дополнительных параметров для REMRAD. Параметр DEVICE соответствует номеру модуля устройства &quot;RAD:&quot;, который вы намерены демонтировать. По умолчанию удаляется модуль 0. Параметр FORCE позволяет удалить &quot;RAD:&quot; даже в том случае, если, система повесила на него замок (см. описание команды <a href="AMIGA-10.html#A101I">LOCK</a>). &quot;RAD:&quot; может быть на замке в том случае, 
если маршрут текущего каталога и/или маршрут какого-либо логического устройства (присвоенный командой <a href="AMIGA-10.html#A1005">ASSIGN</a>) соответствует устройству &quot;RAD:&quot;.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101V>
<b>RENAME</b> FROM/A/M,TO=AS/A,QUIET/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда позволяет переименовывать файлы и/или каталоги. Поскольку переименование может касаться не только имени объекта, но и его маршрута (за исключением имени устройства или тома), то в результате переименования объект может оказаться в совершенно другом каталоге того же самого устройства (тома).
</p></blockquote><blockquote><p align="justify">
Обязательный параметр FROM (маршрут источника) соответствует маршруту объекта, который будет переименован (ОС 2 и 3 допускает применение шаблонов в этом маршруте &mdash; в результате произойдет множественное перемещение объектов из каталога в каталог; маршрут приемника в этом случае должен отличаться от маршрута источника). Применение ключевого слова FROM обязательно в том случае, если этот параметр &mdash; не первый по счету.
</p></blockquote><blockquote><p align="justify">
Параметр ТО или его синоним AS (маршрут приемника) соответствует обязательно указываемому новому маршруту и/или имени переименуемого объекта. Применение ключевого слова ТО (AS) обязательно в том случае, если этот параметр &mdash; не второй по счету.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель QUEIT подавляет вывод сообщений команды RENAME во время множественного переименования объектов в случае использования шаблонов в параметре FROM.
</p></blockquote><blockquote><p align="justify">
RENAME является мощным средством модификации структуры каталогов, поскольку эта команда позволяет переносить содержимое целых каталогов со всеми имеющимися подкаталогами, кардинально меняя при этом структуру тома. Никакого копирования и удаления исходных объектов при этом не происходит &mdash; просто меняются связи каталогов между собой. 
</p></blockquote><blockquote><p align="justify">
Пример использования:
</p></blockquote><blockquote><blockquote><pre>
RENAME Moor More           - переименовать файл &quot;Moor&quot; 
                             текущего каталога в &quot;More&quot;. 
RENAME Письма Архив/Письма - переместить весь каталог &quot;Письма&quot; со всеми его 
                             подкаталогами в каталог &quot;Архив&quot; под тем же именем.
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101X>
<b>REQUESTCHOICE</b> TITLE/A,BODY/A,GADGETS/M,PUBSCREEN/K
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда 3-й версии ОС позволяет чрезвычайно легко и красиво создавать риквестер, который имеет заголовок, текст и поля-кнопки, реагирующие на щелканье по ним мышкой. Использование REQUESTCHOICE упрощает создание как командных, так и ARexx-файлов, которые ведут диалог с пользователем.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром команды (TITLE) является строка с текстом заголовка, выводимого в верхней части рамки риквестера. Как правило, заголовок идентифицирует программу, создавшую риквестер. Параметр BODY тоже обязателен &mdash; это строка, которая будет выведена внутри окна риквестера. 
Если строка содержит пробелы, ее необходимо заключить в кавычки. Если заголовок или основной текст не нужен, соответствующий параметр должен представлять собой пустую строку &quot;&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр GADGETS описывает (точнее сказать, надписывает) одно или несколько управляющих полей-кнопок. Число полей определяется числом строк параметра GADGETS, а сами строки будут выведены на кнопках (строки, в которых есть пробелы, должны быть заключены в кавычки). Каждой получившейся в результате 
кнопке будет соответствовать свой номер. Когда при исполнении REQUESTCHOICE пользователь щелкнет по одной из кнопок, этот номер будет выведен командой. Крайней левой кнопке соответствует 1, далее нумерация идёт по возрастающей с одним исключением: крайняя правая кнопка имеет номер 0. 
Правой кнопке, как правило, соответствует какой-либо &quot;отрицающий&quot; текст типа &quot;Нет&quot;, &quot;Отмена&quot;, &quot;Выход&quot; или что-нибудь в этом роде.
</p></blockquote><blockquote><p align="justify">
Ключевое слово PUBSCREEN позволяет вывести риквестер на поименованном общем экране, за PUBSCREEN должно следовать имя этого экрана. Разумеется, на момент исполнения REQUESTCHOICE этот экран должен быть открыт.
</p></blockquote><blockquote><p align="justify">
Пример использования &mdash; небольшой командный файл:
</p></blockquote><blockquote><blockquote><pre>
set Num 'REQUESTCHOICE &quot;Тест&quot; &quot;Выберите число&quot; 1230'
echo &quot;Вы выбрали число $Num&quot;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101W>
<b>REQUESTFILE</b> DRAWER,FILE/K,PATTERN/K,TITLE/K,POSITIVE/K,
            NEGATIVE/K,ACCEPTPATTERN/K,REJECTPATTERN/K,
            SAVEMODE/S,MULTISELECT/S,DRAWERSONLY/S,
            NOICONS/S,PUBSCREEN/K
</a></pre></font></blockquote><blockquote><p align="justify">
Команда ОС З, выводящая стандартный файловый риквестер. Она чрезвычайно удобна для использования в командных и ARexx-файлах в тех случаях, когда пользователь дожен выбрать каталог и/или файл. Команда возвращает один или несколько маршрутов, соответствующих выбранным файлам. Каждый маршрут заключается в кавычки, в случае нескольких маршрутов они отделяются друг от друга пробелами. Если пользователь решил не выбирать файл(ы) и щелкнул по кнопке "Отмена" (или по закрывающему полю окна риквестера), то команда REQUESTFILE возвращает уровень ошибки 5, на что командный файл может соответствующим образом отреагировать, исполнив конструкцию &quot;<a href="AMIGA-10.html#A101A">IF WARN</a>&quot;. Если пользователь выбрал файл(-ы), команда возвратит нулевой код ошибки.
</p></blockquote><blockquote><p align="justify">
Все параметры команды являются необязательными. Тем не менее, использование каких-либо параметров позволяет подогнать риквестер под конкретные требования, вызванные спецификой исполняемой программы.
</p></blockquote><blockquote><p align="justify">
Параметр DRAWER с последующим маршрутом каталога вызовет открытие риквестера, который сразу же выведет содержимое этого каталога. Поле имени каталога будет сразу же соответствовать требуемому маршруту.
</p></blockquote><blockquote><p align="justify">
Параметр-ключевое слово FILE с последующим именем файла вызовет появление риквестера с этим именем в поле выбора файла. Если такого файла нет в том каталоге, содержимое которого показано в риквестере, то установить требуемый маршрут либо изменить имя файла &mdash; дело пользователя.
</p></blockquote><blockquote><p align="justify">
Параметр-ключевое слово PATTERN вызовет появление риквестера с дополнительным полем фильтра. Если в этом поле присутствует некоторый шаблон, будут показаны только те файлы, имена которых под этот шаблон подпадают. Требуемый шаблон задается после слова PATTERN. Пользователь уже после вывода риквестера может сменить шаблон по своему усмотрению.
</p></blockquote><blockquote><p align="justify">
Параметр-ключевое слово TITLE с последующей строкой позволяет определить заголовок риквестера. Ширина риквестера ограничена, поэтому не стоит определять чрезмерно длинные заголовки (более чем 30 символов). В противном случае заголовок может быть выведен не полностью.
</p></blockquote><blockquote><p align="justify">
Параметр-ключевое слово POSITIVE с последующей строкой позволяет изменить текст крайней левой кнопки риквестера. По умолчанию здесь находится текст &quot;ОК&quot;. Если вы, например, выбираете файл(-ы) для удаления, то можно присвоить этой кнопке текст &quot;Удалить&quot;. Аналогично работает параметр NEGATIVE, но он &mdash; для крайней правой кнопки риквестера, где по умолчанию находится текст &quot;Отмена&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-ключевое слово ACCEPTPATTERN с последующим шаблоном работает подобно PATTERN, но в этом случае в появившемся риквестере не будет поля выбора шаблона, т.е. пользователь будет лишен возможности влиять на то, какие файлы будут показаны в списке, а какие &mdash; нет. Действие параметра-антипода REJECTPATTERN с последующим шаблоном приведет к тому, что в списке будут показаны только те файлы, которые НЕ попадают под шаблон.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель SAVEMODE вызовет появление &quot;подстрахованного&quot; риквестера. который, как правило используется при записи и, особенно, при удалении файлов. Пользователь здесь уже не сможет произвести нужную операцию путем двойного щелчка по имени некоторого файла (каталога), он обязательно должен выбрать "позитивный" ответ (кнопка &quot;ОК&quot;), чтобы операция произошла. Множественный выбор объектов в таком риквестере запрещен.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель MULTISELECT разрешает пользователю выбрать не один, а несколько объектов сразу (для этого необходимо во время выбора нажать и удерживать клавишу Shift). REQUESTFILE выдаст имена всех выбранных файлов, разделенные пробелами, после щелканья по кнопке &quot;ОК&quot;.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель DRAWERSONLY оставит в списке только имена каталогов, a NOICONS &quot;не пустит&quot; в список файлы с расширением .info (иконки).
</p></blockquote><blockquote><p align="justify">
Ключевое слово PUBSCREEN позволяет вывести риквестер на поименованном общем экране; после слова PUBSCREEN должно следовать имя этого экрана. Разумеется, на момент исполнения REQUESTFILE этот экран должен быть открыт.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1010>
<b>RESIDENT</b> NAME,FILE,REMOVE/S,ADD/S,         (встроенная для ОС 2 и 3)
         REPLACE/S,PURE=FORCE/S, SYSTEM/S
</a></pre></font></blockquote><blockquote><p align="justify">
RESIDENT используется для того, чтобы избежать многократной загрузки с диска одних и тех же команд. Вместо этого команды помещаются в оперативную память системы и в списке резидентных (т.е. встроенных в систему) команд делаются соответстветствующие пометки о новых членах этого семейства. Смыслом подобных манипуляций является не только экономия времени, связанная с отсутствием необходимости возиться с диском каждый раз, когда потребуются какие-либо из ставших резидентными команд. 
Как ни странно, зачастую экономится и память, поскольку теперь не надо каждый раз загружать новую копию команды для того, чтобы ее исполнить &mdash; достаточно обратиться к уже существующей резидентной команде. Не надо забывать, что в Амиге одновременно может работать любое число процессов, каждый из которых может пытаться исполнить любые команды, когда ему заблагорассудится.
</p></blockquote><blockquote><p align="justify">
RESIDENT может исполняться только из Shell- (не CLI!) окна. Резидентными могут быть сделаны только исполняемые (не командные!) файлы. Файлы, содержащие разного рода данные, также не могуть стать резидентными. Кроме того, &quot;кандидат в резиденты&quot; должен удовлетворять некоторым специфическим условиям, которые необходимо неукоснительно блюсти при создании подобных программ. Во-первых, они должны иметь способность многократного запуска без перезагрузки или какой-либо внешней инициализации, 
то, что называется кратким, но емким иностранным словом &quot;reexecutable&quot;. Во-вторых, при каждой попытке запуска (которая может возникнуть в любой момент, вне зависимости от того, закончилась ли работа ЭТОЙ ЖЕ программы в результате предыдущего запуска, или нет) программа должна уметь резервировать и, возможно, соответствующим образом инициализировать локальную область данных, чтобы данные, используемые в различных вызовах этой программы не смешались в одну общую кучу (это свойство называется 
реентрантностью от слова &quot;reentrant&quot; &mdash; повторный вход; пусть предыдущее свойство назовёт &quot;реэкзекутабельностью&quot; какой-нибудь эвээмный академик &mdash; им, наверное, можно).
</p></blockquote><blockquote><p align="justify">
Короче говоря, можно ли сделать программу резидентной, знает только тот, кто эту программу написал. Все свои глубокомысленные соображения по этому поводу он (совсем как на суде присяжных) вкладывает в один-единственный бит информации &mdash; признак файла &quot;Резидентный&quot; (pure). Если признак установлен, совершенно спокойно исполняйте команду RESIDENT для этого файла, все последствия будут на совести автора программы, а не на вашей.
</p></blockquote><blockquote><p align="justify">
Будучи исполненной без параметров, команда RESIDENT выведет список всех резидентных команд системы. Встроенные команды ОС 2 и 3 также считаются резидентными, поскольку загружать их с диска не надо &mdash; они находятся в постоянной памяти системы. В списке встроенные команды имеют идентификаторы &quot;Встроенная команда&quot;, в то время как для &quot;нормальных&quot; резидентных команд выводятся значения счетчиков их пользователей. 
Забегая вперед, скажем, что удалить резидентную команду из списка и, соответственно из памяти, можно только в том случае, если число её пользователей равно нулю.
</p></blockquote><blockquote><p align="justify">
Необязательный параметр NAME соответствует имени, которое вы возможно захотите присвоить резидентной копии программы. В этом случае вы сможете вызывать как резидентную, так и нерезидентную версии одной и той же программы, просто пользуясь разными именами. Правда, смысл подобных манипуляций автору далеко не очевиден &mdash; чтобы масло в подшипниках дисковода не загустевало из-за того, стали резидентными?
</p></blockquote><blockquote><p align="justify">
Параметр FILE соответствует полному маршруту файла, который вы намерены сделать резидентным.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель REMOVE используется для изъятия команды из резидентного списка. ОС 2 и 3 таким путем позволяет отключать даже встроенные команды (позже их опять можно активировать с помощью параметра-переключателя REPLACE). Правда, нельзя удалить резидентную команду, которая в данный момент находится &quot;в работе&quot;.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели ADD и REPLACE никак не влияют на исполнение RESIDENT без имени файла (параметра FILE) &mdash; в этом случае просто выводится список резидентных команд. Если же имя файла &mdash; кандидата в резиденты &mdash; определено, то будет сделана попытка сделать его резидентным. Если резидентная команда с таким именем уже существует и её можно безболезненно заменить на новую с тем же именем (что возможно только 
при нулевом значении счетчика пользователей), то такая замена произойдет. Следует заметить, что в случае использования параметра-переключателя REPLACE для ОС 2 или 3, команда с тем же именем УЖЕ должна быть в списке резидентных команд, иначе будет выдано сообщение об ошибке, т.е. действительно должна произойти замена одной версии резидентной команды на другую. REPLACE также позволяет снова активизировать те встроенные команды ОС 2 или 3, которые ранее 
были отключены параметром REMOVE.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели PURE или FORCE вынуждают команду RESIDENT сделать резидентным исполняемый файл без установленного признака &quot;Резидентный&quot; (pure). Особо экспериментировать с попытками делать резидентными те программы, которые для этого не предназначены, мы от всей души не советуем.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель SYSTEM вызывает включение требуемого файла в системную часть списка резидентных команд. Удалить команду оттуда уже нельзя. Если других параметров, кроме SYSTEM у команды RESIDENT нет, то будет выведена именно системная часть резидентного списка.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101Y>
<b>RUN</b> COMMAND/F  (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
RUN позволяет создать CLI-процесс &quot;заднего плана&quot;, не открывающий собственного окна. Можно заставить исполняться подряд несколько команд (файлов) &mdash; их имена должны в этом случае разделяться знаками &quot;+&quot; Как только все команды будут по очереди исполнены, процесс заднего плана, порождённый командой RUN, прекратит существование. 
При запуске RUN выводится сообщение &quot;CLI х&quot;, где х &mdash; номер порожденного CLI-процесса заднего плана. Сразу после вывода этого сообщения управление возвращается в тот процесс, в котором была исполнена команда RUN. Новый же процесс продолжает работать до тех пор, пока не будут по очереди исполнены все команды, указанные в качестве параметров для 
RUN, либо пока процессу не будет послан сигнал останова с помощью команды <a href="AMIGA-10.html#A1008">BREAK</a> (правда, нельзя на 100% гарантировать, что процесс в этом случае послушно остановится &mdash; см. описание команды <a href="AMIGA-10.html#A1008">BREAK</a>). Если во время исполнения какой-либо из команд произойдет ошибка, то процесс заднего плана немедленно остановится и самоликвидируется.
</p></blockquote><blockquote><p align="justify">
Начиная с версии ОС 1.3, команда RUN перед выполнением любой из команд, переданных ей в качестве параметров, обязательно попытается отыскать ее в списке резидентных команд. В случае успеха будет запущена на исполнение именно резидентная версия команды.
</p></blockquote><blockquote><p align="justify">
Может возникнуть вполне резонный вопрос &mdash; а откуда, например, команды, запущенные на исполнение с помощью RUN, будут брать входные данные и куда направят свои выходные потоки? Ведь Shell-окно, где была исполнена команда RUN, уже может быть закрыто к тому моменту, когда команды попросят ввод или захотят вывести какие-то свои сообщения&hellip;
</p></blockquote><blockquote><p align="justify">
Что касается ввода данных, то команды, запущенные на исполнение с помощью RUN, по умолчанию могут &quot;черпать&quot; свой входной поток только из системной &quot;черной дыры&quot; &mdash; устройства &quot;NIL:&quot;, которое немедленно готово удовлетворить любые запросы на получение от него данных, посылая страждущему процессу символ EOF (конец файла, 
аналог &quot;CTRL&nbsp;+&nbsp;\&quot;). Если уж процессам заднего плана просто невтерпёж как захочется получить какие-то данные от пользователя, то никто не мешает им открыть собственные консольные окна, сделать всё что нужно, а затем закрыть их (мы сознательно рассматриваем только простейшие варианты).
</p></blockquote><blockquote><p align="justify">
А вот, что касается потока вывода: любой порожденный командой RUN процесс ЗАПРЕЩАЕТ родительскому процессу закрывать собственное консольное окно в том случае, если поток вывода команды RUN не был направлен в то же знаменитое устройство &quot;NIL:&quot;, которое всегда радо проглотить всё, что в него положили (правда, куда это потом девается, не знает ни один 
системный программист). Поэтому, чуть ли не всегда после слова RUN следует &quot;>NIL:&quot; &mdash; только в этом случае система позволит вам спокойно закрыть окно, где была исполнена команда RUN, не дожидаясь окончания порождённого процесса. Без перенаправления потока вывода команды RUN в &quot;NIL:&quot; при попытке закрыть окно вы получите сообщение 
&quot;Завершается процесс N&quot;, где N &mdash; номер текущего Shell-процесса. Сообщение это будет оставаться в окне до тех пор, пока процесс заднего плана не закончит свою работу, после чего окно благополучно закроется.
</p></blockquote><blockquote><p align="justify">
Пример использования: отформатируем диск, затем проинсталируем на него ОС:
</p></blockquote><blockquote><blockquote><pre>
RUN >NIL: format drive DF0: name Проба + 
install DF0:
</pre></blockquote></blockquote><blockquote><p align="justify">
Пока форматируется диск, можете делать всё, что угодно. Если бы поток вывода не был направлен в &quot;NIL:&quot;, то в ваше Shell-окно непрерывно влетала бы информация от команды <a href="AMIGA-10.html#A100X">FORMAT</a>, не давая возможности продолжать работать во время форматирования диска. Правда и &quot;NIL:&quot; в данном случае &mdash; не идеальное решение: а как узнать, если форматирование не удалось? 
&quot;NIL:&quot; &mdash; в высшей степени философское устройство: какие бы аварийные сообщения ни влетали бы в него, никакой реакции всё равно не последует&hellip; Проще всего &mdash; открыть ещё одно Shell-окно, где и работать &mdash; пусть весь вывод от команды <a href="AMIGA-10.html#A100X">FORMAT</a> идёт в старое окно:
</p></blockquote><blockquote><blockquote><pre>
RUN NEWSHELL +
format drive DF0: name Проба +
install DF0: +
echo &quot;Готово!&quot;
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A101Z>
<b>SEARCH</b> FROM/M,SEARCH=NAME/A,ALL/S,NONUM/S,QUIET/S,QUICK/S,
       FILE/S,PATTERN/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда производит поиск заданной строки в одном/или нескольких файлах, а также поиск файлов по их именам. Во время поиска выводится имя того файла, в котором производится поиск в данный момент времени. 
В случае успешного поиска выводятся все строки, в которые входит искомая подстрока. Для найденных строк выводятся их порядковые номера. Начиная с ОС 1.3 команда возвращает нулевой уровень ошибки, если поиск 
был успешным, либо 5 (WARN) &mdash; в противном случае, что весьма полезно при использовании SEARCH в командных файлах. Поиск всегда можно либо прекратить совсем, нажав &quot;CTRL&nbsp;+&nbsp;C&quot;, либо &mdash; только 
в текущем файле (&quot;CTRL&nbsp;+&nbsp;D&quot;), при этом поиск будет продолжен в следующем файле (если таковой имеется). Символ возврата каретки (10 &mdash; десятичный, 0х0А &mdash; шестнадцатеричный) рассматривается 
командой SEARCH как признак конца строки. Просматривается только 205 первых символов каждой строки.
</p></blockquote><blockquote><p align="justify">
Параметр FROM соответствует маршруту файла, в котором будет осуществляться поиск заданной строки. Ключевое слово FROM обязательно употреблять только в том случае, если параметр FROM не является первым аргументом команды 
SEARCH. В имени можно использовать шаблоны, осуществляя поиск в нескольких файлах сразу. Маршрут может заканчиваться именем каталога, в котором осуществляется поиск.
</p></blockquote><blockquote><p align="justify">
Обязательный параметр NAME (или его синоним SEARCH; NAME можно употреблять только в ОС 2 и 3) &mdash; это и есть та строка, которую необходимо найти. Если в строке имеются пробелы, то она должна быть заключена в кавычки. 
Регистр букв при поиске игнорируется только для латинских букв, поскольку текущие версии команды SEARCH (вплоть до 40.1 включительно) не являются локализованными, т.е. игнорируют системные языковые установки и только латинские 
буквы считают буквами. Поэтому при поиске строк, содержащих русские буквы (за исключением &quot;А&quot;, являющейся в Амиге общей для русского и латинского алфавитов), вам до поры до времени придется считаться с этим обстоятельством 
и каждый раз соображать, какой регистр русских букв надо выставить, чтобы найти искомую строку. Впрочем, возможно в самое ближайшее время удастся написать надлежащие локализованные версии команд SEARCH и <a href="AMIGA-10.html#A1029">SORT</a> (ещё одна не чующая 
языковой специфики ОС-команда).
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL вызовет поиск во всех файлах, подкаталогах заданного параматром FROM подкаталога; NONUM отключит вывод номеров строк, в которых поиск был успешным; QUICK заставит команду SEARCH выводить свои сообщения в более 
сжатом формате.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель FILE вызовет поиск не строки, а файла с заданным именем; разумеется, параметру FROM в этом случае должен соответствовать маршрут не файла, а каталога (как и в случае употребления ALL). Если файл с заданным именем будет 
обнаружен, то его имя будет выведено командой SEARCH либо без маршрута (ОС 1.3), либо в составе полного маршрута (ОС 2 и 3).
</p></blockquote><blockquote><p align="justify">
Дополнительный параметр-переключатель PATTERN, появившийся, начиная с ОС 2, указывает на то, что поиск производится по шаблонам.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1020>
<b>SET</b> NAME,STRING/F
</a></pre></font></blockquote><blockquote><p align="justify">
Встроенная команда ОС 2 и 3, позволяющая присвоить значение локальной переменной окружения, либо просмотреть имена и значения таких переменных (в случае использования SET без параметров). Подробнее о таких переменных см. в описании команды <a href="AMIGA-10.html#A100Y">GET</a>.
</p></blockquote><blockquote><p align="justify">
Параметр NAME соответствует имени переменной, a STRING &mdash; её новому значению. Если переменная с указанным именем отсутствует, то она будет создана; если параметр STRING отсутствует, то переменной будет присвоено значение 
&quot;пустая строка&quot; &mdash; т.е. единственный нулевой байт. Для полного же уничтожения переменной используется команда <a href="AMIGA-10.html#A102E">UNSET</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1021>
<b>SETCLOCK</b> LOAD/S,SAVE/S,RESET/S
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда позволяет работать с часами реального времени с батарейным питанием (наличие таких часов крайне желательно, особенно если вы не только играете в игрушки на вашей Амиге). Вместе с командой обязательно используется один и только один из 
трех параметров-переключателей:
</p></blockquote><blockquote><p align="justify">
LOAD загружает время из аппаратных в системные часы. Обычно это делается автоматически при старте системы (в версиях ОС 1.x команда SETCLOCK LOAD находилась в файле &quot;S:Startup-Sequence&quot;; ОС версий 2 и 3 вообще делают это &quot;сами&quot;).
</p></blockquote><blockquote><p align="justify">
SAVE производит обратное действие: переписывает время из системных часов в аппаратные. Поскольку все команды ОС работают исключительно с системными часами, изменить время аппаратных часов можно только с помощью SETCLOCK SAVE.
</p></blockquote><blockquote><p align="justify">
RESET выручает в том случае, если какая-либо из программ вышла из-под контроля и решила записать нечто прямо в регистры аппаратных часов. Результат подобного поведения может быть каким угодно &mdash; например, полный бред вместо системного времени, 
либо возможные сообщения о том, что аппаратные часы вообще отсутствуют в системе. Исполнение SETCLOCK RESET заново инициализирует часы &mdash; не забудьте только потом правильно установить время.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1022>
<b>SETDATE</b> FILE/A,WEEKDAY,DATE,TIME,ALL/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда изменяет время создания/модификации заданного файла (файлов). Используется исключительно в &quot;аварийных&quot; случаях, когда системное время было неправильным в момент записи некоторых файлов, в результате чего возникла необходимость в коррекции файлового времени.
</p></blockquote><blockquote><p align="justify">
Обязательный параметр FILE соответствует маршруту файла или каталога, время создания/модификации нескольких файлов которого вы хотите изменить. ОС 2 и 3 позволяет использовать шаблоны в строке маршрута. Параметры DATE и TIME вводятся так же, как и для команды DATE (см. описание <a href="AMIGA-10.html#A100E">DATE</a>). 
Если параметр DATE отсутствует, то файловое время устанавливается по системному времени на момент исполнения SETDATE. Если параметр DATE имеется, a TIME &mdash; отсутствует, то время устанавливается на полночь.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL (только для ОС 2 и 3) вызовет соответствующую установку времени во всех файлах и подкаталогах указанного параметром FILE каталога.
</p></blockquote><blockquote><p align="justify">
Пример использования (при установленном русификаторе версии не менее 5-й):
</p></blockquote><blockquote><blockquote><pre>
SETDATE FONTS:topar.font 25-Июн-95 10:26
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1023>
<b>SETENV</b> NAME,STRING/F  (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Действие команды полностью аналогично действию команды <a href="AMIGA-10.html#A1020">SET</a>, но касается не локальных, а глобальных переменных окружения. Подробнее о таких переменных см. описание команды <a href="AMIGA-10.html#A100Z">GETENV</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1024>
<b>SETFONT</b> NAME/A,SIZE/N/A,SCALE/S,PROP/S,ITALIC/S,BOLD/S,
        UNDERLINE/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда ОС 2 и 3. Позволяет установить желаемый шрифт в текущем Shell-окне. По умолчанию Shell-окна используют т.н. 
&quot;стандартный системный шрифт&quot; (system default text), который устанавливается пользователем &quot;глобально&quot;, 
т.е. для всей системы в целом.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром команды является имя шрифта &mdash; например, Helvetica. Шрифт не обязательно должен быть стандартным амижным 
&quot;битмап&quot;-шрифтом, вы можете использовать любой из инсталированных с помощью программы Intellifont масштабируемых шрифтов. 
Правда, для масштабируемых шрифтов небольшой высоты характерно весьма невысокое качество.
</p></blockquote><blockquote><p align="justify">
После имени шрифта должна обязательно следовать его высота (в пикселях).
</p></blockquote><blockquote><p align="justify">
Если вы выбрали битмап-шрифт, а шрифта указанной высоты в системе нет, то SETFONT будет использовать шрифт, наиболее близкий по размеру к заказанному 
(разумеется, имя шрифта будет тем же самым). При использовании параметра-переключателя SCALE (a SCALE необходим всегда при использовании масштабируемых шрифтов) 
система программно смасштабирует выбранный шрифт до нужного размера, что может существенно испортить вид битмап-шрифтов небольшого размера.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель PROP разрешит использование пропорциональных шрифтов (т.е. таких шрифтов, где ширина каждого символа строго индивидуальна). Все без исключения 
масштабируемые шрифты являются пропорциональными, поэтому для их использования параметр PROP обязательно должен присутствовать (равно как и SCALE). 
Учтите, что Shell-окна изначально не были предназначены для работы с пропорциональными шрифтами, поэтому различные опции типа редактирования строк будут работать неправильно! 
Из-за этого (и не только) стандартный шрифт системы всегда является битмап-шрифтом фиксированной ширины.
</p></blockquote><blockquote><p align="justify">
Параметры-переключатели BOLD, ITALIC и UNDERLINE выбирают режимы вывода шрифта &quot;жирный&quot;, &quot;курсив&quot; и &quot;подчеркнутый&quot;, соответственно.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1025>
<b>SETKEYBOARD</b> KEYMAP/A
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда появилась в системе, начиная с ОС 2.1. Она изменяет карту клавиатуры &quot;локально&quot;, т.е. только для текущего Shell-окна. Обязательным параметром служит имя карты 
клавиатуры, которую вы хотите использовать. По умолчанию поиск карты производится в каталоге &quot;DEVS:Keymaps&quot;, однако, в случае указания соответствующего маршрута, её местоположение 
может быть любым. Подробнее о клавиатурных картах см. описание команды <a href="AMIGA-10.html#A1026">SETMAP</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1026>
<b>SETMAP</b> KEYMAP/A
</a></pre></font></blockquote><blockquote><p align="justify">
Это устаревшая команда каталога &quot;SYS:System&quot;, применявшаяся до появления версии ОС 2.1. Её задачей была установка глобальной клавиатурной карты для всей системы. В более новых версиях ОС глобальная карта клавиатуры 
устанавливается из программы &quot;SYS:Prefs/Input&quot;. 
</p></blockquote><blockquote><p align="justify">
На разных вариантах компьютеров расклад клавиатуры зависит от того, для продажи в какой стране этот компьютер предназначается. В России получили распространение в основном американские и немецкие варианты классики, реже встречаются английские. 
Вот имена стандартных карт клавиатур для различных вариантов Амиг:</p></blockquote>
<blockquote><table width="95%" align="center">
<tr><td align="right">cdn &mdash;</td>
<td>Канада (французский)</td></tr>
<tr><td align="right">ch1 &mdash;</td>
<td>Швейцария (французский)</td></tr>
<tr><td align="right">ch2 &mdash;</td>
<td>Швейцария (немецкий)</td></tr>
<tr><td align="right">d &mdash;</td>
<td>Германия</td></tr>
<tr><td align="right">dk &mdash;</td>
<td>Дания</td></tr>
<tr><td align="right">e &mdash;</td>
<td>Испания</td></tr>
<tr><td align="right">f &mdash;</td>
<td>Франция</td></tr>
<tr><td align="right">gb &mdash;</td>
<td>Великобритания</td></tr>
<tr><td align="right">i &mdash;</td>
<td>Италия</td></tr>
<tr><td align="right">is &mdash;</td>
<td>Исландия</td></tr>
<tr><td align="right">n &mdash;</td>
<td>Норвегия</td></tr>
<tr><td align="right">s &mdash;</td>
<td>Швеция</td></tr>
<tr><td align="right">usa0 &mdash;</td>
<td>эмуляция старой клавиатурной карты ОС 1.1</td></tr>
<tr><td align="right">usa1 &mdash;</td>
<td>включена карта для дополнительной части клавиатуры (keypad), которой не было в usa0</td></tr>
<tr><td align="right">usa2 &mdash;</td>
<td>США</td></tr>
</table></blockquote>
</p></blockquote><blockquote><p align="justify">
Поскольку наша маленькая Россия не доросла даже до Исландии, автору этой книги пришлось самому делать соответствующие клавиатурные карты (см. описание русификатора в соответствующей главе этой книги).
</p></blockquote><blockquote><p align="justify">
SETMAP ищет указанную в качестве параметра карту клавиатуры в каталоге &quot;DEVS:Keymaps&quot;. Клавиатурная карта &quot;usa&quot; находится в постоянном запоминающем устройства (ПЗУ) системы и загружается по умолчанию.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1027>
<b>SETPATCH</b> R/S                                  (для ОС 1.3)
         QUIET/S,NOCACHE/S,REVERSE/S,NOAGA/S  (для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Программ без ошибок на свете не бывает. ПЗУ Амиги (иначе называемое &quot;Kickstart&quot;) исключением из этого глобального правила, разумеется, не является. Самое главное, чтобы эти ошибки можно было бы исправлять по мере их обнаружения. 
Для этих целей и служит команда SETPATCH, которая всегда должна исполняться самой первой в файле &quot;S:Startup-Sequence&quot;. Само понятие &quot;patch&quot; в программистской практике означает коррекцию уже готовых программ с помощью некоторых внешних 
средств. Коррекция может быть динамической, т.е. исполняться каждый раз ПОСЛЕ запуска какой-либо программы, либо статической (когда изменяется сам программный файл на диске). В последнем случае коррекция происходит однократно, однако осуществляется другими 
средствами, нежели SETPATCH.
</p></blockquote><blockquote><p align="justify">
В случае команды SETPATCH, которая корректирует системные библиотеки, находящиеся в постоянно запоминающем устройстве, статическую коррекцию осуществить невозможно, поскольку на данном этапе запись данных в ПЗУ Амиги не поддерживается системой; SETPATCH осуществляет 
динамическую коррекцию в момент старта системы.
</p></blockquote><blockquote><p align="justify">
Первоначальный запуск SETPATCH из файла &quot;S:Startup-Sequence&quot; должен обязательно производиться с параметром QUIET (ОС 1.3 вместо QUIET требует &quot;>NIL:&quot;), который подавляет вывод списка коррекций, проделанных этой командой. Дело в том, что в файле 
&quot;S:Startup-Sequence&quot; ОС от 2.0 и старше крайне нежелателен любой вывод сообщений в Shell-окно, т.к. система к этому может быть не готовой. Весь вывод (если он есть) должен быть сконцентрирован в файле &quot;S:User-Startup&quot;.
</p></blockquote><blockquote><p align="justify">
В версии ОС 1.3 параметр R означает включение защиты устройства &quot;RAD:&quot; для систем с объемом Chip-памяти 1 Мб, т.к. по умолчанию ОС 1.3 считает, что объем Chip-памяти равен 512 Кб.
</p></blockquote><blockquote><p align="justify">
Все указанные в образце параметры SETPATCH для ОС 2 и 3 относятся к наиболее новой на данный момент версии этой команды 40.16, которая применима для коррекции функций Kickstart от З8.ххх до 40.ххх включительно.
</p></blockquote><blockquote><p align="justify">
Параметр NOCACHE отключает кэш данных для тех процессоров, которые его имеют (68030 и 68040). По умолчанию кэш включен, что резко ускоряет работу машины, однако это может сбить с толку некоторые допотопные программы.
</p></blockquote><blockquote><p align="justify">
Параметр REVERSE отключает все коррекции, оставляя ПЗУ-шные функции &quot;как они есть&quot;. Практической ценности не он представляет &mdash; разве что для системных программистов.
</p></blockquote><blockquote><p align="justify">
Параметр NOAGA отключает специфические функции AGA-conpoцессоров, при этом эмулируется самый старый сопроцессорный набор (как в А500, например). Впрочем, есть гораздо более удобные средства для подобных манипуляций (например, бутовое меню или программа KillAGA &mdash; 
оптимальный вариант).
</p></blockquote><blockquote><p align="justify">
Повторный запуск SETPATCH &quot;вручную&quot; на уже работающей системе ни к каким фатальным последствиям не приведёт &mdash; SETPATCH определит что все нужные коррекции уже произведены и просто выведет список этих коррекций.
</p></blockquote><blockquote><p align="justify">
Будьте бдительны при установке новых версий SETPATCH, поскольку это &mdash; идеальное место для очередного вируса.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1028>
<b>SKIP</b> LABEL,BACK/S  (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда, предназначенна для использования исключительно внутри командных файлов. SKIP осуществляет переход на метку, заданную командой <a href="AMIGA-10.html#A101F">LAB</a>, после чего исполнение команд продолжается со строки, непосредственно следующей за меткой.
</p></blockquote><blockquote><p align="justify">
Если SKIP не может найти метку, указанную в качестве параметра, то выдается сообщение &quot;Объект не найден&quot; и выполнение командного файла прерывается.
</p></blockquote><blockquote><p align="justify">
Параметром LABEL для команды SKIP является имя метки, на которую планируется произвести переход. Поиск требуемой метки осуществляется только вперёд по тексту командного файла относительно команды SKIP (при отсутствии параметра-переключателя BACK), 
либо назад по тексту (в противном случае).
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A1029>
<b>SORT</b> FROM/A,TO/A,COLSTART/K,CASE/S,NUMERIC/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда выполняет сортировку строк в текстовых файлах. Строки сортируются в соответствии с ASCII-значениями их символов слева направо. Ограничителями строк считаются символы &quot;перевод строки&quot; с ASCII-значением 10 (десятичное).
</p></blockquote><blockquote><p align="justify">
К сожалению, стандартная команда SORT не локализована, т.е. игнорирует языковые установки системы, в связи с чем при сортировке строк, содержащих русские буквы, регистр букв учитывается всегда. Кроме того, твердый знак считается наибольшей по 
значению буквой (т.е. порядок следования русских букв в конце алфавита &mdash; ЦЧШЫЬЭЮЯЪ). Автор этой книги планирует написать надлежащую версию команды SORT в ближайшее время. На данный момент времени правильную сортировку русских и смешанных 
текстов осуществляет текстовый редактор GoldEd в комбинации с русификатором 5-й (или более новой) версии.
</p></blockquote><blockquote><p align="justify">
Команда последовательно сравнивает все символы строк слева направо, и располагает все строки файла по возрастанию ASCII-значений символов. Старые версии команды работают медленнее новых и требуют увеличения размеров стека по сравнению со стандартным 
значением (4 Кб) для сортировки файлов, содержащих более чем 200 строк. Файлы, превышающие по своей длине объем свободной памяти в системе, сортироваться не будут.
</p></blockquote><blockquote><p align="justify">
Обязательный параметр FROM соответствует маршруту текстового файла, содержимое которого необходимо рассортировать. Если параметр FROM &mdash; не первый по счёту, то употребление ключевого слова FROM обязательно.
</p></blockquote><blockquote><p align="justify">
Обязательный параметр ТО соответствует маршруту текстового файла-приемника, либо имени устройства, куда необходимо направить результат работы команды SORT. Если параметр ТО &mdash; не второй по счету, то употребление ключевого слова ТО обязательно.
</p></blockquote><blockquote><p align="justify">
Ключевое слово COLSTART с последующим числовым параметром используется в тех случаях, когда сортировка начинается не с 1-й колонки каждой строки. В этом случае параметром должен явиться требуемый номер колонки. Если строки, начинающиеся с определенной таким 
образом колонки, получатся одинаковыми, то для них будет произведена повторная сортировка уже начиная с 1-й колонки.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель CASE включит режим сортировки, при котором регистр букв (заглавный или строчный) более не игнорируется. Заглавные буквы при этом пойдут перед строчными. Без параметра CASE регистр игнорируется для латинских букв и русской буквы &quot;А&quot;, 
являющейся в русифицированой AmigaOS общей для русского и латинского алфавитов.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель NUMERIC заставляет команду SORT рассматривать содержимое строк как десятичные числа &mdash; первый же нечисловой символ в строке приведет к тому, что содержимое строки далее анализироваться не будет. Строки, вообще не начинающиеся с числа (либо 
строки, колонка с номером COLSTART которых также не содержит цифры), будут иметь нулевой &quot;вес&quot;. Если используются оба параметра CASE и NUMERIC, то NUMERIC просто игнорируется.
</p></blockquote><blockquote><p align="justify">
Пример использования:
</p></blockquote><blockquote><blockquote><pre>
SORT  RAM:Фирмы  RAM:Список_фирм
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102A>
<b>STACK</b> SIZE/N  (встроенная для ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Будучи использованной без параметра, STACK показывает размер стека &mdash; служебной области памяти, резервированной текущим Shell-процессом. Для подавляющего большинства стандартных команд ОС достаточным размером стека является 4096 байт &mdash; стеки именно такого размера 
резервируются системой по умолчанию для всех стартующих задач и процессов. Посмотреть значения длин стеков у идущих в системе процессов удобнее с помощью команды <a href="AMIGA-10.html#A102B">STATUS FULL</a> или <a href="AMIGA-10.html#A102B">STATUS TCB</a>.
</p></blockquote><blockquote><p align="justify">
Если задать числовой параметр SIZE, то именно таким станет размер стека для текущего Shell-процесса. Обычно подобная возможность используется в том случае, если размера стека недостаточно для запуска какой-либо программы из Shell-окна.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102B>
<b>STATUS</b> PROCESS/N,FULL/S,TCB/S,CLl=ALL/S,COM=COMMAND/K
</a></pre></font></blockquote><blockquote><p align="justify">
Команда показывает информацию о процессах, идущих в системе. Выводимая информация может включать в себя имя процесса, приоритет, значение глобального вектора и размер стека. Всё это, скорее всего, представляет наибольший интерес для системных программистов.
</p></blockquote><blockquote><p align="justify">
Использование команды STATUS весьма удобно в комбинации с такими командами, которые могут требовать номер некоторого процесса в качестве параметра (например, <a href="AMIGA-10.html#A1008">BREAK</a>). В этих случаях STATUS передает этим командам требуемый для них параметр &mdash; номер активного 
процесса, который при этом не придётся запоминать при запуске соответствующих программ.
</p></blockquote><blockquote><p align="justify">
Числовой параметр PROCESS соответствует номеру процесса, о состоянии которого команда STATUS должна доложить. Если этот параметр отсутствует, то будет выведена информация обо всех процессах сразу.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ТСВ (сокращение от Task Control Block &mdash; структура-описатель задачи) вызывает вывод информации о значениях глобального вектора, размера стека и приоритета всех активных задач, о которых известно системе.
</p></blockquote><blockquote><p align="justify">
Использование параметра-переключателя FULL адекватно одновременному использованию параметров ТСВ и ALL.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL или его синоним CLI вызывают вывод информации обо всех активных CLI-процессах; будут также показаны имена всех активных в данный момент времени команд, стартовавших из CLI-процессов. Тот же результат дает команда STATUS без параметров.
</p></blockquote><blockquote><p align="justify">
Ключевое слово COMMAND (или его синоним СОМ) с последующим именем файла, соответствующего некоей работающей команде, заставляет STATUS вернуть номер того CLI-процесса, из которого эта команда была запущена на исполнение. Таким образом можно, например, помня только имя активной в 
данный момент времени команды, передать команде <a href="AMIGA-10.html#A1008">BREAK</a> номер процесса, который нужно прекратить. Поясним на примере. Допустим, мы исполнили из некоторого Shell-окна команду <a href="AMIGA-10.html#A102H">WAIT 100</a>, которая просто ждёт 100 секунд. Теперь откроем еще одно Shell-окно и исполним:
</p></blockquote><blockquote><blockquote><pre>
BREAK 'STATUS COMMAND WAIT'
</pre></blockquote></blockquote><blockquote><p align="justify">
Команде <a href="AMIGA-10.html#A1008">BREAK</a> будет передан номер процесса, который исполняет команду <a href="AMIGA-10.html#A102H">WAIT</a> &mdash; в результате исполнение WAIT будет прервано. Любопытный нюанс: если число процессов, из которых была запущена на исполнение искомая команда (в данном случае &mdash; <a href="AMIGA-10.html#A102H">WAIT</a>), больше одного, то STATUS вернёт 
их номера, разделённые символами &quot;новая строка&quot;, т.е. каждый номер на собственной строке. <a href="AMIGA-10.html#A1008">BREAK</a> в этом случае выдаст сообщение об ошибке &quot;Неверное число параметров&quot;, поскольку одна и та же команда <a href="AMIGA-10.html#A1008">BREAK</a> не может прервать исполнение более чем одной Shell-команды.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102С>
<b>TYPE</b> FROM/A/M,TO/K,OPT/K,HEX/S,NUMBER/S
</a></pre></font></blockquote><blockquote><p align="justify">
Команда выводит содержимое некоторого файла на любое заданное устройство или файл. Чаще всего TYPE используется для просмотра содержимого файла, хотя никто не мешает воспользоваться этой командой, скажем, для копирования. Особенностью TYPE является возможность выводить содержимое файла в 
шестнадцатеричном виде, а также добавлять номера строк. Вывод, осуществляемый командой, можно приостановить, нажав какую-либо клавишу (обычно &mdash; &quot;Пробел&quot;), а затем возобновить, нажав Enter, Backspace или &quot;CTRL&nbsp;+&nbsp;X&quot;. Прервать работу TYPE можно как обычно, 
нажав &quot;CTRL&nbsp;+&nbsp;C&quot;.
</p></blockquote><blockquote><p align="justify">
Обязательный параметр FROM соответствует маршруту файла, содержимое которого необходимо вывести. Если параметр FROM &mdash; не первый по счёту, то употребление ключевого слова FROM обязательно. Версии ОС 2 и 3 позволяют использовать сразу несколько маршрутов и/или шаблоны для множественного 
вывода файлов.
</p></blockquote><blockquote><p align="justify">
Ключевое слово ТО соответствует маршруту файла-приемника, либо имени устройства, куда необходимо направить поток вывода TYPE. Если параметр ТО &mdash; не второй по счету, то употребление ключевого слова ТО обязательно. Его необходимо использовать в версиях ОС 2 и 3 и в тех случаях, когда FROM-файлов 
больше одного (поскольку система иначе не будет знать, является ли последний из маршрутов источником или приемником &mdash; ведь маршрут приемника вообще может быть не указан). Если маршрут приемника отсутствует, то вывод происходит в текущее Shell-окно. Если файл-приемник уже существует, то он переписывается 
заново; если маршрут приемника соответствует пустому каталогу, то этот каталог будет удален, а вместо него будет создан файл с соответствующим именем (при соответствии приемника не пустому каталогу будет выдано сообщение об ошибке).
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель HEX (синоним ОРТ Н) меняет формат вывода на шестнадцатеричный, в результате TYPE выдаст то, что программисты называют дампом.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель NUMBER (синоним ОРТ N) заставит TYPE вставлять номера строк перед каждой выводимой строкой. Опции HEX и NUMBER являются взаимно исключающими &mdash; их нельзя использовать одновременно.
</p></blockquote><blockquote><p align="justify">
Пример использования: распечатать файл на принтере в виде hex-дампа.
</p></blockquote><blockquote><blockquote><pre>
TYPE  HackFile >PRT:  HEX
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102D>
<b>UNALIAS</b> NAME  (встроенная команда ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Это встроенная команда ОС 2 и 3. Будучи использованной с параметром &mdash; псевдонимом некоторой команды, UNALIAS отменяет введенный ранее псевдоним (см.описание команды <a href="AMIGA-10.html#A1003">ALIAS</a>). Без параметров она просто выдаст список 
текущих псевдонимов.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102E>
<b>UNSET</b> NAME  (встроенная команда ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Эта встроенная ОС 2 и 3 команда используясь с параметром &mdash; именем локальной переменной окружения &mdash; уничтожает её. UNSET без параметров выдаст список локальных переменных окружения.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102F>
<b>UNSETENV</b> NAME  (встроенная команда ОС 2 и 3)
</a></pre></font></blockquote><blockquote><p align="justify">
Это встроенная команда ОС 2 и 3. Действует аналогично <a href="AMIGA-10.html#A102E">UNSET</a>, но для глобальных переменных окружения. Подробнее о глобальных переменных окружения см. в описании команды <a href="AMIGA-10.html#A100Z">GETENV</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102G>
<b>VERSION</b> NAME,VERSION/N,REVISION/N,FILE/S,FULL/S,UNIT/N,
        INTERNAL/S,RES/S
</a></pre></font></blockquote><blockquote><p align="justify">
В системе такого уровня мощности и сложности, как ОС Амиги (AmigaOS), номера версий различных файлов, ресурсов, библиотек и т.д. имеют наиважнейшее значение. Без них ОС превратилась бы просто в броуновское движение, 
в котором разобраться, что куда движется, было бы под силу разве что самому господину Броуну &mdash; основателю этого движения. Поэтому рекомендуется относиться с должным пиететом к команде VERSION, которая выводит 
номер версии некоторого системного объекта.
</a></pre></font></blockquote><blockquote><p align="justify">
Объект может являться библиотекой, устройством или файлом. Тип объекта распознается по его имени: библиотеки всегда имеют расширение &quot;.library&quot;, устройства &mdash; &quot;.device&quot;. Всё остальное считается 
файлами. VERSION предполагает, что библиотеки и устройства находятся там, где им положено быть по штату, в каталогах &quot;LIBS:&quot; и &quot;DEVS:&quot; соответственно (если библиотека или устройство являются встроенными 
в систему, т.е. находящимися в ПЗУ, то VERSION об этом знает). Имя объекта задается аргументом NAME. При отсутствии NAME выводятся сразу две глобальные версии &mdash; версия Kickstart (системного ПЗУ) и Workbench. To, что 
называется версией Workbench, на самом деле (начиная с ОС 2.1) является версией подгружаемой с диска библиотеки &quot;LIBS:version.library&quot;. Это сделано, чтобы обеспечить максимальную гибкость коррекции номеров версий при 
использовании новых подгружаемых библиотек, кардинально меняющих &quot;лицо&quot; системы. Вот небольшая справка по различным версиям системных ресурсов:
</a></pre></font></blockquote>
<table width="90%">
<tr><td align="right" valign="top" width="20%">V0-V32 &mdash;</td>
<td align="justify">Старые версии, которые практически неработоспособны с точки зрения существующего на данный момент программного обеспечения.</td></tr>
<tr><td align="right" valign="top" width="20%">V33 &mdash;</td>
<td align="justify">Kickstart 1.2 &mdash; Amiga 500 и Amiga 2000. Уже терпимо, если вы не программист.</td></tr>
<tr><td align="right" valign="top" width="20%">V34 &mdash;</td>
<td align="justify">Kickstart 1.3 (Почти то же, что 1.2, но с возможностью старта с жёсткого диска).</td></tr>
<tr><td align="right" valign="top" width="20%">V35 &mdash;</td>
<td align="justify">Экзотическая тест-версия Kickstart 1.4. Устарела, не успев толком появиться на свет.</td></tr>
<tr><td align="right" valign="top" width="20%">V36 &mdash;</td>
<td align="justify">Kickstart 2.00-2.03. Предварительная версия, которая устанавливалась на первые модели АЗ000. Содержит множество &quot;жуков&quot;, так что работает 
весьма ненадежно, хотя уже обрисовываются контуры грандиозной ОС. Вся ОС Амиги (AmigaOS) подверглась глобальным изменениям и усоврешенствованиям по сравнению с прежними 
версиями.</td></tr>
<tr><td align="right" valign="top" width="20%">V37 &mdash;</td>
<td align="justify">Kickstart 2.04. Отлаженная и уже нормально работающая версия. Начиная с 37.200 поддерживаются IDE-винчестеры (актуально для А600). При возможности легко 
обновляется на V38 (Kickstart 2.1), поскольку вся разница между этими версиями заключается в различных файлах дистрибутивов для этих систем (ПЗУ можно не менять).</td></tr>
<tr><td align="right" valign="top" width="20%">V38 &mdash;</td>
<td align="justify">Kickstart 2.1 (библиотека &quot;exec.library&quot; не покажет эту версию, поскольку Kickstart остался прежним!). Все обновленные библиотеки V38 находятся не 
в ПЗУ, а на диске дистрибутива. Введена поддержка локализации, можно в полной мере пользоваться русификатором. Значительный шаг вперёд по сравнению с V37.</td></tr>
<tr><td align="right" valign="top" width="20%">V39 &mdash;</td>
<td align="justify">Kickstart 3.0 &mdash; штатный для А1200, А4000 и А4000Т.</td></tr>
<tr><td align="right" valign="top" width="20%">V40 &mdash;</td>
<td align="justify">Kickstart 3.1 &mdash; наиболее совершенная на данный момент времени. 
Фантастическая по красоте и возможностям система. Устанавливается на все модели Амиг, выпускаемые с 1995г.
<em>(От себя хочу заметить что на 2003 год текущая версия V44.1 &mdash; KickStart 3.9 &mdash; Д.Цуканов)</em></td></tr>
</table>
</p></blockquote><blockquote><p align="justify">
Команда VERSION может возвратить версию любого файла, содержащего внутри себя стандартизованную строку &mdash; идентификатор версии, имеющую примерно следующий вид:
</p></blockquote><blockquote><blockquote><pre>
$VER: 1.0 (25.06.95)
</pre></blockquote></blockquote><blockquote><p align="justify">
Строка должна всегда завершаться или кодом &quot;перевод строки&quot; (10 десятичный), или нулевым байтом. Системные библиотеки и устройства имеют другую организацию хранения номера 
версии (VERSION, разумеется, понимает и её), касаться которой мы в этой книге не будем, поскольку, это уже чистейшая программистская область.
</p></blockquote><blockquote><p align="justify">
Числовые аргументы VERSION и REVISION обычно используются в командных файлах для проверки, соответствует ли версия и подверсия некоторого объекта требуемым (т.е. не ниже требуемых). 
Если номер версии объекта больше, нежели значение аргумента VERSION, команда всегда возвращает код ошибки ноль, если меньше &mdash; код ошибки 5 (WARN). В случае равенства таким же образом, 
как и номера версий, сравниваются номера подверсий (если параметр REVISION не определен, то считается, что всё в порядке). Таким образом можно легко определить, не устарел ли некоторый 
системный ресурс для требований, предъявляемых вашей программой.
</p></blockquote><blockquote><p align="justify">
Аргумент-переключатель FILE заставит команду VERSION трактовать имя библиотеки или устройства, как имя файла.
</p></blockquote><blockquote><p align="justify">
Аргумент-переключатель INTERNAL указывает на то, что необходимо искать версию <em>встроенного</em> объекта.
Аргумент может использоваться в том случае, если в соответствующем каталоге системного диска есть объект с тем же именем, что и встроенный.
</p></blockquote><blockquote><p align="justify">
Аргумент-переключатель RES позволяет определить версию резидентной команды.
</p></blockquote><blockquote><p align="justify">
Аргумент-переключатель FULL заставляет VERSION выводить полную строку версии, включая дату создания.
</p></blockquote><blockquote><p align="justify">
Пример использования VERSION в командном файле:
</p></blockquote><blockquote><blockquote><pre>
VERSION >NIL: exec.library VERSION=39 REVISION=47 
if WARN 
   echo "He слишком свежая версия..." 
else
   echo "Все нормально!"
</pre></blockquote></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102H>
<b>WAIT</b> /N,SEC=SECS/S,MIN=MINS/S,UNTIL/K
</a></pre></font></blockquote><blockquote><p align="justify">
Команда &quot;усыпит&quot; вызвавшую её задачу либо на заданный период времени, либо до определённого значения системного времени. Её имеет смысл использовать или в командных файлах, или в комбинации с командой <a href="AMIGA-10.html#A101Y">RUN</a>. 
Команда <a href="AMIGA-10.html#A1008">BREAK</a> прервет исполнение команды <a href="AMIGA-10.html#A102H">WAIT</a> и вернёт задачу к активному состоянию.
</p></blockquote><blockquote><p align="justify">
Первым параметром для <a href="AMIGA-10.html#A102H">WAIT</a> может являться число временных интервалов, в течение которых задача &quot;спит&quot;. Сами интервалы по умолчанию или при наличии параметра 
SEC (SECS) измеряются в секундах, при наличии параметра MIN (MINS) &mdash; в минутах. По умолчанию интервал равен единице, т.е. если исполнить команду <a href="AMIGA-10.html#A102H">WAIT</a> без параметров, то пауза 
составит ровно 1 секунду.
</p></blockquote><blockquote><p align="justify">
Альтернативой задержке исполнения задачи НА заданный временной интервал является задержка ДО определённого времени &mdash; в этом случае используется ключевое слово UNTIL с последующим 
параметром &mdash; значением системного времени &quot;пробуждения&quot; задачи. Время вводится в формате ЧЧ:ММ, например 22:45. Пробуждение произойдет между ЧЧ:ММ:00 и ЧЧ:ММ:59.
</p></blockquote><blockquote><p align="justify">
Пример использования <a href="AMIGA-10.html#A102H">WAIT</a> в командном файле:
</p></blockquote><blockquote><blockquote><pre>
run >NIL:  WAIT UNTIL 23:59 
rx  &quot;ADDRESS 'Rusifier.port'; SPEAK 'Кончай работу!'&quot;
</pre></blockquote></blockquote><blockquote><p align="justify">
Здесь мы уже начинаем использовать мощнейший внутрисистемный язык ARexx, которому посвящается <a href="AMIGA-11.html">следующая глава</a>.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102I>
<b>WHICH</b> FILE/A,NORES/S,RES/S,ALL/S
</a></pre></font></blockquote><blockquote><p align="justify">
Задачей WHICH является показать маршрут заданного объекта, который может быть командой, файлом, каталогом или устройством. 
Для успешного поиска искомый объект должен находиться или в списке резидентных команд (см. описание команды <a href="AMIGA-10.html#A1010">RESIDENT</a>), или в одном из 
каталогов, входящих в маршрут поиска (включая, разумеется, текущий каталог). Если объект является каталогом или устройством, то будет также 
просмотрен системный список логических устройств (см. описание команды <a href="AMIGA-10.html#A1005">ASSIGN</a>). Если имеется несколько версий заданного объекта, то будет показан 
маршрут первой найденной версии.
</p></blockquote><blockquote><p align="justify">
Обязательным параметром для WHICH является имя искомого объекта. Взаимно исключающие аргументы-переключатели RES и NORES модифицируют режим поиска 
следующим образом: RES заставляет команду WHICH производить поиск ТОЛЬКО в резидентном списке, a NORES &mdash; всюду, ЗА ИСКЛЮЧЕНИЕМ резидентного списка. 
Таким образом, использование любого из этих параметров сужает поле поиска.
</p></blockquote><blockquote><p align="justify">
Параметр-переключатель ALL устраивает самую настоящую облаву в поисках заданного объекта, перетряхивая все вышеуказанные маршруты и списки. 
При этом команда WHICH не успокоится, пока не выловит все возможные версии искомого объекта, не останавливаясь на первой найденной.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102J>
<b>WHY</b>
</a></pre></font></blockquote><blockquote><p align="justify">
Эта команда пытается сообщить нам дополнительную информацию о причинах неудачи предыдущей команды. WHY надо запускать сразу после команды, 
возвратившей ненулевой код ошибки. На самом деле команда WHY выводит строку, соответствующую номеру ошибки, находящемуся в локальной переменной окружения 
result2, поэтому код, находящийся там, должен оставаться нетронутым на момент исполнения WHY. Если ОС не определяет соответствующей текстовой строки для некоторых 
кодов ошибок, то WHY просто выведет этот код.
</p></blockquote>

<blockquote><font face="Arial, Helvetica, sans-serif" size="4"><pre>
<a name=A102K>
<b>;</b>
</a></pre></font></blockquote><blockquote><p align="justify">
Символ &quot;точка с запятой&quot; является идентификатором начала комментария в командных файлах. 
Часть строки после этого символа игнорируется ОС и предназначается исключительно для человеческих существ, пытающихся разобраться в том, что этот файл должен делать.
</p></blockquote>

<hr>
</body></html>
