\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@node Top
@top Top

@menu
* Amiga compatible programming guide::
* Introduction::
* Development environments::
* Basic knowledge for Amiga programming::
* Interaction between programs and users on Amiga GUI::
* APPENDIX B Subversion on Amiga::
@end menu

@node Amiga compatible programming guide
@chapter Amiga compatible programming guide
@anchor{#amiga-compatible-programming-guide}
Preface

@emph{"ShInKurO, you're becoming the eighth Egypt's plague!"} Turrican^,
FreeNode #AmigaITA IRC channel, 17/07/2007

@emph{"becoming.. you are right now! :)"} suppah, FreeNode #AmigaITA IRC
channel, 07/05/2008

@emph{"I would be cash for mui lessons:)"} kiero, FreeNode #MUI IRC
channel, 05/05/2008

@emph{"shinky listen, I've already told it to you, it's a normal, good
and right thing to try code pieces in little programs[...]" "[...]you
write a little program to try things, so you reduce your doubts"} alfie,
FreeNode #AmigaITA IRC channel , 2007
@menu
* I Who is this for::
* II Acknowledgement::
* III Bibliography::
@end menu

@node I Who is this for
@section I Who is this for
@anchor{#i-who-is-this-for}
This guide offers a lot of concepts from subjects like software
engineering, structured and object oriented programming to referring to
the available APIs of the Amiga platform. We recommend the reader follow
the suggested links during the guide, in order to obtain a better point
of view about the methodologies we will reference. Every subject will be
handled in a simulated form sometimes, leaving the task of mastering the
subject to the reader, using reference texts which will always be
suggested here.

Knowledge explained in this guide is easily accessible to those who know
what a compiler is and who have a basic knowledge of the C programming
language. If you don't have this knowledge, please read the following C
courses first:

@verbatim
http://www.cprogramming.com/tutorial.html   
@end verbatim

@node II Acknowledgement
@section II Acknowledgement
@anchor{#ii-acknowledgement}
This guide wouldn't exist if some person wouldn't have had the patience
to suffer and answer all of my numerous asks about Amiga programming. I
thank those people who tolerate to be the betatesters of my programs and
those who have advised me about a number of things too. I wish to thank,
in random order:

Alfonso "alfie" Ranieri Ikka "itix" Lehtoranta Michal "kiero" Wozniak
Michal "mschulz" Schulz Stefano "suppah" Crosara Andrea "guruman"
Maniero Fabio "falemangn" Alemagna Davide "Turrican^" Michelini Elena
Novaretti Claudio "clros" La Rosa Andrea "afxgrup" Palmatè Joachim
"zerohero" Birging

@node III Bibliography
@section III Bibliography
@anchor{#iii-bibliography}
@itemize
@item
Amiga ROM Kernel Reference Manual: Libraries, 3ª Edition
(Commodore-Amiga Inc.);
@item
AmigaDOS Manual;
@item
Amiga User Interface Style Guide;
@item
Amiga Mail Vol. 2;
@item
The Amiga Guru Book, a reference manual (Ralph Babel);
@item
Various articles from Transaction guide on Amiga Magazine (italian
magazine);
@item
Guide about AmigaOS (Andrea Carolfi)
@item
AROS System Development Manual
@item
MUI development guide
@item
AmigaOS 4 Software Development Kit
@item
MorphOS Software Development Kit
@item
Software engeneering notes from Stefania Gnesi teacher
http://fmt.isti.cnr.it/~gnesi/matdid/IngSoftCap6_8.pdf
@end itemize

@node Introduction
@chapter Introduction
@anchor{#introduction}
@emph{"There is a insurmountable problem. Which is not about the ego of
someone or the commercial and industrial projects. It's simply the
litigiosity of the community. We knows, amigans were always fractious
like soccer supporters. When they lived at home with mum who checked at
what time they were back to home and if they were studiyng, things went
well. But when they become independent, they made only messes."} Alfonso
"alfie" Ranieri, ATML, 10/12/2007
@menu
* 11 Problems to face when programming on Amiga::
* 12 Past and modern philosophies reset course::
* 13 What is the Amiga platfrom today? Hints to code portability::
@end menu

@node 11 Problems to face when programming on Amiga
@section 1.1 Problems to face when programming on Amiga
@anchor{#problems-to-face-when-programming-on-amiga}
There are a multitude of problems for a new Amiga programmer:

@enumerate 
@item
Lack of a good documentation;
@item
Lack of modern tools for application development;
@end enumerate

Most of the documentation on Amiga systems that is available is
outdated, mostly in English, and with a lot of obsolete parts.
Throughout this guide we will address the reader to resources still
valid in the world of the Amiga reincarnations. In systems such as
Windows, MacOSX and Linux there are IDEs (Integrated Development
Enviroment) with marvelous features, these programs give the users
everything they need to develop software in the simplest and fastest way
possible. Unfortunately, the Amiga platform doesn't offer this anymore,
except for one IDE, CubicIDE, which offers a lot of features which are
present in modern IDEs. By the way, CubicIDE is a pay for use software
(at this time, the user licence is about 100 euros, an amount of money
which is not always available to students and beginners programmers...),
and this software offers guaranteed support only for AmigaOS3.x and
MorphOS. So, there isn't any version for AROS. In this guide we'll refer
to possible alternatives in the little Amiga universe concerning
advanced editors. By the way, the biggest problem above all of these
problems: the amiga mentality.

@node 12 Past and modern philosophies reset course
@section 1.2 Past and modern philosophies: reset course
@anchor{#past-and-modern-philosophies-reset-course}
Amiga was born in the 80s, it amazed everyone with its features... If
you still don't know much about this, we suggest you read up on it's
history, just to understand some good points about the Amiga platform.
The user/programmer who is starting a new software project have a
valuable cultural and philosophical background, which is the direct
product of the trouble his beloved platform went through. This means
that some of its ideas should be perfectly shareable if we were in the
second half of the 80s, but are completely obsolete if applied in the
21st century. In particular, the amiga philosophies provide:

@enumerate 
@item
Lack of a definite design: the programmer starts to code without any
planning of what he's going to write;

@item
Not reusing the available resources: they often develop a software which
offers 4 or 5 features identical to already available software. So they
often "reinvent the wheel" by not using already available APIs, but
rewriting them from scratch instead.

@item
"Closed" source: the programmer writes the code considering himself as
the only developer able to carry on the project. This code is not
written for public release, it doesn't have any comprehensive
documentation for those who read the code in the future, there are poor
comments and the order of function writing is not always understandable;

@item
Lack of collaboration: an Amiga program is often developed by a single
coder, it's very difficult to see two or more Amiga programmers
collaborate on the same software.

@item
Lack of portability: the programmer believes that his own system will
last forever, it's the only valid system ("OS4 is better! No MOS is
better!") and will never change. For this reason the code is written in
a coder's platform dependent way.

@item
Focus on assembly optimizations: the lack of the design phase causes the
writing of code with non-robust algorythms and, in order to improve
software efficiency, the amiga developer prefers to use assembly
language.

@end enumerate

It's futile to repeat that the above conventions are (in almost all
cases) wrong and bring nothing good to the amiga platform. 21st century
software (those that are absent on amiga and that all users need) are
developed in this way instead:

@enumerate 
@item
Problem analysis and resolution: to develop a software, we first analize
the problems it must solve. This analysis consists of a series of phases
that will define the work to be done to develop the software without any
ambiguity.

@item
Respect of quality rules: there are procedures and metrics to guarantee
the quality of some features of a software, for example reusability and
maintainability (= see point 6). Reusability means the reuse of
functions and/or modules already written, so the programmer doesn't need
to reimplement such features from scratch. This leads to lower
production times and higher program reliability, because third party
modules are reused in other softwares too, being tested and gaining
robustness.

@item
"Open" code: code is written keeping in mind that it should be
understood by someone who has no idea what he's reading. This means that
the code should have plenty of documentation and plenty of comments
inside the code itself. Code is always written following the same order
and considered a public release.

@item
Using of more human resources to develop software: groups of people can
collaborate on the same software. To obtain this, code standards are
defined (such as how to indent code, how to insert comments etc...), and
code sharing tools, such as svn, are used.

@item
Portability: it's useless to define the portability meaning, just see
projects such as Firefox and Openoffice, or independent programming
language such as Java;

@item
Maintenance: it's a microanalysis phase, in which we try to maintain
"alive" the software we developed. In this phase, we can fix bugs
(corrective maintenance), add new features (adaptive maintenance) and
optimize some parts of the software (perfective maintenance). This phase
derives directly from the above points, because the maintenance process
can require a huge resource expense if the software wasn't well thought
out or the code wasn't well written, sometimes this leads to the
dismissal of the software itself.

@end enumerate

@node 13 What is the Amiga platfrom today? Hints to code portability
@section 1.3 What is the Amiga platfrom today? Hints to code
portability...
@anchor{#what-is-the-amiga-platfrom-today-hints-to-code-portability...}
This chapter should appear difficult to who have never used Amiga or
have never developed with it's APIs. Reader's doubts should disappear
following this guide, so don't worry if you don't understand something
initially.

What is the Amiga platfrom? We have to summarize in a single sentence
more than twenty years of Amiga history, so we'll be concise: today, the
Amiga platform is the combination of four operating systems seemingly
independent, whose longevity is intrinsically connected. We refer to the
following operating systems:

@itemize
@item
AmigaOS3: http://en.wikipedia.org/wiki/AmigaOS_versions
@item
AmigaOS4: http://en.wikipedia.org/wiki/AmigaOS_versions
@item
MorphOS: http://en.wikipedia.org/wiki/MorphOS
@item
AROS: http://en.wikipedia.org/wiki/AROS_Research_Operating_System
@end itemize

Due to the conditions in which these Amiga flavours live, we must think
about the reasons we would want to develop something for only one of
those amiga flavours, while we could do it for all of them. If our goal
is to write software for the Amiga platform and the platform is the
result of the combination of these four incarnations, we shouldn't
exclude any of them. Any incarnation could prevail over the others for
some reason and our software wouldn't have some systems to run on, in
other words, our software could unwisely became a non-Amiga software.
The chance to run on more than one amiga flavor makes the software more
complete: more support for different platforms brings in a larger user
base and, therefore, more feedback and testing on its features. This
brings a growth of robustness, reliability, completeness and efficiency
on the program being developed... Writing "Amiga multiplatform" code is
not as difficult as it would appear, but we must follow some tips:

@enumerate 
@item
MUI: http://aminet.net/dev/mui/mui38dev.lha ;

First of all, the choice of an API to build a modern graphic interface
(in which we don't need to reimplement basic gadgets from scratch or to
define procedures for element placement - Layout - or struggle to
understand how to "interconnect" graphical objects) must be MUI, or
Magic User Interface, instead of other solutions. The MUI API is
available for all Amiga flavours, this is what makes MUI a must.

@item
SDI: http://sourceforge.net/projects/sditools/ ;

Every amiga reincarnation has extended the AmigaOS3.1 APIs in different
ways. So, in every reincarnation there is a common API group, an updated
and incompatible API group and some new APIs incompatible and probably
absent from one incarnation to another. Regarding the second point, some
AmigaOS 3.x peculiarities, such as BOOPSI classes' dispatcher
implementation, the callback hook system etc... are different from one
incarnation to another. To write compatible software some macros are
available, they are called SDI tools. Using SDI we can write libraries
and other vital parts of our software in a portable way, without knowing
how a single thing was reimplemented in AROS or in AmigaOS4, but only
knowing the common parts.

@item
Isolated conditional code:

We've just realized that there are new features in every amiga
reincarnation which could be absent in the others. If you want to use
these new APIs we suggest to use conditional code (in C language such
code is marked between the following instruction: #ifdef, #elif, #else,
#endif), inside the vital functions of the software, or to isolate such
parts in functions and/or separate files to include in the compilation
for only one incarnation or the another.

@end enumerate

In the open source and freely readable amiga software we can find Yam,
SimpleMail, Scout, and the MUI classes TextEditor, BetterString,
NListxxx. All of these programs, used by all Amiga users, are developed
with the above three points in mind.

@node Development environments
@chapter Development environments
@anchor{#development-environments}
@emph{"When we need make we need it, as long as it only handles
dependencies."} Elena Novaretti, ATML, 28/12/2007

@emph{"data vu: The vague feeling that you've fixed this particular bug
before"} Peter Cherna, comp.sys.amiga.programmer, 1991
@menu
* 21 Development environments to write Amiga programs::
* 22 Windows cross compilers::
* 23 Compilation on AmigaOS3x GCC::
* 24 TextEditors to write programs on Amiga::
* 25 Amiga documentation historical books::
* 26 Debugging on Amiga how to find errors in our programs::
@end menu

@node 21 Development environments to write Amiga programs
@section 2.1 Development environments to write Amiga programs
@anchor{#development-environments-to-write-amiga-programs}
First of all, to develop something running on Amiga we need to choose
our development system, which can run on the same Amiga platform or on
other platforms, such as Windows and Linux. In the latter case, we call
it development with a cross compiler. In amiga flavors like MorphOS,
AmigaOS4 and newer AROS versions, every compiling guide is useless,
because these systems are provided with easy to use installation
procedures and documentation for new programmers. Regarding the real
execution of our programs, we can run them on the system we compiled it
for, but we can use the (Win)UAE emulator for AmigaOS3.x compiled files,
and/or AROS running in QEMU or VmWare.

@node 22 Windows cross compilers
@section 2.2 Windows cross compilers
@anchor{#windows-cross-compilers}
The power of the solution we are about to show is the capability to
develop for the Amiga platform even if we don't have a real Amiga
computer. In recent times, due to the fact that machines aren't always
available to users and that some tools aren't mature on the new Amiga
flavors, programmers have released a particular version of the DevC++
IDE, able to compile executables not only for Windows, but for
AmigaOS3.x, AmigaOS4.x, MorphOS and AROS too. The version of this IDE is
called AmiDevCPP. All we need to compile an Amiga program on Windows is
a working installation of AmiDevCPP, downloadable from:

@verbatim
http://amidevcpp.amiga-world.de/
@end verbatim

Once you have installed it on Windows, you need to add the additional
headers (SDI Tools) in the following paths:

@verbatim
AmigaOS3.x : "C:\CrossCompiler\AmiDevCpp\usr\local\amiga\m68k-amigaos\sys-include"

AmigaOS4: "C:\CrossCompiler\AmiDevCpp\usr\local\amiga\ppc-amigaos\SDK\Local\common\include"

MorphOS: "C:\CrossCompiler\AmiDevCpp\usr\local\amiga\ppc-morphos\sys-include"

AROS: "C:\CrossCompiler\AmiDevCpp\usr\local\amiga\i686-aros\sys-include"
@end verbatim

We must pay particular attention to external MUI classes headers, which
must be put in a subdirectory called "MUI" inside every above path. We
must recreate directories for developers files for third party library
headers, these directories must follow the form in which they are
distributed.

For those who are already familiar with DevC++ the following steps are
trivial, but it's good to list them anyway: the creation of a new
software project is very simple in AmiDevCPP, you have to choose the
"New->Project" item on the file menu. Now we can choose to build a
Windows project or a project for one of the four Amiga flavors,
choosing, for example, a command line program (called "Hello World"). We
suggest to choose a newly created directory for the new project. If we
want to create a new project from already available sources, we must
remove the source file that AmiDevCPP automatically created for us,
selecting the item "Remove from project" from the Project menu, and
adding our files using the "Add to project" item. The program might ask
us to save changes made to the AmiDevCPP example file, simply say no,
and the example file will disappear. After having made changes to our
source files, to compile the program we simply have to select the
"Rebuild All" menu item, in the "Compile" menu. If compilation went well
we'll find our executable file in the selected project's directory.

@node 23 Compilation on AmigaOS3x GCC
@section 2.3 Compilation on AmigaOS3.x (GCC)
@anchor{#compilation-on-amigaos3.x-gcc}
Amiga programmers in the golden times of their platform had the chance
to choose one of the compilers that were developed to program in that
time. But over the years the chances to choose were reduced: they could
choose SAS-C and GCC. The former was an Amiga specific compiler, easy to
use, the latter is the famous compiler born on UNIX, which runs on OS3.x
through a wrapper, the ixemul.library. Before the release of MorphOS and
AmigaOS4, SAS-C developers discontinued the development of this compiler
and, even if the road was clear, amiga users continued to use SAS-C.
Even if in recent times a multiplatform Amiga compiler is gaining users,
vbcc, which supports only C language, every new incarnation of Amiga
uses GCC as its first standard compiler.

Elena Novaretti in addition to this suggests to us:

"[...] the real reason almost people use gcc is another one [...]:
porting from linux. The GCC is NOT ANSI C, while vbcc is stricty ANSI C.
Linux programs are almost written for gcc and NOT are ANSI-compliant.
So, in these days all Amiga programmers merely to do linux porting, gcc
(and all complete emulation suite, included geek gadgets etc) is for
almost programmers most confortable choose if not even obliged. [...]
when you find programs writton on linux which use posix or gnu C
library, and these functions are not included into standard C library
then it's a very disaster to adapt source to the Amiga. It's for this
reason if you use gcc (and perhaps ixemul ;) you will are able to
compile them[...]"

As from tradition, GCC for AmigaOS3.x remained at 2.9.x version, and its
installation and configuration might lead to the complete abandonment of
your ideas about programming on this platform. We must say that a 3.x
GCC version for AmigaOS3.x, which is mainly used to build executables
for OS3.x from other platforms, such as Linux. In this way OS3.x
versions of softwares like Yam, TextEditor MCC and so on can be
obtained. GCC 3.x is available in a native OS3.x version too, the links
to download it from are the same as the 2.x version:

@verbatim
ftp://ftp.back2roots.org/pub/geekgadgets/baseline

http://ftp.back2roots.org/geekgadgets/amiga/m68k/alpha/gcc/

http://ftp.back2roots.org/geekgadgets/amiga/m68k/snapshots/990529/bin/
@end verbatim

The following are the files to download (you can find them searching the
above links):

@verbatim
BOOT.lha
gcc-2.95.3-4-bin.tgz
binutils-2.9.1-bin.tgz
fileutils-4.0-bin.tgz
make-3.77-bin.tgz
libamiga-bin.tgz
libnix-1.2-bin.tgz
libm-5.4-bin.tgz
ixemul-48.0-inc-bin.tgz
ixemul-48.0-env-bin.tgz
fd2inline-1.21-bin.lha
GG-docs-0.9-bin.tgz (documentation)
GG-misc-bin.tgz
@end verbatim

You can optionally overwrite GCC2.x with the files in the following
archives:

@verbatim
gcc-3.4.0-bin.tar.gz 
gcc-3.4.0-bin020.tar.gz  
gcc3-notes.tar.gz  
gcc3fix-20040503.tar.gz 
@end verbatim

We suggest the installation of GCC on OS3.x only if you have considered
the eventuality of reaching some form of nervous breakdown.

Now that we have done the recommendations, depending of what version you
decided to install, you'll have to proceed with the installation of GCC
2.x. First unarchive the BOOT.lha file in a directory called GG/. Make
two temporary assigns opening a shell:

@verbatim
Assign C: PATH_TO_GG_DIRECTORY/bin ADD
Assign LIBS: PATH_TO_GG_DIRECTORY/Sys/Libs ADD 
@end verbatim

Now you have some commands available, with which you can uncompress the
others archive, like the tar program. In the shell, go into the GG/:
directory

@verbatim
cd PATH_TO_GG_DIRECTORY/
@end verbatim

Start uncompressing the gcc-2.95.3-4-bin.tgz file in this way:

@verbatim
tar -xvf gcc-2.95.3-4-bin.tgz
@end verbatim

Expert users should have noticed that we didn't use the tar's z option,
most of the archives we use are only files combined into a single file
using tar, without compressing with the bzip algorythm. This action will
lead to a number of subdirectories like bin/, lib/, sys-include (or
os-include) and so on... Now you have to extract the contents of the
other archives using the same extraction path you've previously used for
gcc-2.95.3-4-bin.tgz. So, all files will be uncompressed and put in the
correct directories automatically. Now you have to modify your
User-Startup in S: with a text editor, adding the following
instructions:

@verbatim
Assign GG:   DIRECTORY_PATH_GG/
Assign C:    GG:bin ADD
Assign LIBS: GG:Sys/Libs ADD
Assign S:    GG:Sys/S ADD
@end verbatim

Execute GG:Sys/S/GG-Startup

Remember to modify GG:Sys/S/GG-Startup also, and to delete the following
instructions:

@verbatim
Assign DEVS: GG:Sys/Devs ADD
Assign L:    GG:Sys/L    ADD
@end verbatim

Reset your Amiga and you should have a working standard GCC environment.
Under such conditions you should be able to compile the classic hello
world in C:

@verbatim
#include <stdio.h>

int main(void)
{
    printf("Hello world!\n");
    
    return 0;
}
@end verbatim

Save these lines of code in a txt file called hello.c and compile
everything with:

@verbatim
gcc hello.c -o ram:hello
@end verbatim

The compiler shouldn't complain about any problems, producing the
executable called "hello", RAM: resident. Now you simply have to launch
the "hello" program from the shell, if everything went fine you should
see this classic message in the shell:

@verbatim
Hello World!
@end verbatim

Now it's time to install support to compile complex Amiga programs: the
NDK3.9. The following site:

@verbatim
http://www.zerohero.se/cross/os3.html
@end verbatim

offers a nice preconfigured NDK3.9, ready to be executed with GCC, the
archive is:

@verbatim
http://www.zerohero.se/cross/files/m68k-amigaos/ndk-3.9-includes.tar.bz2
@end verbatim

Download and uncompress it, you'll obtain a directory called "amiga",
inside you'll find the m68k-amigaos directory, which contains the
"sys-include" directory. Rename "sys-include" to "os-include" and copy
the latter inside the GG/ directory. Now you have to complete the NDK3.9
with some files that can be found at the following address:

@verbatim
http://yamos.svn.sourceforge.net/viewvc/yamos/trunk/src/
@end verbatim

First of all, open the remote include directory and take all the files
in the following directories:

@verbatim
clib/
inline/
libraries/
mui/
proto/
@end verbatim

Then copy them into the matching subdirectories inside your
GG/os-include directory. The "mui/" subdirectory is not present inside
"os-include", so you have to create it and copy the relative file(s)
inside.

Now you need to modify a file: os-include/inline/intuition.h.

Open the above file with a text editor and search the following
instructions:

@verbatim
#ifndef NO_INLINE_STDARG
__inline APTR NewObject(struct IClass * classPtr, CONST_STRPTR classID, ULONG tagList, ...)
{
  return NewObjectA(classPtr, classID, (const struct TagItem *) &tagList);
}
@end verbatim

Replace them with these:

@verbatim
/*
#ifndef NO_INLINE_STDARG
__inline APTR NewObject(struct IClass * classPtr, CONST_STRPTR classID, ULONG tagList, ...)
{
  return NewObjectA(classPtr, classID, (const struct TagItem *) &tagList);
}
*/

#ifndef NO_INLINE_STDARG
#define NewObject(classPtr, classID, tags...) \
    ({ULONG _tags[] = {tags}; NewObjectA((classPtr), (classID), (const struct TagItem *) _tags);})
#endif
@end verbatim

At last, you get a working GCC environment on AmigaOS3.x. To compile
always remember to include the -noixemul option, that makes the creating
executable to be independent from ixemul.library. To test the
environment we give you an example of a minimal MUI window. The meaning
of the following instructions will be explained later. Save the
following example as helloMUI.c and compile everything with the
following parameters:

@verbatim
gcc helloMUI.c -o ram:helloMUI -noixemul
@end verbatim

@verbatim
/*****************************************************************************/
#include <stdio.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>
#include <proto/iffparse.h>
#include <proto/muimaster.h>
#include <libraries/mui.h>

struct IntuitionBase *IntuitionBase;
struct Library  *MUIMasterBase;

BOOL openLibs(void)
{
  if ( !(IntuitionBase=(struct IntuitionBase *) OpenLibrary("intuition.library",40)) )
    return 0;

  if ( !(MUIMasterBase=OpenLibrary("muimaster.library",19)) )
  {
    CloseLibrary((struct Library *)IntuitionBase);
    return 0;
  }

  return 1;
}

void closeLibs(void)
{
  if (IntuitionBase)
    CloseLibrary((struct Library *)IntuitionBase);

  if (MUIMasterBase)
    CloseLibrary(MUIMasterBase);
}

int main(int argc,char *argv[])
{
  Object *app, *window;

  if (!openLibs())
  {
    printf("Cannot open libs\n");
    return 0;
  }

  app = MUI_NewObject(MUIC_Application,
    MUIA_Application_Title  , "MiaApplicationMUI",
    MUIA_Application_Description, "This is my first MUI window",
    
    MUIA_Application_Window, window = MUI_NewObject(MUIC_Window,
      MUIA_Window_Title,"MyMUIWindow",
      MUIA_Window_ID , MAKE_ID('W','I','N','D'),
      MUIA_Window_RootObject, MUI_NewObject(MUIC_Group,
        MUIA_Group_Child, MUI_NewObject(MUIC_Text,
          MUIA_Text_Contents, "Hello MUI World!",
          TAG_DONE),
        TAG_DONE),
      TAG_DONE),
    TAG_DONE);

  if (!app)
  {
    printf("Cannot create application...\n");
    return 0;
  }

  DoMethod(window,MUIM_Notify,
           MUIA_Window_CloseRequest,TRUE,
           app,
           2,
           MUIM_Application_ReturnID,
           MUIV_Application_ReturnID_Quit);

  SetAttrs(window,MUIA_Window_Open,TRUE, TAG_DONE);

  {
    ULONG sigs = 0;

    while (DoMethod(app,MUIM_Application_NewInput,&sigs) != MUIV_Application_ReturnID_Quit)
    {
      if (sigs)
      {
        sigs = Wait(sigs | SIGBREAKF_CTRL_C);
        if (sigs & SIGBREAKF_CTRL_C) break;
      }
    }
  }

  SetAttrs(window,MUIA_Window_Open,FALSE, TAG_DONE);

  MUI_DisposeObject(app);

  closeLibs();
  
  return 0;
}
/****************************************************************************/         
@end verbatim

As we've already said, the result will be a file that, when executed,
will show a MUI window. Remember to install the auxiliary SDI Tools and
headers you need. A last tip: this example code is meant to be compiled
only on AmigaOS3.x. The changes required to make the code more portable
will be explained later.
@menu
* 231 Preconfigured 68k GCC environment::
@end menu

@node 231 Preconfigured 68k GCC environment
@subsection 2.3.1 Preconfigured 68k GCC environment
@anchor{#preconfigured-68k-gcc-environment}
For those who didn't have the courage to configure a GCC environment
from scratch on OS3.x, a file has been attached, which contains a ready
to use GCC environment. To install it you simply have to have a new
100MB empty hardfile in your WinUAE configuration, format it calling it
"Develop" from AmigaOS3.x on WinUAE and uncompress the lha archive with
the lha command inside of this virtual hard disk. Now, you have to
modify your s:user-startup in this way:

@verbatim
Execute Develop:ADE/ADE-Startup
@end verbatim

From the next system reboot you'll have a ready to use GCC environment
available, with other useful programs for Amiga development.

On a classic Amiga you simply have to uncompress the archive inside a
directory called "Develop", and next modify your user-startup in this
way:

@verbatim
Execute [PATH_DIRECTORY_DEVELOP]/ADE/ADE-Startup 
@end verbatim

We must say that everything you add in the ADE:os-include directory must
be done following the rules explained in the previous paragraphs.

The files inside the archives are up to date, so the installed header
files are for AmigaOS3.9 (NDK_3.9, that you'll find inside the archive).
The MUI headers belong to the 3.8 version of MUI, eventually the
os-include/libraries/mui.h file should be updated.

@node 24 TextEditors to write programs on Amiga
@section 2.4 TextEditors to write programs on Amiga
@anchor{#texteditors-to-write-programs-on-amiga}
Let's start from a general consideration: there isn't as fast and
efficient a TextEditor like CubicIDE for Amiga. It's likely the only
software you should desire that compares to other operating systems. On
Windows, Notepad++ offers something similar, but it doesn't support many
of the features of CubicIDE. Considering CubicIDE as only a TextEditor
is reductive, this software is more than a simple TextEditor, it's the
reference IDE for software development on Amiga.

IDEs like DevC++, Netbeans, XCode are really slow even on modern
machines, they are not very intuitive, although they offer more features
than CubicIDE.

By the way, it's hard to find a valid an alternative to CubicIDE outside
the Amiga platform, and it's impossible to find it inside the small
software set that this platform has inherited over the years.

Once we explained the situation about CubicIDE, it must be specified
that the price of this software is unobtainable to people without money,
the full licence is sold at 100 euros. Sometimes, CubicIDE's author
sells the license through some limited time promotion, or he offers the
license in a development version which only supports C/C++ at a lower
price, even if the overall price has never been lower than 50 euros. If
you can buy CubicIDE, our advice is to do it immediately...

You can use a lot of different TextEditors to write C sources. The valid
freeware "alternatives" available are:

@itemize
@item
BareED, BlackEditor and TuiTED on OS3.x;
@item
Annotate on OS4;
@item
BlackEditor, MorphED on MorphOS (It's an old version of CubicIDE OEM);
@item
JanoEditor on AROS;
@end itemize

All of these TextEditors offer the main features you come to expect,
such as cut&paste, configurable tab handling, undo, redo and so on...
Each of these TextEditor have some limitations, for example BareED and
TuiTED do not offer a preferences panel to the user and force the user
to act manually on icons' tooltypes, the OS4 version of Annotate is not
always stable, JanoEditor and BlackEditor don't offer any syntax
highlighting, BareED and Annotate don't handle more files in a single
session, and so on...

Now that we have underlined the main defects of the above listed
editors, the good features of these softwares are their intuitiveness
and the overall speed and efficiency. We have tested many other freeware
editors, but some of them were too complex, or they crashed the machine
if used heavily. Some examples are Vim and FreeED. The former is a very
powerful editor, but from the installation to its configuration and use,
this famous software forces the user to do a careful study of its
manual, same for FreeED and many others.

On AROS, it's gaining form a developers IDE called Murks!IDE, which can
be worth paying attention. Murks!IDE is freeware and opensource, written
in C++, and uses Zune for its graphical interface. So, this software is
totally portable to all Amiga flavors. It's good to underline that
Murks!IDE is still at the beginning of its evolution, and it's still
very limited. We suggest you try this software on AROS, or at least keep
an eye on it, take a look at its sources too.

@node 25 Amiga documentation historical books
@section 2.5 Amiga documentation: historical books
@anchor{#amiga-documentation-historical-books}
The last paper publications for developers about developing software for
Amiga are from the early 90s and are difficult to find. We must list the
main paper guides that accompanied Developers during the best period of
this platform. These books introduce and master the AmigaOS1.3/2.04
programming, so many parts are obsolete, even if they explains the
common foundations on which modern amiga flavors are based on. If you
find them, preserve them jealously, more for a historical and affective
reason than for their educational value. The most important books are
called Amiga ROM Kernel Reference Manuals, they are:

@enumerate 
@item
Libraries : explains system libraries, talks about subjects like
Intuition, BOOPSI, GadTools, ASL, Workbench, Icon, how libraries are
made, ports, messages, semaphores, etc...;

@item
Devices: talks about the Commodore's few released devices like
serial.device, parallel.device, audio.device, clipboard.device, and it
contains the first documentation about the IFF format;

@item
Include & Autodocs : it's mainly a printed version of autodocs and Amiga
includes (version 2.04);

@end enumerate

There are also:

@enumerate 4
@item
Amiga Hardware Reference Manual: explains old Amiga platform's OCS and
ECS chipsets in detail.

@item
AmigaDOS Manual: it's the only official documentation from Commdore
about AmigaDOS, processes and Filesystem;

@item
Amiga Intuition Reference Manual: it's written by the original fathers
of the Amiga, and it's similar to the Style Guide (see below);

@end enumerate

And:

@enumerate 7
@item
Amiga Programmer's Guide to ARexx: ARexx programming manual;

@item
User Interface Style Guide: a guide to build graphical interfaces
following some Amiga philosophies. It talks about Workbench, ARexx and
Preferences too, although in a introductory way.

@item
Guru Book: talks about AmigaDOS, filesystem, Shell, 68k assembly
programming on Amiga, the use of C language using SAS-C compiler;

@end enumerate

Basically, the most educational book of this era is Libraries, followed
by AmigaDOS Manual and Style Guide. The other books deal with outdated
parts of the Amiga system and so reading them could be misleading for
those who want to start Amiga programming. So, it's always a good idea
to have Libraries, AmigaDOS Manual and Style Guide books available.
@menu
* 251 Amiga documentation the electronic format::
* 252 Autodoc or Robodoc::
@end menu

@node 251 Amiga documentation the electronic format
@subsection 2.5.1 Amiga documentation: the electronic format
@anchor{#amiga-documentation-the-electronic-format}
Most of the Amiga documentation for the Amiga operating system and third
party APIs is distributed in electronic format. Even the Amiga ROM
Kernel Reference Manuals can be found in electronic format on the
developers CD. There are articles completing the RKRM which are called
Amiga Mail volume 2, they talk about changes made to AmigaOS 3.0 and are
available in electronic format, usually inside the Development CD (not
free). These articles explain the old AGA chipset, datatypes, some
BOOPSI classes introduced in AmigaOS3.0, the debug, TCP/IP etc... on
Amiga. They are articles from 1993/1994 and so are a bit outdated.
Documentation about AmigaOS 3.5 can be found inside the last Developer
CD, AmigaOS 3.9 docs is inside the archive called NDK3.9.

Every new flavor of Amiga is accompanied with a series of electronic
documents that explains the main differences between every amiga flavor
and AmigaOS3.x.

Regarding the most common electronic format for developers
documentation, they are AutoDoc, AmigaGuide, HTML and PDF. The last two
are easily readable on platforms other than Amiga, AmigaGuide is simply
an hypertext format that the guides of Amiga programs were distributed
with. We'll talk about AutoDoc here.

@node 252 Autodoc or Robodoc
@subsection 2.5.2 Autodoc or Robodoc
@anchor{#autodoc-or-robodoc}
Autodoc is an ASCII text format written with a particular syntax. In the
Amiga, there are readers that allow us to read an autodoc as if it were
a hypertext, although these programs are handled only with the
particular text formatting inside an AutoDoc. An AutoDoc file is usually
the output of a particular program that can extract comments from a
source code file and translate them into AutoDoc. Obviously, comments
must be written following particular rules to have them converted into
one or more AutoDocs.

The idea of AutoDoc is from Commodore's times, they thought about a way
to maintain API documentation up to date without forcing the programmer
to update API documents as well as the API code. So a program called
"AutoDoc" was born and released with the official documentation of the
first versions of AmigaOS.

Luckily there is an open alternative for all Amiga flavors: Robodoc.

(You can find it on Aminet for AmigaOS3.x, inside our Develop_XX.lha and
DevAROS_XX.zip files, with the reader AutoDocReader, already configured
to read system and MUI AutoDocs).

Robodoc follows the same idea of the Commodore's program, adding new
interesting features, for which we introduce you to the documentation
attached to the program itself. Robodoc documentation explains the
AutoDoc standard and how to write comments for your code.

All of the documentation of the Amiga and MUI APIs are in AutoDoc
format, so we suggest you get familiar with these files and choose a
program to handle them that suits your needs, such as AutoDocReader.

@node 26 Debugging on Amiga how to find errors in our programs
@section 2.6 Debugging on Amiga: how to find errors in our programs
@anchor{#debugging-on-amiga-how-to-find-errors-in-our-programs}
Introducing the subject of searching for errors in programs to those who
have no idea of how an Amiga compatible system is structured requires
some knowledge about the system on which we will program. For this
reason we'll introduce some basic concepts of AmigaOS, postponing the
rest to the following chapter.
@menu
* 261 Amiga a system without memory protection::
* 262 Enforcer and Amiga compatible systems::
* 263 MungWall / MemGuard / WipeOut::
* 264 Sashimi and the serial port::
* 265 AmigaOS4 GrimReaper and addr2line::
@end menu

@node 261 Amiga a system without memory protection
@subsection 2.6.1 Amiga: a system without memory protection
@anchor{#amiga-a-system-without-memory-protection}
An Amiga compatible OS doesn't have memory protection due to its own
nature. You surely already know what "memory protection" is, but it's
better to explain this concept here:

Memory protection is a feature of all modern operating systems.
Basically a memory protected system executes each program giving it a
portion of memory, which is shown to the program process as if it were
all the memory available in the machine. The executed program handles
this memory as usual, nevertheless it's unable to access other memory
portions, because the system itself prevents it from being aware of
them. To reach this goal, the system uses some parts of the CPU (like
the MMU), so to have memory protection in a system, we need the
underlying hardware support.

At its beginning, the Amiga system used a Motorola 68000 processor,
which was a processor lacking MMU and other parts that every modern CPU
of our century is equipped with. Additionally, the project of the Amiga
platform was born with a console/computer thing in mind, so the original
team gave more attention to the multimedia features of the platform
instead of protection techniques of the operating system. Keep in mind
that we are referring to the early 80s, when consoles and home computers
ruled the market, these machines had very poor power and resources and
so they couldn't face slow downs caused by protection techniques, even
if they were not supported by the underlying hardware.

For these reasons, the Amiga original system allows a process to read
and write datas onto other processes' memory, and many Amiga APIs (such
as Hook and IPC support, used everywhere) uses this opportunity to get
better performance. Obviously, if a program contains an error, the wrong
writing of a memory area causes unexpected situations that lead to the
so hated Amiga crashes. Even the amiga system parts might be involved in
an abnormal situation, at least in the original Amiga system, and this
can lead to a freeze that forces the user to reboot the machine. In
other words, while an error in a process inside a protected memory
system involves only the process itself, the same error on an Amiga
system might involve other processes and the entire system.

@node 262 Enforcer and Amiga compatible systems
@subsection 2.6.2 Enforcer and Amiga compatible systems
@anchor{#enforcer-and-amiga-compatible-systems}
As we previously explained, an Amiga system doesn't have memory
protection and if a software bug occurs we would notice it only when the
system freezes. Anyway, the Amiga platform, since its first version
based on Motorola 68000, has evolved in a short time, until using more
modern processors like 68030 on Amiga 3000 and many other expansion
boards sold in the early 90s. Even the operating system evolved from its
first 1.x version to the more stable 2.x, anyway no major work has been
done on memory protection, in order to maintain backward compatibility
with old software and machines. With the arrival of MMU equipped 68030
processors, at least some debug software was developed that used this
hardware feature, Enforcer was the most used.

Enforcer uses MMU to detect reading and writing done by an Amiga program
during execution. The main task of Enforcer is to report every attempt
to read/write memory regions which should be accessible only from system
modules. Furthermore, this debug tool blocks every attempt to read/write
nonexistent memory areas. If a program is going to read a "protected"
area from Enforcer, it will catch the read attempt, it will show what
happened to the user (signaling the, so called "Enforcer Hit") and will
pass zero instead of the real memory address to the bugged program. In
the case of a wrong writing attempt, Enforcer will report this action
the the user.

In Amiga compatible systems, like MorphOS, AROS and AmigaOS4 we can find
typical protections done by Enforcer on AmigaOS3.x already implemented.
Anyway, it's good to advise you that such features are available in AROS
only in recent times, with the new 64bit kernel, and we hope that such
features will be inherited to the 32 bit kernel soon. Regarding
AmigaOS4, besides the usual Enforcer protections, the free memory areas,
stack memory areas of every program and freed memory areas are protected
from following illegal access too.

If you are developing through WinUAE, there is an ad hoc Enforcer
version called winuaeenforcer, inside the emulator's archive.

@node 263 MungWall / MemGuard / WipeOut
@subsection 2.6.3 MungWall / MemGuard / WipeOut
@anchor{#mungwall-memguard-wipeout}
We've already pointed out that a memory protection for free and freed
memory areas is already being contemplated in AmigaOS4. Handling of
these memory areas could be controlled before the arrival of this Amiga
compatible system, using a special debug tool called MungWall. Although
AmigaOS4 already protects these parts, the use of a tool such as
MungWall is useful to find memory handling problems inside our programs,
even in this Amiga compatible system. The counterpart of MungWall on
AmigaOS4 is MemGuard, in MorphOS another alternative called WipeOut
should work. AROS has MungWall's features already built in, and if this
Amiga system has been compiled with debug options (all nightly builds
are compiled this way) such features can be used. Let's show how
MungWall works. MungWall has two main tasks:

@itemize
@item
Mung: to mark all free/freed/uninitialized memory areas with special odd
values;

@item
Wall: to allocate a handful of memory before and after every allocation
done by a program. Such limited areas are marked with a value and are
enriched with some information to perform tests. Such limited areas can
be compared to "walls";

@end itemize

Regarding the first MungWall task, first of all the marking of
free/freed/uninitialized memory areas with an odd value should bring
serious problems to programs containing errors. Indeed, there are a lot
of chances that the reading (unexpected/wrong) of these values instead
of NULL will cause a visible abnormal behavior of bugged programs.
Somehow, these programs are put in a stress condition by MungWall, in
order to emphasize wrong uses of memory areas. The second task of
MungWall allows us to understand if our allocations/deallocations are
carried out in the proper way. More precisely, if a program were to free
up more memory than allocated, MungWall will report this incident.
MungWall's tasks are intrinsically linked to the work of Enforcer, in
fact, if a program read a MungWall set odd value or a "wall" value, it's
likely that the program would generate an Enforcer Hit, and all of this
would allow us to identify more easily the error in our program.

Our friend Bernd Roesch we also noted:

On AmigaOS3.x there is gccfindhit on Aminet, to find the sourceline
where the hit came. It's similar to OS4 addr2line [see paraghraph
2.6.5]. On 68k, programs need to be built with the -g option.

To get segment offsets you need to start segtracker during boot and
(winuae)Enforcer outout print out segment offset and large stack
backtrace.

[N.B.: Almost all programs AmigaOS runs are loaded by the system as
segments using the LoadSeg()'s dos.library call. So most code in memory
is structured as "segment list". It's possible to get corrupted segment
lists if something overriding the standard LoadSeg() not using the
correct seglist format, or something is trashing memory on your system.
Using SegTracker while is running Enforcer, it will try to trace back
into the segment lists of the task causing the hit.]

You can use a graphical debugger such as Barfly(on Aminet) to single
step your program.

Before you start your program type in a shell (winuae) Enforcer 1 then
an illegal mem access will give an illegal address access requester. But
before you jump into debugger, it's better to set (winuae) Enforcer 0 to
switch off the illegal address stop mode, because debuggers also like to
access illegal addresses. The mode can always at any time be changed.
Now you can choose on barfly post mortem and you can grab the task that
is stopped by the Guru requester and single step it.

@node 264 Sashimi and the serial port
@subsection 2.6.4 Sashimi and the serial port
@anchor{#sashimi-and-the-serial-port}
Most of the debug tools on Amiga like Enforcer and MungWall route their
output to the serial port, this means that we should have a device,
usually another connected computer, which we can intercept debug
information with. Anyway, not all people have a debug "station", for
this reason we use Sashimi, a tool to route to the command line
interface all the information that goes through the serial port. Sashimi
allows us to view all output routed to the serial port, but it also
allows us to save the output of a file, in order to analyze it more
carefully. Further information on Sashimi is available in the
documentation of this tool.

Not closely tied to Sashimi is the use of functions that route their
output to the serial port, such as kprintf(). The syntax of kprintf() is
identical to that of printf(), so you shouldn't have problems. Every
flavor of Amiga has their unique way to provide the facility of sending
strings to the serial port, for this reason we should use conditional
code that allows us to use a macro in every cases:

@verbatim
#ifdef __amigaos4__
    #define __KPRINTF DebugPrintF
#else
    #define __KPRINTF kprintf
#endif

#ifdef _DBUG
    #define KPRINTF __KPRINTF
#else
    #define KPRINTF if (0) __KPRINTF
#endif
@end verbatim

Such code, that must be included in every file to debug, allows us to
use the KPRINT() macro in every flavor of Amiga. More precisely, before
this code, if we want to "activate" our serial output, we should add:

@verbatim
#define _DBUG
@end verbatim

in order to send through KPRINTF() the debug information that we
consider useful. If you don't define _DBUG symbol, the conditional code
lines will replace all KPRINTF() calls with empty lines. Anyway, it's
good to underline that this way of sending output to the serial port is
only one example. You must keep in mind that debug functions like
kprintf() are not automatically available, and you often will have to
use the respective libraries containing such functions.

In both the Develop_XX.lha archive and the DevAROS_XX.zip distribution
you can launch preconfigured Sashimi in order to save your own output in
a file inside the Debug-Output directory. To get this result you have to
execute the Debug-Startup script, inside the Debug/ directory for
Develop_XX.lha and in S: for DevAros_XX.zip.

@node 265 AmigaOS4 GrimReaper and addr2line
@subsection 2.6.5 AmigaOS4, GrimReaper and addr2line
@anchor{#amigaos4-grimreaper-and-addr2line}
AmigaOS4 offers the chance to use a popular UNIX tool to develop native
programs: addr2line. To use addr2line we first have to compile our
program with gcc, using the -ggdb option. In this way the resulting
executable will be full of additional information that will be shown if
the program crashes. As the AmigaOS4 users know, a crash in the system
involves the execution of a particular tool called Grim Reaper, which
assists the user during the abnormal behavior of a program in a friendly
way, providing a lot of information regarding the error that occured.
Anyway, such information is not available if the program that caused the
error wasn't compiled with the -ggdb option. Only if it is compiled in
this way, do we have the chance to find the exact point our program has
crashed. After the -ggdb compiled program has crashed, we have to act as
follow:

@enumerate 
@item
Click on "Other" button on GrimReaper;
@item
Click on "Stack Trace" page;
@item
Click on "Build Stack Trace" button;
@end enumerate

Now a list of our program's functions will be shown. The uppermost shown
function in the list is the one that has produced the problem in the
crashed program. The following items refers to function's steps running
at the time of the crash. Each of these items has the following form:

@verbatim
function_name()+offset1 (section sectionNumber @ offset2)
@end verbatim

For example, the MUI3.9's Slidorama demo in AmigaOS4 crashes at this
point:

@verbatim
muimaster.library:CustomClassDispatcher()+0x8C (section 1 @0x992c)
@end verbatim

To understand what offset2 is related to you simply need to use the
debug tool, included in AmigaOS4, called addr2line in such way:

@verbatim
ppc-amigaos-addr2line -e program_name -f offset2
@end verbatim

In our example:

@verbatim
ppc-amigaos-addr2line -e Slidorama -f 0x992c
@end verbatim

After all, the offset1 that we have considered is useful if we want to
disassemble the object code of our program. If you need to do such a
thing we suggest that you read the appropriate guide inside the
AmigaOS4's SDK.

@node Basic knowledge for Amiga programming
@chapter Basic knowledge for Amiga programming
@anchor{#basic-knowledge-for-amiga-programming}
"AmigaOS is a microkernel message-passing design, with better response
time and performance than any other readily available PC operating
system: including MINIX, OS/2, Windows, MacOS, Linux, UNIX, and
@emph{certainly} MS-DOS.

The microkernel design has proven invaluable. Things like new file
systems that are normally available only from the vendor are hobbyist
products on the Amiga. Device drivers are simply shared libraries and
tasks with specific entry points and message ports. So are file systems,
the window system, and so on. It's a WONDERFUL design, and validates
everything that people have been saying about microkernels. Yes, it
takes more work to get them off the ground than a coroutine based
macrokernel like UNIX, but the versatility pays you back many times
over."

Peter Da Silva, The Tanenbaum-Torvalds Debate, 07/02/1992
@menu
* 31 Excursus discussion on Amiga OS::
* 32 Inside AmigaOS::
* 33 Using Amiga functions::
* 34 Differences between various Amiga OS types::
* 35 AROS variable passing::
* 36 Programs tasks and processes::
@end menu

@node 31 Excursus discussion on Amiga OS
@section 3.1 Excursus (discussion) on Amiga OS
@anchor{#excursus-discussion-on-amiga-os}
Introducing programming concepts starting from scratch is very hard: you
are never sure if a concept has been explained in a clear way and if
it's better to discuss a particular theory before or after another one.
Let's try to proceed by applying some base rules for the understanding
of this and following chapters:

@itemize
@item
To know the basics of C language;
@item
To know the basics of operating systems;
@end itemize

All Amiga APIs are designed to be used with C language, or even 68k
assembly if on OS3.x, but since we are in 21st century it's better to
focus on the most famous medium-level language that everyone has heard
at least talked about once. Assuming that you have mastery of concepts
such as functions, pointers, structures, casting, API (Application
Programming Interface) etc... Let's introduce some amiga related
concepts.

@node 32 Inside AmigaOS
@section 3.2 Inside AmigaOS
@anchor{#inside-amigaos}
All Amiga flavors have AmigaOS3.1 as their common root, so a little look
to the 90s of AmigaOS is needed. AmigaOS is a monouser multiprogrammed
operating system, mainly built on three important components:

@itemize
@item
An atypical microkernel called MultitaskingExecutive (Exec);
@item
AmigaDOS;
@item
Intuition;
@end itemize

And there are other more or less relevant modules.

Exec is AmigaOS's microkernel. Exec's job is to handle the whole system
and its resources, running programs (called tasks), message ports and
many other things.

AmigaDOS is the module that handles AmigaOS's I/O and offers:

@itemize
@item
A command line interface;
@item
Processes: the tasks that can use particular functions;
@item
Filesystem related APIs, which organizes datas on storage devices. On
AmigaOS a filesystem is a process, used by applications to communicate
through message exchange.
@end itemize

Intuition provides AmigaOS graphical objects to interact with the user.
Although AmigaOS's graphical interface has intuition as its core, there
are other tools, built on intuition, that allow you to build GUIs
quickly:

@itemize
@item
GadTools, should ease the making of new gadgets and menus;
@item
ASL, allows an easier making of Requesters;
@item
BOOPSI, allows you to extend and improve Intuition through the object
oriented technique (OOP). BOOPSI is essentially a collection of classes
to build graphical objects;
@item
Workbench, a system program that uses graphical symbols, called icons,
useful to interact with the filesystem offered by AmigaOS;
@end itemize

AmigaOS is, more generally, organized following an overlapped modules
hierarchy; starting from the lower modules we have:

@itemize
@item
resource: a collection of low level functions that allow direct access
to the system hardware;
@item
device: a collection of functions that control character and block I/O
devices and, more generally, all available hardware using AmigaOS IPC
tecnique;
@item
library: collection of functions for different uses;
@item
system programs;
@end itemize

Libraries are organized according to a hierarchy of levels, following
the set of functions that they collect; in fact there are groups of
functions that work in a lower level than other groups. Devices and
resources don't have the same organization, because each of them handles
the devices for which it was designed. Libraries are used for most of
the tasks to be performed, devices and resources are only used in
particular cases. Such design makes AmigaOS a modular Operating System,
giving the opportunity to extend and update its features without
interfering with existing applications.

@node 33 Using Amiga functions
@section 3.3 Using Amiga functions
@anchor{#using-amiga-functions}
Every program that uses the functions of an operating system, here
AmigaOS and spin-offs, must be able to access such APIs. On AmigaOS,
using library functions, devices and so on, means making available such
modules to the application. For this reason we need the opening process
of one or more libraries at the beginning of every program.

On AmigaOS there is always a library opened: exec.library, which offers
the functions that exec provides to the programmer. For example, if we
want to create a requester, using the EasyStruct structure, defined in
<intuition/intuition.h> :

@verbatim
struct EasyStruct {
    ULONG es_StructSize;    /* structure dimentsion                */
    ULONG es_Flags;         /* usually set to 0                    */
    UBYTE *es_Title;        /* requester's title                   */
    UBYTE *es_TextFormat;   /* string inside the requester         */
    UBYTE *es_GadgetFormat; /* string inside the close button      */
};
@end verbatim

and the Intuition's EasyRequestArgs() function, declared in this way:

@verbatim
LONG EasyRequestArgs(struct Window *window,               /* window which the  */
                                                          /* requester belongs */
                                                          /* to;               */
                              
                     CONST struct EasyStruct *easyStruct, /* requester to      */
                                                          /* open;             */
                     LONG *idcmpPtr,                      /* a particular      */
                                                          /* event that closes */
                                                          /* the requester     */
                     CONST APTR args );                   /* optional          */
                                                          /* arguments...;     */
@end verbatim

we have to open intuition.library first. To perform this task Exec's
function calls OpenLibrary(). When we close the program we need to close
all the libraries we opened at the beginning of the program itself, so
we use CloseLibrary() to do this. Summarizing, in our example we'll have
a situation like this:

@verbatim
/*****************************************************************************/
#include <stdio.h>
#include <proto/exec.h>
#include <proto/intuition.h>

struct IntuitionBase *IntuitionBase;

int main(void)
{
  IntuitionBase=(struct IntuitionBase *) OpenLibrary("intuition.library",39);

  if (!IntuitionBase)
    return 0;
  
  struct EasyStruct requester;
  
  requester.es_StructSize   = sizeof(struct EasyStruct);
  requester.es_Flags        = 0;
  requester.es_Title        = "Example requester";
  requester.es_GadgetFormat = "Exit";
  requester.es_TextFormat   = "This is a try!";
  EasyRequestArgs(NULL, &requester, NULL, NULL);

  if (IntuitionBase)
    CloseLibrary((struct Library *)IntuitionBase);
  
  return 0;
}
/*****************************************************************************/
@end verbatim

To use library functions, a program needs a pointer to the library's
data area, stored somewhere in memory, such area is called "Base". The
base of an OpenLibrary() returned library is nothing more than a
structure having its own name (to know the name of the Base of a
function, see header protos of the same functions). OpenLibrary() takes
the name of the library to open and its minimum version as arguments. If
the system cannot find the library we requested or find a previous
version that is specified, OpenLibrary() would return NULL.

As we said, the first parameter of OpenLibrary() is the name of the
library, such library might already be in memory, in this case
OpenLibrary() will open the resident library, anyway, our library might
not yet be resident in memory. In this case, OpenLibrary() will refer to
the "LIBS:" device (which is usually an assign to Sys:Libs/) to find the
library, load it into memory and open it. If you want to specify a
different path than "LIBS:", you'll have to insert the path with the
name of the library as first parameter of OpenLibrary(), for example:

@verbatim
OpenLibrary("sys:foo/bar.library", 0);
@end verbatim

In this way we open any version of bar.library resident in sys:foo/.
Although AmigaOS id case insensitive, Exec's functions are not case
insensitive, so you need to be careful with uppercase and lowercase
letters of names specified to OpenLibrary().

The data area of a library is called Base because it specifies the lower
part of the memory reserved to a particular library. Before the Base, or
if we want "above" the base, there is another structure called functions
table. Functions table contains references to all the functions a
library provides. The program essentially browses the functions table to
find the one which was invoked. After being sure to have a pointer to
the Base of the library we are interested in, we can use the functions
offered by the library. It's important to note that AmigaOS needs the
programmer to expressly close the library, to perform it the
CloseLibrary() function is used.

Due to the number of libraries used normally in a program, it's common
practice to put the processes of opening and closing libraries inside
two different functions, which respectively open and close all the
libraries we'll use in our program.
@menu
* 331 AmigaOS4 interfaces and Amiga OS's preprocessor symbols::
@end menu

@node 331 AmigaOS4 interfaces and Amiga OS's preprocessor symbols
@subsection 3.3.1 AmigaOS4 interfaces and Amiga OS's preprocessor
symbols.
@anchor{#amigaos4-interfaces-and-amiga-oss-preprocessor-symbols.}
AmigaOS4 introduces some changes relating the access of library
functions. In the previous paragraph we learned how a program needs to
get the Base of a library to access its functions. Using the Base the
program gains the capability to access the table of functions of the
corresponding library. On AmigaOS4 a new version of shared libraries has
been introduced, called "interfaces". On AmigaOS4 it is still not
possible to access directly the library functions simply opening it with
OpenLibrary(), you'll need to specify first which interface contains the
functions we'll refer to. Basic functions of a library are pointed to
from the "main" interface, on OS4 even the AmigaOS3.x APIs are
accessible through this interface. So, while on AmigaOS3.x we only
needed to get access to the Base of a function with OpenLibrary(), on
AmigaOS4 we'll also need to access the interface of the library, "main"
in our case. To obtain all these things there are two new functions in
ExecSG (the new AmigaOS4 kernel), called GetInterface() and
DropInterface(), used respectively to open and close an interface. The
previous paragraph's example become the following:

@verbatim
/*****************************************************************************/
#include <proto/exec.h>
#include <proto/intuition.h>

struct Library *IntuitionBase;
struct IntuitionIFace *IIntuition;

int main(void)
{
  IntuitionBase= (struct Library *) IExec->OpenLibrary("intuition.library",39);

  if (!IntuitionBase)
    return 0;
  
  IIntuition = (struct IntuitionIFace *) IExec->GetInterface(IntuitionBase, 
                                 "main", 1, NULL);
  
  if (!IIntuition)
  {
    IExec->CloseLibrary((struct Library *)IntuitionBase);
    return 0; 
  }             
  
  struct EasyStruct requester;
  
  requester.es_StructSize   = sizeof(struct EasyStruct);
  requester.es_Flags        = 0;
  requester.es_Title        = "Example requester";
  requester.es_GadgetFormat = "Exit";
  requester.es_TextFormat   = "This is a try!";
  IIntuition->EasyRequestArgs(NULL, &requester, NULL, NULL);
  
  
  IExec->DropInterface((struct Interface *)IIntuition);

  if (IntuitionBase)
    IExec->CloseLibrary((struct Library *)IntuitionBase);
    
  return 0;
}
/*****************************************************************************/
@end verbatim

First of all, it's good to notice how the name of Base structure is not
referring to a given library anymore, except for rare cases (see the
relating documentation). As for exec.library, even the IExec interface
for this library is already open and available to the programmer. Every
function is now invocable only explicitly by a direct access to the
relating interface, such as IIntuition->EasyRequestArgs(). This makes it
difficult to keep compatibility with other Amiga flavors, so you can use
two preprocessor's symbols __USE__INLINE__ and __USE_BASETYPE__, which
allows us to keep the AmigaOS3.x function syntax and to use specific
names for libraries' Bases. Our example, rewritten in a portable manner
becomes:

@verbatim
/*****************************************************************************/
#ifdef __amigaos4__
#define __USE_INLINE__
#define __USE_BASETYPE__
#endif
#include <proto/exec.h>
#include <proto/intuition.h>

struct IntuitionBase *IntuitionBase;
struct IntuitionIFace *IIntuition;

int main(void)
{
  IntuitionBase= (struct IntuitionBase *) OpenLibrary("intuition.library",39);

  if (!IntuitionBase)
    return 0;
  
  #ifdef __amigaos4__
  IIntuition = (struct IntuitionIFace *) GetInterface(IntuitionBase,  
                            "main", 1, NULL);
  
  if (!IIntuition)
  {
    CloseLibrary((struct Library *)IntuitionBase);
    return 0; 
  } 
  #endif      
  
  
  struct EasyStruct requester;
  
  requester.es_StructSize   = sizeof(struct EasyStruct);
  requester.es_Flags        = 0;
  requester.es_Title        = "Example requester";
  requester.es_GadgetFormat = "Exit";
  requester.es_TextFormat   = "This is a try!";
  EasyRequestArgs(NULL, &requester, NULL, NULL);
  
  
  #ifdef __amigaos4__
  DropInterface((struct Interface *)IIntuition);
  #endif
  
  if (IntuitionBase)
    CloseLibrary((struct Library *)IntuitionBase);
    
  return 0;
}
/*****************************************************************************/
@end verbatim

As you can see, we also used the conditional compilation directives, so
if the source is not being compiled on AmigaOS4, calls to GetInterface()
and DropInterface() would be ignored by the compiler. The symbols for
the four amiga systems, of our example use the conditional code #id
defined() are:

@verbatim
AmigaOS3.x :  #if defined (__AMIGA__) && !defined (__PPC__)
AmigaOS4   :  #if defined (__amigaos4__)
MorphOS    :  #if defined (__MORPHOS__)
AROS       :  #if defined (__AROS__)
@end verbatim

To be honest, we could omit the following conditional code:

@verbatim
#ifdef __amigaos4__
#define __USE_INLINE__
#define __USE_BASETYPE__
#endif
@end verbatim

In this case we should use __USE_INLINE__ and __USE_BASETYPE__ symbols
using the -D option of GCC, in other terms:

gcc mySource.c -o myExecutable -D__USE_INLINE_ -D__USE_BASETYPE_

@node 34 Differences between various Amiga OS types
@section 3.4 Differences between various Amiga OS types
@anchor{#differences-between-various-amiga-os-types}
As you surely know, the established range of values to represent integer
and decimal variables changes depending on the architecture an operating
system is running on. Since its first version, AmigaOS defines also
other types to declare variables, which reside in the header file
exec/types.h. It's important to notice that such types are dependent
from the architecture in which AmigaOS has born, in other words the
Motorola 68000 processor, which is a 16/32bit CPU. With the version 4 of
AmigaOS and the migration to the PowerPC architecture, more support
types were introduced, the same applies to AROS, which, as you know,
runs on numerous different architectures. AmigaOS3.x types were
maintained for compatibility on both systems, but the relating
documentation encourages us to use new types for the future software to
be developed.

We must consider that AmigaOS uses a particular type, APTR, if we know
that the return value of a function is a generic pointer. Anyway in many
cases we do not have such a certainty, so, in similar cases, it's common
to use ULONG as return value, which represents a 32 bit unsigned
integer. This trick works pretty well for 32 bit architectures, while
it's totally incompatible with 64 bit and later ones. The reason is
pretty trivial: in the case of pointers larger than 32bit there would be
a truncation and thus invalid addresses. In the case of AmigaOS4 and
MorphOS for modern architectures there isn't such a problem, because
both systems still use 32 bit addresses. In the AmigaOS4 case it's
recommended to use a new type, uint32, to avoid any ambiguity regarding
the size of the type which is being used. Regarding AROS, the truncation
problem is a real situation and easily occurs if you're writing an AROS
x86_64 compatible program. For this reason, AROS introduces another new
type, IPTR, which is the only portable way to represent a variable that
can keep both an integer value as a pointer of any size.

Even MorphOS supports IPTR type.

In the case of portable applications from one Amiga flavor to another,
it's good to employ a similar conditional code:

@verbatim
#if !defined(__AROS__) || !defined(__MORPHOS__)
    #ifdef __amigaos4__
    #define IPTR uint32
    #else
    #define IPTR ULONG
    #endif 
#endif
@end verbatim

and using IPTR through it.

@node 35 AROS variable passing
@section 3.5 AROS, variable passing
@anchor{#aros-variable-passing}
Some AmigaOS functions often requires variable parameters passing, using
program stack for their manipulations. As we said, AmigaOS assigns a
range of types that ranges from 8bit integers to 64bit integers in
modern flavors. Anyway, some modern CPUs don't allow such handling with
all variable types. For example, some CPUs allow us to handle only some
kind of variable on the stack, other types are accepted only through CPU
registers, other CPUs allow variable passing through registers only and
so on. To solve such issues, AROS uses a particular symbol, STACKED,
which must be put before variable declarations and structures fields to
be passed to Amiga functions (such as BOOPSI messages that will be
explained later). For portable software, it's good to use such
conditional code:

@verbatim
#ifndef __AROS__
#define STACKED
#endif          
@end verbatim

In order to use STACKED without interference with AmigaOS3.x, AmigaOS4
and MorphOS.

For completeness, it's important to specify the STACK symbol too. In
many AROS declarations you can find such expressions:

@verbatim
STACKULONG foo;

STACKIPTR pointer;
@end verbatim

These expressions, although they have the same goal of STACKED, they are
not a synonym, in fact:

@verbatim
STACKULONG foo;
@end verbatim

and

@verbatim
STACKED ULONG bar;
@end verbatim

Doesn't declare same size variables on AROS, it depends on which
architecture we are running this Amiga flavor on. For example, on AROS
x86-64 STACKULONG declares a 64bit integer, while STACKED ULONG is a a
32bit integer.

STACK symbol is even supported by MorphOS.

@node 36 Programs tasks and processes
@section 3.6 Programs, tasks and processes
@anchor{#programs-tasks-and-processes}
We often read that a process is a running program, on Amiga it's better
to make some distinctions. A running Amiga program is called a "Task". A
task is able to invoke almost all the functions that the Amiga operating
system provides, except some, including those offered by AmigaDOS. The
only way to execute such functions unavailable to a simple task is to
invoke them through a process. A process on Amiga is a special Task,
able to use all functions that the operating system provides. The
difference between Tasks and Processes must be searched in the AmigaOS
history, and we are not going to go deeper in this subject here, we only
have to know that when we launch our program, usually it will be a
process. Essentially a process on AmigaOS is a task enriched with other
information that allows it to also use other resources, among which are
some system functions. A task and a process are identified by pointers
to structures: the Task structure and the Process structure. What
concerns us here is knowing that a process (struct Process) contains
within it:

@itemize
@item
a reference to a task used by Exec to identify it (struct Task pr_Task);

@item
a reference to a message port (struct MsgPort pr_MsgPort) see chapter
5.2

@end itemize

@node Interaction between programs and users on Amiga GUI
@chapter Interaction between programs and users on Amiga: GUI
@anchor{#interaction-between-programs-and-users-on-amiga-gui}
@emph{"Neither PC, nor Mac, nor Amiga have invented the concept of
mouse-driven GUI, but in 1985 Amiga offered certainly its most
interesting and complete implementation."} Massimo Tantignone,
"VisualPrefs and the Amiga GUI: tips and tricks", ??/01/2000

@emph{"Design beautiful Gadgets, Menus, Requesters. Think simplicity and
elegance. Always remember the fourth grader, the sophisticated user, and
the poor soul who is terrified of breaking the machine."} Robert J.
Mical, Amiga Intuition Reference Manual

@emph{"In my opinion, neither a programmer nor the operating system
shall define how GUI elements shall look. The only person who knows the
best choice is the user of an application. That's what MUI tries to
accomplish. The user of a MUI application can decide if he wants to have
standard system scrollers or absolutely fancy designed knobs sliding on
a stony background pattern."} Stefan Stuntz, comp.sys.amiga.programmer,
13/08/1993

@emph{"[...]If you had read the MUI docs more carefully, you would have
noticed that all MUI classes are subclasses of rootclass (since every
BOOPSI object is a subclass of rootclass)[...]" "[...]Commodore
implemented a gadget class and an image class (with several sub classes)
and instances of these (and only these) classes are sometimes called by
input.device.[...]" "[...]MUI classes are not called by input.device and
do not affect system performance[...]"} Stefan Stuntz,
comp.sys.amiga.programmer, 04/09/1993

@emph{"From a programmers point of view alone, MUI is heaven. Everything
is so much easier than using gadtools. MUI isn't slow, either."}
Hans-Joerg Frieden, comp.sys.amiga.programmer, 02/04/1994

@emph{"I like MUI for its configurability and ease of programming, and
hence I use it. [...]GadTools gadgets suck. The can't resize without
being removed first, and that something I don't like. Also, you have to
control the keyboard, too, which is in my opinion a waste. Additionally,
most people use GadTools with a hardcoded font and position, because
gadtools (and even BOOPSI without a layout engine) encourages fixed
coordinates. There is no way to use the font-size directly to position
your gadgets.[...] I do not like the MAGIC prefix, either. But then, I
don't judge a program by its name, or else I would consider the BOOPSI
concept a VERY bad one."} Hans-Joerg Frieden, comp.sys.amiga.programmer,
11/04/1994

@emph{"[...]Its imperative for it (MUI) to be as flexible and as
extendable as possible."} Stephan Stunz, comp.sys.amiga.programmer,
14/04/1994
@menu
* 41 Tools to build a graphical interface GUI on Amiga::
* 42 BOOPSI and MUI some history::
* 43 BOOPSI programming::
* 44 From BOOPSI to MUI::
* 45 MUI Notifications::
* 46 At the heart of a BOOPSI/MUI class the Dispatcher::
* 47 DoSuperNew and variadic functions::
* 48 MUI notification performed using public methods of private classes::
* 49 MUI synchronizations MUIM_Application_PushMethod and MUIM_Application_KillPushMethod::
* 410 MUI a bit more about hooks private methods and notifications::
* 411 MUI macro shortcuts::
@end menu

@node 41 Tools to build a graphical interface GUI on Amiga
@section 4.1 Tools to build a graphical interface (GUI) on Amiga
@anchor{#tools-to-build-a-graphical-interface-gui-on-amiga}
A modern user application offers its features through the use of a
graphical interface. Nowadays, a "high level" programmer (he who
develops programs without accessing low level resources) should only use
features offered by BOOPSI, and use GadTools and Intuition functions
only if there is no viable high-level alternative, ready-made BOOPSI
classes, that is. Using GadTools functions or other similar primitives
entails a waste of energy to write the code, and the final result in
many cases may not be consistent with the rest of the Amiga GUI. In
order to use BOOPSI, some concepts about object-oriented programming
(OOP from now on) must be clear.
@menu
* 411 OOP primer::
@end menu

@node 411 OOP primer
@subsection 4.1.1 OOP primer
@anchor{#oop-primer}
This paragraph is addressed to those being not confortable with OOP;
those already familiar with concepts such as instance, object and
inheritance, can skip this paragraph.

OOP is based on concepts like classes and objects, which are very close
to the way of thinking in human beings.

Consider for example how living beings are classified. For example we
have animals, mammals, cats. Let's consider a cat like Sylvester, your
neighbour's cat. Sylvester is a specific example of cat, but if we want
to refer to cats in general, we shall refer to a generic family of
animals, a "class" of animals. A class is a generic entity which holds
together common properties; in case of a cat "class" we know that cats
have "properties" such as age, the fur color and so on.

An object is a unique representation of a specific entity: in our case
we know that Sylvester is a black cat of one year old. In other terms,
Sylvester is an "object". We can identify inside a class structural and
behavioural characteristics; in the former case we refer to them with
the "attributes" term, while in the latter we talk about "methods". The
attributes of a cat are its colour, age, etc, while the methods in a cat
should be its possible actions, such as running, meowing and eating.

A class can be seen as the matrix from which a particular thing is
generated: the object. The process of generation of an object is called
"instantiation", therefore an object is an instance of a class with all
its attributes and methods.

There are generic classes, such as mammals, and more specific classes,
such as the cat. Generally speaking, classes are developed following a
hierarchy starting from a very generic class to a more specific one,
through a sort of relationship that involves a definite group of
classes. In our example we could say that the "cat" class is daughter of
the "mammal" class. The "mammal" class is derived from the "animal"
class.

The relationships between different classes are described by a special
characteristic: a child class is provided with the characteristics of
the mother class, and possibly adding also new ones. This mechanism is
called hierarchy. In our case, for example, mammals have breasts and
eat, characteristics inherited from mammals, but they also have
whiskers, claws and they meow.

In OOP, each class has two special methods, called constructor and
destructor. The constructor is usually the method that initializes an
object instantiated from a class, while the destructor releases the
memory the object was using.

There are also the so called setter and getter functions, used to read
and write each class' object attribute values. Using getter and setter
functions allows the object-oriented philosophy to implement the
encapsulation. This concept means that the internal class modules are
protected and handled through a method in charge of checking if data
provided is correct. For example, if a "cat" class has a "colour"
attribute, you cannot simply assign a value to this attribute, one will
rather use a "setColour" method; this method will also check whether by
mistake a value "sunny" is being assigned to the "colour" attribute.

Obviously, getter and setter methods would be used to their maximum
extend if there was a system to hide the attributes of a class from the
outside. To this purpose, OOP philosophy offers the chance to define
such attributes as "private", i.e. not directly accessible from the
outside. Obviously, there are also "public" attributes that accessible
from outside the class. Again, private attributes are not inherited by
child classes.

During the process of inheritance, where daughter classes inherit
methods from the upper classes, you can have problems of inconsistency.
For example we may consider the class of "birds" with a daughter class
"penguins"; this class, respecting the rules of hierarchy, will have a
"fly" method. But we know that penguins can't fly! This is a typical
example of inconsistency in the process of inheritance.

To solve this and other problems it's possible to redefine the behavior
of a method that the child class has inherited from the mother class,
this process is called method "overriding". In the above mentioned
example, the "fly" method called from a penguin object may have been
reimplemented in the penguin class such as to behave as if it were
called a method for swimming. Not all methods of a superclass must be
inherited by the subclass; there are private methods which can be used
only by instances of the class they belong to.

Other classes can be defined inside a class too, either public or
private; in the latter case we will have the same behavior described for
private attributes.

Finally, all these objects can communicate with each other by exchanging
messages. A message in this case is the combination of a method to be
invoked and a value of the attributes that this method should
manipulate. Example of a message for an object of the class "dog":
method "bark", the value "woof, woof".

@node 42 BOOPSI and MUI some history
@section 4.2 BOOPSI and MUI: some history
@anchor{#boopsi-and-mui-some-history}
BOOPSI, Basic Object Oriented Programming System for Intuition, sets the
basis for OOP on AmigaOS. The BOOPSI system is developed following a
class hierarchy, which are related to a mother class: the rootclass.
Since its birth, BOOPSI has had a little number of classes which were a
bit extended with AmigaOS 3.0 (1992). Until then BOOPSI didn't have
policies about the layout of graphical objects nor had many classes to
offer; also, some concepts about the interaction between classes and
font handling were quite laborious, and even the look these classes
produced was not top notch.

While the small number of classes and the lack of policies for the
positioning of the elements in a window allowed great freedom to the
management of the graphics application, not everyone was willing to
support such an effort for the creation of a graphical interface. For
these reasons, again in 1992, a new solution composed of classes was
developed, starting right from the rootclass. This solution solved a lot
of problems we mentioned, adopting different solutions than those
proposed by the few BOOPSI official classes.

Such new classes were released with the name of "Magic User Interface":
MUI was born. During the years, through the long wait for a new version
of the operating system, many programmers used MUI as an API to develop
their GUI applications, allowing the system to become increasingly
robust, comprehensive and versatile. In 1995 ClassAct was introduced. It
was a new set of "pure" BOOPSI classes, extending the original BOOPSI
system following the philosophies of AmigaOS classes. However MUI had
already gained the favours of the developers, and the number of
applications written using ClassAct never exceeded those developed with
MUI. This situation considerably slowed down the development of new
ClassAct classes and the debugging of the classes of this distribution,
while at the same time new third party MUI classes were born, offering
many modern features to programmers and the MUI "core" classes also
became increasingly robust with the release of new versions of the
distribution.

In 1999, a new AmigaOS version (3.5) was finally distributed. It
officially incorporated a new ClassAct version, called Reaction.
However, even this attempt to drive developers towards a more "pure"
BOOPSI didn't result in programmers abandon MUI. In 2001, with the
release of AmigaOS 3.9 which included new Reaction classes, MUI was
choosen by MorphOS as its official API for graphical interfaces. In 2002
MUI was reimplemented by AROS, and renamed Zune. In 2004, the
pre-release version of AmigaOS 4 was released. This operating system
sports both the new Reaction classes and an OEM distribution of MUI,
providing the programmers with both solutions. In the end, although
Reaction classes have been greatly improved and developed in recent
times, they are not available on AROS and MorphOS and have many missing
features and bugs on AmigaOS3.x. They also have not the same
functionality and robustness of the corresponding MUI classes, and the
number of classes available to Reaction programmers is lower than those
available to MUI ones. That is why the choice for an Amiga programmer
without specific needs is obliged: MUI must be used.

@node 43 BOOPSI programming
@section 4.3 BOOPSI programming
@anchor{#boopsi-programming}
In the previous paragraph we mentioned that all BOOPSI classes are
related to a single mother class called rootclass. The rootclass defines
a set of methods, some of them have to be implemented in the child
classes. BOOPSI methods are classified by an identifier, called
MethodID. The "pure" BOOPSI methods that we will discuss are declared in
<intuition/classusr.h>:

@itemize
@item
OM_NEW: constructor;
@item
OM_DISPOSE: destructor;
@item
OM_SET: setter method;
@item
OM_GET: getter method;
@end itemize

Each MethodID has a prefix, "OM" for these four mentioned methods, which
stands for "ObjectMethod". As we know, the object-oriented philosophy
requires that interaction with an object is made through messages. A
BOOPSI message, called "Object Packet", is made of the MethodID of the
method to be invoked and the parameters it accepts. For example, the
object packet of the OM_NEW and OM_SET methods is the following
structure (defined in <intuition/classusr.h>):

@verbatim
struct opSet{

  STACKED ULONG MethodID;
  
  STACKED struct TagItem *ops_AttrList;
  
  STACKED struct GadgetInfo *ops_GInfo; 
}
@end verbatim

The first member of the structure is the MethodID, the second member is
a pointer to a list of attributes and corresponding values to be
assigned, while for the last member, currently not useful for our guide,
let's just say that it must be set to NULL in our examples.

We mentioned the second element of the opSet message is a pointer to a
list, but what is this TagItem structure? A TagItem, or more shortly
tag, is a [key,value] structure defined in <utility/tagitem.h> like
this:

@verbatim
struct TagItem {
  STACKED ULONG ti_Tag;  /* Tag identifier, in other words the name     */ 
                         /* of the object's attribute;                  */
           
  STACKIPTR ti_Data;     /* The value to assign the tag; it's the value */
                         /* to assign to the object's attribute;        */
}
@end verbatim

It's very common, however, handling more tags at a time and for this
reason they are saved in an array (called "tag list") before the message
is being dispatched.

In practice, an application sends a message to an object using the
AmigaOS function called DoMethodA(), or its variation DoMethod().

Such functions are declared in <clib/intuition_protos.h> on OS4, and are
called IDoMethodA() and IDoMethod(), while in all other Amiga OS
variants the declaration is in <clib/alib_protos.h>. On OS4, however,
these functions can be called using the "old" name without the "I"
prefix.

If, for example, we want to modify an object attribute, we should write:

@verbatim
struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
struct opSet msg = {OM_SET, taglist, NULL};
DoMethodA (object, (Msg)&msg);
@end verbatim

In the first line we create a tagList made by two tags, the first is the
attribute we want to modify, the second tag is a control attribute
closing the taglist declaration. In this case we can use both TAG_END or
TAG_DONE.

In the second line we build the actual BOOPSI message, made of the
MethodID ("OM_SET"), the attribute/value list to be assigned ("taglist")
and - last - the third member of the opSet structure that, as we said,
must be set to NULL in our case.

In the third line we are simply sending the message to our object. There
is a shorter method to do this, using the DoMethodA() variation called
DoMethod():

@verbatim
struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
DoMethod(object, OM_SET, taglist, NULL);
@end verbatim

This whole procedure is quite laborious and its use is not recommended
in practice. There are actually some Intuition's functions ready-made to
invoke these BOOPSI methods, which take of performing the right
initializations. Such methods are:

@itemize
@item
NewObject() : calls OM_NEW;
@item
DisposeObject() : calls OM_DISPOSE;
@item
SetAttrs() : calls OM_SET;
@item
GetAttrs() : calls OM_GET;
@end itemize

Let's modify the last example:

@verbatim
struct TagItem taglist[] = {{Attribute_ID, Attribute_Value},{TAG_END,0}};
DoMethod(object, OM_SET, taglist, NULL);
@end verbatim

which becomes:

@verbatim
SetAttrs(object, Attribute_ID, Attribute_Value, TAG_END);
@end verbatim

Invoking such functions requires passing the tag in the argument list of
the function itself, and this passing mode is called "varargs": a
function is variadic when accepts a variable number of arguments.

Handling a variable number of parameters in C language has precise
rules, (http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html)
which affect the API of all the incarnation of AmigaOS, so we'll talk in
more detail this topic later (The relevant SDI include file is
SDI_stdarg.h)

Not all methods explained at the start of this paragraph can be applied
to every attribute of an object: some attributes are not configurable,
not readable or not initializable. To indicate the applicability of a
method on an attribute some flags are included in the documentation of a
BOOPSI class:

@itemize
@item
I: If present, the attribute can be handled by OM_NEW;
@item
S: If present, the attribute can be handled by OM_SET;
@item
G: If present, the attribute can be handled by OM_GET;
@end itemize

There are other flags that we've not considered, which refer to methods
that we still have not examinated.
@menu
* 431 Instantiating a BOOPSI class::
* 432 BOOPSI adding an object to another object::
@end menu

@node 431 Instantiating a BOOPSI class
@subsection 4.3.1 Instantiating a BOOPSI class
@anchor{#instantiating-a-boopsi-class}
As you surely have guessed from the previous paragraph, we must use the
Intuition function NewObject() to instantiate a BOOPSI class; its
declaration is the following:

@verbatim
APTR NewObject(struct IClass *privateclass, 
           UBYTE *publicclassID, 
           unsigned long tag1, ...);
@end verbatim

The first two parameters could be confusing to those who have never used
Amiga, so it's time to introduce private and public BOOPSI classes. A
private class in BOOPSI is a class without a name (a simple ASCII
value). A private class is @emph{mostly} created by the user to be only
employed in his application, while a public class is associated with an
ASCII name and so it can also be accessed by other applications beyond
the one that contains the declaration and implementation.

Let's return to the NewObject() function, if we pass NULL as first
parameter, the function will know that it must create an instance of a
public class; and this is the reason why it will ask the name of this
class as an ASCII value in the second parameter. Viceversa, if we want
to instantiate a private class, we have to pass a pointer to the private
class to instantiate as first parameter in NewObject(), but we will deal
with this case later.

NewObject() is a variadic function, in fact the second parameter accepts
a tag list, which is built "on the fly" on the stack, following the
varargs functions rules. The NewObject() function returns a pointer to
the instantiated object, or NULL if something went wrong. So, if we have
a class whose ASCII name is "WindowPUB", with a "Title" attribute whose
type is STRPTR (pointer to string), we will have something like this:

@verbatim
Object *objWin; /* Declare a window object */
objWin = (Object *) NewObject(NULL, "WindowPUB", 
                   Title, "This is a Window", 
                  TAG_DONE);
@end verbatim

We will later include the following call to release the memory used by
this BOOPSI object:

@verbatim
DisposeObject(objWin);
@end verbatim

The original BOOPSI project stated that for every call to the
constructor of a class there is sooner or later a call to the destructor
of the same class. However, with the new classes, manual calls to every
class destructor are very rare: if a class allows to connect other
objects to its instance (see the following chapter), the calling to the
DisposeObject() function of that class instance will recall the
destructor for every object connected to that instance. In other words,
we will have a cascade deallocation.

@node 432 BOOPSI adding an object to another object
@subsection 4.3.2 BOOPSI: adding an object to another object
@anchor{#boopsi-adding-an-object-to-another-object}
In the previous chapter we mentioned how some BOOPSI object allow to be
connected to other objects. It's probably better to talk about objects
contained by other objects. The "containment" is another type of
hierarchical relationship in the latest BOOPSI releases, where the
contained object becomes, in some manner, "child" of its container. If,
for example, we want a window with buttons inside, we simply have to
instantiate a window object, the button objects and add these to the
newly instantiated window object. So, the button objects are somehow
childs of the window object. This is, in other terms, more a logical
relationship than a physical one. The handling of the containment in
BOOPSI is committed to two methods of the rootclass:

@itemize
@item
OM_ADDMEMBER: add an object to another object;
@item
OM_REMMEMBER: removes a specific object from another object;
@end itemize

For example, if we want to add a button object objBut (public class
"ButtonPUB" with a "Label" attribute) to the window object objWin we
will do the following:

@verbatim
Object *objBut; /* we declare a button object  */
objBut = (Object *) NewObject(NULL, "ButtonPUB", 
                Label, "Click me!", 
                  TAG_DONE);

DoMethod(objWin, OM_ADDMEMBER, objBut); 
@end verbatim

Otherwise, if we want to remove that button from the window:

@verbatim
DoMethod(objWin, OM_REMMEMBER, objBut); 
@end verbatim

In this last case, we have to be careful when releasing the resources,
because after disconnecting an object from another we obviously must
call explicitly DiposeObject() on the disconnected child object,
otherwise the memory will not be released:

@verbatim
DisposeObject(objBut);
@end verbatim

@node 44 From BOOPSI to MUI
@section 4.4 From BOOPSI to MUI
@anchor{#from-boopsi-to-mui}
Adding objects to other objects would be an useless feature if such
objects don't supply functions to the user. A user is not willing to
press a button without obtaining a feedback. Following the OOP
programming, an object could interact with another one by exchanging
messages or, in other conditions, the handling of an object by a user
could lead to the execution of one or more methods. In all these cases
we talk about "event notification".

The handling of notifications on "pure" BOOPSI is quite peculiar as it
involves two methods from the rootclass called OM_UPDATE e OM_MODIFY; we
must instantiate two child classes of the rootclass called icclass and
modelclass and, at the end, we must use the ICA_TARGET and ICA_MAP
attributes of these two classes. Moreover, there are other
implementation details to follow that make this work a bit laborious.
Moreover, if we want to program following the standard OOP, therefore
developing with subclasses, "pure" BOOPSI forces to a number of
arrangements to follow that lead the programmers' efforts towards the
graphical interface instead of the application itself. Another important
aspect to keep in mind using "pure" BOOPSI programming is the
difficulties to implement GUIs that follows a Multiple Document
Interface philosophy (MDI), which is based on repeatedly adding and
removing graphical objects on the fly. This lack of "pure" BOOPSI
programming will force you to implementation of GUIs based on multiple
windows, a philosophy very widespread in the middle of the '90. Another
problem not easily solvable with "pure" BOOPSI programming is object
management focus, more precisely when many graphical objects want to
control shortcuts from keyboard in the same GUI. The standard behaviour
of "pure" BOOPSI assigns all inputs to the focused object, so if for
example a string object doesn't support that kind of keyboard shortcut,
the input will not be managed. In other words "pure" BOOPSI lacks input
inheritance between objects. "Pure" BOOPSI programming lacks also
drag&drop support between graphical objects of a GUI, so you can't
implement a GUI where a user can drag&drop UI components at his own will
into windows of your program (like it happens inside the Firefox UI).
Sure, you can write from scratch this kind of thing into your "pure"
BOOPSI application, but it's not easy and it takes too much time...
Luckily the Amiga universe offers a solution to all these problems: the
most loved and hated Amiga Users' GUI, in other words: MUI.
@menu
* 441 MUI overview::
* 442 MUI An example of a simple graphical interface::
@end menu

@node 441 MUI overview
@subsection 4.4.1 MUI: overview
@anchor{#mui-overview}
As already mentioned, MUI is a collection of classes, linked one another
following a complex hierarchy that starts from the Notify and Semaphores
classes, both children of the rootclass. For the moment we will focus
only on the Notify class and all of its subclasses. The Notify class
implements a new mechanism to notify events, which is inherited by all
its subclasses, following OOP rules. The class hierarchy is shown in the
following simple graph:

@verbatim
 rootclass                    
 +--Notify                  
 !  +--Family                
 !  !  *
 !  !      
 !  +--Application
 !  !           
 !  +--Window               
 !  !  * 
 !  !        
 !  +--Area                 
 !  !  +--Group
 !  !  *  *
@end verbatim

Family is a generic class whose instances are able to keep objects
containing other objects. In other words, an instance of Family could
contain some Menu objects, that could contain other menu items or other
menus as well. Application is a class whose instance represents an
application that runs on the system, which can have a variable number of
windows (Window class instances).

Finally, the Area class is the mother of all other MUI gadgets and
handles all their informations, such as their size, their look and their
position. The Area class handles user inputs too. It's important to
notice that Area doesn't set the position of the elements inside one of
its instances, because Area is a generic class which can be used to
build more complex gadgets. Layout handling is performed by a child
class of Area, called Group. In theory, all these classes should have a
direct relationship; in other words, Area should be child of Window,
which should be child of Application which should be child of Family.
The author of MUI says that a direct relationship between these classes
wasn't possible to implement, due to some BOOPSI limits. Nonetheless, an
instance of Application can contain one or more instances of Window, and
this is valid also for Family-->Application and for Window-->Area,
partially solving the non-physical relationship problem.

Each MUI class is identified by a name preceded by "MUIC_" prefix, a
class attribute is identified by the "MUIA_" prefix, a method is
identified by the "MUIM_" prefix and so on... All the BOOPSI rules we
talked about regarding the methods of the rootclass are valid on MUI
too, even if this set of API provides the programmer with an alternative
way for object instantiation and destruction. It's possibile to use
MUImaster.library's MUI_NewObject() and MUI_DisposeObject() methods
instead of NewObject() and DisposeObject(). We'll compare their use
creating an instance of the MUIC_Window class:

@verbatim
objWin = (Object *) NewObject(MUI_GetClass(MUIC_Window), NULL, 
                                  MUIA_Window_Title, "This is a Window", 
                              TAG_DONE);
@end verbatim

becomes:

@verbatim
objWin = (Object *) MUI_NewObject(MUIC_Window, 
                                      MUIA_Window_Title, "This is a window", 
                                  TAG_DONE); 
@end verbatim

First of all, we notice that in the first case any MUI class is seen as
a BOOPSI private class. The instantiation occurs after getting the
pointer to the MUI class using the MUI_GetClass() method. Such procedure
can be problematic sometimes, as MUI_GetClass() keeps open the class we
are getting the pointer from, until the FreeClass() function is called;
so, forgetting to invoke FreeClass() could generate errors in the code.
MUI_NewObject() solves the problems of MUI class opening and closing
because a single call to DisposeObject() or MUI_DisposeObject() will
leave the system clear. Again, if MUI_NewObject() will not be able to
instantiate an object containing more objects previously instanced, it
will deallocate these objects that should have been part of the new
object (not created).

@node 442 MUI An example of a simple graphical interface
@subsection 4.4.2 MUI: An example of a simple graphical interface
@anchor{#mui-an-example-of-a-simple-graphical-interface}
Let's try building a simple graphical interface with MUI, we want to get
a window with a string as first element, and a button beneath it as
second element. Using MUI classes we will have the following snippet of
code for the button:

@verbatim
Object *button = MUI_MakeObject(MUIO_Button, "Click me!");
@end verbatim

As you can see, we don't instantiate an object from a class, but we get
an object from a so called "prebuilt object". We talked about how the
Area class handle user input, this class can react to some input in a
variety of ways, such as reacting like it was a button, or something
totally different. This is why MUI doesn't have a generic button class;
in fact on MUI a button is an instance of the MUIC_Text class with a
border as attribute and a behaviour assigned to react to the release of
a mouse or keyboard button. This way, it's very simple to create more
complex gadgets, but it's a bit awkward building a simple button. For
this reason, MUI provides pre built objects, ready for use. These
objects are identified by the "MUIO_" prefix. The MUI_MakeObject()
function takes a prebuilt object as first parameter plus its optional
parameters that aren't a tag list (therefore there isn't TAG_END or
TAG_DONE as last parameter). This is how we instantiate a String from
the MUIC_String class:

@verbatim
Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String, 
                                    MUIA_String_Contents, (IPTR) "Click on the button...", 
                                TAG_DONE);
@end verbatim

Please notice the MUIA_Frame attribute that allows to define the border
in which our string will be put.

As we mentioned, in order to delegate MUI to arrange the gadgets layout
we must use the MUIC_Group class:

@verbatim
Object *group = MUI_NewObject(MUIC_Group,
                                   MUIA_Group_Child, string,
                                   MUIA_Group_Child, button,
                               TAG_DONE);
@end verbatim

The default layout of the objects linked to an instance of MUIC_Group is
to align them in the same column, in which the first inserted element
will be the first element at the top of the column. To change the layout
we must work on the attributes provided by the MUIC_Group class. We
recommend reading the relevant documentation.

At the end, we can instantiate our window:

@verbatim
Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, "My Window",
                                     MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);
@end verbatim

In this last instantiation process we can notice the MUIA_Window_ID
attribute, which allows the system to identify the window with an ID
(using the MAKE_ID() macro our characters will be condensed in an ULONG.
This macro is in <libraries/iffparse.h>). This attribute is important if
the user wish to save, for example, the size of the program window.
Everything will be transparent to the programmer. We must pay attention
to the MUIA_Window_RootObject attribute. It establishes what the windows
is going to contain (in other words, its children); usually it contains
a group, if you need to display multiple gadgets. A MUIC_Window object
can have only one child.

As we previoulsy said, we must assign a MUIC_Application object to our
window:

@verbatim
Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , "ShInKy Tutorial GUI",
                                MUIA_Application_Base  , "ShInKyTutorialGUI",
                                MUIA_Application_Description, "MUI GUI Example",
                                MUIA_Application_Window, window,
                            TAG_DONE);
@end verbatim

MUIA_Application_Title is used by the system as the application name
which will be displayed to the user, while MUIA_Application_Base is the
name used by the system to identify the application.
MUIA_Application_Description is our application's description the system
will provide to the user. Now you can make the window visible (in other
words, open it) setting the MUIA_Window_Open attribute to TRUE, like
this:

@verbatim
SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);
@end verbatim

We should mention that a MUIC_Window object exists only in the context
of a MUIC_Application object, this means that you cannot make your
window visible until you add it to your application object, otherwise
you will get a crash.

We started building the graphical interface from the innermost to the
outermost element, avoiding passing a NULL pointer to the above
mentioned MUIA_Group_Child, MUIA_Window_RootObject and
MUIA_Application_Window attributes. It's time to go back to the
rootclass' OM_ADDMEMBER method we have previously described (4.3.2),
which allows us to build our interface as follows:

@verbatim
Object *app = MUI_NewObject(MUIC_Application,
                                MUIA_Application_Title  , "ShInKyButton",
                                MUIA_Application_Base  , "ShInKyButton",
                            TAG_DONE);

Object *group = MUI_NewObject(MUIC_Group, TAG_DONE);


Object *string = MUI_NewObject(MUIC_String, 
                                    MUIA_Frame, MUIV_Frame_String,
                                    MUIA_String_Contents,(IPTR) "Click the button...",
                                TAG_DONE);
        
Object *button= MUI_MakeObject(MUIO_Button, "Click me!");

DoMethod(group, OM_ADDMEMBER, string);
DoMethod(group, OM_ADDMEMBER, button);

Object *window = MUI_NewObject(MUIC_Window,
                                     MUIA_Window_Title, "My Window",
                                     MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                     MUIA_Window_RootObject, group,
                                 TAG_DONE);


DoMethod(app, OM_ADDMEMBER, window);
@end verbatim

Using this method we can add children objects to other objects after
their instantiation. If, for example, we want to remove our window from
the app object, we will write the following steps:

@verbatim
SetAttrs(window, MUIA_Window_Open, FALSE, TAG_DONE); /* close the window;*/

DoMethod(app, OM_REMMEMBER, window); /* remove the window object         */
                                     /* from the application object;     */
@end verbatim

If we want to add MUIC_Group objects to a window we must close it first,
while if we want to add or remove objects from a MUIC_Group instance, we
must explicitly notify these actions to MUI. To do this, we must
surround the code (in which we will perform the removal or addition of
elements in the group) with the MUIM_Group_InitChange method and
notifying the end of the changes invoking the MUIM_Group_ExitChange
method:

@verbatim
DoMethod(group, MUIM_Group_InitChange);
.
.
.
/*changes*/
.
.
.
DoMethod(group, MUIM_Group_ExitChange);
@end verbatim

Feel free to decide about the creation and removal of objects according
to your needs.

@node 45 MUI Notifications
@section 4.5 MUI: Notifications
@anchor{#mui-notifications}
In 4.4 we talked about the notification concept. A GUI item can react to
a user triggered event, performing an action that can involve other
graphical objects. Following the example in the previous paragraph, now
we want the content of the string and the button to react when we click
the button. To do so, MUI employs the MUIM_Notify method of the class
with the same name; since almost alla MUI classes are children of
MUIC_Notify, all our instances can use the MUI notification system.
MUIM_Notify method can be used with three different techniques: an
AmigaOS standard called "callback hook", a notification through methods
inside our private classes, or using notificable attributes. For the
time being, we will deal with the first technique, we will see the other
(more OOP compliants) later.
@menu
* 451 MUI Notifications with callback hook::
* 452 MUI window closing and the old notify method with ReturnID::
* 453 Zune and MUIM_Application_Execute::
@end menu

@node 451 MUI Notifications with callback hook
@subsection 4.5.1 MUI: Notifications with callback hook
@anchor{#mui-notifications-with-callback-hook}
The philosophy behind the callback hook involves the extension of a
module (a library, a device, a class, etc...) by hooking new functions.
To obtain this, a new function is hooked to a module using a structure
called Hook. The Hook structure is different in the various AmigaOS
flavours, so to keep compatibility, we will use the SDI tools (see Chap
1), specifically a header called SDI_hook.h. In practice, using
SDI_hook.h, we can build the function to hook and its relative hook in
this way:

@verbatim
/*Function to hook*/
HOOKPROTO(NameOfTheFunction, 
          ReturnValue,
          ObjectToHandle,
          ParametersToReceive);
{
....
}
/*Hook to be used*/
MakeHook(HookName, NameOfTheFunction);
@end verbatim

SDI_hook.h allows us to choose between different ways to create
functions and to create hooks. We suggest reading this header for
further details.

Following the example in the previous paragraph, we first write the
hookPutVal() function able to perform the change of the attributes of
the button and the string objects, then the relative Hook called
buttonHook:

@verbatim
HOOKPROTONO(hookPutVal, void, APTR *data)
{

  Object *button, *string;
  
  button=(Object *) *data++;
  string=(Object *) *data; 
    
  SetAttrs(string, 
           MUIA_String_Contents,
           (IPTR) "Button clicked!",
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Text_Contents,
           (IPTR) "Clicked!",
           TAG_DONE);
     
  SetAttrs(button, 
           MUIA_Disabled,
           TRUE,
           TAG_DONE);  
}
MakeStaticHook(buttonHook,hookPutVal); 
@end verbatim

As you can see in the function declaration, we are using the "NO"
variant provided by SDI_hook.h that allows us avoiding the parameter
representing the object to be manipulated; actually in this case we are
dealing not only with one object, but two. These objects are passed by
address, more precisely the "data" variable contains the parameters
received by the invoked function, whose first parameter passed with data
is the hook address. To obtain the address of the first object passed to
the function after the hook, we cast to (Object *) the pointer. We
proceed incrementing the pointer position to retrieve the following
objects; in this case we only have a button and a string. Now we got all
the data we need to handle MUI objects: we can proceed to the three
SetAttrs() calls, the first of them will set the text "Button clicked!"
inside our MUIC_String object, the second call changes the text inside
the button and the third disables the button. The hooking of the
function to an object is made by the MUIM_CallHook method, through
MUIM_Notify:

@verbatim
DoMethod(button,  MUIM_Notify, 
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  4,
                  MUIM_CallHook,
                  &buttonHook,
                  button,
                  string);
@end verbatim

Invoking MUIM_Notify through a DoMethod() function call will bind a
notification to an object. This method takes the following parameters:

@itemize
@item
the object that will activate a notification;
@item
the attribute of the object to be checked in order to activate a
notification;
@item
the object on which the notification method will be executed;
@item
the number of parameters passed to the notification method;
@item
the notification method;
@item
the parameteres, if any;
@end itemize

In our example:

@itemize
@item
MUIM_Notify is the method that will be invoked on the button click
event;
@item
MUIA_Pressed is the attribute that will be checked to be FALSE, that
means the notification will be triggered on release of the button after
being pressed;
@item
The notification method must be applied to the button itself
(MUIV_Notify_Self);
@item
The number of parameters for the notification method: 4;
@item
The notification method: MUIM_CallHook;
@end itemize

To be honest, the number "4" indicates how many parameters will be after
the MUIV_Notify_Self value. Obviously, the programmer must know the
number of parameters that will be passed to the hook function; a wrong
number of parameters specified here could lead to a disaster later
inside the hook due to the pointer arithmetic we previously explained.

The value MUIV_Notify_Self is used to decide whether to trigger the
notification method, in our case MUIM_CallHook. MUIM_Notify takes these
decisions using a predeclared value in the MUI system. Generally, a MUI
value is identified by the "MUIV_" prefix, in the MUIV_Notify case we
can choose from:

@itemize
@item
MUIV_Notify_Self: the object itself on which the MUIM_Notify method is
called;
@item
MUIV_Notify_Window: the MUIC_Window instance that contains the object;
@item
MUIV_Notify_Application: the MUIC_Application instance that contains the
object's mother window;
@item
MUIV_Notify_Parent: the object's parent instance;
@end itemize

The MUIM_CallHook method calls a function through the relative hook, in
our case "buttonHook", whose hooked function hookPutVal() receives
button and string as parameters.

@node 452 MUI window closing and the old notify method with ReturnID
@subsection 4.5.2 MUI: window closing and the old notify method with
ReturnID
@anchor{#mui-window-closing-and-the-old-notify-method-with-returnid}
Even the close gadget at the top of the window managing the application
exit is handled by the MUIM_Notify method. Following the example in the
previous paragraph, our window object is handled as follows:

@verbatim
DoMethod(window, MUIM_Notify, 
                   MUIA_Window_CloseRequest, TRUE,
                   MUIV_Notify_Application,
                   2,
                   MUIM_Application_ReturnID,
                   MUIV_Application_ReturnID_Quit);
@end verbatim

We are declaring that when the MUIA_Window_CloseRequester turns to TRUE
(the user clicks the window close gadget), the method
MUIM_Application_ReturnID must be triggered on the MUIC_Application
instance (identified by MUIV_NotifyApplication), passing a
MUIV_Application_ReturnID_Quit value.

MUIM_Application_ReturnID is a method that "forces" the
MUIM_Application_(New)Input method to return a value, in our case the
next call to MUIM_Application_Input will return
MUIV_Application_ReturnID_Quit.

MUIM_Application_Input is a method, now deprecated, used to catch all
the return values associated to user inputs on a MUI application. This
involved the use of a big control cycle, in which every return value of
a MUI interface was checked. This technique is the same of the "pure"
BOOPSI programming and assigns the input controlling to the application
itself. Even though in some situations this kind of handling can be
avoided, using Reaction classes, on "pure" BOOPSI a big control cicle is
the standard way of handling inputs. MUI keeps a similar method for
backward compatibility with older applications and only to handle the
close gadget of the window. More precisely, a faster version of
MUIM_ApplicationInput is used for this goal, called
MUIM_Application_NewInput; actually, we will invoke
MUIM_Application_ReturnID with:

@verbatim
IPTR sigs = 0;
while (DoMethod(app, MUIM_Application_NewInput, (IPTR)&sigs) != MUIV_Application_ReturnID_Quit)
{
  ;
}
@end verbatim

Basically we check that MUIM_Application_NewInput returns a value
different in the sigs variable from MUIV_Application_ReturnID_Quit.
Otherwise the loop will exit, allowing the application to follow closing
operations. Is a common practice to add a check for the interrupt signal
CTRL+C inside that loop, in order to catch the CTRL+C signal when the
application is launched from the command line (the Shell).

@verbatim
while (DoMethod(app, MUIM_Application_NewInput, (IPTR)&sigs) != MUIV_Application_ReturnID_Quit)
{
  if (sigs)
  {
    sigs = Wait(sigs | SIGBREAKF_CTRL_C);
    if (sigs & SIGBREAKF_CTRL_C) break;
  }
}
@end verbatim

To learn about the Wait() function and the SIGBREAKF_CTRL_C see
paragraph 5.1

@node 453 Zune and MUIM_Application_Execute
@subsection 4.5.3 Zune and MUIM_Application_Execute
@anchor{#zune-and-muim_application_execute}
In the previous paragraph we described a while loop to check for the
application closing signal, usually called the "main loop". Zune offers
the programmer the chance to avoid the loop, leaving the closing task to
a new method, MUIM_Application_Execute. Basically this method hides the
use of the main loop from the programmer, making everything look more
readable and modern. Its syntax is simply:

@verbatim
DoMethod(app, MUIM_Application_Execute);
@end verbatim

We leave to the reader the implementation of a portable
MUIM_Application_Execute method. Informations useful for such
implementation will be explained later.

@node 46 At the heart of a BOOPSI/MUI class the Dispatcher
@section 4.6 At the heart of a BOOPSI/MUI class: the Dispatcher
@anchor{#at-the-heart-of-a-boopsimui-class-the-dispatcher}
Up until now we just created instances of classes already available,
without knowing how to create our own. Object-Oriented Programming (OOP)
serves the purpose of creating highly modular applications. Following
the rules of OOP, developers create also software modules that can be
used again in different contexts, and MUI programming is no exception.

The engine behind a BOOPSI (and MUI) class that makes it an active
module is a peculiar function called dispatcher. When a BOOPSI object
receives a message, the dispatcher checks the message in order to verify
if the receiver is able to handle its parameters (the message itself).
In other words every Intuition and MUI function we've talked about until
now use the dispatcher. A BOOPSI object, in the end, is nothing but a
plain C structure and it could not perform any action without a
dispatcher.

Now we know that each BOOPSI class has a parent class; this relationship
goes up until the rootclass. Each class has its own dispatcher function.
If the class dispatcher does not recognize a parameter received, it will
push the unknown parameter to the parent class. This could happen up
until the rootclass itself that, in this case, would return an error
message.

In other words, the dispatcher is the function that invokes the class
methods it belongs to, choosing which one is appropriate for that
message. The dispatcher could implement itself the code to manage the
message or invoke the corresponding class method. Also, the declaration
and the definition of a dispatcher changes depending on which Amiga
flavour we are working. Luckily the SDI Tools will help us again
providing two macros, again in sdi_hook.h, called DISPATCHERPROTO() and
DISPATCHER(). DISPATCHERPROTO() is the macro used to declare the
dispatcher prototype and accepts just one argument, the name of our
dispatcher:

@verbatim
DISPATCHERPROTO(MyDispatcher);
@end verbatim

With the DISPATCHER() macro we define the real function:

@verbatim
DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW : return myNew(cl,obj,(APTR)msg);
  }

  return DoSuperMethodA(cl,obj,msg);
}
@end verbatim

In this example the dispatcher only takes care of managing the OM_NEW
method of its class, invoking a myNew() function that will be described
later. After having managed (if needed) OM_NEW, the dispatcher sends the
message to the rootclass, using the DoSuperMethodA() of Intuition. The
parameters "cl", "obj" and "msg", were received by the dispatcher
itself. The prototype of the dispatcher, on any Amiga-ish incarnation,
needs these three parameters. "cl" is the class the dispatcher belongs
to, "obj" is the object that has received the message and "msg" is the
message itself, "opSet" in our example (see paragraph 4.3).
@menu
* 461 Implementation of a MUI private class::
* 462 Implementing OM_NEW and its external tags::
* 463 Using a private class::
@end menu

@node 461 Implementation of a MUI private class
@subsection 4.6.1 Implementation of a MUI private class
@anchor{#implementation-of-a-mui-private-class}
OOP's strength lies on the possibility to let the programmer write
his/her own classes and use them again in different contexts. For
example, if we would like to subclass MUIC_Group, creating a subclass
containing the two objects of paragraph 4.5 (the button and the string),
first of all we should declare a private data area (a simple struct) of
our new class:

@verbatim
struct myDataArea
{    
   Object *button, *string;
   STRPTR labelButton, labelStr;
};
@end verbatim

Now, according to BOOPSI rules variables declared inside the data area
will be later recognized as private attributes of the class.

Speaking of methods, a MUI class provides implementation of the
following methods:

@verbatim
- OM_NEW;
--- MUIM_Setup;
--- MUIM_AskMinMax;
------ MUIM_Show;
--------- MUIM_Draw;
------ MUIM_Hide;
--- MUIM_Cleanup;
- OM_DISPOSE;
@end verbatim

Each method will be implemented only if really needed. For the moment we
will explain only how to implement the OM_NEW method.

@node 462 Implementing OM_NEW and its external tags
@subsection 4.6.2 Implementing OM_NEW and its external tags
@anchor{#implementing-om_new-and-its-external-tags}
Looking at the sample dispatcher in paragraph 4.5.2, a possible
definition of a myNew() function (which will represent OM_NEW method
implementation) could be:

@verbatim
IPTR myNew(struct IClass *cl,Object *obj,struct opSet *msg)
{
  struct myDataArea *data;
  .
  .
  .
  .
  /*call to method OM_NEW of superclass*/
  .
  .
  .

  data = INST_DATA(cl,obj);
  
  .
  .
  .
  .
  /*return pointer to istantiated object*/   
}
@end verbatim

A function in charge of implementing OM_NEW will always have this
signature: "cl" is the class the dispatcher belongs to, "obj" is the
object that has received the message, "msg" is the message. INST_DATA()
is a macro used to get a pointer to the private data area of the caller
object.

The data area of our class is nothing but the struct we declared before
and the other superclasses' data areas (polymorphism), if any.
Allocation of the superclass data area happens when the OM_NEW method of
the superclass is invoked. This process repeats and goes up until the
rootclass. The OM_NEW method of the rootclass will now allocate enough
memory for its own data area, passing the pointer to the subclass: this
is how an instance of the rootclass is created. The subclass, upon
receiving the rootclass object, will use the INST_DATA() macro to tell
the system to allocate more memory to be added to the superclass data
area (identified by the rootclass pointer), and then populate it with
its own data area. After that, and after having executed other actions
(if any), the OM_NEW method of said class will send this data area to
the subclass, again using a pointer to the instanced object. Each class
performs these actions until our OM_NEW method is reached, which - again
- will perform these actions, again through the INST_DATA() macro.

Before invoking the OM_NEW method of the superclass, we may want to read
parameters (a message, that is) - if any are existing - passed to our
method. In our example, if we want to inizialize the values of
labelButton and labelStr from our OM_NEW overload method, we should
associate these variables to labels (ID) that our method will recognize.
Here's how to declare such IDs:

@verbatim
#define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000)
#define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
#define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2
@end verbatim

Here we have defined three symbols, the location of the last two of them
depending on the first. MUI_CLASS_TUTORIAL is the first defined symbol
and his value is given by a bitwise OR on TAG_USER (a system value used
to separate user tags from system tags) and the hexadecimal value
0x80420000. This hex value is not randomly choosen: MUI documentation,
in fact, recommend using hex values in the range 0x80420000 - 0x80429999
for public attributes of your own classes.

Actually, if we are creating private classes, not reachable by other
tasks othen than our own, we could define these symbols as follows:

@verbatim
#define MUIA_MUIClassTutorial_TextStr  TAG_USER + 20
#define MUIA_MUIClassTutorial_LabelBut TAG_USER + 21#
@end verbatim

and so on...

Remember to use values not too close to TAG_USER, otherwise in some
conditions weird behaviour could arise.

Now we should analyze the message received, checking whether he user has
possibly sent initialization code for labelButton and labelStr:

@verbatim
Object *string, *button;        /*we alloc objects which later will*/
STRPTR labelStr, labelButton;   /*populate our data area*/

{/*block for tag list reading*/
  struct TagItem *tags, *tag;

  tags=((struct opSet *)msg)->ops_AttrList;
  while (tag=NextTagItem(&tags))
  {
    switch (tag->ti_Tag)
    {
      case MUIA_MUIClassTutorial_TextStr:
      if (tag->ti_Data)
        labelStr= (STRPTR) tag->ti_Data;
      break;
      
      case MUIA_MUIClassTutorial_LabelBut:
      if (tag->ti_Data)
        labelButton= (STRPTR) tag->ti_Data;
      break;
    }
  }
}
@end verbatim

As we know, the opSet message (see paragraph 4.3) has a variable
ops_AttrList pointing to the passed taglist. This is why we have
declared two pointers (tags and tag), they will be used while iterating
through the list using NextTagItem() function from utility.library. Each
call to NextTagItem() pops the current item from the list into the tag
variable. Using a switch we check the value of tag->ti_Tag of the
current item against the values we have declared before: if tag->ti_Tag
equals MUIA_MUIClassTutorial_TextStr, for example, labelStr will be
initialized to the value from tag->ti_Data, while if tag->ti_Tag equals
MUIA_MUIClassTutorial_LabelBut, the value in tag->ti_Data will be put
into labelBtn.

It's important to notice how the declaration of NextTagItem() on AROS is
slightly different than other Amiga-ish operating systtems; for this
reason the above mentioned code could emit warnings when compiled. In
order to solve this issue, we can define our own TAGITEM define:

@verbatim
#ifdef __AROS__
  #define TAGITEM const struct TagItem **
#else
  #define TAGITEM  struct TagItem **
#endif  
@end verbatim

and use it to cast the value returned:

@verbatim
...
 while (tag=NextTagItem((TAGITEM)&tags))
...
@end verbatim

It's common practice using such a syntax (NextTagItem() associated with
a switch) when implementing the OM_SET method when there are a lot of
attributes to manage. It is possible to make the code more compact by
using the shortcuts GetTagData() from utility.library:

@verbatim
IPTR GetTagData(Tag,IPTR,struct TagItem *);
@end verbatim

This function requires the tag to be used as first argument, a default
return value if the label is not found as second argument and the
already mentioned ops_AttrList as last argument. Replacing the switch
with GetTagData() is described below:

@verbatim
struct TagItem *tags;
tags=((struct opSet *)msg)->ops_AttrList;

labelStr = (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)NULL, tags);
      
labelButton = (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)NULL, tags);      
@end verbatim

We have mentioned there could be an attribute not managed by the OM_NEW
method we are overloading. Such an attribute must be handled by the
superclass' OM_NEW (which will be invoked anyway, also to solve this
kind of issues).

At this stage we should istantiate the label and button objects, just
like we did before (see paragraph 4.4.2) and initialize them with the
labelStr and labelButton values.

In order to call the superclass' OM_NEW method we can either use
DoSuperMethodA() or its variadic version DoSuperMethod():

@verbatim
struct TagItem taglist[] = {{MUIA_Group_Child, (IPTR) string},
                            {MUIA_Group_Child,(IPTR) button},
                            {TAG_MORE, (IPTR) msg->ops_AttrList}};

obj =(Object *) DoSuperMethod(cl, 
                              obj,
                              OM_NEW,
                              taglist,
                              NULL);
            
if (obj==NULL)
    return 0;
@end verbatim

With DoSuperMethod() we invoke the superclass', in our example
MUIC_Group, OM_NEW method passing a tag list that will let the method
create a group with our string and our label as children. TAG_MORE
signals the presence of a new taglist which pointer - as we know - is
found in tag->ops_AttrList. If DoSuperMethod() returns NULL it means the
arguments passed were not recognized by the superclass' method. This
syntax is a bit tedious, so it is common practice using the utility
function DoSuperNew(), which we will better explain later. Suffice to
say for the moment that this function can replace the above code with
the following:

@verbatim
obj = DoSuperNew(cl, 
                 obj,
                 MUIA_Group_Child, string,
                 MUIA_Group_Child, button,
                 TAG_MORE, msg->ops_AttrList);

if (obj==NULL)
  return 0;
@end verbatim

With DoSuperNew() we passed the objects label and button to our
superclass' OM_NEW method; these objects will become children of the
next object we will instantiate. These objects will be automatically
positioned inside the container object of MUIC_Group class and, with
that, they will represent the instance of our private MUI class. Now
there's only to invoke INST_DATA(), that will provide our own private
data structure that will be populated as follows:

@verbatim
data = INST_DATA(cl,obj);

data->labelStr    = labelStr;
data->labelButton = labelButton;
data->str         = string;
data->button      = button;

return obj;
@end verbatim

At this point we have shown all there's to do to implement the OM_NEW
method.

@node 463 Using a private class
@subsection 4.6.3 Using a private class
@anchor{#using-a-private-class}
After having implemented all that is needed in the previous paragraphs,
we are now able to use our new MUI class. To do so, we use the method
MUI_CustomClass() from MUImaster.library. The syntax is as follows:

@verbatim
struct MUI_CustomClass *mcc;

mcc = (struct MUI_CustomClass *) MUI_CreateCustomClass(NULL,
                                                       MUIC_Group,
                                                       NULL,
                                                       sizeof(struct myDataArea),
                                                       ENTRY(MyDispatcher));
@end verbatim

The first parameter of this function call is NULL when dealing with
private classes; it is only assigned if we are sharing a public MUI
class, that's all we need to know at the moment. The second parameter is
our class's superclass, from which it will inherit methods and
attributes. The third parameter is only used if our subclass is daughter
of another private class, so this parameter too is NULL in this case.
The fourth parameter is the size of our private data struct. The fifth
and last parameter is the dispatcher name. The ENTRY() macro, from the
SDI tools, is used by MorphOS to tell a native PPC class from a 68K one;
other compilers will ignore this macro. Using this macro allows us to be
compatible with MorphOS.

Now, if the call to MUI_CreateCustomClass() succeded, we should have in
"mcc" the instance of our private MUI class, to be used as a parameter
for the Intuition method NewObject() as follows:

@verbatim
Object *MyObj; 

MyObj = (Object *) NewObject(mcc->mcc_Class, 
                             NULL,
                             MUIA_MUIClassTutorial_TextStr,(IPTR) "Click the button...",
                             MUIA_MUIClassTutorial_LabelBut,(IPTR) "ClickMe!",
                             TAG_DONE);
@end verbatim

As you can see in the above example, a MUI private class is identified
by a MUI_CustomClass data structure that contains a pointer "mcc_Class"
to a IClass struct (used to identify private BOOPSI classes). The
official documentation recommends to not use the MUI_NewObject()
function. With NewObject() - as we explained earlier - we are invoking
the OM_NEW method of our class, and we are passing it the values for the
attributes MUIA_MUIClassTutorial_TextStr and
MUIA_MUIClassTutorial_LabelBut.

After having used our class, we must deallocate it from the memory:

@verbatim
MUI_DeleteCustomClass(mcc);
@end verbatim

this call must be put after the usual MUI_DisposeObject();

So, after inserting MUI_CreateCustomClass() in a special function, our
code is now complete:

@verbatim
/****************************************************************************/
//file sys.h
/****************************************************************************/
/* Includes */
#ifndef __SYS_INCLUDES__
#define __SYS_INCLUDES__

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/utility.h>
#include <proto/intuition.h>

#include <proto/MUImaster.h>
#include <libraries/mui.h>

#if !defined (__amigaos4__)
#include <clib/alib_protos.h>
#endif
                
#include <SDI_compiler.h>
#include <SDI_hook.h>
#include <SDI_stdarg.h>


#if !defined(__AROS__) || !defined(__MORPHOS__)
#ifdef __amigaos4__
#define IPTR uint32
#else
#define IPTR ULONG
#endif
#endif

#ifndef __AROS__
#define STACKED
#endif

#ifdef __AROS__
    #define TAGITEM const struct TagItem **
#else
    #define TAGITEM  struct TagItem **
#endif

#if !defined (__MORPHOS__)
Object * VARARGS68K DoSuperNew(struct IClass *cl, Object *obj, ...);
#endif

#endif   
         
/****************************************************************************/

/****************************************************************************/
// file MUIClass.h
/****************************************************************************/

#ifndef __MYMUICLASS__
    #define __MYMUICLASS__

    #define MUI_CLASS_TUTORIAL (TAG_USER | 0x80420000<<16)

    #define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
    #define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2

    struct MUI_CustomClass *initMUIClass();
#endif    
/****************************************************************************/

/****************************************************************************/
//file MUIClass.c
/***************************************************************************/

#include "sys.h"
#include "MUIClass.h"

struct MyData
{
    Object *button, *str;
    STRPTR labelButton, labelStr;
};


///hookPutVal
HOOKPROTONO(hookPutVal, void,APTR *data)
{
    Object *bt_1, *str;
        
    bt_1=(Object *) *data++;
    str=(Object *) *data;
                
    SetAttrs(str, MUIA_String_Contents,(IPTR) "Clicked button...", TAG_DONE);
    SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) "Clicked!", TAG_DONE);
    SetAttrs(bt_1, MUIA_Disabled, TRUE, TAG_DONE);    
}
MakeStaticHook(buttonHook, hookPutVal);
///

///OM_NEW()
IPTR mNew(struct IClass *cl, Object *obj, struct opSet *msg)
{
    struct MyData *data;
        
    STRPTR labelStr, labelButton;
    Object *str, *button;
    struct TagItem *tags;

    tags=((struct opSet *)msg)->ops_AttrList;

    labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)" ",tags);

    labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)" ",tags);

        
    str = MUI_NewObject(MUIC_String,
                            MUIA_Frame, MUIV_Frame_String,
                            MUIA_String_Contents,(IPTR) labelStr,
                        TAG_DONE);
        
    button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                                        
    obj = (Object *) DoSuperNew(cl, obj,
                                    MUIA_Group_Child, str,
                                    MUIA_Group_Child, button,
                                TAG_MORE, msg->ops_AttrList);

    if (obj==NULL)
        return 0;

    data = (struct MyData *) INST_DATA(cl,obj);

    data->str= str;
    data->button=  button;
    data->labelStr= labelStr;
    data->labelButton=  labelButton;

    DoMethod(data->button, MUIM_Notify,
             MUIA_Pressed, FALSE,
             MUIV_Notify_Self, 4,
             MUIM_CallHook,
             &buttonHook,
             data->button,
             data->str);
                         
    return (IPTR)obj;
}
///

///MyDispatcher
DISPATCHER(MyDispatcher)
{
    switch (msg->MethodID)
    {
        case OM_NEW : 
            return mNew(cl,obj,(struct opSet *)msg);
    }

    return(DoSuperMethodA(cl,obj,msg));
}
///

struct MUI_CustomClass *initMUIClass()
{
    return (MUI_CreateCustomClass(NULL, MUIC_Group, NULL, sizeof(struct MyData), ENTRY(MyDispatcher)));
}
                                                                                                 
/****************************************************************************/

/****************************************************************************/
//file main.c
/****************************************************************************/
#include "sys.h"
#include "MUIClass.h"

#ifdef __MORPHOS__
    struct Library *UtilityBase;
#else
    struct UtilityBase *UtilityBase;
#endif

struct IntuitionBase *IntuitionBase;
struct Library *MUIMasterBase;

#ifdef __amigaos4__
    struct UtilityIFace *IUtility;
    struct IntuitionIFace *IIntuition;
    struct MUIMasterIFace *IMUIMaster;
#endif

struct MUI_CustomClass *mcc;

///fail()
void fail(Object *app, STRPTR notice_txt)
{
    struct EasyStruct requester;
        
    if (app)
        MUI_DisposeObject(app);

#ifdef __amigaos4__
    if (IMUIMaster)
        DropInterface((struct Interface *)IMUIMaster);
        
    if (IIntuition)
        DropInterface((struct Interface *)IIntuition);
        
    if (IUtility)
        DropInterface((struct Interface *)IUtility);
#endif

    if (MUIMasterBase)
        CloseLibrary((struct Library *)MUIMasterBase);

    if (IntuitionBase)
        CloseLibrary((struct Library *)IntuitionBase);

    if (UtilityBase)
        CloseLibrary((struct Library *)UtilityBase);


    requester.es_StructSize = sizeof(struct EasyStruct);
    requester.es_Flags      = 0;
        
    if (notice_txt != NULL)
    {
        requester.es_Title        =  "Startup Error";
        requester.es_TextFormat =  notice_txt;
        requester.es_GadgetFormat =  "Exit";
        EasyRequestArgs(NULL, &requester, NULL, NULL);
    }
    else
    {
        requester.es_Title        = "Attention";
        requester.es_TextFormat =  "Closure completed successfully";
        requester.es_GadgetFormat = "Exit";
        EasyRequestArgs(NULL, &requester, NULL, NULL);
    }
}
///

///init()
void init(void)
{
    #ifdef __MORPHOS__
    if ( !(UtilityBase=(struct Library *) OpenLibrary("utility.library",39)) )
    #else
    if ( !(UtilityBase=(struct UtilityBase *) OpenLibrary("utility.library",39)) )
    #endif
    {
        fail(NULL, "Problem! Failed to open\n utility.library");
    }
    else
    {
    #ifdef __amigaos4__
        IUtility = (struct UtilityIFace *) GetInterface((struct Library *)UtilityBase, 
                                "main", 
                                1, 
                                NULL);
    #endif        
    }

    if ( !(IntuitionBase=(struct IntuitionBase *) OpenLibrary("intuition.library",39)) )
    {
        fail(NULL, "Problem! Failed to open\n intuition.library");
    }
    else
    {
        #ifdef __amigaos4__
        IIntuition = (struct IntuitionIFace *) GetInterface((struct Library *)IntuitionBase, 
                                        "main", 
                                        1, 
                                        NULL);
        #endif        
    }

    if (!(MUIMasterBase = OpenLibrary(MUIMASTER_NAME,19)))
    {
        fail(NULL,"Problem! Failed to open\n MUImaster.library" );
    }
    else
    {
        #ifdef __amigaos4__
        IMUIMaster = (struct MUIMasterIFace *) GetInterface(MUIMasterBase, 
                                        "main", 
                                        1, 
                                        NULL);
        #endif        
    }    
}
///

///main() function                             
int main(int argc,char *argv[])
{
    Object *MyObj, *window, *app;
    

    init();

    if (!(mcc = (struct MUI_CustomClass *) initMUIClass()))
    {
                        fail(NULL,"Problem! Failed to create our class...");
    }


    MyObj = (Object *) NewObject(mcc->mcc_Class, NULL,
                                    MUIA_MUIClassTutorial_TextStr,(ULONG) "Click the button...",
                                    MUIA_MUIClassTutorial_LabelBut,(ULONG) "Click me!",
                                 TAG_DONE);


    window = (Object *) MUI_NewObject(MUIC_Window,
                                        MUIA_Window_Title,(IPTR) "My Window",
                                        MUIA_Window_ID ,MAKE_ID('M','a','i','n'),
                                        MUIA_Window_RootObject, (IPTR) MyObj,
                                      TAG_DONE);
                                        

     app = (Object *) MUI_NewObject(MUIC_Application,
                                        MUIA_Application_Title      ,(IPTR)  "MuiPortableClass",
                                        MUIA_Application_Version    ,(IPTR)  "$VER: MuiPortableClass 1.0",
                                        MUIA_Application_Copyright  ,(IPTR)  " ",
                                        MUIA_Application_Author     ,(IPTR)  "ShInKurO",
                                        MUIA_Application_Description,(IPTR)  "Portable MUI class",
                                        MUIA_Application_Base       ,(IPTR)  "MuiPortableClass",
                                        MUIA_Application_Window, (IPTR) window,
                                       TAG_DONE);
                                        
     

    if (!app)
        fail(app, "Problem! Failed to create app");

    DoMethod(window, 
                MUIM_Notify,
                MUIA_Window_CloseRequest,
                TRUE,
                app,
                2,
                MUIM_Application_ReturnID,
                MUIV_Application_ReturnID_Quit);

    
    SetAttrs(window, MUIA_Window_Open, TRUE, TAG_DONE);
                
    {/*main loop*/
        IPTR sigs = 0;
        while (DoMethod(app, MUIM_Application_NewInput, &sigs) != MUIV_Application_ReturnID_Quit)
        {
            if (sigs)
            {
                sigs = Wait(sigs | SIGBREAKF_CTRL_C);
                if (sigs & SIGBREAKF_CTRL_C) break;
            }
        }
    }

    SetAttrs(window, MUIA_Window_Open,FALSE,TAG_DONE);


    DisposeObject(app);     
    MUI_DeleteCustomClass(mcc);
    fail(NULL, NULL);          

    return 0;
}
///  
/****************************************************************************/
@end verbatim

@node 47 DoSuperNew and variadic functions
@section 4.7 DoSuperNew() and variadic functions
@anchor{#dosupernew-and-variadic-functions}
DoSuperNew() belongs to the utility functions of MorphOS and allows the
programmer to simplify the creation of methods of new BOOPSI and MUI
subclasses. Obviously, as tradition imposes, DoSuperNew() is not present
in other systems, but then again the SDI Tools authors have put an
"indirect" implementation of this function that employs such headers.
The implementation uses the SDI_stdarg.h and SDI_compiler.h headers.
Proceed as follows:

@verbatim
Object * VARARGS68K DoSuperNew(struct IClass *cl, Object *obj, ...)
{
  Object *rc;
  VA_LIST args;

  VA_START(args, obj);
  rc = (Object *)DoSuperMethod(cl, obj, OM_NEW, VA_ARG(args, IPTR), NULL);
  VA_END(args);

  return rc;
} 
@end verbatim

The VARARGS68K macro (located in the declaration of the function) finds
its origin on AmigaOS4 and its purpose is to indicate the OS4 compiler
to manage the variable number of parameters just like it would be done
on AmigaOS3.x. Other compilers, thanks to the SDI_compiler.h, can safely
ignore the VARARGS68K macro. The macros VA_LIST, VA_START(), VA_ARG()
and VA_END() matches respectively va_list, va_start(), va_arg() and
va_end() from the stdarg.h library and have been "reimplemented" in
SDI_stdarg.h so to have a common standard for all the Amiga variations
(they implement the standard ANSI variadic functions differently).

@node 48 MUI notification performed using public methods of private classes
@section 4.8 MUI: notification performed using public methods of private
classes
@anchor{#mui-notification-performed-using-public-methods-of-private-classes}
After showing the main concepts of a private class creation, we can now
introduce the second model to manage the notifications that we mentioned
before (paragraph 4.5).

First of all it's good to underline the fact that the previous method of
notification employing callbacks hook, under certain circumnstances,
could not respect one the main rules of OOP, the encapsulation, based on
the concept of information hiding. In other words, a class should be a
black box (which contents are mostly unknown) that provides services to
the user. However, using hooks and a function connected it is possible
to change from outside the attributes os a class considered private,
simply passing them to the hook. Using hooks implies using the
arithmethic of pointers, which can easily lead to errors. In order to
avoid these issues and respect the OOP paradigm, it is possible to
manage notifications using public methods belonging to our private
class. A method belonging to a class will obviously operate with the
class private data area (the attributes of said class, that is).

It's also good to remind how in the OOP paradigm a class method is
invoked through a message; in a BOOPSI and MUI world we know that the
message is a struct containing the ID of the method and possibly
additional parameters. Let's pick again the example of paragraph 4.5
where we had a string and a button and we wanted to change their values
when the user clicks the button. First of all let's declare the ID of
our new public method:

@verbatim
#define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20
@end verbatim

Now let's declare the method's message:

@verbatim
struct MUIMP_MUIClassTutorial_ClickBut
{
  STACKED ULONG  MethodID;
};
@end verbatim

In this case the message will only contain its initialization method; in
our example we don't need anything else as the method needs to work with
internal class data. The function that will be associated to the
MUIM_MUIClassTutorial_ClickBut method is nothing but a modified version
of the previous "hookPutVal" function. More precisely, using the
callback we had:

@verbatim
HOOKPROTONO(hookPutVal, void, APTR *data)
{

  Object *button, *string;

  button=(Object *) *data++;
  string=(Object *) *data;

  .
  .
  .

}
MakeStaticHook(buttonHook,hookPutVal);
@end verbatim

now we have a function like that:

@verbatim
IPTR mClickBut(struct IClass *cl, Object *obj, struct MUIMP_MUIClassTutorial_ClickBut *msg)
{

  struct MyData *data;
  data = (struct MyData *) INST_DATA(cl,obj);
  Object *bt_1, *str;

  bt_1=(Object *) data->button;
  str=(Object *)  data->str;

  .
  .
  .

  return (IPTR) obj;
}
@end verbatim

The difference between the two is apparent. We don't have an explicit
use of pointer arithmetic and our function looks exactly like a class
method. The dispatcher of our private class will now associate the
mClickBut() function the MUIM_MUIClassTutorial_ClickBut ID:

@verbatim
DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW :
    return mNew(cl,obj,(struct opSet *)msg);

    case MUIM_MUIClassTutorial_ClickBut :
    return mClickBut(cl,obj,(struct MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  return(DoSuperMethodA(cl,obj,msg));
}
@end verbatim

Until now we have only declared a new method for our private class,
without any connection to the MUI notification system. To do so, first
of all we need to invoke the already mentioned MUIM_Notify method, that
in our previous example of the callbacks worked like this:

@verbatim
DoMethod(button, MUIM_Notify,
                  MUIA_Pressed, FALSE,
                  MUIV_Notify_Self,
                  4,
                  MUIM_CallHook,
                  &buttonHook,
                  button,
                  string);

while in case of notification using public method we will have:

DoMethod(data->button, MUIM_Notify,
                   MUIA_Pressed, FALSE,
                   obj,
                   1,
                   MUIM_MUIClassTutorial_ClickBut);
@end verbatim

In other words we are using DoMethod() to do the following: "everytime
data->button object is selected, invoke the
MUIM_MUIClassTutorial_ClickBut method on istance obj of our private
class". This is the resulting code:

@verbatim
/*****************************************************************************/
// file MUIClass.h                             
/*****************************************************************************/

#ifndef __MYMUICLASS__
  #define __MYMUICLASS__

  #define MUI_CLASS_TUTORIAL (TAG_USER+20)

  #define MUIA_MUIClassTutorial_TextStr MUI_CLASS_TUTORIAL + 1
  #define MUIA_MUIClassTutorial_LabelBut MUI_CLASS_TUTORIAL + 2
  #define MUIA_MUIClassTutorial_App MUI_CLASS_TUTORIAL + 3

  struct MUIMP_MUIClassTutorial_ClickBut
  {
    STACKED ULONG MethodID;

  };


  #define MUIM_MUIClassTutorial_ClickBut MUI_CLASS_TUTORIAL + 20

  struct MUI_CustomClass  *initMUIClass();
#endif
/*****************************************************************************/

/*****************************************************************************/
//file MUIClass.c
/*****************************************************************************/
struct MyData
{
  Object *button, *str;
  STRPTR labelButton, labelStr;
};


///OM_NEW
static IPTR mNew(struct IClass *cl,Object *obj,struct opSet *msg)
{

  STRPTR labelStr, labelButton;
  Object *str, *button;
  struct TagItem *tags =((struct opSet *)msg)->ops_AttrList;
    
  labelStr= (STRPTR) GetTagData(MUIA_MUIClassTutorial_TextStr, (IPTR)" ",tags);

  labelButton= (STRPTR) GetTagData(MUIA_MUIClassTutorial_LabelBut, (IPTR)" ",tags);
      
  str = MUI_NewObject(MUIC_String,
                      MUIA_Frame, MUIV_Frame_String, 
                      MUIA_String_Contents,(IPTR) labelStr,
                      TAG_DONE);
    
  button= (Object *) MUI_MakeObject(MUIO_Button,(IPTR) labelButton, TAG_DONE);
                    
  obj = (Object *) DoSuperNew(cl, 
            obj,
            MUIA_Group_Child, str,
            MUIA_Group_Child, button,
            TAG_MORE, msg->ops_AttrList);

  if (obj==NULL)
    return 0;
    
  {
    struct MyData *data;
    data = (struct MyData *) INST_DATA(cl,obj);

    data->str = str;
    data->button = button;
    data->labelStr = labelStr;
    data->labelButton = labelButton;

    DoMethod(data->button, MUIM_Notify,
                           MUIA_Pressed, FALSE,
                           obj,
                           1,
                           MUIM_MUIClassTutorial_ClickBut);
  }


  return (IPTR)obj;
}
///

/// MUIM_MUIClassTutorial_ClickBut
static IPTR mClickBut(struct IClass *cl,Object *obj, struct MUIMP_MUIClassTutorial_ClickBut *msg)
{

  struct MyData *data;
  Object *bt_1, *str;

  data = (struct MyData *) INST_DATA(cl,obj);
  bt_1=(Object *) data->button;
  str=(Object *)  data->str;

 

  SetAttrs(str,  MUIA_String_Contents,(IPTR) "Button clicked", TAG_DONE);
  SetAttrs(bt_1, MUIA_Text_Contents,(IPTR) "Clicked!", TAG_DONE);
  SetAttrs(bt_1, MUIA_Disabled,TRUE, TAG_DONE);
 
  return (IPTR) obj;
}
///

///MyDispatcher
DISPATCHER(MyDispatcher)
{
  switch (msg->MethodID)
  {
    case OM_NEW :
        return mNew(cl,obj,(struct opSet *)msg);
    case MUIM_MUIClassTutorial_ClickBut :
        return mClickBut(cl,obj,(struct MUIMP_MUIClassTutorial_ClickBut *)msg);
  }

  return(DoSuperMethodA(cl,obj,msg));
}
///

///initMUIClass()
struct MUI_CustomClass  *initMUIClass()
{
  return (struct MUI_CustomClass *) MUI_CreateCustomClass(NULL, MUIC_Group, NULL, 
        sizeof(struct MyData), ENTRY(MyDispatcher));

}
///
/*****************************************************************************/
@end verbatim

@menu
* 481 MUI notification through notifiable attributes::
* 482 MUI notification chains::
* 483 MUI warnings about using notified attributes::
@end menu

@node 481 MUI notification through notifiable attributes
@subsection 4.8.1 MUI: notification through notifiable attributes
@anchor{#mui-notification-through-notifiable-attributes}
We have already mentioned the case where changing the value of an
attribute leads to the execution of an action. In our case the attribute
was already provided by the MUI class that we were using, more precisely
we are referring to the MUIA_Pressed attribute. We could think that
changing a value of any attribute of a MUI class triggers our function
according to the above mentioned rules, but this is not completely true.
Actually only some attributes of each of MUI classes can trigger an
action everytime their value changes. First of all let's explicit a
concept we have only silently expressed: an attribute is defined
"notifiable" when it allows plugging an action on any change of its
value. As we said, not every attribute provided by a MUI class is
notifiable; moreover attributes of our private classes are not
notifiable unless we explicitely make them so. There are specific rules
to respect in case we want to make an attribute of our private class
notifiable, so to be able to plug it to an action triggered by some
other class. To better understand, now it's time to list the object
packet (the message) of the OM_GET method:

@verbatim
struct opGet
{
  STACKED ULONG  MethodID;      /*OM_GET                             */
  STACKED Tag    opg_AttrID;    /*attribute to be read               */
  STACKED IPTR   *opg_Storage;  /*memory area that contains          */
                                /*the attribute value requested      */ 
};
@end verbatim

The message handling by the Get method of a class is quite easy: the
function designated to overload the OM_GET method will simply check if
inside opg_AttrID there is the ID of an attribute belonging to its own
class. If the answer is positive, the function will use the opg_Storage
memory area, putting the value of the requested attribute; finally the
function will return TRUE. This latest value, according to BOOPSI rules,
indicates that the operation succeded. If, on the other hand, opg_AttrID
does not contain any known attribute, the function will push the message
upwards to the superclass, as usual.

We have now explained the main steps concerning the OM_GET method
because the first and most important rule of MUI to obtain an notifiable
attribute is to make it readable "outside", or - using a better word -
our attribute must be "gettable".

Obviously we need our attribute to trigger a notification only if the
new value is not equal to the current value of the attribute. For
example, if our attribute's value is TRUE, we don't want to be informed
that it is being "changed" again to TRUE. In order to do so, there's
only to overwrite the ID in the ti_Tag field of our attribute's OM_SET
message with TAG_IGNORE. This way we will also avoid weird situations.

Now we have all the theoretical elements to make our attribute
notifiable, so there's only to show a practical example.

Let's say the we have three classes, binded by a hierarchical link:
Class1 and Class2 are known to Class3 but they're in direct contact.
This could be a representation of these relationship:

@verbatim
Classe1--->Classe3<---Classe2
@end verbatim

Each of these classes has a private data area which is only known to
each other, respecting the concept of information hiding. Let's also
suppose that each of these classes has its own set of attributed and
public methods. Now we want that when the value of the MUIA_Class1_Attr1
attribute changes to TRUE, Class2 executes its own MUIM_Class2_Method2
method. First of all, concerning Class1 we will have a situation like
the following:

@verbatim
*******************************************************************************
struct dataArea1
{
  LONG attr1;
  ....
};

*******************************************************************************
....
//method OM_GET
IPTR GetClass1(struct IClass *cl,Object *obj,struct opGet *msg)
{
  struct dataArea1 *data = INST_DATA(cl, obj);

  switch (msg->opg_AttrID)
  {
    case MUIA_Class1_Attr1:
      *msg->opg_Storage = (LONG) data->attr1;
      return TRUE;

    ...
  }

  return DoSuperMethodA(cl,obj,(Msg)msg);
}                                         
*******************************************************************************

//method OM_SET
IPTR SetClass1(struct IClass *cl,Object *obj,struct opSet *msg)
{
  struct dataArea1  *data = INST_DATA(cl,obj);

  {/*code block to read the tags list*/
    struct TagItem *tags, *tag;
    tags=((struct opSet *)msg)->ops_AttrList;

    while (tag=NextTagItem((TAGITEM)&tags))
    {
      switch (tag->ti_Tag)
      {
        case MUIA_Class1_Attr1:
         if (data->attr1==tag->ti_Data) tag->ti_Tag = TAG_IGNORE;
        else                                                                        
          data->attr1 = (LONG) tag->ti_Data;
        break;

        ...
      }
    }
  }

  return DoSuperMethodA(cl,obj,(Msg)msg);
}
....
 
*******************************************************************************
@end verbatim

In this way the attribute MUIA_Class1_Attr1 notifies its own status
change from outside Class1. In order to trigger MUIM_Class2_Method2
let's suppose we have instanced two objects inside Class3, one from
Class1 and the other from Class2:

@verbatim
....

Object *obj1, *obj2;

obj1 = NewObject(Class1->mcc_Class,  NULL, TAG_DONE);
obj2 = NewObject(Class2->mcc_Class,  NULL, TAG_DONE);

....
@end verbatim

Now we only have to link the notification as usual:

@verbatim
DoMethod(obj1,  MUIM_Notify,
        MUIA_Class1_Attr1, TRUE,
        obj2,
        1,
        MUIM_Class2_Method2);
@end verbatim

@node 482 MUI notification chains
@subsection 4.8.2 MUI: notification chains
@anchor{#mui-notification-chains}
In paragraph 4.8.1 we have learned how to make notifiable an attribute
of our class. Often we have a hierarchy of classes where a class on top
of it should be notified of a value changed in an attribute of one of
its subclasses. Let's see the following example of class hierarchy:

@verbatim
Class1-->Class2-->Class3
@end verbatim

Class3 does not know about Class1 since our system respects the
incapsulation and information hiding paradigm. Class2 has an attribute
(MUIA_Class2_Attr2) which value can be that of a Class1 attribute
(MUIA_Class1_Attr1). Also, Class3 has an attribute (MUIA_Class3_Attr3)
which value can be taken from a Class2 attribute (MUIA_Class2_Attr2).

In other words we have a class relationship in which changing value to
attribute MUIA_Class1_Attr1 triggers a notification in Class2 attribute
MUIA_Class2_Attr2; same thing happens for Class3 attribute
MUIA_Class3_Attr3. We observe that Class3 has an instance of Class2 and
Class2 has an instance of Class1:

@verbatim
MUIA_Class1_Attr1 = MUIA_Class2_Attr2 = MUIA_Class3_Attr3
@end verbatim

In order to make all this work, the first thing to do is describe the
OM_GET and OM_SET methods for each one of these three classes, just like
in paragraph 4.8.1. We will have a "instance1" object that will be our
instance of Class1 inside Class2; then, somewhere in Class2 (usually
inside the OM_NEW method) we need the notification:

@verbatim
DoMethod(instance1, MUIM_Notify,
           MUIA_Class1_Attr1, MUIV_EveryTime,
           obj,
           3,
           MUIM_Set,
           MUIA_Class2_Attr2,
           MUIV_TriggerValue);
@end verbatim

MUIV_EveryTime is a special MUI value that instucts the system to catch
any valid change (an actual change of value, that is) in
MUIA_Class1_Attr1 attribute value. MUIM_Set is nothing but our OM_SET
method a bit modified: as we know, OM_SET requires a taglist, but
building such a parameter would be a bit tedious. This is why MUI offers
the MUIM_Set method; it allows to pass parameters without the need of a
taglist, just like in the previous example. MUIV_TriggerValue is another
special value that tells the system to pass on to a method, in our case
MUIM_Set, any value that is being notified through MUIV_EveryTime.
Basically MUI replaces MUIV_TriggerValue with the value that triggered
the notification.

Same behaviour will be observed for MUIA_Class2_Attr2 and
MUIA_Class3_Attr3 while building the following notification:

@verbatim
DoMethod(instance2, MUIM_Notify,
           MUIA_Class2_Attr2, MUIV_EveryTime,
           obj,
           3,
           MUIM_Set,
           MUIA_Class3_Attr3,
           MUIV_TriggerValue);
@end verbatim

Now, everytime MUIA_Class1_Attr1 will change value, this event will
trigger a reaction also on MUIA_Class2_Attr2 and MUIA_Class3_Attr3
attributes.

As the last thing, we can now implement in a different way the example
shown in paragraph 4.5.1, without using hooks or new methods of the
class to be defined. We will only need three notifications: in the
example from paragraph 4.5.1 we had a button, a string and three
attributes that changed when MUIA_Pressed value changed. We can
accomplish all that with the following code:

@verbatim
DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          string,
          3,
          MUIM_Set,
          MUIA_String_Contents,
          "Clicked button");  

DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          button,
          3,
          MUIM_Set,
          MUIA_Text_Contents,
          "Clicked!");

DoMethod(button, MUIM_Notify,
          MUIA_Pressed, FALSE,
          button,
          3,
          MUIM_Set,
          MUIA_Disabled,
          TRUE);
@end verbatim

@node 483 MUI warnings about using notified attributes
@subsection 4.8.3 MUI: warnings about using notified attributes
@anchor{#mui-warnings-about-using-notified-attributes}
In paragraph 4.8.2 we have realized a couple of notifications that in
some way connected three classes to each other:

@verbatim
Class1-->Class2-->Class3
@end verbatim

This connection is one-way only since the attribute notification goes
from Class1 to Class3. Sometimes we would like to also notify
MUIA_Class1_Attr1 when MUIA_Class3_Attr3 changes. In order to do so we
would need to synchronize these value changes, having these
notifications go back and forth; however such connections would lead to
an endless loop of the MUI notification facility offered by MUI:

@verbatim
  -->Class1-->Class2-->Class3--
  |                            |
  -------------Class2<---------
@end verbatim

If we want to overcome this limitation, we should "break" the loop where
it makes sense: on the one hand, when the value change of
MUIA_Class1_Attr1 reaches Class3 and, on the other, when the value
change of MUIA_Class3_Attr3 reaches Class1; after reaching the
designated class and setting the destination attribute accordingly, both
notifications will stop. To do so, we should provide a piece of code
like the following:

@verbatim
DoMethod(obj, MUIM_Notify,
              MUIA_Class3_Attr3, MUIV_EveryTime,
              instance2,
              3,
              MUIM_Set,
              MUIA_Class2_Attr2,
              MUIV_TriggerValue);

DoMethod(instance2, MUIM_Notify,
           MUIA_Class2_Attr2, MUIV_EveryTime,
           obj,
           3,
           MUIM_NoNotifySet,
           MUIA_Class3_Attr3,
           MUIV_TriggerValue);
@end verbatim

The first function call to MUIM_Notify it's easy to understand:
basically we have linked the value changing of MUIA_Class3_Attr3 to
MUIA_Class2_Attr2; we are propagating our notification from Class3 to
Class2. Same thing must be done in Class2 in order to propagate the
notification to Class1. In the second function call to MUIM_Notify we
have used MUIM_NoNotifySet instead of MUIM_Set.

The MUIM_NoNotifySet method executes the same actions of MUIM_Set
without notifying MUI about the changes that are being performed to a
certain attribute. In other words we have performed the first
interruption on our notification loop. Now we have to perform the second
interruption, which will be in Class2:

@verbatim
DoMethod(obj,   MUIM_Notify,
                MUIA_Class2_Attr2, MUIV_EveryTime,
                instance1,
                3,
                MUIM_NoNotifySet,
                MUIA_Class1_Attr1,
                MUIV_TriggerValue);
@end verbatim

@menu
* 4831 Warnings about chained notifications in Zune::
@end menu

@node 4831 Warnings about chained notifications in Zune
@subsubsection 4.8.3.1 Warnings about chained notifications in Zune
@anchor{#warnings-about-chained-notifications-in-zune}
MUI recognizes and manages accordingly the case where there are chained
notifications. In other words, in a situation like the following:

@verbatim
 -->MUIA_Class1_Attr1 --> MUIA_Class2_Attr2 --> MUIA_Class3_Attr3--> MUIA_Class4_Attr4-->
 |                                                                                      |
(#)                                                                                    (#)
 |                                                                                      |
 <--MUIA_Class1_Attr1 <-- MUIA_Class2_Attr2 <-- MUIA_Class3_Attr3<-- MUIA_Class4_Attr4<--
@end verbatim

where (#) represents the loop interruption provided by
MUIM_NoNotify_Set, MUI automatically breaks the "subloops" that could be
generated in between the notifications. To better understand, in the
above situation the following subloop could show up:

@verbatim
 -->MUIA_Class2_Attr2 --> MUIA_Class3_Attr-->
 |                                          |
 |                                          |
 <--MUIA_Class2_Attr2 --> MUIA_Class3_Attr<-- 
@end verbatim

In this case MUI 3.8+ breaks the subloop, preventing any possible
unwanted interaction between notifications, without breaking the
notification chain.

All this does not happen with Zune. In the latest versions Zune
recognizes loops, but the countermeasures are not as quick as in MUI. As
a workaround of this "bug", in Zune there is a further action to be
performed, besides the two MUIM_NoNotifySet at the end of the loops; the
developer has also to decouple the attributes in use. In other words,
when possible, the same attributes should have different labels. In our
example:

@verbatim
 -->MUIA_Class1_Attr1 --> MUIA_Class2_Attr2_X --> MUIA_Class3_Attr3_X --> MUIA_Class4_Attr4-->
 |                                                                                           |
(#)                                                                                         (#)
 |                                                                                           |
 <--MUIA_Class1_Attr1 <-- MUIA_Class2_Attr2_Y <-- MUIA_Class3_Attr3_Y <-- MUIA_Class4_Attr4<--
@end verbatim

In this example MUIA_Class2_Attr2_X equals MUIA_Class2_Attr2_Y and
MUIA_Class3_Attr3_X equals MUIA_Class3_Attr3_Y. What is actually needed
is to declare new labels that in the OM_SET and OM_GET methods will be
used to execute the same actions as of the original labels. Of course
this approach works fine in MUI too, therefore it should be the
preferred method in case of portable applications.

@node 49 MUI synchronizations MUIM_Application_PushMethod and MUIM_Application_KillPushMethod
@section 4.9 MUI: synchronizations, MUIM_Application_PushMethod and
MUIM_Application_KillPushMethod
@anchor{#mui-synchronizations-muim_application_pushmethod-and-muim_application_killpushmethod}
MUI provides that all notifications triggered while iterating the main
event control loop (see paragraph 4.5.2) will be executed inside the
current iteration. What is not guaranteed, however, is the order these
notifications will be executed. Let's see two examples of chain
notifications:

@verbatim
Class1_AttrA --> Class2_AttrA --> Class3_AttrA  --> Class4_AttrA
@end verbatim

and

@verbatim
Class1_AttrB --> Class2_AttrB --> Class3_AttrB  --> Class4_AttrB
@end verbatim

MUI will guarantee that Class4_AttrA and Class4_AttrB will eventually be
notified of the value change of (respectively) Class1_AttrA and
Class1_AttrB during an iteration of the event control loop, but it
doesn't guarantee which one will be notified first or last. In other
words, the two following instructions:

@verbatim
SetAttrs(objFromClass1, Class1_AttrA, value1, TAG_DONE);
SetAttrs(objFromClass1, Class1_AttrB, value2, TAG_DONE);
@end verbatim

can be equally given in opposite order:

@verbatim
SetAttrs(objFromClass1, Class1_AttrB, value2, TAG_DONE);
SetAttrs(objFromClass1, Class1_AttrA, value1, TAG_DONE);
@end verbatim

and it will be exactly the same. The order MUI will set the attributes
Class4_AttrA and Class4_AttrB is not predictable.

This is especially visible in case of long chained notifications with
many methods involved. Although in our code notifications are triggered
in a logical order, it is possible that they will not be executed
according to that order. It is therefore very important to avoid
assumptions about the order execution of our algorithms when they
involve notification chains.

It is however possible to maintain a certain degree of order execution
also in case of long notification chains using a special method, which
main use is not connected to notifications: MUIM_Application_PushMethod.

MUIM_Application_PushMethod takes as parameters a method along with its
arguments and incapsulate them in a private data area of the
MUIC_Application object that had invoked said method. The encapsulated
method is therefore maintained until the following iteration of the
event control loop, actually slowing down its execution.

In other terms, suppose considering the nth iteration of the event
control loop, we can write the following code:

@verbatim
LONG pushIDFoo = 0, pushIDBar= 0;

pushIDFoo = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objFooClass1, 
                        3, 
                        MUIM_Set, 
                        Class1_AttrA, 
                        value1);

pushIDBar = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objBarClass1,
                        3, 
                        MUIM_Set, 
                        Class1_AttrB, 
                        value2);
@end verbatim

this way the attribute Class4_AttrA will be set during the nth+1
iteration of the control loop, and the attribute Class4_AttrB will be
set during the the nth+2 iteration of the control loop.

Starting with MUI 3.9, MUIM_Application_PushMethod returns a value that
identifies the method put into the memory area. This value is useful in
case we would like to manually remove that very method that is being
"pushed".

It's important to note that the private memory area we mentioned before
can be easily filled up if MUIM_Application_PushMethod is invoked too
many times before the following iteration of the event control loop
occurs.

When this buffer is all used, unpredictable situations can arise, a MUI
crash in the worst case. For example when invoked inside our subclass
MUIM_Draw method, or when there are many OM_SET calls to set an
attribute.

In other terms, these dangerous situations show up when the attribute is
set to a temporary value many times before being set to its final value
(imagine the various interim values indicating the position of a
scroller). In order to avoid all this, and in this case only, it is
possible to use a non-documented MUI method (supported by Zune too)
which definition is as follows:

@verbatim
#define MUIM_Application_KillPushMethod 0x80429954
@end verbatim

By invoking this method we will manually remove from the buffer the
previous methods archived for a certain object. Starting from MUI 3.9,
as mentioned before, it is possible to perform a specific method
removal, using the return value of the method
MUIM_Application_PushMethod. In case of previous versions of MUI or
Zune, this value will be ignored and the last method pushed to the
buffer will be removed (the MUIM_Application_PushMethod method returns
TRUE on MUI 3.8 and Zune if the method linked to it has been added to
the private buffer). Our previous code will turn into the following:

@verbatim
if (pushIDFoo)
{
    DoMethod(objApp, MUIM_Application_KillPushMethod,
                objFooClass1,
                pushIDFoo);

    pushIDFoo = 0;
}

pushIDFoo = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objFooClass1,
                        3, 
                        MUIM_Set, 
                        Class1_AttrA,
                        value1);

if (pushIDBar)
{
    DoMethod(objApp, MUIM_Application_KillPushMethod, 
              objBarClass1, 
             pushIDBar);

    pushIDBar=0;
}

pushIDBar = DoMethod(objApp, MUIM_Application_PushMethod, 
                        objBarClass1, 
                        3, 
                        MUIM_Set, 
                        Class1_AttrB,
                        value2);
@end verbatim

Of course this piece of code also works in case of MUI 3.9 and earlier
versions, Zune included, since the "pushIDxxxx" of the message
definition of the earlier versions of MUIM_Application_KillPushMethod
have that flag set to zero.

@node 410 MUI a bit more about hooks private methods and notifications
@section 4.10 MUI: a bit more about hooks (private methods and
notifications)
@anchor{#mui-a-bit-more-about-hooks-private-methods-and-notifications}
Until now we have learned how to implement public attributes and methods
for our classes, without expliticing the concept of private attributes
and methods. It is clear that private attributes and methods are nothing
but variables and functions used inside a class itself. We know how the
BOOPSI standard identifies public attributes and methods through symbols
we declare; think of our previous examples:
MUIM_MUIClassTutorial_ClickBut, MUIA_Class1_Attr1 and so on.

We have also shown the so called notifiable attributes, that are simply
public attributes implemented following specific rules that allow
alerting MUI of their value change. Actually we have already mentioned
how to manage private attributes and methods: using hoooks (paragraph
4.5.1). Using a hook allows us declaring a function just like a public
method, without having this new function to be known outside the class
itself, according to BOOPSI ruling. In other words, if used correctly,
hooks can be a powerful tool to improve the encapsulation of our class,
as long as the hook is not reachable from outside the class that is
implementing and using it.

In our first example, where we had a button and a string linked through
a notification, we were inside the class that declared these objects,
therefore using a hook to implement the notification would have been the
best solution. On the other hand, when we have to connect two objects
belonging to two different classes, our choice would be to implement the
notification through a public method or a notifiable attribute.

Now let's recap briefly, we have learned that a MUI class can have:

@itemize
@item
Private attribute: these are variables declared inside the private data
area of our class and are not associated with any symbol.

@item
Public attribute: these are variables (usually) declared inside the data
area of the class and they are associated in OM_NEW/OM_SET/OM_GET to
symbols (e.g. MUIA_Class1_Attr1).

@item
Notifiable attributes: these are public attributes which value change is
catched and/or modified by MUI through methods such as MUIM_Notify and
MUIM_Set.

@item
Private methods: these are utility functions, defined and used inside a
class, but not associated to any symbol;

@item
Private methods linkable to notifications: these are functions
associated to hooks, listening to the value change of notifiable
attributes through methods such as MUIM_Notify and MUIM_CallHook;

@item
Public methods: these are functions declared and defined that are
associated in the class dispatcher to symbols (e.g.
MUIM_MUIClassTutorial_ClickBut) and linked to notifiable attributes
through MUIM_Notify;

@end itemize

@node 411 MUI macro shortcuts
@section 4.11 MUI macro shortcuts
@anchor{#mui-macro-shortcuts}
On many occasions, while being compliant to the OOP paradigm, there are
objectively problems, let's think of the already mentioned
MUIM_Application_PushMethod. This method belongs to the MUIC_Application
class, but in many cases it would be also useful using it inside objects
of our subclasses from an instance of MUIC_Application, even though - in
theory - these objects should not be allowed to directly communicate
with the instance.

When such an situation (and many other) occurs, instead of passing
important addresses through subclasses that are not supposed to know
that kind of external detail, it is possible to use the so called MUI
shortcuts. It is not advisable to always use these shortcuts, you have
to know what you're doing; also - from a theoretical standpoint - they
break the OOP paradigm. In brief, pay attention to avoid creating
spaghetti-code.

Let's make another example: suppose we have a generic "obj" object. Some
of the most used MUI shortcuts are:

@verbatim
_app(obj) = returns the MUIC_Application instance containing our object;
_win(obj) = returns the MUIC_Window instance containing our object;
@end verbatim

Namely these two shortcuts are usable only after the MUIM_Setup has been
invoked from our MUI subclass and before MUIM_Cleanup has been invoked.
So, for example, if these shortcuts are being used inside a OM_NEW or
OM_DISPOSE method the application would crash.

Although these MUI shortcuts has been provided to create low level
graphic classes (just have a look at the sources of some MUI classes
like TextEditor MCC and similar classes), by using them our code is able
to invoke methods outside of our subclass without getting us mad trying.

It is suggested to read the mui.h header to find all the available MUI
shortcuts and learn when they can be used.

@node APPENDIX B Subversion on Amiga
@chapter APPENDIX B: Subversion on Amiga
@anchor{#appendix-b-subversion-on-amiga}
@emph{"And given how Amiga software looks today, it appears to me that
not everyone who should have read this book really did know."} Olaf
Barthel about the book "The User Interface Style Guide", 26/11/1996
comp.sys.amiga.programmer

@emph{"It's really high time the RKMs are taken care of."} Olaf Barthel
comp.sys.amiga.programmer 12/09/1997
@menu
* B1 Introduction::
* B2 What is a repository::
* B3 What is a review::
* B4 Collaborate in projects that use Subversion::
* B5 Command SVN::
* B53 Update update their local files to the latest version::
* B6 svnadmin creation of own projects::
@end menu

@node B1 Introduction
@section B.1 Introduction
@anchor{#b.1-introduction}
Subversion is a set of programs that allows different developers to work
simultaneously with one or more files. Using Subversion is also
recommended in projects where working as a single person, because the
use of these programs involves a number of advantages:

@itemize
@item
The ability to edit any file in real time anywhere;

@item
The ability to maintain different versions on synchronized different
machines automatically and without bothering to copy from one machine to
another, the latest version;
@item
The possibility of returning to earlier revisions of their work at any
time, instead of going crazy trying to remember what changes were made
from some period onwards;

@end itemize

We can therefore define Subversion as a set of programs for clean and
transparent management of its work.

The interaction between different users within the same project is
through a main server, which receives project files with whom they are
collaborating. A user downloads onto their computer a file copy of the
project in which they are interested in, making their changes and then
sends them to the main server, Subversion will then integrate them
properly with the version of project resident on the server.

@node B2 What is a repository
@section B.2 What is a repository
@anchor{#b.2-what-is-a-repository}
Subversion is a system for sharing information that works using a data
store, in the jargon "repository". Repository stores information
hierarchically, being used as our computer files and directories. One or
more computers can connect to the repository and read or write these
files. Obviously the repository is located on a remote server.

@node B3 What is a review
@section B.3 What is a review
@anchor{#b.3-what-is-a-review}
One of the concepts that underpins the functioning of Subversion is that
of revision. Suppose we have on our Amiga a text file, pippo_r0.txt, and
then go and edit, then save the edited file with another name, for
example pippo_r1.txt. We will in this situation have two files, separate
from the fact that the second represents a modernized version of the
first. File pippo_r0.txt 0 we can define the revision of our files,
while pippo_r1.txt is identifiable as the revision 1 of the same file. A
review is therefore a copy, or rather a "snapshot" (snapshots) than one
file at a given moment of its existence. Each time we send successfully
a change to the files of a project managed on a server to Subversion,
the repository will be responsible for creating a revision of the file
before our changes, so that allow us to recover any of the work done
before accidental loss. This is one of the strengths of projects using
Subversion: the ability to recover any data when a review of one or more
files of a project without tasking our computer to manage different
copies manually. As mentioned, those who perform the operations and
maintenance control revisions in the repository, which remembers every
change has been made in it: it will consider any change made to every
file and directory. When a computer reads the data from the repository,
normally seeing only the latest revision of the directory tree. In
reality, it also has the chance to see a previous review of the tree
directory.

@node B4 Collaborate in projects that use Subversion
@section B.4 Collaborate in projects that use Subversion
@anchor{#b.4-collaborate-in-projects-that-use-subversion}
To collaborate on a project that uses Subversion you only have to have
an account on the server that hosts the project and the Subversion
package installed on your Amiga. Usually all of these programs are on
Aminet, os4depot and other sites of this kind.

@node B5 Command SVN
@section B.5 Command SVN
@anchor{#b.5-command-svn}
The suite contains a number of Subversion commands to be given to the
Shell, SVN is one of the main. The SVN command controls most of the
actions used to collaborate in a project already started. Of particular
relevance is the version of svn and the server with which you interact.
More specifically, some new servers, such as code.google.com, require
identification through SSL, which is supported in the Amiga version 1.7
of Subversion (a port of version 1.1.4), So if you have a version
earlier than 1.7 you cannot access projects that reside on this server
from your Amiga. As mentioned, the command svn allows enough interaction
to complete existing projects, using appropriate options among those
offered by this command. Options used most frequently are:

@itemize
@item
Checkout (or co): allows you to download to your harddisk all files of a
project;
@item
Diff: shows the differences between the local review (harddisks) and the
Journal of the repository;
@item
Update (or up): upgrade to the latest revision of a file copying project
on your harddisk;
@item
Resolved: alerts the server that we have eliminated the possible
conflicts that were present in our local copy that prevented it to send
/ integrate their resident version on the repository design changes;
@item
Revert: allows you to restore one or more local files replacing them
with the files on the repository;
@item
Add: shows which new files will be added to project's repository;
@item
Delete: indicates which files will be removed from a project's
repository;
@item
Commit: send your changes to the repository that will deal with
integrity;
@end itemize

@menu
* B51 Checkout download the source code of a project::
* B52 Diff preview of the differences between local files and Review the repository::
@end menu

@node B51 Checkout download the source code of a project
@subsection B.5.1 Checkout, download the source code of a project
@anchor{#b.5.1-checkout-download-the-source-code-of-a-project}
As we mentioned, the projects managed with Subversion reside on a server
that supports this suite of programs. Among the most popular server we
have those provided by portals and sourceforge.net, code.google.com, The
first accepts and agrees for most software projects, while the second
also hosts projects which are not necessarily the sources of software,
but also documentation and guides works.

Suppose we want to collaborate on a project that resides on sourceforge
portal, for example NoWinED. The web page of this project is:

@verbatim
http://sourceforge.net/projects/nowined/
@end verbatim

This page has a series of choices to be made by the browser, including
at the top is the link to "Code". This link leads to a javascript menu
on which are listed, among other items, SVN and SVN Browser. The second
is simply a way to see parts of the code that make up the project
directly from the browser, while The first link is what we are concerned
with. After selecting SVN link from the site, we will enter a page that
displays another link immediately preceded by the svn command. This
string is what you type subsequently in our Shell. Attention, followed
by the svn co will create the directory inside the current one in which
the Shell is a directory containing all files the project is accessing,
then before you type svn the Shell must position themselves exactly to
the location where we want this directory to be created. Then write in
the Shell:

@verbatim
svn co https://nowined.svn.sourceforge.net/svnroot/nowined nowined
@end verbatim

After typing this command the program will download from the svn site
all the files needed to create a working copy of the draft in which we
participate, in our case, all files will be included in a directory
named nowined.

We have therefore introduced a first parameter of the command svn co, or
also checkout, which would serve to download from a repository all the
files that make up a project, automatically creating all the necessary
directories.

Typically the files that we are interested in are in the program
directory / trunk /. Each project obviously has it's own directory
structure within the trunk, for example NoWinED currently has two
directories inside trunk.

Svn The command also creates in each directory private subdirectories
that "monitor" further, called. "svn". Just keep in mind that the
directories by name. "Svn" are for Subversion to perform their duties
and should not be modified or deleted.

@node B52 Diff preview of the differences between local files and Review the repository
@subsection B.5.2 Diff, preview of the differences between local files
and Review the repository
@anchor{#b.5.2-diff-preview-of-the-differences-between-local-files-and-review-the-repository}
After changing one or more files of a project, before sending the
repository your changes, you may feel the need to view from a global
point of view all of the changes you've made to the project. To achieve
this the program svn can generate an output that displays all of our
changes compared to the last revision of the project on the server.

Also, usually every project has the person which needs to review before
sending your changes first. Such persons may require you to analyze your
changes before eventual integration with the project.

To get a file containing the changes we have made simply type in the
Shell, placed in the directory where you downloaded the project with
svn:

@verbatim
svn diff > RAM: diff.txt
@end verbatim

In this way we will get in RAM: the file that will contain what diff.txt
we need to reassure operators of the project which we want to cooperate.

The output has a similar option diff syntax:

@verbatim
Index: file2
==================================================
--- File2 (revision 46)
+ + + File2 (working copy)
@ @ @ @ -1.7 +1.12


- LINE REMOVED
+ LINE ADDITION
@end verbatim

lines erased than copying the repository are preceded by a -, while the
added lines are preceded by a +.

@node B53 Update update their local files to the latest version
@section B.5.3 Update, update their local files to the latest version
@anchor{#b.5.3-update-update-their-local-files-to-the-latest-version}
And 'good practice, prior to submission of amendments to main server,
synchronize the files on your computer with those residing in the
official repository of the project in which we're cooperating. The
upgrade could save any estimate of problems of incompatibility between
local files and those on the repository and above all else allows you to
verify whether your changes are or not compatible with the latest
version of the project we're working. To update our working copy with
the one on the repository Just place go in the Shell to the directory
that contains the project files we're working together and write:

@verbatim
svn update
@end verbatim

or:

@verbatim
svn up
@end verbatim

Option update (and up) allows you then to download files more updated by
the server that maintains the official version of the project in which
we cooperate. Subversion will synchronize all files if everything went
through. If we wanted to retrieve from the server instead a particular
revision of one or more files we should type:

@verbatim
svn up-r numeroRevisione
@end verbatim

In this way we could retrieve such a file we accidentally overwrote on
the same repository so as to restore any changes we made several
revisions before and lost in the most recent revisions

B.5.4 Revert, resolve conflicts

A common enough occurrence when working on a project with Subversion is
the possibility of incurring conflicts. Conflict occurs when a file has
been modified locally, which in turn is changed even in its official
version on the repository. Svn command during the update procedure warns
us of conflicts through a particular symbology. If for example, we have
updated three files to the repository, two of which were also modified
locally we have a situation Similarly, displayed as output to Shell:

@verbatim
:> svn update
U file1
G file2
C file3
Updated to revision 46.
@end verbatim

We can see three codes output: U, G and C. U indicates that the files
Rooms have been updated successfully, G indicates that the changes sent
to the server have been successfully integrated with our modifications
while C indicates that there was a conflict to be resolved manually
before attempting to submit the changes to the repository. Subversion
behaves differently depending on the nature of the conflict met.

In the case of minor changes, Subversion might consider such integration
changes of the official version on the repository easily, For this
purpose the program puts markers of conflict, which are simply special
strings of text that surround the "extreme" of the problem within the
file. Thus Subversion makes visible the changes of problems that can be
integrated. In other words we will charged within a situation this:

@verbatim
<<<<<<<. Landmines
Our changes
=======
OFFICIAL CHANGE
>>>>>>>. R2
@end verbatim

In the case of larger conflicts, for each file in which a problem was
detected, put in your Subversion working copy three extra files that are
not under the control of the program:

file.mine: This is the file that was in the working copy first upgrade.
This file contains the latest changes done and nothing else. (If
Subversion considers the file not able to be integrated, then the file.
mine is not created, because it could be identical to the working file);

file.OLDREV: This is the file that was checked out before recent changes
we have made;

file.NEWREV: This is the file that has just been received from the
server svn you did when you updated the working copy;

At this point, Subversion will not allow you to send any changes to the
server until the three temporary files are removed.

We therefore must decide how to intervene to resolve conflicts: we will
have to choose the most appropriate modification, eliminate what to
discard, or combine in a single block / file both changes. You can also
choose to discard your changes in favor of those in the revision of the
file on the server, to obtain this just type:

@verbatim
svn revert file
@end verbatim

So with the option remove revert our changes locally, the file locally
will accept the version of the file on the repository.

After resolving the conflicts simply type:

@verbatim
svn resolved
@end verbatim

to notify the repository that we have solved everything.
@menu
* B55 Add and delete add and remove files::
* B56 Commit sending and integration of changes::
@end menu

@node B55 Add and delete add and remove files
@subsection B.5.5 Add and delete, add and remove files
@anchor{#b.5.5-add-and-delete-add-and-remove-files}
In the event that you have created new files to integrate into the
project which you are working, svn offers the option svn add. With add
it is reported that at the next commit changes to files on repository,
will be added and also sent the new files. The managers of a project
might want to see these new files, after using add, svn diff is invoked
if the output of this option displays the changes between the content of
the new file. If we want to point out the need for Subversion to remove
some files from the project we're working together we type:

@verbatim
svn delete fileCancelled
@end verbatim

@node B56 Commit sending and integration of changes
@subsection B.5.6 Commit, sending and integration of changes
@anchor{#b.5.6-commit-sending-and-integration-of-changes}
If all the steps described until now have been successful, and managers
of the project have willingly accepted your changes by sending the
differences (diff), it is time to send your changes to the repository.
To achieve this move to the directory in the shell that contains the
project files and type:

@verbatim
svn commit-m "commentoAlleMieModifiche"
@end verbatim

The-m flag tells SVN to attach a comment to the modifications that they
are sending to the official repositories, not mandatory, but strongly
recommended in order to make others understand what our changes consist
of. If you omit the-m flag a window will be opened of the program and
where you must enter the edit comment. At this point, you may be asked
the root password that is not usually possessed, just simply type send,
then you will only require the first time your userid (the same as Your
account on the server), and a password (which in the case of SourceForge
is the password for your account, while in the case of Code. Google will
be the one given to you by your project). This way your changes will
represent the current review present in the repository.

@node B6 svnadmin creation of own projects
@section B.6 svnadmin, creation of own projects
@anchor{#b.6-svnadmin-creation-of-own-projects}
So far we have dealt only with how to interact with existing projects.
If we wanted to create from scratch a new project that uses Subversion
we will have to use another svn tool package, the command svnadmin.
However, before using this command it is good to exhibit assumptions
regarding the choice of the server to be used for their design and
structure the directory you will create.
@menu
* B61 Server custom or already prepared?::
* B62 Preparing the necessary files and creation of the repository::
@end menu

@node B61 Server custom or already prepared?
@subsection B.6.1 Server custom or already prepared?
@anchor{#b.6.1-server-custom-or-already-prepared}
You can create your own project that uses Subversion and employs space
usually provided by your ISP or other services such as Altervista, but
such a choice involves a number of risks and limitations. The biggest
problem with the choice of server is usually the obligation of having to
install Apache, that serves in this case to restrict access to visitors,
in so that the administrator of the server (ie us) is the only one able
to possibly delete the repository. Without Apache anyone could destroy
all of our work, we also have to have prior knowledge of the Apache
package.

Fortunately, there are portals that make a specific server ready for use
with Subversion, among them SourceForge and Code.Google are certainly
the most known. Each these portals allows the administrator to easily
set the rules of access to their projects, configure the visibility of
files belonging to the project (for example if we had a closed source
project we will not want to give access to its sources to everyone), the
removal and addition of users who collaborate to project, and much more.

There are some differences between SourceForge and Code.Google:

@itemize
@item
SourceForge allows users to send data using the sourceforge account
password, and Code.Google provides a password auto generated and known
only to the administrator;

@item
SourgeForge does not accept projects that do not relate to programming
in other words within the repository of SourgeForge are accepted only
source files and the like. You are also obliged to choose a license from
those listed or propose their own, but licenses such as Creative Commons
will not be allowed to SourgeForge. All this does not exist on
Code.Google;

@item
Code.Google allows interaction with your server via SSL, So prior to
version 1.7 of Subversion on Amiga not Code.Google work with, while on
SourceForge it does not have these problems (yet);

@end itemize

Code.Google provides a user-created tree for each project Directory
typical of a SVN repository, and SourceForge requires more attention
when the user will have to create its standard directory tree;

Once you choose the portal to use and have created the necessary
account, the site will provide you a URL that will be the homepage of
your project (see section B.5.1) in it as usual you will find links that
will be used with the command svn (see section B.5.1) and also with the
svnadmin command. For example, if the project was registered as
"MyProject" in SourgeForge:

@verbatim
https://nowined.svn.sourceforge.net/svnroot/MyProject
@end verbatim

while Code.Google you:

@verbatim
https://myproject.googlecode.com/svn/trunk
@end verbatim

@node B62 Preparing the necessary files and creation of the repository
@subsection B.6.2 Preparing the necessary files and creation of the
repository
@anchor{#b.6.2-preparing-the-necessary-files-and-creation-of-the-repository}
To create our own repository you must first do these actions in the
Shell. First, in RAM:

@verbatim
cd RAM:
@end verbatim

At this point we create directories that will host temporarily our
project:

@verbatim
MAKEDIR temp
MAKEDIR temp/MyProject
@end verbatim

If the chosen server is provided by SourgeForge at this point must
create other directories:

@verbatim
MAKEDIR RAM:temp/MyProject/branches
MAKEDIR RAM:temp/MyProject/tags
MAKEDIR RAM:temp/MyProject/trunk
@end verbatim

This guide is does not presently discuss in detail the use of these
three directories, so for further information you should refer to the
complete guide for Subversion
(http://svnbook.red-bean.com/nightly/it/svn-book.html), suffice it to
say the trunk directory will contain all the files in your project while
branches and tags directories will remain (for now) empty. Directories
branches, tags, and trunk are not actually required by Subversion, they
simply represent a common convention most likely to be followed.

It is time to create a temporary directory destination (temporary
repository):

@verbatim
MAKEDIR RAM:svnroot
@end verbatim

At this point you can put all the files in your project within
ram:temp/MyProject/trunk/. Now it is possible to create the actual
repository:

@verbatim
svnadmin create /ram/svnroot/repos
@end verbatim

Finally, we must import all the files in the remote repository that we
created so far, to the URL we use for our SVN server (section B.6.1):

@verbatim
svn import /ram/temp/MyProject URL_DEL_VOSTRO_PROGETTO -m "initial import"
@end verbatim

During these steps you may be requested to login, that which we have
already described (section B.5.6). Thus we have finally got the
repository for our project, there is nothing left to do but find a
suitable space on our harddisk and type:

@verbatim
svn co URL_TO_YOUR_PROJECT MyProject
@end verbatim

The directory will be created on the harddisk. As usual the local copy
of our project will be resident on the remote repository. Directories in
RAM were temporary and therefore should be removed.

@bye
