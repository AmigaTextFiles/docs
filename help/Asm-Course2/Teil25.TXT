          A S S E M B L E R - K U R S       (c)  Jeff Kandle 1990

                                25.Teil...

So, noch ein paar Tips zum TDD und dann gehts weiter.

Ihr koennt natuerlich auch gepackte Files auf die Disk `Tracken`, und sie
dann von dem TDD einladen lassen. Ich will mal kurz erklaeren wie da mit
Bytekiller-Files gemacht wird.

1. Demo/Intro packen.
2. Gepacktes File in den Speicher laden.
3. Ohne Hunks wieder abspeichern
4. Mit Amon auf die Disk Tracken.
5. TDD Bootblock schreiben.

Beim Bytekiller ist es so das die Decrunchroutine PC-Relativ geschrieben
ist, und deshalb ueberall laeuft. Ihr koennt sie deshalb ueberall hinladen.
Ausser halt dahin wo das entpackte liegt.
Ich habe mir angewoehnt meine Intro`s immer erst ab $38000 zu beginnen.
Dann habe ich immer knapp 100 KB zur verfuegung um darin das gepackte unter
zu kriegen.
Beim Bytekiller speziell sieht es so aus das die ersten 34 Bytes,
Hunk_Codes sind. Deshalb muesst ihr wenn ihr das File geladen habt, mit dem
Abspeichern um 34 Bytes spaeter beginnen.

Beispiel:
Ihr habt das vom CLI lauffaehige Intro nach $40000 geladen, dann muestt ihr
es ab $40022 abspeichern. Dann faengt es genau mit dem ersten Befehl der
Entpackroutine an.
Das mit dem Tracken muesst ihr dann selber ausrechnen. Bitte denkt daran,
das ihr auch bei der Laenge auf die naechste 512($200) Byte aufrunden
muesst. Bei anderen Werten kann es schwierigkeiten geben.

Wenn ihr euch jetzt ein bisschen mit der Bootblock-Programmierung
beschaeftigt, dann empfehle ich euch das Studium der Librarys. Die
Funktionen sind zwar sehr langsam, aber da wir ja nicht grosses machen ist
es ganz nuetzlich sie zu kennen. Denn so ein Aufruf zu einer bestimmten
Funktion ist sicherlich kuerzer als wie wenn man diese Funktion selber in
den Bootblock schreibt.

Ich habe auf einer Diske noch einen Bootblock-Source gefunden. Er zeigt was
man wenn man ein bisschen geschickt programmiert, alles mit dem Bootblock
anstellen kann.

Ich habe den Source ein bisschen Editiert, aber nur die Befehle selber
verrueckt und das ganze der lesbarkeit halber etwas auseinander gezogen.
Den Rest habe ich so gelassen, denn wer einen solche Bootblock schreiben
kann, der verdient es das man ihn erwaehnt.

Hier erstmal der Source...

ORG     $40000
LOAD    $40000

Bootblock:
        dc.b    "DOS",0
        dc.l    0


        dc.l    $00000370

; Library Addressen und Offsets

Execbase=       4

OldOpenLibrary= -408
InitBitMap=     -390
InitRastPort=   -198
ClearScreen=    -48
RectFill=       -306
FindResident=   -96
ScrollRaster=   -396
Text=   -60

; ChipAddressen

OffsetBase=     $dff000
VPOSR=  $6
DMACON= $96
BPL1MOD=        $108
BPL2MOD=        $10a
DIWSTRT=        $8E
DIWSTOP=        $90

; Konstanten

SETCLR= $8000
DMAEN=  $100
DIWSTRTV=       44
DIWSTRTH=       129
DIWSTOPV=       244
DIWSTOPH=       193

; Hardware Register

LeftMouseButton=        $bfe001

; Tabellen

RastPort=       $70000
BitMap= $70200
Copperlist=     $7a000
JumpAddr=       $6c

Start:  movem.l d0-d7/a0-a6,-(sp)       ; Alle Register auf Stack retten

; graphics.library oeffnen

        Move.l  execbase,A6
        Lea     Gfxlibname(PC),A1
        Jsr     OldOpenLibrary(A6)      ;Graphics Library oeffnen
        Move.l  D0,A6                   ;Gfxbase nach A6

; Bildschirm Variable initialisieren

        Lea     OffsetBase,A0
        Move.w  #SETCLR+DMAEN,DMACON(A0)
        Move.w  #6,BPL1MOD(A0)
        Move.w  #6,BPL2MOD(A0)
        Move.w  #DIWSTRTV*$100+DIWSTRTH,DIWSTRT(A0)
        Move.w  #DIWSTOPV*$100+DIWSTOPH,DIWSTOP(A0)

; Init Copperlist

        Lea     Copperlist,A0
        Move.l  #$00e00005,(A0)+        ; MOVE $5 -> BPL1PTH
        Move.l  #$00e29000,(A0)+        ; MOVE $9000 -> BPL1PTL
        Move.l  #$01001200,(A0)+        ; MOVE 1 -> BPU0 & 1 -> COLOR
        Move.l  #$01800000,(A0)+        ; MOVE 0 -> COLOR0
        Move.l  #$01820000,(A0)+        ; MOVE 0 -> COLOR1
        Lea     Copperlist,A0
        Move.l  A0,50(A6)               ; GfxBase+50

; BitMap initialisieren

        Lea     BitMap,A0               ; BitMap
        Move.w  #1,D0                   ; depth
        Move.w  #368,D1                 ; width
        Move.w  #220,D2                 ; height
        Jsr     InitBitMap(A6)
        Move.l  #$58e62,BitMap+8        ; erstes BitPlane

; RastPort initialisieren

        Lea     RastPort,A1             ; rastport
        Jsr     InitRastPort(A6)
        Move.l  #BitMap,RastPort+4      ; BitMap Addresse -> RastPort
        Jsr     ClearScreen(A6)         ; Bildschirm loeschen

; Kaestchen in die Copperliste schreiben

        Lea     Copperlist+20,A0        ; Ende der Copperliste -> A0
        Move.w  #175,D7
        Move.l  #$2c09fffe,D5           ; WAIT 8, 44
EinsVertikal:
        Move.l  D5,D0
        Move.w  #15,D6
Horizontalline:
        Move.l  D0,(A0)+
        Move.l  #$1800000,(A0)+         ; MOVE $000 -> COLOR0
        Addi.l  #$e0000,D0              ; WAIT Oldx+15, Oldy
        Dbf     D6,Horizontalline
        Addi.l  #$1000000,D5            ; WAIT 8, Oldy+1
        Dbf     D7,EinsVertikal
        Move.l  #28,D7                  ; Kaestchenhoehe = 10
        Lea     Textscrollfeld(PC),A4
AppendCopList:
        Move.l  (A4)+,(A0)+             ; Scrollfeld malen anhaengen
        Dbf     D7,AppendCopList

; The P.R.O.F.I. auf BitMap malen

        Lea     BobTab(PC),A5
        Move.w  #30,D7                  ; The PROFI = 31 Vierecke
InitBob:
        Lea     RastPort,A1             ; RastPort
        Clr.l   D0                      ; xl
        Clr.l   D1                      ; yl
        Clr.l   D2                      ; xu
        Clr.l   D3                      ; yu
        Move.b  (A5)+,D0                ; xl
        Addi.w  #25,D0                  ; xl+25
        Move.b  (A5)+,D1                ; yl
        Move.b  (A5)+,D2                ; xu
        Addi.w  #25,D2                  ; xu+25
        Move.b  (A5)+,D3                ; yu
        Jsr     RectFill(A6)
        Dbf     D7,InitBob

; Farbtabelle spiegeln auf 44 Farben

        Lea     Farbtabelle(PC),A0
        Lea     Farbtabelle+80(PC),A1
        Move.w  #20,D7
SpiegelFarbtabelleLoop3:
        Move.w  (A0)+,-(A1)
        Dbf     D7,SpiegelFarbtabelleLoop3

        Lea     Dummy(PC),A0
        Move.l  JumpAddr,2(A0)          ; -> jmp ($6c)
        Lea     TextScrollen(PC),A0
        Move.l  A0,JumpAddr             ; -> jmp Textscrollen

Mainloop:

; Farben in die Copperliste eintragen

        Move.w  #21,D7
        Lea     Copperlist+26,A0
        Lea     Farbtabelle(PC),A5
        Move.w  (A5),-8(A0)
FCLop0: Move.w  #7,D4
FCLop1: Move.l  A5,A1
        Move.w  #15,D6
FCLop2: Move.w  (A1)+,(A0)
        Addq.l  #8,A0
        Dbf     D6,FCLop2
        Dbf     D4,FCLop1
        Addq.l  #2,A5
        Dbf     D7,FCLop0

; Farbtabelle rotieren

        Lea     Farbtabelle(PC),A0
        Lea     Farbtabelle+2(PC),A1
        Move.w  #38,D0
        Move.w  (A0),D1                 ; farbe0 -> dummy
RotateFarbtabelle:
        Move.w  (A1)+,(A0)+
        Dbf     D0,RotateFarbtabelle
        Move.w  D1,-(A1)                ; dummy -> farbe44

; Warten bis Elektronenstrahl in Zeile 64 ist (WaitTOF)

WaitTOF:
        Cmpi.b  #64,OffsetBase+VPOSR
        Bls.s   WaitTOF

        Btst    #6,LeftMouseButton      ; Mousebutton gedrueckt
        Bne.s   MainLoop                ; falls nein -> Mainloop

; Programm beenden

        Lea     Dummy+2(PC),A0
        Move.l  (A0),JumpAddr
        Lea     Dummy+10(PC),A1
        Move.l  #$20646f73,(A1)         ; " dos"

        Movem.l (sp)+,d0-d7/a0-a6
        Lea     Dummy+11(PC),A1         ; Name = dos.library
        Jsr     FindResident(A6)
        Move.l  D0,A0
        Move.l  22(A0),A0
        Clr.l   D0
        Rts

TextScrollen:
        Movem.l d0-d7/a0-a6,-(sp)
        Lea     RastPort,A1             ; RastPort
        Move.w  #1,D0                   ; dx
        Clr.w   D1                      ; dy
        Clr.w   D2                      ; minx
        Move.w  #198,D3                 ; miny
        Move.w  #351,D4                 ; maxx
        Move.w  #206,D5                 ; maxy
        Jsr     ScrollRaster(A6)
        Lea     Scrolltext-2(PC),A0
        Subi.b  #1,(A0)
        Bne.s   Bra2
        Move.b  #9,(A0)
        Lea     Scrolltext-1(PC),A0
        Eori.b  #1,(A0)
        Lea     RastPort,A1
        Move.w  #320,36(A1)             ; Current Pen Position x
        Move.w  #205,38(A1)             ; Current Pen Position y
        Lea     AktBuchstabe(PC),A2
        Addq.b  #1,(A2)
        Cmpi.b  #Textende-Scrolltext,(A2)       ;Anzahl der Buchstaben
        Bne.s   PrintBuchstabe
        Clr.b   (A2)
PrintBuchstabe:
        Lea     Scrolltext(PC),A0
        Adda.w  -1(A2),A0               ; string
        Move.l  #1,D0                   ; count
        Jsr     Text(A6)                ; A1=RastPort

Bra2:   Lea     Copperlist+6,A1
        Lea     Scrolltext-1(PC),A0

; Scrollen des grossen Schriftzueges
; er wird durch veraendern der HintergrundBitmap Startaddresse
; gescrollt.

        Tst.b   (A0)
        Beq.s   Scrollrunter
        Addi.w  #46,(A1)                ; Scrollwert * 46
        Bra.s   Hochgescrollt
Scrollrunter:
        Subi.w  #46,(A1)                ; Scrollwert * 46
Hochgescrollt:
        Movem.l (sp)+,d0-d7/a0-a6
Dummy:  Jmp     $ffffffff

Gfxlibname:
        dc.b    "graphics.library",0

AktBuchstabe:
        dc.b    $ff

Farbtabelle:
        dc.w    $005,$006,$007,$008,$009,$00a,$00b,$00c,$00d,$00e,$00f
        dc.w    $50f,$60f,$70f,$80f,$90f,$a0f,$b0f,$c0f,$d0f,$e0f,$f0f

TextScrollFeld:
        dc.l    $dc09fffe       ; WAIT 8, 220
        dc.l    $00e2b058       ; MOVE $b058 -> BPL1PTL
        dc.l    $01800aaf       ; MOVE $aaf  -> COLOR0
        dc.l    $de09fffe       ; WAIT 8, 222
        dc.l    $0180086f       ; MOVE $86f  -> COLOR0
        dc.l    $e609fffe       ; WAIT 8,230
        dc.l    $01820fff       ; MOVE $fff -> COLOR1
        dc.l    $e709fffe       ; WAIT 8,231
        dc.l    $01820fdd       ; MOVE $fdd -> COLOR1
        dc.l    $e809fffe       ; WAIT 8,232
        dc.l    $01820fcc       ; MOVE $fbb -> COLOR1
        dc.l    $e909fffe       ; WAIT 8,233
        dc.l    $01820faa       ; MOVE $faa -> COLOR1
        dc.l    $ea09fffe       ; WAIT 8,234
        dc.l    $01820f99       ; MOVE $f99 -> COLOR1
        dc.l    $eb09fffe       ; WAIT 8,235
        dc.l    $01820f77       ; MOVE $f77 -> COLOR1
        dc.l    $ec09fffe       ; WAIT 8,236
        dc.l    $01820f66       ; MOVE $f55 -> COLOR1
        dc.l    $ed09fffe       ; WAIT 8,237
        dc.l    $01820f44       ; MOVE $f33 -> COLOR1
        dc.l    $ee09fffe       ; WAIT 8,238
        dc.l    $01820f33       ; MOVE $f11 -> COLOR1
        dc.l    $ef09fffe       ; WAIT 8,239
        dc.l    $01820f00       ; MOVE $f00 -> COLOR1
        dc.l    $f609fffe       ; WAIT 8, 246
        dc.l    $0180042f       ; MOVE $42f  -> COLOR0
        dc.l    $f809fffe       ; WAIT 8, 248
        dc.l    $01800000       ; MOVE $000  -> COLOR0

BobTab:

        dc.b    65,80,105,90    ; T 1
        dc.b    80,90,90,120    ; T 2

        dc.b    110,80,120,120  ; H 3
        dc.b    120,95,140,105  ; H 4
        dc.b    140,80,150,120  ; H 5

        dc.b    155,85,165,115  ; E 6
        dc.b    160,80,195,90   ; E 7
        dc.b    165,95,185,105  ; E 8
        dc.b    160,110,195,120 ; E 9

        dc.b    0,130,35,140    ; P 10
        dc.b    30,135,40,150   ; P 11
        dc.b    10,145,35,155   ; P 12
        dc.b    0,145,10,170    ; P 13
        dc.b    45,160,55,170   ; Punkt 14

        dc.b    60,130,95,140   ; R 15
        dc.b    90,135,100,150  ; R 16
        dc.b    60,145,95,155   ; R 17
        dc.b    60,155,70,170   ; R 18
        dc.b    90,155,100,170  ; R 19
        dc.b    105,160,115,170 ; Punkt 20

        dc.b    120,135,130,165 ; O 21
        dc.b    125,130,155,140 ; O 22
        dc.b    150,135,160,165 ; O 23
        dc.b    125,160,155,170 ; O 24
        dc.b    165,160,175,170 ; Punkt 25

        dc.b    180,135,190,170 ; F 26
        dc.b    185,130,220,140 ; F 27
        dc.b    190,145,210,155 ; F 28
        dc.b    215,160,225,170 ; Punkt 29

        dc.b    230,130,240,170 ; I 30
        dc.b    245,160,255,170 ; Punkt 31

        dc.b    1
        dc.b    0

ScrollText:
        dc.b    "K-Seka Assembler Diskette von The P.R.O.F.I.  "
        dc.b    "many greetings to ICI  "
TextEnde:


Hiermit moechte ich das Thema Bootblock, endgueltig beenden. Hab wieder
viel zu viel geschrieben. Aber es ist halt auch eine interressante Sachen.

Der Bootblock ist etwas woran man Programmierer messen kann. Denn dort ist
der Platz sehr begrenzt, und man muss mit alle Haken und Oesen arbeiten.
Dort wird sich auch noch mehr tun.
Es ist nur schade das es Leute gibt die dieses koennen, kurz zu
Programmieren dafuer benutzen einen Virus zu schreiben.

Ich gebe zu das ich mich auch schon damit beschaeftigt habe. Ich habe auch
schon einen Kleinen Virus selber gemacht, aber eben nur zu testzwecken. Ich
habe dabei gemerkt das es wirklich schwer ist etwas so perfekt zu
programmieren wie die Viren neuerer Generation, wie z.b den Butonic, oder
den Revenge-Lamer. Aber wenn man so etwas kann gibt es einem noch lange
nicht das Recht anderen den Spass zu verderben.

Deshalb bitte ich die Leute unter euch die bald besser programmieren
lernen, und die Finessen des Amigas kennenlernen, doch bitte vom
Virenschreiben abzusehen.

Naja, ich will jetzt keinen Moralischen kriegen, aber das gehoert auch
dazu..

Schoenen Tag noch....

                Jeff Kandle
