          A S S E M B L E R - K U R S       (c)  Jeff Kandle 1990

                                17.Teil...

So, bevor wir weiter machen, will ich mal eine kurze Listre durchgeben, in
der alle befehle des MC 68000 mit UltraKurzbeschreibung sind. Die
Kompletten listen kommen allerdings erst am Ende. Ich bringe diese Listen
auch nur weil es sich so gehoert fuer einen Kurs.

Also pack mers...

ABCD    Addition von BCD-Zahlen
ADD     Binaere Addition zweier Operanden zwischen 8 und 32 Bit
ADDA    Addition eines Operanden zu einem Adressregister als Ziel
ADDI    Binaere Adition mit Konstanten
ADDQ    Addition eines 3-Bit-Operanden zu einem Register oder
        Speicherbereich
ADDX    Addition zweier Operanden mit Extend-Flag
AND     Logische UND-Verknuepfung zweier Operanden
ANDI    Logische UND-Verknuepfung unmittelbarer Daten
ASL     Arithmetische Verschiebung nach Links
ASR     Arithmetische Verschiebung nach Rechts
BCC     Bedingter relativer Sprung
BHI     Bedingter relativer Sprung
BLS     Bedingter relativer Sprung
BCS     Bedingter relativer Sprung
BNE     Bedingter relativer Sprung
BEQ     Bedingter relativer Sprung
BVC     Bedingter relativer Sprung
BVS     Bedingter relativer Sprung
BPL     Bedingter relativer Sprung
BMI     Bedingter relativer Sprung
BGE     Bedingter relativer Sprung
BLT     Bedingter relativer Sprung
BGT     Bedingter relativer Sprung
BLE     Bedingter relativer Sprung
BCHG    Bit pruefen und aendern
BCLR    Bit pruefen und auf Null setzen
BRA     Verzweige immer (Branchen)
BSET    Bit pruefen und auf Eins setzen
BSR     Verzweige zu Unterprogramm (Branchen)
BTST    Bit pruefen
CHK     Inhalt eines Datenregisters gegen eine obere und untere Grenze
        Pruefen
CLR     Inhalt eines Operanden loeschen
CMP     Vergleich zweier Operanden
CMPA    Vergleich eines Adressregisters mit einem Operanden
CMPI    Vergleich einer Konstanten mit dem Zieloperanden
CMPM    Vergleich zweier Speicherzellen
DBCC    Bedingung pruefen, dekrementieren und verzweigen  C=0
DBCS    Bedingung pruefen, dekrementieren und verzweigen  C=1
DBEQ    Bedingung pruefen, dekrementieren und verzweigen  Z=1
DBF     Bedingung pruefen, dekrementieren und verzweigen  nie erfuellt
DBGE    Bedingung pruefen, dekrementieren und verzweigen  >=
DBGT    Bedingung pruefen, dekrementieren und verzweigen  >
DBHI    Bedingung pruefen, dekrementieren und verzweigen  Hoeher
DBLE    Bedingung pruefen, dekrementieren und verzweigen  <=
DBLS    Bedingung pruefen, dekrementieren und verzweigen  niedriger =
DBLT    Bedingung pruefen, dekrementieren und verzweigen  <
DBMI    Bedingung pruefen, dekrementieren und verzweigen  N=1
DBNE    Bedingung pruefen, dekrementieren und verzweigen  Z=0
DBPL    Bedingung pruefen, dekrementieren und verzweigen  N=0
DBT     Bedingung pruefen, dekrementieren und verzweigen  immer erfuellt
DBVC    Bedingung pruefen, dekrementieren und verzweigen  V=0
DBVS    Bedingung pruefen, dekrementieren und verzweigen  V=1
DIVS    Division mit Vorzeichen
DIVU    Division ohne Vorzeichen
EOR     Logisch Exklusiv-Oder
EORI    Logische Exklusiv-Oder mit einer Konstanten
EXG     Registerinhalte vertauschen
EXT     Vorzeichenrichtige Erweiterung eines Datenregisters
JMP     Unbedingter absoluter Sprung
JSR     In ein Unterprogramm springen
LEA     Effektive Adresse in ein Adressregister laden
LINK    Stackpointer retten und einen neuen Stackbereich anlegen
LSL     Logische Verschiebung nach links
LSR     Logische Verschiebung nach rechts
MOVE    Daten von Quelle zum Ziel uebertragen
MOVE to CCR     Uebertragen von Daten in das CC-Register
MOVE to SR      Uebertragen von Daten in das SR-Register
MOVE from SR    Den Inhalt des Statusregisters in einen Zieloperanden
                uebertragen
MOVE USP        Manipulieren des User-Stackpointers
MOVEA   Daten in ein Adressregister uebertragen
MOVEM   Mehrere Register uebertragen
MOVEP   Datentransfer zwischen CPU und Peripheriegeraeten
MOVEQ   Uebertraegt eine Konstante schnell in ein Datenregister
MULS    Multiplikation mit Vorzeichen
MULU    Multiplikation ohne Vorzeichen
NBCD    Negation von BCD-Zahlen
NEG     Negieren eines Operanden
NEGX    Negation mit Extend
NOP     Keine Operation
NOT     Invertieren eines Operanden
OR      Logische ODER-Verknuepfung
ORI     Logische ODER-Verknuepfung mit einer Konstanten
PEA     Ablegen einer effektiven Adresse auf den Stack
RESET   Ruecksetzen externer Einheiten
ROL     Rotieren eines Operanden nach links
ROR     Rotieren eines Operanden nach rechts
ROXL    Rotieren eines Operanden nach links mit Extend
ROXR    Rotieren eines Operanden nach rechts mit Extend
RTE     Ruecksprung von Eception
RTR     Ruecksprung mit Laden der Flags
RTS     Ruecksprung vom Unterprogramm
SBCD    Subtraktion von BCD-Zahlen
ST      Testen einer Bedingung  1
SF      Testen einer Bedingung  0
SHI     Testen einer Bedingung  (C or Z)=0
SLS     Testen einer Bedingung  (C or Z)=1
SCC     Testen einer Bedingung  C=0
SCS     Testen einer Bedingung  C=1
SNE     Testen einer Bedingung  Z=0
SEQ     Testen einer Bedingung  Z=1
SVC     Testen einer Bedingung  V=0
SVS     Testen einer Bedingung  V=1
SPL     Testen einer Bedingung  N=0
SMI     Testen einer Bedingung  N=1
SGE     Testen einer Bedingung  N eor V=0
SLT     Testen einer Bedingung  N eor V=1
SGT     Testen einer Bedingung  Z and (N eor V)=0
SLE     Testen einer Bedingung  Z or (N eor V)=1
STOP    Prozessor anhalten
SUB     Subtraktion zweier Operanden
SUBA    Subtraktion mit Adressregister als Ziel
SUBI    Subtraktion mit Konstanten als Quelloperand
SUBQ    Subtraktion eines 3-Bit-Operanden
SUBX    Subtraktion zweier Operanden mit Etend
SWAP    Austauschen zweier Registerhaelften
TAS     Bit im Zieloperanden pruefen und setzen
TRAP    Bit im Zieloperanden pruefen und setzen
TRAPV   Trap bei Overflow
TST     Operanden testen
UNLK    Stackpointer zurueckholen

So das waren sie...
Wenn man bedenkt das die Befehle im Durchnitt auch noch 6-7
Adressierungsarten beherrschen, und wir sie im Byte, Word und
Langwordbereich einsetzen koennen, dann kann man sich gut vorstellen wieviel
verschiedene schalter vom Prozessor erkannt und verarbeitet werden muessen
damit er ueberhaupt weiss was das fuer ein Befehl ist. Wenn man dann noch
daran denkt das er die instruktion dann auch noch ausfuehrt, dann weiss man
wie schnell er wirklich ist.


Naja, wem die Vielfalt an Befehlen gefaellt, und wer gerne alle einsetzen
moechte dem sei gesagt, das es fast unmoeglich ist alle befehle
einzusetzen. Denn man soll ja Programme mit Befehlen schreiben, und nicht
die Programme so schreiben das man die Befehle brauchen kann. Denn dann
programmiert man umstaendlich. Es ist zwar schoen das, wenn man etwas
programmiert, man ein bisherige schreibweise durch die kenntnis eines Neuen
befehls erleichtern, verschnellern oder verkuerzen kann. Aber man soll sich
nicht zwingen neue tolle befehle unbedingt zu benutzen, denn das ist
oftmals dann schlimmer als wie es nutzen hat.

So, wem die Kurzbeschreibungen nicht reichen, weil er doch lieber
Profisionell arbeiten moechte, der muss leider bis ende des Kurses warten,
weil ich dann erst die kompletten Befehlslisten hier reinsetze. Das hat
nichts damit zutun das ich die Leute dabei halten will, nur etwas damit das
es sehr viel arbeit ist, und ich das noch nebenbei mache, ausserdem
Schreibe ich noch an einem neuen demo, und bin mir auch schon die Sachen
fuer das Intro das am Ende diese Kurses steht am zusammen am Bauen, wie wir
Koelsche sagen.
Da seht ihr mal wieviel Zeit dabei drauf geht, und nebenbei mache ich
noch eine Lehre, und habe dort in Fuenf Monaten Facharbeiter Pruefung. Also
ich riskiere fuer euch Kopf und Kragen.

Nun das reicht erstmal...Weiter mit dem programmieren, und den hilfen.

Dieser Tips kommt zwar etwas Spaet, aber immerhin..er kommt.
Waehrend ihr diesen Kurs mitmacht solltet ihr alles SourceCodemaessige was
ihr in die Finger kriegt, so bearbeiten und Analysieren das ihr genau wisst
was es macht. Ihr solltet auch ganz alleine Listings von mir
nachprogrammieren. Wenn es dann nicht klappt koennt ihr ja immer noch
nachgucken was falsch war. Aber das naechste mal passiert das nicht mehr,
so war es jedenfalls bei mir, und ich habe werweisswieviel Falsch gemacht.

Ueberhaupt solltet ihr alle moeglichen SourceCodes sammeln, und immer
wieder angucken und laufen lassen, denn aus der Puren Theorie lernt man
nicht besonders gut. Denn auch die erfahrensten bauen immer mal wieder
einen Guru, da ist nicht Schlimmes dran, ehrlich.

Fuer alle die sich noch eingehende mit dem IFF Format und dessen
konvertierung befassen wollen habe ich hier noch ein Listing eines
Konverters, es hat mir sehr geholfen, und ich habe anhan dessen schon einen
kleinen IFF Konverter zusammengeschrieben. Vielleicht koennt ihr den ja
schon bald bewundern.

; Iff-Decrunch-Routine

Dateilaenge = 4666

>Extern "test.iff",Quelle,Dateilaenge

Execbase = 4
Allocmem = -$c6
Freemem = -$d2

; Makros

FINDCHUNK        MACRO

Fc?0:
        cmp.l   #?1,(a0)                  ; ist parameter gefunden ?
        nop
        adda.l  #2,a0                    ; adda veraendert keine Flags
        beq     fc1?0                       ; ja
        dbra    d0,fc?0                    ; nein weiter
        sub.l   d0,d0                     ; nicht gefunden Chunk laenge
        bra.s   fc2?0
fc1?0:
        adda.l  #2,a0
        move.l  (a0)+,d0
fc2?0:
                ENDM


; Programm

Start:
        lea.l   quelle,a0
        move.l  #dateilaenge\2-1,d0
        FINDCHUNK "FORM"
        beq     stop
        cmp.l   #"ILBM",(a0)
        bne     stop
        FINDCHUNK "BMHD"
        move.b  10(a0),d0
        cmp.b   #1,d0
        bhi     stop
        move.l  a0,bmhdptr
        move.w  (a0),breite
        move.w  2(a0),hoehe
        move.b  8(a0),tiefe
        move.l  Execbase,a6
        sub.l   d0,d0
        move.w  breite,d0
        add.w   #15,d0
        asr.w   #3,d0
        andi.w  #$fffe,d0
        mulu    hoehe,d0
        sub.l   d1,d1
        move.b  tiefe,d1
        mulu    d1,d0
        move.l  d0,bodysize
        moveq   #1,d2
        asl.l   d2,d1
        asl.l   #1,d2
        add.l   d2,d0
        move.l  d0,filesize
        move.l  #$10003,d1
        jsr     allocmem(a6)
        move.l  d0,outfile
        beq     stop
        lea     quelle,a0
        move.l  #dateilaenge-1,d0
        FINDCHUNK "CMAP"
        beq     nocmap
        move.l  outfile,a1
        add.l   bodysize,a1
        move.l a1,colormap
CMLOOP:
        sub.w   d1,d1
        move.b  (a0)+,d1
        lsl.w   #4,d1
        andi.w  #$0f00,d1
        move.b  (a0)+,d2
        andi.w  #$00f0,d2
        ori.w   d2,d1
        move.b  (a0)+,d2
        andi.w  #$000f,d2
        ori.w   d2,d1
        move.w  d1,(a1)+
        sub.l   #3,d0
        bgt     cmloop
nocmap:
        lea     quelle,a0
        move.l  #dateilaenge-1,d0
        FINDCHUNK "BODY"
        beq     stop
        subq.l  #1,d0
        move.l  bmhdptr,a1
        move.b  10(a1),d1
        move.l  outfile,a1
        beq copy
Dekompress:
        clr.w   d1
        move.b  (a0)+,d1
        cmp.b   #128,d1
        beq     noop
        bhi     double
copybytes:
        move.b  (a0)+,(a1)+
        dbra    d1,copybytes
        bra.s   noop
double:
        neq.b   d1
        move.b  (a0)+,d2
doubleloop:
        move.w  #$000f,$dff180
        move.b  d2,(a1)+
        dbra    d1,doubleloop
noop:
        dbra    d0,dekompress
        bra.s   stop
copy:
        move.w  #$00f0,$dff180
        move.b  (a0)+,(a1)+
        dbra    d0,copy
stop:
        sub.l   d0,d0
        sub.l   d1,d1
        sub.l   d2,d2
        sub.l   d3,d3
        move.w  breite,d0
        move.w  hoehe,d1
        move.b  tiefe,d2
        move.l  outfile,a0
        move.l  filesize,a1
        adda.l  a0,a1
ILLEGAL

clean:
        move.l  execbase,a6
        move.l  filesize,d0
        move.l  outfile,a1
        jsr     freemem(a6)
ILLEGAL


BMHDptr:        dc.l 0
bodysize:       dc.l 0
colormap:       dc.l 0
outfile:        dc.l 0
filesize:       dc.l 0
breite:         dc.w 0
hoehe:          dc.w 0
tiefe:          dc.b 0
even
Quelle:         blk.b dateilaenge,0
Quelle1:

Wie gesagt, ich habe sie abgetippt, aus dem Copperkurs der Amiga.
(Ich muss das dabeischreiben, wegen dem Copyrights und so)
Wundert euch also nicht ueber den Programmierstil.

Da ihr aber jetzt, wenigstens von Sinn her viele Befehle kennt, dann
koenntet ihr euch ja mal an das Konverterlisting setzen und es
Anaylisieren.
Viel Spass dabei....

See you...

                Jeff Kandle
