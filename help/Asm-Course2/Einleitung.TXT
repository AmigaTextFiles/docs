
          A S S E M B L E R - K U R S       (c)  Jeff Kandle 1990

                              Einleitung....

So, leute

jetzt geht`s rund hier. Es ist der Erste Assemblerkurs der zugibt das man
mit ihm auf keinen Fall `Gut` programmieren lernt, allenfalls lernt man
durch geschicktes umgehen der Betriebssystemroutinen unheimlich schnell zu
werden.
Er ist einzig und allein dazu geschrieben, damit die Leute die ihn lesen, nach
dem Kurs im Stande sind
eine Intro oder sogar ein Gutes Demo zu schreiben. Denn das ist es was die
meisten erstmal koennen wollen...was danach kommt kann ja jeder selber
entscheiden.

Auch werdet ihr nicht stundenlang BefehlsTabellen lesen muessen, oder sogar
auswendig lernen muessen. Vielmehr, ihr werdet ja noch nicht mal alle
Assembler-Befehle kennenlernen, eben halt nur die wichtigsten (glaubt mir
die reichen schon)
Falls einer jedoch an den Befehlen interessiert ist, soll er mir nur
schreiben, ich habe ein paar brauchbare listen hier rumzufliegen.

Da ich die Kursteile ja nacheinander schreibe, bin ich in der lage,
ausfuehrlich auf bestimmte sachen einzugehen. Ich halte nicht viel von
pers. briefen an mich, wie diesen...Schreib mir doch bitte mal ein kleines
Intro oder so...das koennt ihr mit sicherheit selber, wenn ihr
einigermassen intelligent seit, und etwas lust mitbringt.

Nun, allerdings will ich mich nicht in erklaerungen fuer dieses und jenes
programm verstricken, deshalb werde ich erstmal eine liste von den Sachen
abschiessen, mit denen ich waehrend dieses Kurses arbeite. Also waere es
guenstig wenn ihr euch ebenfalls diese Tools besorgt. Wenn es auch leute
gibt die ein Modem haben, und dazu noch in der Gluecklichen lage sind
eingetragene User der Titanic zu sein, muesst ihr mir einfach da nur einen
brief schreiben und ihr kriegt zugriff auf ein brett, indem der ganze
Klamauk liegt....also hier erstmal die liste vom noetigsten....

                Seka V3.2
                Dpaint 1,2 oder 3 (3.21)
                Soundtracker 2.3 oder 2.5
                Noiseripper V1.0
                Kefrens Iff Converter
                Bytekiller (dazu spaeter mehr)

So, den meisten krempel kennt ihr ja schon, oder ihr wisst bestimmt wie man
da dran kommt.

Naja, eigentlich ist es ja mehr ein kurs zum Intro schreiben, den ich zeige
auch sachen wie das packen oder konvertieren. Viele Kurse nehmen das als
Selbstverstaendlich hin, oder gehen gar nicht in dieses Thema ein.
Auch braucht ihr keinen Super-Duper getunten Amiga zu diesem Kurs, da ich
selber auch nur mit 1 MB und drei Laufwerken arbeite, also auch keine
Astro-aufgeruestete Maschine...
Ausserdem ist es bei der Programmierung sowieso Aegerlich wenn man da 2.3
MB hat und man sie nicht ausnutzen kann, den so ein Intro muss auch auf
`nem normalen Amiga laufen. Es ist allerdings mit 1 MB besser zu
realisieren, also waere ein Megabyte schon guenstig, ich werde allerdings
auch auf die `Kleinen` eingehen, falls es Probleme bei einer Sachen geben
koennte...

Ich werde auch fuer die Minderbegabten im Zeichnen oder Komponieren 1 oder
2 Bilder und Soundtracker module hierher schicken.
Allerdings erst wenn das dran ist. Auch um eine Abspielroutine (was`n das)
braucht ihr euch nicht zu kuemmern, ich werde die demnaechst irgendwann
liefern.

Tja, was gibt es noch zu sagen (ich weiss ich rede soviel, aber ich finde
das gehoert dazu, schliesslich haben wir ja auch eine menge vor)...achja,
ihr braucht bei diesem Kurs nicht Tage oder Wochenlang vor der Kiste zu
sitzen, denn das mache ich auch nicht. Eine Stunde am Tag reicht voellig
aus. Am besten waere es ihr habt auch einen Drucker, oder einen Freund der
einen Drucker hat, oder einen Freund der einen Kennt dessen Bruder einen
Drucker hat, denn dann koenntet ihr euch das ausdrucken lassen, was ich mir
hier so zusammen schreibsele. Und wenn ihr das dann unter euer Kopfkissen
legt, und darauf eine Nacht schlaft, was meint ihr was...Quatsch, aber ich
werde im Laufe des kurses immer wieder auf die Intern Buecher von Data
Becker zurueckkommen, dort ist es zwar nicht unbedingt besser erklaert,
aber die haben die ganzen adressen die man so braucht, schoen kompakt auf 5
bis 6 seiten. Allerdings werde ich auch immer bezeichnung und wert einer
Adresse oder eines Wichtigen registers nennen, wenn ich damit arbeite, wenn
ihr euch dann noch mit einem Edding bewaffnet, und euch die sachen Markiert
dann koennt ihr euch schon nach kurzer zeit die Einzelnen Adressen, aus
vorherigen kursteilen ziehen, und euch vielleicht eine kleine Kartei
anlegen, wo dann der wichtigste Krempel drin steht.

Ja, ansonsten braucht ihr ausser ein paar leerer disketten eigentlich
nichts mehr, und deshalb koennte ich jetzt loslegen mit dem Kurs...

        In 273 Tagen zum Programmierer werden....

Ach Quatsch, ich weiss nicht wielange der Kurs geht, aber solange bestimmt
nicht, aber es ist die genaue Zahl meiner Zeit in Amiga Assembler...

Auch wenn der Kurs etwas anders als die anderen sein soll, ich weiss nicht
ob er es wird, kann ich doch nicht um einige Themen rum. Obwohl ich nicht
glaube das ihr ohne Jegliche unterstuetzende Literatur, oder ohne Sonstige
sachen, wie zum Beispiel andere Assembler-kurse (wehe, wenn ich das
erfahre) ins `rennen` geht, muss ich als erstes eine Frage beantworten, die
da lautet....

1) Was ist eigentlich Maschinensprache ?

Ja, das ist leicht erklaert, naehmlich einen Haufen Transistoren die
entweder leiten oder nicht leiten, also bloss zwei zustaende. Wie ihr die
nennt ist Egal...ob Schwarz oder Weiss...Heiss oder kalt..An oder Aus,
alles was gegensaetzlich ist stimmt. Der einfachheit halber bleiben wir
aber bei 1101001010010100101

Das war Maschinensprache...wenn ihr mich jetzt fragt was das heisst dann
wuesste ich es nicht, denn dieses Wissen uebernimmt fuer mich der Assembler,
ich meine diesmal das Programm. Ich gebe ihm, eine fuer ihn (und
hoffentlich bald auch fuer euch) sinnvolle kombination von Woertern und
zahlen ein, der er dann Uebersetzt und im Speicher zusammenbaut
(Assembliert).
Diese Kombination aus Zahlen und worten, stellen ein Sinnfaelliges Wort
dar, welches in etwa die Funktion beschreibt die die darauss entstehende Bit
kombination, ich meine dieses 1101001001, dann bei aufruf und abarbeitung
durchfuehrt wie zum beispiel

   Move  fuer Moven oder zu deutsch schieben (schiebe wert von nach)

        oder

   Add oder Sub fuer addieren oder Subtrahieren

        noch eins

   Cmp fuer Compare oder vergleichen.

Diese Worte, man nennt sie Uebrigens Mnemonics (ich weiss - Scheisswort)
ergeben meisstens in irgendwelchen Listings ein ausfuehbares programm.
Alleine hingegen, sind die Befehle, bis auf ein paar ausnahmen nicht in der
lage irgendetwas sinnvolles zu bewirken. Die meisten Sachen in Assembler
laufen sowieso durch vergleichen, kopieren und nochmals vergleichen ab,
deshalb kommen die meisten befehle die wir lernen werden auch aus diesem
gebiet.

Wie der Prozessor das Ganze verwaltet ist zu schwierig um es euch zu
erklaeren (um ehrlich zu sein weiss ich es selber nicht so ganz genau) aber
das wuerde auch den rahmen eine Kurses Sprengen. Wichtig ist nur das ihr
wisst Wie der Prozessor was und warum macht, und wie man ihm das sagt.

Nur halt soviel.....
Der Prozessor hat ein Register in sich in der die Augenblickliche Adresse
befindet an der der Prozessor knabbert. Wenn wir ein Programm starten,
machen wir nichts anderes als wie dem Prozessor einfach eine neue Adresse
dahin zu schreiben, wenn er dann denn Aktuellen Befehlabgearbeitet hat,
nimmt er sich die Adresse und macht da weiter. Das ist genauso als wenn ich
ein Aufgezogenes Spielzeug Auto das an mir vorbeifaehrt, hochhebe, die
Raeder Blockiere, und es irgendwo anders wieder hinsetze und die raeder
loslasse...
Dieses angesprochene Register ist der sogenannte Prozessor Counter (PC)
Wichtig wird es erst, wenn man damit programmiert, aber erstmal lassen wir
die Finger davon, also wenn ich mich mal vertippen sollte, und da steht was
von `Schreiben wir den Wert nach A7, dann macht da eine A6 daraus, denn der
PC befindet sich eben in diesem Register.
Bei anderen Prozessoren war dieses wichtige register immer gut verstckt,
bei Amiga bzw. bei MC 68000 oder MC 68010 ist es halt einfacher.

Der Prozessor schnappt sich also nach der Abarbeitung eines Befehls den PC
und holt sich das erste Word aus dem Speicher....

Haeh, word...eben hat der doch was von Zahlen gesagt...
Klar um nicht von Halbbyte, zwei bytes und vierbytes reden zu muessen,
wurden die Synonyme Nibble, Byte, Word, Longword erfunden, sie heissen im
einzelnen.

Nibble =
Vier Bits, stellt werte von 0 bis 15 oder von -8 bis +7 dar

Byte =
Acht Bits, stellt werte von 0 bis 255 oder von -128 bis +127 dar

Word =
Zwei Bytes, stellt werte von 0 bis 65535 oder von -32768 bis +32767 dar

Longword =
Vier Bytes, stellt werte von 0 bis 4294967295 oder von
 -2147483648 bis +2147483647 dar

So jetzt wisst ihr dass schon...

Also weiter im Text...wie gesagt, er holt sich das naechste wort aus dem
Speicher, da alle befehle des MC 68000 ein wort lang sind reicht das
erstmal. Nachdem er erkannt hat was es fuer ein Befehl ist weiss er ob er
noch etwas, und wenn wieviel er aus dem Speicher holen muss damit der
Befehl richtig laeuft. Manche Befehle brauchen auch keine weiteren Daten,
die sind natuerlich sehr schnell.
Natuerlich, wird bei jedem weiteren Element was er sich holt auch der PC
weitergesetzt, waere dies nicht der falls wuerde es sehr schnell zum Guru
Fuehren, den Obwohl es unheimlich viele Kombinationen gibt die fuer den
Prozessor ein brauchbare Kombination abgeben, gibt es immer wieder welche
die das Teil halt unheimlich ins Husten bringt weil er damit nicht anfangen
kann. In vielen Faellen merkt er allerdings vorher einen Kleinen
Hustenreiz, dann weiss er das das was er sich da geholt hat nicht gut war,
und gibt dann die Guru-Meditation aus. Aber manchmal schafft er noch nicht
mal mehr das, und dann weiss man noch nicht mal was man da Falsch gemacht
hat.
Naja, da wollen wir ja nicht hoffen das euch das oft passiert, aber es
passiert halt immer wieder....mir taeglich.

Nun noch mal zu den Zahlensystemen mit denen Ihr zutun bekommt..
Diese Zahlen die ich da oben genannt habe, sehen mehr oder weniger Wild
ausgesucht aus, das kommt daher das sie dezimal System dargestellt sind, da
man aber auf einem Computer mit einen Zahlen System rechnet das 16 als
basis hat sind es halt dezimal so schraege zahlen, Hexadezimal heisst das
16 ner System, und da sehen die werte so aus

Nibble          $0 bis $f
Byte            $00 bis $ff
Word            $0000 bis $ffff
und
Longword        $00000000 bis $ffffffff

Ha, das sieht doch viel einfacher aus...
Es waere also Gunestig wenn ihr einen Taschenrechner habt der Hexadezimal
umrechnen kann. Da ich davon ausgehe das alle Computerfreaks auch einen
Fimmel fuer taschenrechner haben, schaetze ich mal das so ein ding doch
aufzutreiben ist.
Falls nicht, der Seka nimmt alle werte auch dezimal an, und kann auch um
rechnen.

So, das wars es fuers erste...noch nichts zum lernen dabei, naja ein
bisschen, aber lest es euch trotzdem gut durch.....

bis demnaechst

                Jeff Kandle
