          A S S E M B L E R - K U R S       (c)  Jeff Kandle 1990

                                 1.Teil...


Es ist eigentlich nicht der erste oder soundsovielte teil, sondern der 1
abschnitt, weil ich immer soviel tippe wie ich lust habe.

O.K....weiter mit den Zahlen.
Wenn euch das mit dem -128 und +127 gewundert hat, wundert mich das nicht,
denn ich hatte auch etwas probleme das zu verstehen.
Also, es verhaelt sich bei der Zahlenverwaltung der Computer so das, man
den Bereich in dem man rechnet vorher auswaehlt. Das heisst, wenn ich eine
schleife mit 8000 durchlaeufen programmieren will, kann ich kein Byte als
Zaehler nehmen, da es nur bis 255 Zaehlen kann. Ich muss schon ein Wort
reservieren. Genauso verhaelt es sich umgekehrt, warum soll ich bei einer
Schleife mit 6 durchlaeufen gleich ein Langwort reservieren, das ist doch
platzverschwendung.
Nun aber zum Pudels des kerns des Problems...Wenn ein Wort in einer Adresse
dauernd um eins weiter gezaehlt wird, dann erreicht es irgendwann 65535.
Das ist der letzte darstellbare wert den das wort darstellen kann. Wenn ich
jetzt noch eins dazuzaehle, dann laeuft das wort sozusagen ueber. Der
Uebertrag wird aber vernachlaessigt, und faellt links raus. Also steht
wieder null in dem Wort. Also ist es irgendwie endlos mit den Zahlen, und
da hat man sich gedacht, `Machen wir es wie ein Wanderer` der um die Erde
spaziert. Er faengt irgendwo an zu gehen (tolles deutsch), und entfernt
sich immer weiter von dem Punkt an dem er gestartet war...aber irgendwann
hat er den punkt erreicht der genau unter dem liegt von dem er aus
gestartet war. Wenn er nun weiter geht kommt er unweigerlich dem Punkt
wieder naeher...und irgendwann steht er wieder dort. Da ihr die ihr das
lest das nicht ausprobieren koennen muesst ihr mir das schon glauben.

Also, so ist es auch bei den Zahlen, wenn man die haelfte ueberschritten
hat kommt man der null immer wieder naeher. Um das auch sichtbar zu machen
zaehlt man von 0 bis zur Haelfte positiv also 1, 2, 3 usw. und ab der
haelfte so bei 127 schlaegt man dann noch eins darauf um nennt es dann -128
 und man zaehlt jetzt -127, -126.......
und wenn ihr das jetzt zusammen zaehlt  127 + -128 dann kommt da -1 bei
raus. Und -1 ist dasselbe wie 255, wobei wir dann wieder bei dem Byte
waeren. Womit auch bewiesen waere das man mit einem Byte nur bis 255
zaehlen kann. Trotzdem kann man mit einem Byte 256 Werte darstellen, denn
die 0 ist eine Vollwertige zahl, findet euch damit ab.

So da ihr jetzt ungefaehr wisst wie das mit dem Zaehlen auf dem Compi geht,
koennen wir so langsam anfangen etwas in richtung Assembler zu lernen.
Dazu gehen wir in das naechste Kapitel

2. Die Ersten Assembler Befehle (Mnemonics)

Tja, bevor wir allerdings damit anfangen muesst ihr noch wissen womit und
wie man das eingibt, damit auch irgendetwas passiert, denn auf die Backe
Taetowieren hat so glaube ich nicht viel sinn, habe es zwar nocht nicht
ausprobiert, aber ich gehe mal nicht davon aus.
Also, schnappen wir uns den Seka. Starten, und wie folgt vorgehen.
Wenn ihr die gepachte version benutzt, sie heisst V3.2 dann fragt er
erstmal was ihr fuer einen Arbeitsspeicher benutzen wollt...

Ihr habt drei moeglichkeiten, die ich mal kurz erklaeren will.

(C)hip  =   Chipram, sind die ersten 512 Kbyte im Amiga, also die
            Grundkonfiguration, wenn ihr keine Speicher erweiterung habt
            dann solltet ihr das eingeben.

(F)ast  =   Alles was rein oder dran gesteckt wird, zaehlt als Fastram.
            Allerdings wurde ich davon abraten, da der Amiga meisten alle
            Sachen in Vorhandenes fastram legt, somit auch den Seka, und
            den wuerdet ihr ggf. ueberschreiben und damit loeschen.

(A)llocate  =  Einen ganz betimmten bereich auswaehlen. (braucht man nie !)


Habt ihr euch entschieden C fuer Chiop zu druecken, dann fragt der
neugierige Seka dann noch wieviel Speicher ihr braucht bzw. haben wollt.
Wenn ihr mit `nur` 512 KB arbeitet solltet ihr nicht mehr als 150 eingeben,
obwohl fuer die normalen sachen schon 20 oder 30 reichen. Wenn ihr
allerdings `nen ganzen Megabyte habt koennt ihr bis dreihundert eingeben,
hat aber nicht viel sinn, da meistens hundert reichen.

Wenn ihr das alles eingegeben habt dann kann es losgehen, die weiteren
kommandos des Seka Assemblers lernt ihr wenn man sie braucht, so kann man
sich das besser merken.
Also der Modus in dem ihr euch jetzt befindet ist der kommando modus, indem
alle sachen die irgendwie mit programmieren mit dem Seka zu tun haben
eingeben kann, als da das laden und abspeichern von SourceCodes waeren.

Ein Teil von euch, hat warscheinlich noch keinen Schimmer von Assembler,
ich meine bis auf das was ich bisher geschrieben habe, und sich deshalb
auch noch nicht um irgendwelche SourceCode gekuemmert, also muessen wir
erstmal etwas lauffaehiges schreiben damit wir es abspeicher koennen.

Also schreiben wir das Kuerzeste programm was es auf dem Amiga gibt,
naehmlich.....
Moment, erstmal muessen wir in den Editor, und zwar gelangen wir durch
druecken von Escape dort hin wo wir SourceCodes eingeben koennen.
Also wenn ihr Escape gedrueckt habt muesste der bildschirm sich jetzt in
zwei teile teilen. Mit dem Unteren habt ihr im Moment nichts mehr zu tun,
ihr befindet euch jetzt im Editor.
Der Editor gibt euch die zahlen vor die am anfang der zeile stehen, also
braucht ihr euch darum nicht zu kuemmern.

Das (End) was da steht kann man nicht loeschen, es ist wichtig, und liegt
automatisch am Ende des SourceCodes.

So, jetzt kommt dieses Kuerzeste lauffaehige programm. Und zwar muesst ihr
dazu dieses Woertchen eingeben.

rts

Es heisst ausgesprochen `Return from Subroutine`
zu deutsch `Kehre vom Unterprogramm zurueck`
Jetzt sage ich euch erstmal wie es lauffaehig gemacht wird, und dann was
passiert.

Also, ihr habt das jetzt eingegeben, drueckt nun wieder Escape um aus dem
Editor zu fluechten. Nun seit ihr wieder im Kommando Modus, und koennt das
programm jetzt Assemblieren.
Dazu muesst ihr `A` druecken und return. Jetzt fragt der Seka noch nach
options. Da muesst ihr im Prinzip auch return druecken, da die einzige
sache die man da eingeben kann und die fuer euch sinnvoll waere `VH` ist.
Damit koennt ihr dem Seka bei der Arbeit zugucken.

So, nachdem er es assembliert hat, und `No Errors` ausgegeben hat koennt
ihr das programm mit `J` starten.

Boooh, was ist das, nichts passiert...ganz klar das ist richtig.

Was ist passiert....Nach dem Start wird der PC wieder auf die neue Adresse
verbogen, das heisst dahin wo der Seka das Prograemmchen geschrieben hat.
Allerdings merkt sich der Prozessor von wo aus er gesprungen ist..das sieht
dann so aus....

Stellt euch vor das der Prozessor gerade mit dem Abareiten des J-befehls
des Seka zu tun hat...wenn er soweit ist, weiss er das er das programm was
er irgendwo hingeschrieben hat jetzt als unterroutine abarbeiten soll.
Dazu setzt er den PC auf die Adresse des Programms, allerdings merkt er
sich vorher die adresse wo er im Moment arbeitet

Sagen wir mal das J-befehls-programm liegt bei $10000, und das programm mit
dem RTS - befehl liegt bei $50000, beobachten wir den PC mal

. Normale bearbeitung von sachen               PC
.
. Bearbeitung des J befehls                  $10000
. Jetzt kommt der aufruf des Prograemmchens
. der Prozessor merkt sich die position an der er im Moment arbeitet, indem
. den wert einfach auf einen Stapel legt wo er sich alle moeglichen sachen
. merkt, dieser Stapel ist auch wie ein Stapel, das was man zuletzt darauf
. gelegt hat bekommt man wieder. Also nachdem er sich die $10000 `gemerkt`
. hat schreibt er die $50000 in den PC, und arbeitet da weiter.
. Der Befehl der jetzt kommt macht das alles wieder rueckgaengig, den er
. sagt das der prozessor sich die oberste adresse von Stapel nehmen soll,
. und in den PC schreiben soll.
. Jetzt arbeitet der Prozessor am J-befehl weiter. Der nur noch die
. Kontrolle an den Seka zurueckgibt, weil er ebenfalls mit RTS endet.

Wie ihr seht tut dieses Kleine prograemmchen doch schon eine ganze menge.
Nur halt nichts das man sieht.
Trotzdem dieser Befehl `MUSS` hinter jedem programm stehen was zurueck
kehren soll. Sonst wuerde der Prozessor weiterarbeiten, und wie ihr schon
wisst, bei einer ungueltigen Bit-Kombination abstuerzen.

So ich hoffe das ihr das verstanden habt, den das war alles was man dazu
sagen kann.

Jetzt wollen wir mal etwas Programmieren, wobei man auch etwas sehen kann.
Es wird zwar nicht atemberaubendes, aber immerhin.

Vielleicht habt ihr schon bemerkt das der Seka nach abarbeitung eines
programms eine kleine tabelle ausgibt. Die ist eigentlich nur zur fehler
erkennung gedacht, allerdings gibt sie auch alle arbeitregister des
Prozessor`s aus, und die koennen wir natuerlich gut gebrauchen...
Was, ihr wisst nicht was Arbeitsregister sind, nun....achja hatte ich ja
noch nicht erklaert. Nun gut

Es gibt in einem Prozessor einen haufen von register der er so benutzt, und
wo wir nicht drankommen, allerdings gibt es beim MC 68000 16(15) stueck wo
wir mit arbeiten koennen, als da waeren

Datenregister D0 - D7
Adressregister A0 - A7

A7 ist ja wie ihr wisst nicht zu benutzen da der MC 68000 seinen PC da rein
schreibt.
Da diese register direkt im Prozessor sind koennt ihr euch vorstellen das
er damit viel schneller arbeiten kann als wie mit anderen.
Eine Muenze die in eurer Hosentasche steckt habt ihr auch schneller in der
Hand als wie eine die im Schrank liegt.

Weil wir damit arbeiten koennen, koennen wir diese Register auch direkt
benutzen, und uns das ergebnis, nach der wiederkehr ueber `RTS` in der
tabelle die der Seka ausgibt anschauen.

Also, loeschen wir den SourceCode im Speicher erstmal. Dazu gehen wir in
den kommando Modus, und tippe `KS` ein, was heissen soll Kill Source.
Nach einer sicherheits abfrage, die wir natuerlich mit `J` beantworten
loescht der Seka den Source mit dem `RTS`.
Gehen wir in den Editor (Escape)....

So jetzt kommt der maechtigste und meist benutzten Befehl der MC 68000
maschinesprache, er tritt auch auf sehr vielen anderen dialekten auf, also
kennt ihr den auch wenn ihr mal einen anderen Compi besitzen werdet.
Allerdings glaube ich nicht das er dort soviele Adressierungarten drauf hat
wie bei unserer Freundin.

Also, dieser tolle Befehl heisst schlicht und ergreifend Move, und das ist
auch genau das was er macht, er schiebt werte hin und her. Das ist an sich
nichts tolles, aber wenn ihr wisst auf wieviele arten er das kann, dann
werdet ihr schon merken wie toll dieser befehl ist.
Wir geben uns aber erstmal nur mit der einfachsten art und weise ab,
naemlich der Direkten.
Das heisst....Einen ganz bestimmten wert in eine ganz bestimmte Adresse
oder in ein ganz bestimmtes register zu schrieben.
Es ist die einfachste sache, und sieht so aus.....halt, erinnert euch was
ich gesagt habe, das wir vor jeder sache mit zahlen gucken muessen in
welchem bereich wir arbeiten, je nach zahl muessen wir das zeichen hinter
dem punkt veraendern. Und zwar in b, w oder l
Wenn ich den bereichviel groesserangebe nimmt uns das der 68000 nicht krum
aber bei unterschaetzung macht er manchmal zicken.

Move.w #$4000,$40000

wuerde das Word #$4000 nach der Adresse $40000 schreiben.
Wir wollen das aber etwas einfacher zum kontrollieren machen, und deshalb
nehmen wir einfach ein Datenregister, und zwar das mit der nummer null.

Move.w #$4000,d0

so, tippt das mal ein, und setzt noch ein RTS drunter.

Verlasst jetzt den Editor (Esc..) und assembliert das, ihr wisst ja wie.

So, jetzt koennt ihr das ding mit `J` starten.
Ha, kaum gedrueckt ist der auch schon wieder da, denn Maschinensprache ist
sehr schnell. Ich kann zwar nicht die genaue Zeit sagen die er dafuer
gebraucht hat aber ich gehe mal von 2 oder 3 Hunderttausendstel Sekunden
aus.
Schnell wa.

So wenn ihr euch jetzt die tabelle anguckt, findet ihr irgendwo `D0` stehen
und dahinter muesste dann eine 00004000 stehen,toll ne ?
So das kann man Naturlich mit allen registern und werten machen.
Jetzt kommt auch der beweis, fuer meine Aussage zum thema Zahlen.

Geht mal in den Editor und macht aus dem `w` hinter dem Move ein `l`.
Und loescht mit del die `4000` und schreibt da `ffffffff` hin.
Starten, und `D0` angucken...
Jetzt steht da auch dieses `ffffffff`.
Aber da man rueckwaerts und Negativ viel leichter an die `ffffffff` kommt
kann man auch die ff... loeschen und dort einfach `-1` hinschreiben.
Wenn ihr das jetzt startet kommt eben wieder dieses `ffffffff` raus.

Jetzt seht ihr auch wie wichtig die richtige bereichswahl ist.
Denn -1 im Bytebereich ist $ff oder 255, und -1 im Langwortbereich ist
nunmal $ffffffff oder 4294967295
Also, immer daran denken.

see you later

                Jeff Kandle
